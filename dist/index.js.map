{"version":3,"file":"index.js","sources":["../core/validator-service.ts","../core/server/validator.ts","../core/server/nodes/node.ts","../core/server/nodes/io-node.ts","../core/server/nodes/config-node.ts","../core/schemas/node-configs.ts","../core/schemas/config-node-configs.ts","../core/schemas/message.ts","../core/schemas/io-node-configs.ts","../core/constants.ts","../core/schemas/typed-input.ts","../src/schemas/your-node.ts","../src/server/nodes/your-node.ts","../src/schemas/remote-server.ts","../src/server/nodes/remote-server.ts","../core/utils.ts","../core/server/index.ts","../src/server/index.ts"],"sourcesContent":["import Ajv, {\n  Options,\n  ErrorObject,\n  ErrorsTextOptions,\n  AnySchemaObject,\n} from \"ajv\";\nimport addFormats from \"ajv-formats\";\nimport addErrors from \"ajv-errors\";\nimport { MessageSchema, TypedInputSchema } from \"./schemas\";\n\nclass ValidatorService {\n  private readonly ajv: Ajv;\n\n  constructor(options?: Options) {\n    this.ajv = new Ajv({\n      allErrors: true,\n      useDefaults: \"empty\",\n      verbose: true,\n      validateFormats: true,\n      strict: true,\n      coerceTypes: true,\n      ...options,\n    });\n\n    console.log(this.ajv.schemas);\n\n    // NOTE: this plugin enables users to use formats keyword\n    addFormats(this.ajv);\n\n    // NOTE; this plugin enables users to declare custom error messages\n    addErrors(this.ajv);\n\n    this.ajv.addKeyword(\"nodeType\");\n  }\n\n  createValidator(schema: AnySchemaObject) {\n    return this.ajv.compile(schema);\n  }\n\n  errors(\n    errors?: ErrorObject[] | null | undefined,\n    options?: ErrorsTextOptions\n  ) {\n    return this.ajv.errorsText(errors, options);\n  }\n}\n\nexport { ValidatorService };\n","import { ValidatorService } from \"../validator-service\";\n// NOTE: singleton to use ajv caching features\nconst validatorService = new ValidatorService();\n\nexport { validatorService };\n","import { AnySchemaObject } from \"ajv\";\nimport { Static } from \"@sinclair/typebox\";\nimport { MessageSchema, NodeConfigsSchema } from \"../../schemas\";\nimport { validatorService } from \"../validator\";\n\ntype Message = Static<typeof MessageSchema>;\ntype NodeConfigs = Static<typeof NodeConfigsSchema>;\n\ninterface ConfigNodeValidations {\n  configs: AnySchemaObject;\n  credentials?: AnySchemaObject;\n}\n\ninterface IONodeValidations {\n  configs: AnySchemaObject;\n  credentials?: AnySchemaObject;\n  input?: AnySchemaObject;\n  outputs?: AnySchemaObject;\n}\n\ntype NodeValidations = ConfigNodeValidations | IONodeValidations;\n\n// NOTE: these methods are implemented and defined by Node-RED runtime. They were added here to provide intelisense only.\ndeclare module \"./node\" {\n  interface Node<TConfigs, TCredentials> {\n    error(logMessage: string, msg: any): void;\n    debug(msg: any): void;\n    trace(msg: any): void;\n    log(msg: any): void;\n    warn(msg: any): void;\n  }\n}\n\nabstract class Node<\n  TConfigs extends NodeConfigs = NodeConfigs,\n  TCredentials = any,\n> {\n  static RED: any;\n  static type: string;\n\n  public static readonly validations: NodeValidations;\n\n  public readonly id: string;\n  public readonly type: string;\n  public readonly name: string;\n  public readonly z?: string;\n  public readonly g?: string;\n\n  public readonly configs: TConfigs;\n  public readonly credentials?: TCredentials;\n\n  constructor(configs: TConfigs) {\n    Node.RED.nodes.createNode(this, configs);\n    this.configs = configs;\n    this.id = configs.id;\n    this.type = configs.type;\n    this.name = configs.name;\n    this.z = configs.z;\n    this.g = configs.g;\n\n    if (Node.validations?.configs) {\n      console.log(\"validating configs\");\n      console.log(this.configs);\n      console.log(this);\n      const validator = validatorService.createValidator(\n        Node.validations?.configs\n      );\n      const isConfigsValid = validator(this.configs);\n      if (!isConfigsValid) {\n        const errors = validatorService.errors(validator.errors, {\n          separator: \"\\n\",\n          dataVar: \"- configs\",\n        });\n        console.error(errors);\n      }\n    }\n\n    if (Node.validations?.credentials) {\n      console.log(\"validating credentials\");\n      const validator = validatorService.createValidator(\n        Node.validations?.credentials\n      );\n      const isCredentialsValid = validator(this.credentials);\n      if (!isCredentialsValid) {\n        const errors = validatorService.errors(validator.errors, {\n          separator: \"\\n\",\n          dataVar: \"- credentials\",\n        });\n        console.error(errors);\n      }\n    }\n  }\n\n  static init(): void | Promise<void> {\n    console.log(\"not implemented\");\n  }\n\n  static getNode<T>(id: string): T | undefined {\n    return this.RED.nodes.getNode(id) as T;\n  }\n}\n\nexport {\n  ConfigNodeValidations,\n  Node,\n  NodeConfigs,\n  NodeValidations,\n  IONodeValidations,\n};\n","import { Static } from \"@sinclair/typebox\";\nimport { MessageSchema, IONodeConfigsSchema } from \"../../schemas\";\nimport { validatorService } from \"../validator\";\nimport { Node, IONodeValidations } from \"./node\";\n\ntype CloseDoneFunction = () => void;\ntype InputDoneFunction = (error?: Error | string) => void;\ntype IONodeConfigs = Static<typeof IONodeConfigsSchema>;\ntype Message = Static<typeof MessageSchema>;\ntype SendFunction<T> = (data: T | T[]) => void;\ninterface ContextStore {\n  get(key: string): any;\n  set(key: string, value: any): void;\n}\n\ninterface Context {\n  flow: ContextStore;\n  global: ContextStore;\n  node: ContextStore;\n}\n\n// NOTE: these methods are implemented and defined by Node-RED runtime. They were added here to provide intelisense only.\ndeclare module \"./io-node\" {\n  interface IONode<TConfigs, TCredentials, TInputMessage, TOutputMessage> {\n    close(removed: boolean): Promise<void>;\n    context(): Context;\n    emit(event: string, ...args: any[]): void;\n    on(event: string, callback: (...args: any[]) => void): void;\n    receive(msg: TInputMessage): void;\n    removeAllListeners(name: string): void;\n    removeListener(name: string): void;\n    send(msg: TOutputMessage): void;\n    updateWires(wires: string[][]): void;\n    metric(\n      eventName: string,\n      msg: Message & { [key: string]: any },\n      metricValue: number\n    ): boolean | void;\n    status(\n      status:\n        | { fill?: \"red\" | \"green\"; shape?: \"dot\" | \"string\"; text?: string }\n        | string\n    ): void;\n  }\n}\n\nabstract class IONode<\n  TConfigs extends IONodeConfigs = IONodeConfigs,\n  TCredentials = any,\n  TInputMessage = Message,\n  TOutputMessage = Message | Message[] | (Message | null)[],\n> extends Node<TConfigs, TCredentials> {\n  public static override readonly validations: IONodeValidations;\n\n  public readonly wires: string[][];\n  public readonly x: number;\n  public readonly y: number;\n\n  constructor(configs: TConfigs) {\n    super(configs);\n\n    this.x = configs.x;\n    this.y = configs.y;\n    this.wires = configs.wires || [[]];\n\n    console.log(\"SETUP EVENT HANDLERS\");\n    this.setupEventHandlers();\n  }\n\n  abstract onInput(\n    msg: TInputMessage,\n    send: SendFunction<TOutputMessage>,\n    done: InputDoneFunction\n  ): void | Promise<void>;\n\n  abstract onClose(\n    removed: boolean,\n    done: CloseDoneFunction\n  ): void | Promise<void>;\n\n  /**\n   * Sets up event handlers for the node. Automatically binds methods starting with \"on\" from the base class\n   * to their corresponding events.\n   */\n  private setupEventHandlers() {\n    console.log(\"INSIDE SETUPTEVENTHANDLERS\");\n    if (this.onInput) {\n      console.log(\"REGISTERING ON INPUT\");\n      this.on(\n        \"input\",\n        async (\n          msg: TInputMessage,\n          send: SendFunction<TOutputMessage>,\n          done: InputDoneFunction\n        ) => {\n          try {\n            const inputSchema = IONode.validations?.input;\n            if (inputSchema) {\n              console.log(\"validating message\");\n              const messageValidator =\n                validatorService.createValidator(inputSchema);\n              const isValid = messageValidator(msg);\n              if (!isValid) {\n                const errors = validatorService.errors(\n                  messageValidator.errors,\n                  {\n                    separator: \"\\n\",\n                    dataVar: \"- message\",\n                  }\n                );\n                console.error(errors);\n                return done(errors);\n              }\n            }\n\n            await Promise.resolve(this.onInput(msg, send, done));\n          } catch (error) {\n            if (error instanceof Error) {\n              this.error(\"Error while processing input: \" + error.message, msg);\n              done(error);\n            } else {\n              this.error(\"Unknown error occurred during input handling\", msg);\n              done(\"Unknown error occurred during input handling\");\n            }\n          }\n        }\n      );\n    }\n    if (this.onClose) {\n      this.on(\"close\", this.onClose);\n    }\n  }\n}\n\nexport {\n  CloseDoneFunction,\n  Context,\n  ContextStore,\n  InputDoneFunction,\n  IONode,\n  IONodeConfigs,\n  SendFunction,\n};\n","import { Static } from \"@sinclair/typebox\";\nimport { ConfigNodeConfigsSchema } from \"../../schemas\";\nimport { Node, ConfigNodeValidations } from \"./node\";\n\ntype ConfigNodeConfigs = Static<typeof ConfigNodeConfigsSchema>;\n\nabstract class ConfigNode<\n  TConfigs extends ConfigNodeConfigs = ConfigNodeConfigs,\n  TCredentials = any,\n> extends Node<TConfigs, TCredentials> {\n  public static override readonly validations: ConfigNodeValidations;\n  public readonly users: string[];\n\n  constructor(configs: TConfigs) {\n    super(configs);\n    this.users = configs._users || [];\n  }\n}\n\nexport { ConfigNode, ConfigNodeConfigs };\n","import { Type } from \"@sinclair/typebox\";\n\nexport default Type.Object({\n  id: Type.String(),\n  type: Type.String(),\n  name: Type.String(),\n  g: Type.Optional(Type.String()),\n  z: Type.Optional(Type.String()),\n});\n","import { Type } from \"@sinclair/typebox\";\nimport NodeConfigsSchema from \"./node-configs\";\n\nexport default Type.Object({\n  ...NodeConfigsSchema.properties,\n  _users: Type.Array(Type.String()),\n});\n","import { Type } from \"@sinclair/typebox\";\n\nexport default Type.Object({\n  payload: Type.Optional(Type.String()),\n  topic: Type.Optional(Type.String()),\n  _msgid: Type.Optional(Type.String()),\n});\n","import { Type } from \"@sinclair/typebox\";\nimport NodeConfigsSchema from \"./node-configs\";\n\nexport default Type.Object({\n  ...NodeConfigsSchema.properties,\n  wires: Type.Array(Type.Array(Type.String(), { default: [] }), {\n    default: [[]],\n  }),\n  x: Type.Number(),\n  y: Type.Number(),\n});\n","const TYPED_INPUT_TYPES = [\n  \"msg\",\n  \"flow\",\n  \"global\",\n  \"str\",\n  \"num\",\n  \"bool\",\n  \"json\",\n  \"bin\",\n  \"re\",\n  \"jsonata\",\n  \"date\",\n  \"env\",\n  \"node\",\n  \"cred\",\n];\n\nexport { TYPED_INPUT_TYPES };\n","import { Type, Static } from \"@sinclair/typebox\";\nimport { TYPED_INPUT_TYPES } from \"../constants\";\n\nconst TypedInputTypeLiterals = TYPED_INPUT_TYPES.map((type) =>\n  Type.Literal(type)\n);\n\nexport default Type.Object(\n  {\n    value: Type.Union(\n      [Type.String(), Type.Number(), Type.Boolean(), Type.Null()],\n      {\n        description: \"The actual value entered or selected.\",\n        default: \"\",\n      }\n    ),\n    type: Type.Union(TypedInputTypeLiterals, {\n      description:\n        \"The type of the value (string, number, message property, etc.)\",\n      default: \"str\",\n    }),\n  },\n  {\n    description: \"Represents a Node-RED TypedInput value and its type.\",\n    default: {\n      type: \"str\",\n      value: \"\",\n    },\n  }\n);\n","import { Type, Static } from \"@sinclair/typebox\";\nimport {\n  IONodeConfigsSchema,\n  TypedInputSchema,\n  MessageSchema,\n} from \"../../core/schemas\";\n\nconst ConfigsSchema = Type.Object(\n  {\n    ...IONodeConfigsSchema.properties,\n    name: Type.String({ default: \"your-node\" }),\n    myProperty: TypedInputSchema,\n    myProperty2: TypedInputSchema,\n    remoteServer: Type.String({ nodeType: \"remote-server\" }),\n    anotherRemoteServer: Type.Optional(\n      Type.String({ nodeType: \"remote-server\" })\n    ),\n    country: Type.String({ default: \"brazil\" }),\n    fruit: Type.Array(Type.String(), { default: [\"apple\", \"melon\"] }),\n    number: Type.String({ default: \"1\" }),\n    object: Type.Array(Type.String(), {\n      default: [JSON.stringify({ test: \"a\" }), JSON.stringify({ test: \"b\" })],\n    }),\n    array: Type.String({\n      default: '[\"a\"]',\n    }),\n    jsontest: Type.String({ default: \"\" }),\n    csstest: Type.String({ default: \"\" }),\n  },\n  {\n    $id: \"YourNodeConfigsSchema\",\n  }\n);\n\nconst CredentialsSchema = Type.Object(\n  {\n    password: Type.Optional(\n      Type.String({\n        default: \"\",\n        minLength: 8,\n        maxLength: 20,\n        pattern: /^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]+$/.source,\n        format: \"password\",\n      })\n    ),\n    password2: Type.Optional(\n      Type.String({\n        default: \"\",\n        pattern:\n          /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/\n            .source,\n        format: \"password\",\n      })\n    ),\n    username: Type.Optional(\n      Type.String({ default: \"\", maxLength: 10, minLength: 5 })\n    ),\n  },\n  {\n    $id: \"YourNodeCredentialsSchema\",\n  }\n);\n\nconst InputMessageSchema = Type.Intersect(\n  [\n    MessageSchema,\n    Type.Object({\n      myVariable: Type.Optional(Type.String()),\n    }),\n  ],\n  {\n    $id: \"YourNodeInputMessageSchema\",\n  }\n);\n\nconst OutputMessageSchema = Type.Intersect(\n  [\n    MessageSchema,\n    Type.Object({\n      originalType: Type.Union([\n        Type.Literal(\"string\"),\n        Type.Literal(\"number\"),\n      ]),\n      processedTime: Type.Number(),\n    }),\n    Type.Unknown(),\n  ],\n  { $id: \"YourNodeOutputMessageSchema\" }\n);\n\nexport {\n  ConfigsSchema,\n  CredentialsSchema,\n  InputMessageSchema,\n  OutputMessageSchema,\n};\n","import { Static } from \"@sinclair/typebox\";\nimport {\n  CloseDoneFunction,\n  InputDoneFunction,\n  IONode,\n  IONodeValidations,\n  SendFunction,\n} from \"../../../core/server/nodes\";\nimport RemoteServerConfigNode from \"./remote-server\";\nimport {\n  ConfigsSchema,\n  CredentialsSchema,\n  InputMessageSchema,\n  OutputMessageSchema,\n} from \"../../schemas/your-node\";\n\nexport type YourNodeConfigs = Static<typeof ConfigsSchema>;\nexport type YourNodeCredentials = Static<typeof CredentialsSchema>;\nexport type YourNodeInputMessage = Static<typeof InputMessageSchema>;\nexport type YourNodeOutputMessage = Static<typeof OutputMessageSchema>;\n\nexport default class YourNode extends IONode<\n  YourNodeConfigs,\n  YourNodeCredentials,\n  YourNodeInputMessage,\n  YourNodeOutputMessage\n> {\n  static override validations: IONodeValidations = {\n    configs: ConfigsSchema,\n    credentials: CredentialsSchema,\n    input: InputMessageSchema,\n    outputs: OutputMessageSchema,\n  };\n\n  static override async init() {\n    console.log(\"testing your-node node init\");\n\n    try {\n      const response = await fetch(\"https://dog.ceo/api/breeds/image/random\");\n      if (!response.ok) {\n        throw new Error(`Response status: ${response.status}`);\n      }\n\n      const json = await response.json();\n      console.log(json);\n    } catch (error) {\n      if (error instanceof Error) {\n        console.error(\"Error while fetching dogs: \", error.message);\n      } else {\n        console.error(\"Unknown error occurred: \", error);\n      }\n    }\n  }\n\n  async onInput(\n    msg: {\n      payload?: string | undefined;\n      topic?: string | undefined;\n      _msgid?: string | undefined;\n    } & { myVariable?: string | undefined },\n    send: SendFunction<\n      {\n        payload?: string | undefined;\n        topic?: string | undefined;\n        _msgid?: string | undefined;\n      } & { originalType: \"string\" | \"number\"; processedTime: number }\n    >,\n    done: InputDoneFunction\n  ): Promise<void> {\n    console.log(this);\n    console.log(msg);\n\n    const server = IONode.getNode<RemoteServerConfigNode>(\n      this.configs.remoteServer\n    );\n    console.log(server?.users);\n\n    const outputMsg: YourNodeOutputMessage = {\n      originalType: \"number\",\n      processedTime: 1,\n    };\n    send(outputMsg);\n    done();\n  }\n\n  async onClose(removed: boolean, done: CloseDoneFunction): Promise<void> {\n    console.log(\"removing node\");\n    done();\n  }\n}\n","import { Type } from \"@sinclair/typebox\";\nimport { ConfigNodeConfigsSchema } from \"../../core/schemas\";\n\nconst ConfigsSchema = Type.Object(\n  {\n    ...ConfigNodeConfigsSchema.properties,\n    name: Type.String({ default: \"remote-server\", minLength: 10 }),\n    host: Type.String({ default: \"localhost\" }),\n  },\n  {\n    $id: \"RemoteServerConfigsSchema\",\n  }\n);\n\nexport { ConfigsSchema };\n","import { Static } from \"@sinclair/typebox\";\nimport { ConfigNode, ConfigNodeValidations } from \"../../../core/server/nodes\";\nimport { ConfigsSchema } from \"../../schemas/remote-server\";\n\nexport type RemoteServerConfigs = Static<typeof ConfigsSchema>;\n\nexport default class RemoteServerConfigNode extends ConfigNode<RemoteServerConfigs> {\n  static override validations: ConfigNodeValidations = {\n    configs: ConfigsSchema,\n  };\n\n  // NOTE: run only once when node type is registered\n  static override async init() {\n    console.log(\"testing remote-server node init\");\n\n    try {\n      const response = await fetch(\"https://dog.ceo/api/breeds/image/random\");\n      if (!response.ok) {\n        throw new Error(`Response status: ${response.status}`);\n      }\n\n      const json = await response.json();\n      console.log(json);\n    } catch (error) {\n      if (error instanceof Error) {\n        console.error(\"Error while fetching dogs: \", error.message);\n      } else {\n        console.error(\"Unknown error occurred: \", error);\n      }\n    }\n  }\n}\n","import { AnySchemaObject } from \"ajv\";\nimport { Type } from \"@sinclair/typebox\";\n\nfunction getDefaultsFromSchema(\n  schema: AnySchemaObject\n): Record<string, { type?: string; required: boolean; value: any }> {\n  const result: Record<\n    string,\n    { type?: string; required: boolean; value: any }\n  > = {};\n\n  console.log(\"getDefaultsFromSchema\");\n  for (const [key, value] of Object.entries(schema.properties)) {\n    // NOTE: these are excluded from defaults because they must be set by the editor\n    if ([\"x\", \"y\", \"z\", \"g\", \"wires\", \"type\", \"id\"].includes(key)) continue;\n    const property = value as { default?: any; nodeType?: string };\n    console.log(key);\n    console.log(property);\n\n    result[key] = {\n      // NOTE: required is defined by the JSON Schema\n      required: false,\n      value: property.default ?? undefined,\n      // NOTE: I'm using a custom json schema keyword to determine the node type\n      type: property.nodeType,\n    };\n  }\n\n  return result;\n}\n\nfunction getCredentialsFromSchema(\n  schema: AnySchemaObject\n): Record<string, { type: string; required: boolean; value: any }> {\n  const result: Record<\n    string,\n    { type: string; required: boolean; value: any }\n  > = {};\n\n  for (const [key, value] of Object.entries(schema.properties)) {\n    const property = value as {\n      default?: any;\n      format: string;\n      nodeType?: string;\n    };\n    console.log(property);\n    const isPassword = property.format === \"password\";\n    result[key] = {\n      // NOTE: required is defined by the JSON Schema\n      required: false,\n      type: isPassword ? \"password\" : \"text\",\n      value: property.default ?? undefined,\n    };\n  }\n\n  return result;\n}\n\nexport { getDefaultsFromSchema, getCredentialsFromSchema };\n","import { Type } from \"@sinclair/typebox\";\nimport camelCase from \"camelcase\";\nimport { merge } from \"es-toolkit\";\nimport { Request, Response } from \"express\";\nimport { getCredentialsFromSchema } from \"../utils\";\nimport { Node, IONode, ConfigNode } from \"./nodes\";\nimport { validatorService } from \"./validator\";\n\n// TODO: define RED type\n/**\n * Registers a custom node built with the nrg framework\n * @static\n * @async\n * @param {object} RED - The Node-RED runtime API object\n * @param {(Node | IONode | ConfigNode )} NodeClass - A node class extending Node or ConfigNode\n * @returns {Promise<void>} A promise that resolves when the node type registration and setup are complete. It might wait for the `NodeClass.init()` promise if one is returned.\n * @throws {Error} If NodeClass does not extend `Node`\n * @throws {Error} If type is note defined\n */\nexport async function registerType(\n  RED: any,\n  type: string,\n  NodeClass:\n    | typeof Node\n    | typeof ConfigNode<any, any>\n    | typeof IONode<any, any, any, any>\n) {\n  if (!(NodeClass.prototype instanceof Node)) {\n    throw new Error(\n      `${NodeClass.name} must extend IONode or ConfigNode classes`\n    );\n  }\n\n  if (!type) {\n    throw new Error(`type must be provided when registering the node`);\n  }\n\n  // TODO: move this somewhere else\n  if (Node.RED === undefined) {\n    Object.defineProperty(Node, \"RED\", {\n      value: RED,\n      writable: false,\n      configurable: false,\n      enumerable: false,\n    });\n  }\n\n  // TODO: move this somewhere else\n  if (IONode.RED === undefined) {\n    Object.defineProperty(IONode, \"RED\", {\n      value: RED,\n      writable: false,\n      configurable: false,\n      enumerable: false,\n    });\n  }\n\n  // TODO: move this somewhere else\n  if (ConfigNode.RED === undefined) {\n    Object.defineProperty(ConfigNode, \"RED\", {\n      value: RED,\n      writable: false,\n      configurable: false,\n      enumerable: false,\n    });\n  }\n\n  if (NodeClass.RED === undefined) {\n    Object.defineProperty(NodeClass, \"RED\", {\n      value: RED,\n      writable: false,\n      configurable: false,\n      enumerable: false,\n    });\n  }\n\n  if (NodeClass.type === undefined) {\n    Object.defineProperty(NodeClass, \"type\", {\n      value: type,\n      writable: false,\n      configurable: false,\n      enumerable: false,\n    });\n  }\n\n  console.log(\"NodeClass\");\n  console.log(NodeClass);\n  if (typeof NodeClass.init === \"function\") {\n    const result = NodeClass.init();\n\n    if (result instanceof Promise) {\n      await result;\n    }\n  }\n\n  RED.nodes.registerType(type, NodeClass, {\n    credentials: NodeClass.validations.credentials\n      ? getCredentialsFromSchema(NodeClass.validations.credentials)\n      : {},\n  });\n\n  RED.httpAdmin.get(`/nrg/nodes/${type}`, (req: Request, res: Response) => {\n    if (NodeClass.validations) {\n      const validationConfig = NodeClass.validations;\n\n      const configsProperties = validationConfig.configs.properties\n        ? validationConfig.configs.properties\n        : {};\n\n      const credentialsProperties = validationConfig.credentials?.properties\n        ? validationConfig.credentials.properties\n        : {};\n\n      const nodeProperties = {\n        schema: Type.Object({\n          ...configsProperties,\n          credentials: Type.Object({\n            ...credentialsProperties,\n          }),\n        }),\n      };\n\n      res.json(nodeProperties);\n    } else {\n      res.json({\n        message:\n          \"Node was not configured with schemas to validate configs and credentials\",\n      });\n    }\n  });\n}\n","import YourNode from \"./nodes/your-node\";\nimport RemoteServerConfigNode from \"./nodes/remote-server\";\nimport { registerType } from \"../../core/server\";\n\nexport { YourNode, RemoteServerConfigNode };\n\n// NOTE: this root module can be used to manually control the order nodes are registered\n// TODO: define RED type\nexport default async function (RED: any): Promise<void> {\n  try {\n    console.log(\"Registering node types in series\");\n    // TODO: the order nodes are registered will be defined in nrg.config.ts. If not provided, it will be registered alphabetically based on the folder names\n    // TODO: investigate if it is possible to run Khan's algorithm to determine the registration order\n    await registerType(RED, \"remote-server\", RemoteServerConfigNode);\n    await registerType(RED, \"your-node\", YourNode);\n\n    // TODO: add the order in the message\n    console.log(\"All node types registered in series\");\n  } catch (error) {\n    console.error(\"Error registering node types:\", error);\n  }\n}\n"],"names":["Type","ConfigsSchema"],"mappings":"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"}