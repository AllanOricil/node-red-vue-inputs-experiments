var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function($$1) {
  "use strict";
  /**
  * @vue/shared v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map2[key] = 1;
    return (val) => val in map2;
  }
  const EMPTY_OBJ = Object.freeze({});
  const EMPTY_ARR = Object.freeze([]);
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
  const isArray = Array.isArray;
  const isMap = (val) => toTypeString(val) === "[object Map]";
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const isRef$1 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray(val) && !isPlainObject$1(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i = "") => {
    var _a;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
    );
  };
  /**
  * @vue/reactivity v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function warn$2(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else {
        warn$2(`cannot run an inactive effect scope.`);
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        this.effects.length = 0;
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        if (activeSub !== this) {
          warn$2(
            "Active effect was not restored correctly - this is likely a Vue internal bug."
          );
        }
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed = false) {
    sub.flags |= 8;
    if (isComputed) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    const dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
      computed2.flags &= -3;
      return;
    }
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subsHead === link) {
      dep.subsHead = nextSub;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      {
        this.subsHead = void 0;
      }
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      if (activeSub.onTrack) {
        activeSub.onTrack(
          extend(
            {
              effect: activeSub
            },
            debugInfo
          )
        );
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (true) {
          for (let head = this.subsHead; head; head = head.nextSub) {
            if (head.sub.onTrigger && !(head.sub.flags & 8)) {
              head.sub.onTrigger(
                extend(
                  {
                    effect: head.sub
                  },
                  debugInfo
                )
              );
            }
          }
        }
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l = computed2.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      if (link.dep.subsHead === void 0) {
        link.dep.subsHead = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    "Object iterate"
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    "Map keys iterate"
  );
  const ARRAY_ITERATE_KEY = Symbol(
    "Array iterate"
  );
  function track(target, type2, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      {
        dep.track({
          target,
          type: type2,
          key
        });
      }
    }
  }
  function trigger(target, type2, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger({
            target,
            type: type2,
            key,
            newValue,
            oldValue,
            oldTarget
          });
        }
      }
    };
    startBatch();
    if (type2 === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type2) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn, thisArg) {
      return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  function hasOwnProperty(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      if (key === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty;
        }
      }
      const res = Reflect.get(
        target,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver
      );
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(
        target,
        key,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      {
        warn$2(
          `Set operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key) {
      {
        warn$2(
          `Delete operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type2) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        warn$2(
          `${capitalize(type2)} operation ${key}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
          return this;
        },
        delete(key) {
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get ? get.call(target, key) : void 0;
          const result = target.delete(key);
          if (hadKey) {
            trigger(target, "delete", key, void 0, oldValue);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const oldTarget = isMap(target) ? new Map(target) : new Set(target);
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0,
              oldTarget
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
      const type2 = toRawType(target);
      warn$2(
        `Reactive ${type2} contains both the raw and reactive versions of the same object${type2 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      {
        warn$2(
          `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
            target
          )}`
        );
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject(value) ? readonly(value) : value;
  function isRef(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
      activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      } else {
        warn$2("Write operation failed: computed value is readonly");
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    } else if (!failSilently) {
      warn$2(
        `onWatcherCleanup() was called when there was no active watcher to associate with.`
      );
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const warnInvalidSource = (s) => {
      (options.onWarn || warn$2)(
        `Invalid watch source: `,
        s,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction(s)) {
          return call ? call(s, 2) : s();
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope2 = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope2 && scope2.active) {
        remove(scope2.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    {
      effect2.onTrack = options.onTrack;
      effect2.onTrigger = options.onTrigger;
    }
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$1(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a) => {
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
  };
  function callWithErrorHandling(fn, instance, type2, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type2);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type2, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type2, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type2);
        });
      }
      return res;
    }
    if (isArray(fn)) {
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
      }
      return values;
    } else {
      warn$1(
        `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
      );
    }
  }
  function handleError(err, instance, type2, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = ErrorTypeStrings$1[type2];
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
    {
      const info = ErrorTypeStrings$1[type2];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  const RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id2) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    const check = (job) => checkRecursiveUpdates(seen, job);
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (check(job)) {
            continue;
          }
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs(seen);
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    const count = seen.get(fn) || 0;
    if (count > RECURSION_LIMIT) {
      const instance = fn.i;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    }
    seen.set(fn, count + 1);
    return false;
  }
  let isHmrUpdating = false;
  const hmrDirtyComponents = /* @__PURE__ */ new Map();
  {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  const map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id2 = instance.type.__hmrId;
    let record = map.get(id2);
    if (!record) {
      createRecord(id2, instance.type);
      record = map.get(id2);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id2, initialDef) {
    if (map.has(id2)) {
      return false;
    }
    map.set(id2, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component2) {
    return isClassComponent(component2) ? component2.__vccOpts : component2;
  }
  function rerender(id2, newRender) {
    const record = map.get(id2);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id2, newComp) {
    const record = map.get(id2);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (let i = 0; i < instances.length; i++) {
      const instance = instances[i];
      const oldComp = normalizeClassComponent(instance.type);
      let dirtyInstances = hmrDirtyComponents.get(oldComp);
      if (!dirtyInstances) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
      }
      dirtyInstances.add(instance);
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        dirtyInstances.add(instance);
        instance.ceReload(newComp.styles);
        dirtyInstances.delete(instance);
      } else if (instance.parent) {
        queueJob(() => {
          isHmrUpdating = true;
          instance.parent.update();
          isHmrUpdating = false;
          dirtyInstances.delete(instance);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
      if (instance.root.ce && instance !== instance.root) {
        instance.root.ce._removeChildStyle(oldComp);
      }
    }
    queuePostFlushCb(() => {
      hmrDirtyComponents.clear();
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return (id2, arg) => {
      try {
        return fn(id2, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  let devtools$1;
  let buffer = [];
  let devtoolsNotInstalled = false;
  function emit$1(event, ...args) {
    if (devtools$1) {
      devtools$1.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version2) {
    emit$1("app:init", app, version2, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:added"
    /* COMPONENT_ADDED */
  );
  const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:updated"
    /* COMPONENT_UPDATED */
  );
  const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
    /* COMPONENT_REMOVED */
  );
  const devtoolsComponentRemoved = (component2) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools$1.cleanupBuffer(component2)) {
      _devtoolsComponentRemoved(component2);
    }
  };
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function createDevtoolsComponentHook(hook) {
    return (component2) => {
      emit$1(
        hook,
        component2.appContext.app,
        component2.uid,
        component2.parent ? component2.parent.uid : void 0,
        component2
      );
    };
  }
  const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:start"
    /* PERFORMANCE_START */
  );
  const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:end"
    /* PERFORMANCE_END */
  );
  function createDevtoolsPerformanceHook(hook) {
    return (component2, type2, time) => {
      emit$1(hook, component2.appContext.app, component2.uid, component2, type2, time);
    };
  }
  function devtoolsComponentEmit(component2, event, params) {
    emit$1(
      "component:emit",
      component2.appContext.app,
      component2,
      event,
      params
    );
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type2) => type2.__isTeleport;
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
      {
        if (hasOwn(rawSetupState, key) && !isRef(rawSetupState[key])) {
          warn$1(
            `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
          );
        }
        if (knownTemplateRefs.has(rawSetupState[key])) {
          return false;
        }
      }
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray(existing) && remove(existing, refValue);
            } else {
              if (!isArray(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else {
            warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else {
        warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
      }
    }
  }
  getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type2, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type2, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type2, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
    const injected = injectHook(
      type2,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type2], injected);
    }, target);
  }
  function injectHook(type2, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type2] || (target[type2] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type2, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type2].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve$1(instance[type2] || Component[type2], name) || // global registration
        resolve$1(instance.appContext[type2], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (warnMissing && !res) {
        const extra = `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.`;
        warn$1(`Failed to resolve ${type2.slice(0, -1)}: ${name}${extra}`);
      }
      return res;
    } else {
      warn$1(
        `resolve${capitalize(type2.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve$1(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => shallowReadonly(i.props),
      $attrs: (i) => shallowReadonly(i.attrs),
      $slots: (i) => shallowReadonly(i.slots),
      $refs: (i) => shallowReadonly(i.refs),
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $host: (i) => i.ce,
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => {
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    })
  );
  const isReservedPrefix = (key) => key === "_" || key === "$";
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
          markAttrsAccessed();
        } else if (key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
      // to infinite warning loop
      key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
              key
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type2, key) => {
      if (cache[key]) {
        warn$1(`${type2} property "${key}" is already defined in ${cache[key]}.`);
      } else {
        cache[key] = type2;
      }
    };
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          {
            Object.defineProperty(ctx, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          }
          {
            checkDuplicateProperties("Methods", key);
          }
        } else {
          warn$1(
            `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (!isReservedPrefix(key[0])) {
              Object.defineProperty(ctx, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get === NOOP) {
          warn$1(`Computed property "${key}" has no getter.`);
        }
        const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
          warn$1(
            `Write operation failed: computed property "${key}" is readonly.`
          );
        };
        const c = computed({
          get,
          set
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
      {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type2) {
    callWithAsyncErrorHandling(
      isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type2
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction(handler)) {
        {
          watch(getter, handler);
        }
      } else {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        } else {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else {
      warn$1(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction(to) ? to.call(this, this) : to,
        isFunction(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray(to) && isArray(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          }
          return app;
        },
        component(name, component2) {
          {
            validateComponentName(name, context.config);
          }
          if (!component2) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn$1(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component2;
          return app;
        },
        directive(name, directive) {
          {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn$1(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              context.reload = () => {
                render(
                  cloneVNode(vnode),
                  rootContainer,
                  namespace
                );
              };
            }
            {
              render(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getComponentPublicInstance(vnode.component);
          } else {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        onUnmount(cleanupFn) {
          if (typeof cleanupFn !== "function") {
            warn$1(
              `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
            );
          }
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render(null, app._container);
            {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            warn$1(
              `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
            );
          }
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) {
      {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else {
        warn$1(`injection "${String(key)}" not found.`);
      }
    } else {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId) return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys) needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn$1(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type2 = propType[index];
              const typeName = isFunction(type2) && type2.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    } else {
      warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
    for (const key in options) {
      let opt = options[key];
      if (opt == null) continue;
      validateProp(
        key,
        resolvedValues[key],
        opt,
        shallowReadonly(resolvedValues),
        !camelizePropsKey.includes(key)
      );
    }
  }
  function validateProp(name, value, prop, props, isAbsent) {
    const { type: type2, required: required2, validator, skipCheck } = prop;
    if (required2 && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required2) {
      return;
    }
    if (type2 != null && type2 !== true && !skipCheck) {
      let isValid = false;
      const types2 = isArray(type2) ? type2 : [type2];
      const expectedTypes = [];
      for (let i = 0; i < types2.length && !isValid; i++) {
        const { valid, expectedType } = assertType(value, types2[i]);
        expectedTypes.push(expectedType || "");
        isValid = valid;
      }
      if (!isValid) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  const isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type2) {
    let valid;
    const expectedType = getType(type2);
    if (expectedType === "null") {
      valid = value === null;
    } else if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type2;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else {
      valid = value instanceof type2;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type2) {
    if (type2 === "String") {
      return `"${value}"`;
    } else if (type2 === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type2) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type2.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1(
          `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        {
          warn$1(
            `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type2, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        if (isHmrUpdating) {
          assignSlots(slots, children, optimized);
          trigger(instance, "set", "$slots");
        } else if (optimized && type2 === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  let supported;
  let perf;
  function startMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type2}-${instance.uid}`);
    }
    {
      devtoolsPerfStart(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type2}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(
        `<${formatComponentName(instance, instance.type)}> ${type2}`,
        startTag,
        endTag
      );
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    {
      devtoolsPerfEnd(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type2, ref: ref3, shapeFlag } = n2;
      switch (type2) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else {
            warn$1("Invalid VNode type:", type2, `(${typeof type2})`);
          }
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      {
        def(el, "__vnode", vnode, true);
        def(el, "__vueParentComponent", parentComponent, true);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      {
        el.__vnode = n2;
      }
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (
        // #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048
      ) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        {
          startMeasure(instance, `init`);
        }
        setupComponent(instance, false, optimized);
        {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        if (isHmrUpdating) initialVNode.el = null;
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent, root, type: type2 } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root.ce) {
              root.ce._injectChildStyle(type2);
            }
            {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
          {
            devtoolsComponentUpdated(instance);
          }
          {
            popWarningContext();
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type2, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type2.move(vnode, container, anchor, internals);
        return;
      }
      if (type2 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type2 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type: type2,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type: type2, el, anchor, transition } = vnode;
      if (type2 === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type2 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope: scope2, job, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope2.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    return {
      render,
      hydrate,
      createApp: createAppAPI(render)
    };
  }
  function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
    return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watch(source, cb, options) {
    if (!isFunction(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const baseWatchOptions = extend({}, options);
    baseWatchOptions.onWarn = warn$1;
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance, type2, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
            warn$1(
              `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event))}" prop.`
            );
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction(validator)) {
            const isValid = validator(...rawArgs);
            if (!isValid) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    {
      devtoolsComponentEmit(instance, event, args);
    }
    {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event
          )}" instead of "${event}".`
        );
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  let accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render.call(
            thisProxy,
            proxyToUse,
            renderCache,
            true ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render2.length > 1 ? render2(
            true ? shallowReadonly(props) : props,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render2(
            true ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      setTransitionHooks(root, vnode.transition);
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  const isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component: component2 } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component2.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type2) => type2.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type2, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && n1.component) {
      const dirtyInstances = hmrDirtyComponents.get(n2.type);
      if (dirtyInstances && dirtyInstances.has(n1.component)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
      }
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...args
    );
  };
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type2,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type2.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = createVNodeWithArgsTransform;
  function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
      if (!type2) {
        warn$1(`Invalid vnode type when creating vnode: ${type2}.`);
      }
      type2 = Comment;
    }
    if (isVNode(type2)) {
      const cloned = cloneVNode(
        type2,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type2)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type2)) {
      type2 = type2.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction(type2) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type2)) {
      type2 = toRaw(type2);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type2
      );
    }
    return createBaseVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type2 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type2 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type2 = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type2 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type2 = 16;
        children = [createTextVNode(children)];
      } else {
        type2 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type2;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type2 = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type: type2,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type2, appContext),
      emitsOptions: normalizeEmitsOptions(type2, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type2.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = createDevRenderContext(instance);
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key])) setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set) => set(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names2 = Object.keys(Component.components);
        for (let i = 0; i < names2.length; i++) {
          validateComponentName(names2[i], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names2 = Object.keys(Component.directives);
        for (let i = 0; i < names2.length; i++) {
          validateDirectiveName(names2[i]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          shallowReadonly(instance.props),
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name = (_a = Component.name) != null ? _a : "Anonymous";
            warn$1(
              `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  const isRuntimeOnly = () => true;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!Component.render && instance.render === NOOP && !isSSR) {
      if (Component.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function: `, Component);
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      markAttrsAccessed();
      track(target, "get", "");
      return target[key];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  };
  function getSlotsProxy(instance) {
    return new Proxy(instance.slots, {
      get(target, key) {
        track(instance, "get", "$slots");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray(exposed)) {
              exposedType = "array";
            } else if (isRef(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    {
      let attrsProxy;
      let slotsProxy;
      return Object.freeze({
        get attrs() {
          return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
        },
        get slots() {
          return slotsProxy || (slotsProxy = getSlotsProxy(instance));
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    {
      const i = getCurrentInstance();
      if (i && i.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      __vue_custom_formatter: true,
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            // avoid debugger accessing value affecting behavior
            formatValue("_value" in obj ? obj._value : obj),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed2 = extractKeys(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type2, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type2
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type2) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type2)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type2) {
      const opts = Comp[type2];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type2)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type2))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  const version = "3.5.13";
  const warn = warn$1;
  /**
  * @vue/runtime-dom v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
      warn(`Error creating trusted types policy: ${e}`);
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id2) {
      el.setAttribute(id2, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const vtcKey = Symbol("_vtc");
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const semicolonRE = /[^\\];\s*$/;
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null) val = "";
      {
        if (semicolonRE.test(val)) {
          warn(
            `Unexpected semicolon at the end of '${name}' style value: '${val}'`
          );
        }
      }
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type2 = typeof el[key];
      if (type2 === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type2 === "string") {
        value = "";
        needRemove = true;
      } else if (type2 === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (!needRemove) {
        warn(
          `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e
        );
      }
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = sanitizeEventValue(nextValue, rawName);
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          sanitizeEventValue(nextValue, rawName),
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function sanitizeEventValue(value, propName) {
    if (isFunction(value) || isArray(value)) {
      return value;
    }
    warn(
      `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
    );
    return NOOP;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
    ) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component2 = app._component;
      if (!isFunction(component2) && !component2.render && !component2.template) {
        component2.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn(msg);
          return compilerOptions;
        },
        set() {
          warn(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }
  /**
  * vue v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  {
    initDev();
  }
  function noop() {
  }
  function isPrimitive(value) {
    return value == null || typeof value !== "object" && typeof value !== "function";
  }
  function isTypedArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }
  function getSymbols(object) {
    return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
  }
  function getTag(value) {
    if (value == null) {
      return value === void 0 ? "[object Undefined]" : "[object Null]";
    }
    return Object.prototype.toString.call(value);
  }
  const regexpTag = "[object RegExp]";
  const stringTag = "[object String]";
  const numberTag = "[object Number]";
  const booleanTag = "[object Boolean]";
  const argumentsTag = "[object Arguments]";
  const symbolTag = "[object Symbol]";
  const dateTag = "[object Date]";
  const mapTag = "[object Map]";
  const setTag = "[object Set]";
  const arrayTag = "[object Array]";
  const functionTag = "[object Function]";
  const arrayBufferTag = "[object ArrayBuffer]";
  const objectTag = "[object Object]";
  const errorTag = "[object Error]";
  const dataViewTag = "[object DataView]";
  const uint8ArrayTag = "[object Uint8Array]";
  const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
  const uint16ArrayTag = "[object Uint16Array]";
  const uint32ArrayTag = "[object Uint32Array]";
  const bigUint64ArrayTag = "[object BigUint64Array]";
  const int8ArrayTag = "[object Int8Array]";
  const int16ArrayTag = "[object Int16Array]";
  const int32ArrayTag = "[object Int32Array]";
  const bigInt64ArrayTag = "[object BigInt64Array]";
  const float32ArrayTag = "[object Float32Array]";
  const float64ArrayTag = "[object Float64Array]";
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack2 = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack2);
    if (cloned != null) {
      return cloned;
    }
    if (isPrimitive(valueToClone)) {
      return valueToClone;
    }
    if (stack2.has(valueToClone)) {
      return stack2.get(valueToClone);
    }
    if (Array.isArray(valueToClone)) {
      const result = new Array(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
      }
      if (Object.hasOwn(valueToClone, "index")) {
        result.index = valueToClone.index;
      }
      if (Object.hasOwn(valueToClone, "input")) {
        result.input = valueToClone.input;
      }
      return result;
    }
    if (valueToClone instanceof Date) {
      return new Date(valueToClone.getTime());
    }
    if (valueToClone instanceof RegExp) {
      const result = new RegExp(valueToClone.source, valueToClone.flags);
      result.lastIndex = valueToClone.lastIndex;
      return result;
    }
    if (valueToClone instanceof Map) {
      const result = /* @__PURE__ */ new Map();
      stack2.set(valueToClone, result);
      for (const [key, value] of valueToClone) {
        result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (valueToClone instanceof Set) {
      const result = /* @__PURE__ */ new Set();
      stack2.set(valueToClone, result);
      for (const value of valueToClone) {
        result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
      return valueToClone.subarray();
    }
    if (isTypedArray(valueToClone)) {
      const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
      }
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
      return valueToClone.slice(0);
    }
    if (valueToClone instanceof DataView) {
      const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof File !== "undefined" && valueToClone instanceof File) {
      const result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Blob) {
      const result = new Blob([valueToClone], { type: valueToClone.type });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Error) {
      const result = new valueToClone.constructor();
      stack2.set(valueToClone, result);
      result.message = valueToClone.message;
      result.name = valueToClone.name;
      result.stack = valueToClone.stack;
      result.cause = valueToClone.cause;
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
      const result = Object.create(Object.getPrototypeOf(valueToClone));
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack2, cloneValue) {
    const keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor == null || descriptor.writable) {
        target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack2, cloneValue);
      }
    }
  }
  function isCloneableObject(object) {
    switch (getTag(object)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  function isPlainObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
    if (!hasObjectPrototype) {
      return false;
    }
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function merge(target, source) {
    const sourceKeys = Object.keys(source);
    for (let i = 0; i < sourceKeys.length; i++) {
      const key = sourceKeys[i];
      const sourceValue = source[key];
      const targetValue = target[key];
      if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge([], sourceValue);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge({}, sourceValue);
        }
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function isEqualWith(a, b, areValuesEqual) {
    return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  function isEqualWithImpl(a, b, property, aParent, bParent, stack2, areValuesEqual) {
    const result = areValuesEqual(a, b, property, aParent, bParent, stack2);
    if (result !== void 0) {
      return result;
    }
    if (typeof a === typeof b) {
      switch (typeof a) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined": {
          return a === b;
        }
        case "number": {
          return a === b || Object.is(a, b);
        }
        case "function": {
          return a === b;
        }
        case "object": {
          return areObjectsEqual(a, b, stack2, areValuesEqual);
        }
      }
    }
    return areObjectsEqual(a, b, stack2, areValuesEqual);
  }
  function areObjectsEqual(a, b, stack2, areValuesEqual) {
    if (Object.is(a, b)) {
      return true;
    }
    let aTag = getTag(a);
    let bTag = getTag(b);
    if (aTag === argumentsTag) {
      aTag = objectTag;
    }
    if (bTag === argumentsTag) {
      bTag = objectTag;
    }
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case stringTag:
        return a.toString() === b.toString();
      case numberTag: {
        const x = a.valueOf();
        const y = b.valueOf();
        return eq(x, y);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a.valueOf(), b.valueOf());
      case regexpTag: {
        return a.source === b.source && a.flags === b.flags;
      }
      case functionTag: {
        return a === b;
      }
    }
    stack2 = stack2 ?? /* @__PURE__ */ new Map();
    const aStack = stack2.get(a);
    const bStack = stack2.get(b);
    if (aStack != null && bStack != null) {
      return aStack === b;
    }
    stack2.set(a, b);
    stack2.set(b, a);
    try {
      switch (aTag) {
        case mapTag: {
          if (a.size !== b.size) {
            return false;
          }
          for (const [key, value] of a.entries()) {
            if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case setTag: {
          if (a.size !== b.size) {
            return false;
          }
          const aValues = Array.from(a.values());
          const bValues = Array.from(b.values());
          for (let i = 0; i < aValues.length; i++) {
            const aValue = aValues[i];
            const index = bValues.findIndex((bValue) => {
              return isEqualWithImpl(aValue, bValue, void 0, a, b, stack2, areValuesEqual);
            });
            if (index === -1) {
              return false;
            }
            bValues.splice(index, 1);
          }
          return true;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer !== "undefined" && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0; i < a.length; i++) {
            if (!isEqualWithImpl(a[i], b[i], i, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case arrayBufferTag: {
          if (a.byteLength !== b.byteLength) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
        }
        case dataViewTag: {
          if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
        }
        case errorTag: {
          return a.name === b.name && a.message === b.message;
        }
        case objectTag: {
          const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack2, areValuesEqual) || isPlainObject(a) && isPlainObject(b);
          if (!areEqualInstances) {
            return false;
          }
          const aKeys = [...Object.keys(a), ...getSymbols(a)];
          const bKeys = [...Object.keys(b), ...getSymbols(b)];
          if (aKeys.length !== bKeys.length) {
            return false;
          }
          for (let i = 0; i < aKeys.length; i++) {
            const propKey = aKeys[i];
            const aProp = a[propKey];
            if (!Object.hasOwn(b, propKey)) {
              return false;
            }
            const bProp = b[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        default: {
          return false;
        }
      }
    } finally {
      stack2.delete(a);
      stack2.delete(b);
    }
  }
  function isEqual(a, b) {
    return isEqualWith(a, b, noop);
  }
  function getDefaultsFromSchema(schema) {
    const result = {};
    console.log("getDefaultsFromSchema");
    for (const [key, value] of Object.entries(schema.properties)) {
      if (["x", "y", "z", "g", "wires", "type", "id"].includes(key)) continue;
      const property = value;
      console.log(key);
      console.log(property);
      result[key] = {
        // NOTE: required is defined by the JSON Schema
        required: false,
        value: property.default ?? void 0,
        // NOTE: I'm using a custom json schema keyword to determine the node type
        type: property.nodeType
      };
    }
    return result;
  }
  function getCredentialsFromSchema(schema) {
    const result = {};
    for (const [key, value] of Object.entries(schema.properties)) {
      const property = value;
      console.log(property);
      const isPassword = property.format === "password";
      result[key] = {
        // NOTE: required is defined by the JSON Schema
        required: false,
        type: isPassword ? "password" : "text",
        value: property.default ?? void 0
      };
    }
    return result;
  }
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var jsonpointer$1 = {};
  var hasRequiredJsonpointer;
  function requireJsonpointer() {
    if (hasRequiredJsonpointer) return jsonpointer$1;
    hasRequiredJsonpointer = 1;
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p2 = 1, len = pointer.length; p2 < len; ) {
        if (pointer[p2] === "constructor" || pointer[p2] === "prototype" || pointer[p2] === "__proto__") return obj;
        part = untilde(pointer[p2++]);
        hasNextPart = len > p2;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p2] !== "" && pointer[p2] < Infinity || pointer[p2] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p2 = 1; p2 < len; ) {
        obj = obj[untilde(pointer[p2++])];
        if (len === p2) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile2(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    jsonpointer$1.get = get;
    jsonpointer$1.set = set;
    jsonpointer$1.compile = compile2;
    return jsonpointer$1;
  }
  var jsonpointerExports = requireJsonpointer();
  const jsonpointer = /* @__PURE__ */ getDefaultExportFromCjs(jsonpointerExports);
  const _sfc_main$7 = {
    name: "NodeRedVueApp",
    props: {
      node: {
        type: Object,
        required: true
      },
      validator: {
        type: Function,
        required: true
      },
      disableSaveButtonOnError: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    data() {
      return {
        localNode: this.node,
        errors: {}
      };
    },
    beforeMount() {
      this.validator(this.localNode);
      Object.keys(this.localNode._def.defaults).forEach((prop) => {
        this.$watch(
          () => this.localNode[prop],
          (newVal) => {
            this.validate();
          },
          { deep: true }
        );
      });
      Object.keys(this.localNode._def.credentials).forEach((prop) => {
        if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`]) {
          this.localNode.credentials[prop] = "__PWD__";
        }
        this.$watch(
          () => this.localNode.credentials[prop],
          (newVal, oldVal) => {
            this.validate();
            if (this.localNode._def.credentials[prop].type === "password" && newVal !== oldVal) {
              this.localNode.credentials[`has_${prop}`] = !!newVal;
            }
          },
          { deep: true }
        );
      });
    },
    beforeUnmount() {
      var _a, _b;
      if (this.disableSaveButtonOnError) {
        (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", false).removeClass("disabled");
        (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", false).removeClass("disabled");
        $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
      }
      Object.keys(this.localNode._def.credentials).forEach((prop) => {
        if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`] && this.localNode.credentials[prop] === "__PWD__") {
          this.localNode.credentials[prop] = void 0;
        }
      });
    },
    methods: {
      validate() {
        var _a, _b;
        const valid = this.validator(this.localNode);
        if (!valid) {
          const errors2 = this.validator.errors;
          this.errors = errors2.reduce((acc, error) => {
            const errorValue = jsonpointer.get(
              this.localNode,
              error.instancePath
            );
            if (error.parentSchema.format === "password" && errorValue === "__PWD__") {
              console.log(
                "password fields with value equal to __PWD__ should not be an error"
              );
              return acc;
            } else {
              const key = `node${error.instancePath.replaceAll("/", ".")}`;
              acc[key] = error.message;
              return acc;
            }
          }, {});
        } else {
          this.errors = {};
        }
        if (this.disableSaveButtonOnError) {
          if (Object.keys(this.errors).length) {
            (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", true).addClass("disabled");
            (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", true).addClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "none", "important");
          } else {
            $("#node-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#node-config-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
          }
        }
      }
    }
  };
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _hoisted_1$7 = { style: { "width": "100%" } };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedNodeForm = resolveComponent("NodeRedNodeForm");
    return openBlock(), createElementBlock("div", _hoisted_1$7, [
      createVNode(_component_NodeRedNodeForm, {
        node: $data.localNode,
        errors: $data.errors,
        style: { "width": "100%" }
      }, null, 8, ["node", "errors"])
    ]);
  }
  const NodeRedVueApp = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
  const _sfc_main$6 = {
    props: {
      value: String,
      type: {
        type: String,
        default: "text"
      },
      placeholder: String,
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value", "input"],
    data() {
      return {
        internalValue: "",
        secretPattern: "*************"
      };
    },
    beforeMount() {
      this.internalValue = this.value;
      this.onBlur();
    },
    methods: {
      onInput(event) {
        this.internalValue = event.target.value;
        this.$emit("update:value", this.internalValue);
        this.$emit("input", this.internalValue);
      },
      onFocus() {
        if (this.type === "password" && this.internalValue === this.secretPattern) {
          this.internalValue = "";
        }
      },
      onBlur() {
        if (this.type === "password" && this.value === "__PWD__") {
          this.internalValue = this.secretPattern;
        }
      }
    }
  };
  const _hoisted_1$6 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$6 = ["type", "value", "placeholder"];
  const _hoisted_3$4 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$6, [
      createBaseVNode("input", {
        ref: "inputField",
        type: $props.type,
        value: $data.internalValue,
        placeholder: $props.placeholder,
        onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
        onFocus: _cache[1] || (_cache[1] = (...args) => $options.onFocus && $options.onFocus(...args)),
        onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
        style: { "flex": "1", "width": "100%" }
      }, null, 40, _hoisted_2$6),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$4, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedInput = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
  const TYPED_INPUT_TYPES = [
    "msg",
    "flow",
    "global",
    "str",
    "num",
    "bool",
    "json",
    "bin",
    "re",
    "jsonata",
    "date",
    "env",
    "node",
    "cred"
  ];
  const _sfc_main$5 = {
    props: {
      value: {
        type: Object,
        required: true,
        validator: function(obj) {
          if (false) {
            console.warn(
              "[WARN] Invalid value for 'value' property. It must be an object."
            );
            return false;
          }
          const isValid = typeof (obj == null ? void 0 : obj.value) === "string" && typeof (obj == null ? void 0 : obj.type) === "string";
          if (!isValid) {
            console.warn(
              "[WARN] Invalid value for 'value' property. It must be an object with 'value' and 'type' properties being strings.",
              obj
            );
          }
          return isValid;
        }
      },
      types: {
        type: Array,
        default: () => TYPED_INPUT_TYPES
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    computed: {
      isProvidedValueTypeValid() {
        const type2 = this.value.type;
        const types2 = this.types;
        return types2.includes(type2);
      }
    },
    mounted() {
      const inputElement = this.$refs.typedInput;
      this.$input = $(inputElement).typedInput({
        default: this.value.type || this.types[0],
        types: this.types
      });
      this.$input.typedInput("value", this.value.value || "");
      this.$input.typedInput("type", this.value.type || this.types[0]);
      this.$nextTick(() => {
        const observer = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            if (mutation.attributeName === "value") {
              this.onChange();
            }
          }
        });
        observer.observe(inputElement, {
          attributes: true,
          attributeFilter: ["value"]
        });
        this._observer = observer;
      });
      this.$input.on("change", () => {
        this.onChange();
      });
    },
    watch: {
      isProvidedValueTypeValid: {
        handler(newValue) {
          if (!newValue) {
            console.warn(
              `Validation failed: this.value.type (${this.value.type}) must be one of the provided types (${this.types}).`
            );
          }
        },
        immediate: true
      },
      error(newVal) {
        this.$nextTick(() => {
          const targetDiv = this.$el.querySelector(
            ".red-ui-typedInput-container"
          );
          if (newVal) {
            targetDiv.classList.add("input-error");
          } else {
            targetDiv.classList.remove("input-error");
          }
        });
      }
    },
    methods: {
      onChange() {
        const newValue = this.$input.typedInput("value");
        const newType = this.$input.typedInput("type");
        if (this.value.value !== newValue || this.value.type !== newType) {
          this.$emit("update:value", {
            value: newValue,
            type: newType
          });
        }
      }
    }
  };
  const _hoisted_1$5 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$5 = {
    type: "text",
    ref: "typedInput",
    class: "node-red-typed-input",
    style: { "flex": "1", "width": "100%" }
  };
  const _hoisted_3$3 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$5, [
      createBaseVNode("input", _hoisted_2$5, null, 512),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$3, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedTypedInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
  const _sfc_main$4 = {
    props: {
      value: String,
      type: String,
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    computed: {
      inputPrefix() {
        return "node-input-" + Math.random().toString(36).substring(2, 9);
      },
      inputId() {
        return this.inputPrefix + "-" + this.value;
      }
    },
    mounted() {
      RED.editor.prepareConfigNodeSelect(
        this,
        this.value,
        this.type,
        this.inputPrefix
      );
      const input = $("#" + this.inputId);
      input.on("change", () => {
        this.$emit("update:value", input.val());
      });
      input.val(this.value || "_ADD_");
    }
  };
  const _hoisted_1$4 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$4 = ["id"];
  const _hoisted_3$2 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$4, [
      createBaseVNode("input", {
        type: "text",
        id: $options.inputId,
        style: { "width": "100%" }
      }, null, 8, _hoisted_2$4),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$2, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedConfigInput = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
  const _sfc_main$3 = {
    props: {
      value: String | Array,
      options: {
        type: Array,
        required: true,
        validator: function(value) {
          if (!Array.isArray(value)) {
            console.warn(
              "[WARN] Invalid value for 'options' property. It must be an array."
            );
            return false;
          }
          const isValid = value.every((item) => {
            const isObject2 = typeof item === "object" && item !== null;
            if (!isObject2) return false;
            return item.hasOwnProperty("value") && item.hasOwnProperty("label") && typeof item.value === "string" && typeof item.label === "string";
          });
          if (!isValid) {
            console.warn(
              "[WARN] Invalid value for 'options' property. Each item must be an object with 'value' and 'label' properties being strings.",
              value
            );
          }
          return isValid;
        }
      },
      multiple: {
        type: Boolean,
        default: false
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    mounted() {
      const inputElement = this.$refs.selectInput;
      const $selectInput = $(inputElement);
      $selectInput.typedInput({
        types: [
          {
            multiple: this.multiple,
            options: this.options
          }
        ]
      });
      $selectInput.typedInput(
        "value",
        Array.isArray(this.value) ? this.value.join(",") : this.value
      );
      $selectInput.on("change", () => {
        var _a;
        const newValue = this.multiple ? (_a = $selectInput.typedInput("value")) == null ? void 0 : _a.split(",") : $selectInput.typedInput("value");
        this.$emit("update:value", newValue);
      });
    }
  };
  const _hoisted_1$3 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$3 = {
    type: "text",
    ref: "selectInput",
    class: "node-input-select",
    style: { "width": "100%" }
  };
  const _hoisted_3$1 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$3, [
      createBaseVNode("input", _hoisted_2$3, null, 512),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$1, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
  const _sfc_main$2 = {
    props: {
      value: String,
      language: {
        type: String,
        default: "json",
        validator: function(value) {
          const allowedLanguages = [
            "abap",
            "apex",
            "azcli",
            "bat",
            "bicep",
            "cameligo",
            "clojure",
            "coffee",
            "cpp",
            "csharp",
            "csp",
            "css",
            "cypher",
            "dart",
            "dockerfile",
            "ecl",
            "elixir",
            "flow9",
            "freemarker2",
            "fsharp",
            "go",
            "graphql",
            "handlebars",
            "hcl",
            "html",
            "ini",
            "java",
            "javascript",
            "json",
            "julia",
            "kotlin",
            "less",
            "lexon",
            "liquid",
            "lua",
            "m3",
            "markdown",
            "mdx",
            "mips",
            "msdax",
            "mysql",
            "objective-c",
            "pascal",
            "pascaligo",
            "perl",
            "pgsql",
            "php",
            "pla",
            "postiats",
            "powerquery",
            "powershell",
            "protobuf",
            "pub",
            "python",
            "qsharp",
            "r",
            "razor",
            "redis",
            "redshift",
            "restructuredtext",
            "ruby",
            "rust",
            "sb",
            "scala",
            "scheme",
            "scss",
            "shell",
            "solidity",
            "sophia",
            "sparql",
            "sql",
            "st",
            "swift",
            "systemverilog",
            "tcl",
            "twig",
            "typescript",
            "typespec",
            "vb",
            "wgsl",
            "xml",
            "yaml"
          ];
          const isValid = allowedLanguages.includes(value);
          if (!isValid) {
            console.warn(
              `[WARN]: Invalid value for 'type' property: "${value}". Expected one of: ${allowedLanguages.join(", ")}`
            );
          }
          return isValid;
        }
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    editor: null,
    data() {
      return {
        editorId: "node-red-editor-" + Math.random().toString(36).substring(2, 9)
      };
    },
    mounted() {
      this.mountEditor();
    },
    methods: {
      mountEditor() {
        this.$nextTick(() => {
          const containerEl = this.$refs.containerDiv;
          const editorEl = this.$refs.editorDiv;
          if (containerEl && editorEl) {
            try {
              const inlineHeight = containerEl.style.height;
              const inlineWidth = containerEl.style.width;
              if (inlineHeight) {
                editorEl.style.height = inlineHeight;
              } else {
                editorEl.style.height = "200px";
              }
              if (inlineWidth) {
                editorEl.style.width = inlineWidth;
              } else {
                editorEl.style.width = "100%";
              }
              this.createEditorInstance();
            } catch (e) {
              console.error(
                "[NodeRedEditorInput] Error setting initial editor style:",
                e
              );
              this.createEditorInstance();
            }
          } else {
            console.error(
              "[NodeRedEditorInput] Container or Editor div refs not found on mount."
            );
          }
        });
      },
      createEditorInstance() {
        this.editorInstance = RED.editor.createEditor({
          id: this.editorId,
          mode: this.language,
          value: this.value
        });
        this.editorInstance.getSession().on("change", () => {
          const currentValue = this.editorInstance.getValue();
          if (currentValue !== this.value) {
            this.$emit("update:value", currentValue);
          }
        });
      }
    },
    beforeUnmount() {
      if (this.editorInstance) {
        try {
          this.editorInstance.destroy();
        } catch (err) {
          console.error(`Error destroying editor for ID ${this.editorId}:`, err);
        }
        this.editorInstance = null;
      }
    }
  };
  const _hoisted_1$2 = {
    ref: "containerDiv",
    class: "node-text-editor-container"
  };
  const _hoisted_2$2 = ["id"];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$2, [
      createBaseVNode("div", {
        ref: "editorDiv",
        id: $data.editorId,
        class: "node-text-editor"
      }, null, 8, _hoisted_2$2),
      withDirectives(createBaseVNode("div", { class: "node-red-vue-input-error-message" }, toDisplayString($props.error), 513), [
        [vShow, $props.error]
      ])
    ], 512);
  }
  const NodeRedEditorInput = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  var ajv = { exports: {} };
  var core$1 = {};
  var validate = {};
  var boolSchema = {};
  var errors = {};
  var codegen = {};
  var code$1 = {};
  var hasRequiredCode$1;
  function requireCode$1() {
    if (hasRequiredCode$1) return code$1;
    hasRequiredCode$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
      class _CodeOrName {
      }
      exports._CodeOrName = _CodeOrName;
      exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class Name extends _CodeOrName {
        constructor(s) {
          super();
          if (!exports.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      exports.Name = Name;
      class _Code extends _CodeOrName {
        constructor(code2) {
          super();
          this._items = typeof code2 === "string" ? [code2] : code2;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a;
          return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
        }
        get names() {
          var _a;
          return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
            if (c instanceof Name)
              names2[c.str] = (names2[c.str] || 0) + 1;
            return names2;
          }, {});
        }
      }
      exports._Code = _Code;
      exports.nil = new _Code("");
      function _(strs, ...args) {
        const code2 = [strs[0]];
        let i = 0;
        while (i < args.length) {
          addCodeArg(code2, args[i]);
          code2.push(strs[++i]);
        }
        return new _Code(code2);
      }
      exports._ = _;
      const plus = new _Code("+");
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i = 0;
        while (i < args.length) {
          expr.push(plus);
          addCodeArg(expr, args[i]);
          expr.push(plus, safeStringify(strs[++i]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports.str = str;
      function addCodeArg(code2, arg) {
        if (arg instanceof _Code)
          code2.push(...arg._items);
        else if (arg instanceof Name)
          code2.push(arg);
        else
          code2.push(interpolate(arg));
      }
      exports.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i = 1;
        while (i < expr.length - 1) {
          if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
            if (res !== void 0) {
              expr.splice(i - 1, 3, res);
              continue;
            }
            expr[i++] = "+";
          }
          i++;
        }
      }
      function mergeExprItems(a, b) {
        if (b === '""')
          return a;
        if (a === '""')
          return b;
        if (typeof a == "string") {
          if (b instanceof Name || a[a.length - 1] !== '"')
            return;
          if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
          if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
          return;
        }
        if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
          return `"${a}${b.slice(1)}`;
        return;
      }
      function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
      }
      exports.strConcat = strConcat;
      function interpolate(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
      }
      function stringify(x) {
        return new _Code(safeStringify(x));
      }
      exports.stringify = stringify;
      function safeStringify(x) {
        return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
      }
      exports.getProperty = getProperty;
      function getEsmExportName(key) {
        if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
          return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
      }
      exports.getEsmExportName = getEsmExportName;
      function regexpCode(rx) {
        return new _Code(rx.toString());
      }
      exports.regexpCode = regexpCode;
    })(code$1);
    return code$1;
  }
  var scope = {};
  var hasRequiredScope;
  function requireScope() {
    if (hasRequiredScope) return scope;
    hasRequiredScope = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
      const code_1 = requireCode$1();
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`);
          this.value = name.value;
        }
      }
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
      exports.varKinds = {
        const: new code_1.Name("const"),
        let: new code_1.Name("let"),
        var: new code_1.Name("var")
      };
      class Scope {
        constructor({ prefixes: prefixes2, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes2;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_1.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a, _b;
          if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      }
      exports.Scope = Scope;
      class ValueScopeName extends code_1.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
        }
      }
      exports.ValueScopeName = ValueScopeName;
      const line = (0, code_1._)`\n`;
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name = this.toName(nameOrPrefix);
          const { prefix } = name;
          const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
          let vs = this._values[prefix];
          if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs.set(valueKey, name);
          const s = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s.length;
          s[itemIndex] = value.ref;
          name.setValue(value, { property: prefix, itemIndex });
          return name;
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix];
          if (!vs)
            return;
          return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_1._)`${scopeName}${name.scopePath}`;
          });
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(values, (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code2 = code_1.nil;
          for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs.forEach((name) => {
              if (nameSet.has(name))
                return;
              nameSet.set(name, UsedValueState.Started);
              let c = valueCode(name);
              if (c) {
                const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                code2 = (0, code_1._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
              } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
              } else {
                throw new ValueError(name);
              }
              nameSet.set(name, UsedValueState.Completed);
            });
          }
          return code2;
        }
      }
      exports.ValueScope = ValueScope;
    })(scope);
    return scope;
  }
  var hasRequiredCodegen;
  function requireCodegen() {
    if (hasRequiredCodegen) return codegen;
    hasRequiredCodegen = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
      const code_1 = requireCode$1();
      const scope_1 = requireScope();
      var code_2 = requireCode$1();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = requireScope();
      Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports.operators = {
        GT: new code_1._Code(">"),
        GTE: new code_1._Code(">="),
        LT: new code_1._Code("<"),
        LTE: new code_1._Code("<="),
        EQ: new code_1._Code("==="),
        NEQ: new code_1._Code("!=="),
        NOT: new code_1._Code("!"),
        OR: new code_1._Code("||"),
        AND: new code_1._Code("&&"),
        ADD: new code_1._Code("+")
      };
      class Node {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      }
      class Def extends Node {
        constructor(varKind, name, rhs) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.rhs = rhs;
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (!names2[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
        }
      }
      class Assign extends Node {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
          return addExprNames(names2, this.rhs);
        }
      }
      class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
      }
      class Label extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          return `${this.label}:` + _n;
        }
      }
      class Break extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n;
        }
      }
      class Throw extends Node {
        constructor(error) {
          super();
          this.error = error;
        }
        render({ _n }) {
          return `throw ${this.error};` + _n;
        }
        get names() {
          return this.error.names;
        }
      }
      class AnyCode extends Node {
        constructor(code2) {
          super();
          this.code = code2;
        }
        render({ _n }) {
          return `${this.code};` + _n;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names2, constants) {
          this.code = optimizeExpr(this.code, names2, constants);
          return this;
        }
        get names() {
          return this.code instanceof code_1._CodeOrName ? this.code.names : {};
        }
      }
      class ParentNode extends Node {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i = nodes.length;
          while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
              nodes.splice(i, 1, ...n);
            else if (n)
              nodes[i] = n;
            else
              nodes.splice(i, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names2, constants) {
          const { nodes } = this;
          let i = nodes.length;
          while (i--) {
            const n = nodes[i];
            if (n.optimizeNames(names2, constants))
              continue;
            subtractNames(names2, n.names);
            nodes.splice(i, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      }
      class Root extends ParentNode {
      }
      class Else extends BlockNode {
      }
      Else.kind = "else";
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code2 = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code2 += "else " + this.else.render(opts);
          return code2;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e = this.else;
          if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
          }
          if (e) {
            if (cond === false)
              return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
              return this;
            return new If(not2(cond), e instanceof If ? [e] : e.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names2, constants) {
          var _a;
          this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
          if (!(super.optimizeNames(names2, constants) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          addExprNames(names2, this.condition);
          if (this.else)
            addNames(names2, this.else.names);
          return names2;
        }
      }
      If.kind = "if";
      class For extends BlockNode {
      }
      For.kind = "for";
      class ForLoop extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iteration = optimizeExpr(this.iteration, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from, to) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.from = from;
          this.to = to;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name, from, to } = this;
          return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
          const names2 = addExprNames(super.names, this.from);
          return addExprNames(names2, this.to);
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iterable = optimizeExpr(this.iterable, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super();
          this.name = name;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      }
      Func.kind = "func";
      class Return extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      }
      Return.kind = "return";
      class Try extends BlockNode {
        render(opts) {
          let code2 = "try" + super.render(opts);
          if (this.catch)
            code2 += this.catch.render(opts);
          if (this.finally)
            code2 += this.finally.render(opts);
          return code2;
        }
        optimizeNodes() {
          var _a, _b;
          super.optimizeNodes();
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names2, constants) {
          var _a, _b;
          super.optimizeNames(names2, constants);
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          if (this.catch)
            addNames(names2, this.catch.names);
          if (this.finally)
            addNames(names2, this.finally.names);
          return names2;
        }
      }
      class Catch extends BlockNode {
        constructor(error) {
          super();
          this.error = error;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      }
      Catch.kind = "catch";
      class Finally extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      }
      Finally.kind = "finally";
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value);
          const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
          vs.add(name);
          return name;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name.str] = rhs;
          this._leafNode(new Def(varKind, name, rhs));
          return name;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
          if (typeof c == "function")
            c();
          else if (c !== code_1.nil)
            this._leafNode(new AnyCode(c));
          return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
          const code2 = ["{"];
          for (const [key, value] of keyValues) {
            if (code2.length > 1)
              code2.push(",");
            code2.push(key);
            if (key !== value || this.opts.es5) {
              code2.push(":");
              (0, code_1.addCodeArg)(code2, value);
            }
          }
          code2.push("}");
          return new code_1._Code(code2);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
              this.var(name, (0, code_1._)`${arr}[${i}]`);
              forBody(name);
            });
          }
          return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
          }
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label(label));
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error) {
          return this._leafNode(new Throw(error));
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_1.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n = 1) {
          while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N1, N2) {
          const n = this._currNode;
          if (n instanceof N1 || N2 && n instanceof N2) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
          const n = this._currNode;
          if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns = this._nodes;
          return ns[ns.length - 1];
        }
        set _currNode(node) {
          const ns = this._nodes;
          ns[ns.length - 1] = node;
        }
      }
      exports.CodeGen = CodeGen;
      function addNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) + (from[n] || 0);
        return names2;
      }
      function addExprNames(names2, from) {
        return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
      }
      function optimizeExpr(expr, names2, constants) {
        if (expr instanceof code_1.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_1._Code(expr._items.reduce((items2, c) => {
          if (c instanceof code_1.Name)
            c = replaceName(c);
          if (c instanceof code_1._Code)
            items2.push(...c._items);
          else
            items2.push(c);
          return items2;
        }, []));
        function replaceName(n) {
          const c = constants[n.str];
          if (c === void 0 || names2[n.str] !== 1)
            return n;
          delete names2[n.str];
          return c;
        }
        function canOptimize(e) {
          return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
        }
      }
      function subtractNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) - (from[n] || 0);
      }
      function not2(x) {
        return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
      }
      exports.not = not2;
      const andCode = mappend(exports.operators.AND);
      function and(...args) {
        return args.reduce(andCode);
      }
      exports.and = and;
      const orCode = mappend(exports.operators.OR);
      function or(...args) {
        return args.reduce(orCode);
      }
      exports.or = or;
      function mappend(op) {
        return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
      }
      function par(x) {
        return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
      }
    })(codegen);
    return codegen;
  }
  var util = {};
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil) return util;
    hasRequiredUtil = 1;
    Object.defineProperty(util, "__esModule", { value: true });
    util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
    const codegen_1 = requireCodegen();
    const code_1 = requireCode$1();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    util.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    util.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules2 = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules2[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    util.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules2) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules2[key])
          return true;
      return false;
    }
    util.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    util.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
    }
    util.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    util.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    util.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    util.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    util.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    util.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    util.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items2) => gen.var("items", items2)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    util.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
    }
    util.setEvaluated = setEvaluated;
    const snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    util.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (util.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    util.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    util.checkStrictMode = checkStrictMode;
    return util;
  }
  var names = {};
  var hasRequiredNames;
  function requireNames() {
    if (hasRequiredNames) return names;
    hasRequiredNames = 1;
    Object.defineProperty(names, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const names$1 = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    names.default = names$1;
    return names;
  }
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const names_1 = requireNames();
      exports.keywordError = {
        message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
      };
      exports.keyword$DataError = {
        message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
      };
      function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen, errObj);
        } else {
          returnErrors(it, (0, codegen_1._)`[${errObj}]`);
        }
      }
      exports.reportError = reportError;
      function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it, names_1.default.vErrors);
        }
      }
      exports.reportExtraError = reportExtraError;
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
      }
      exports.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, (i) => {
          gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
          gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
          gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
          if (it.opts.verbose) {
            gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
            gen.assign((0, codegen_1._)`${err}.data`, data);
          }
        });
      }
      exports.extendErrors = extendErrors;
      function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
        gen.code((0, codegen_1._)`${names_1.default.errors}++`);
      }
      function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it;
        if (schemaEnv.$async) {
          gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
          gen.return(false);
        }
      }
      const E = {
        keyword: new codegen_1.Name("keyword"),
        schemaPath: new codegen_1.Name("schemaPath"),
        // also used in JTD errors
        params: new codegen_1.Name("params"),
        propertyName: new codegen_1.Name("propertyName"),
        message: new codegen_1.Name("message"),
        schema: new codegen_1.Name("schema"),
        parentSchema: new codegen_1.Name("parentSchema")
      };
      function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return (0, codegen_1._)`{}`;
        return errorObject(cxt, error, errorPaths);
      }
      function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt;
        const keyValues = [
          errorInstancePath(it, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error, keyValues);
        return gen.object(...keyValues);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
        return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
        if (schemaPath) {
          schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
        }
        return [E.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword: keyword2, data, schemaValue, it } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it;
        keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
        if (opts.messages) {
          keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
        }
        if (propertyName)
          keyValues.push([E.propertyName, propertyName]);
      }
    })(errors);
    return errors;
  }
  var hasRequiredBoolSchema;
  function requireBoolSchema() {
    if (hasRequiredBoolSchema) return boolSchema;
    hasRequiredBoolSchema = 1;
    Object.defineProperty(boolSchema, "__esModule", { value: true });
    boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
    const errors_1 = requireErrors();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    boolSchema.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
    return boolSchema;
  }
  var dataType = {};
  var rules = {};
  var hasRequiredRules;
  function requireRules() {
    if (hasRequiredRules) return rules;
    hasRequiredRules = 1;
    Object.defineProperty(rules, "__esModule", { value: true });
    rules.getRules = rules.isJSONType = void 0;
    const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    const jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    rules.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    rules.getRules = getRules;
    return rules;
  }
  var applicability = {};
  var hasRequiredApplicability;
  function requireApplicability() {
    if (hasRequiredApplicability) return applicability;
    hasRequiredApplicability = 1;
    Object.defineProperty(applicability, "__esModule", { value: true });
    applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type2) {
      const group = self2.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    applicability.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    applicability.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    applicability.shouldUseRule = shouldUseRule;
    return applicability;
  }
  var hasRequiredDataType;
  function requireDataType() {
    if (hasRequiredDataType) return dataType;
    hasRequiredDataType = 1;
    Object.defineProperty(dataType, "__esModule", { value: true });
    dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
    const rules_1 = requireRules();
    const applicability_1 = requireApplicability();
    const errors_1 = requireErrors();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (dataType.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    dataType.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    dataType.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types2) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types2, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    dataType.coerceAndCheckDataType = coerceAndCheckDataType;
    const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types2, coerceTo) {
      const { gen, data, opts } = it;
      const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType2) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType2}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    dataType.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t in types2)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    dataType.checkDataTypes = checkDataTypes;
    const typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    dataType.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
    return dataType;
  }
  var defaults = {};
  var hasRequiredDefaults;
  function requireDefaults() {
    if (hasRequiredDefaults) return defaults;
    hasRequiredDefaults = 1;
    Object.defineProperty(defaults, "__esModule", { value: true });
    defaults.assignDefaults = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    function assignDefaults(it, ty) {
      const { properties: properties2, items: items2 } = it.schema;
      if (ty === "object" && properties2) {
        for (const key in properties2) {
          assignDefault(it, key, properties2[key].default);
        }
      } else if (ty === "array" && Array.isArray(items2)) {
        items2.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    defaults.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
    return defaults;
  }
  var keyword = {};
  var code = {};
  var hasRequiredCode;
  function requireCode() {
    if (hasRequiredCode) return code;
    hasRequiredCode = 1;
    Object.defineProperty(code, "__esModule", { value: true });
    code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const names_1 = requireNames();
    const util_2 = requireUtil();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    code.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
      return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    code.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    code.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    code.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    code.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    code.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    code.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    code.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p2]));
    }
    code.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    code.callValidateCode = callValidateCode;
    const newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern2) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern2, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
      });
    }
    code.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    code.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword: keyword2, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    code.validateUnion = validateUnion;
    return code;
  }
  var hasRequiredKeyword;
  function requireKeyword() {
    if (hasRequiredKeyword) return keyword;
    hasRequiredKeyword = 1;
    Object.defineProperty(keyword, "__esModule", { value: true });
    keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const code_1 = requireCode();
    const errors_1 = requireErrors();
    function macroKeywordCode(cxt, def2) {
      const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
      const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    keyword.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def2) {
      var _a;
      const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def2);
      const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
      const validateRef = useKeyword(gen, keyword2, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def2.errors === false) {
          assignValid();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def2.async ? validateAsync() : validateSync();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def2.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def2 && !$data || def2.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
      }
      function reportErrs(errors2) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
      }
    }
    keyword.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def2) {
      if (def2.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    keyword.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
      if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def2.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def2.validateSchema) {
        const valid = def2.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    keyword.validateKeywordUsage = validateKeywordUsage;
    return keyword;
  }
  var subschema = {};
  var hasRequiredSubschema;
  function requireSubschema() {
    if (hasRequiredSubschema) return subschema;
    hasRequiredSubschema = 1;
    Object.defineProperty(subschema, "__esModule", { value: true });
    subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    subschema.getSubschema = getSubschema;
    function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema2.propertyName = propertyName;
      }
      if (dataTypes)
        subschema2.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema2.data = _nextData;
        subschema2.dataLevel = it.dataLevel + 1;
        subschema2.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema2.parentData = it.data;
        subschema2.dataNames = [...it.dataNames, _nextData];
      }
    }
    subschema.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema2.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema2.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema2.allErrors = allErrors;
      subschema2.jtdDiscriminator = jtdDiscriminator;
      subschema2.jtdMetadata = jtdMetadata;
    }
    subschema.extendSubschemaMode = extendSubschemaMode;
    return subschema;
  }
  var resolve = {};
  var fastDeepEqual;
  var hasRequiredFastDeepEqual;
  function requireFastDeepEqual() {
    if (hasRequiredFastDeepEqual) return fastDeepEqual;
    hasRequiredFastDeepEqual = 1;
    fastDeepEqual = function equal2(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
    return fastDeepEqual;
  }
  var jsonSchemaTraverse = { exports: {} };
  var hasRequiredJsonSchemaTraverse;
  function requireJsonSchemaTraverse() {
    if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
    hasRequiredJsonSchemaTraverse = 1;
    var traverse2 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse2.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse2.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse2.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse2.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse2.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse2.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse2.keywords || opts.allKeys && !(key in traverse2.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    return jsonSchemaTraverse.exports;
  }
  var hasRequiredResolve;
  function requireResolve() {
    if (hasRequiredResolve) return resolve;
    hasRequiredResolve = 1;
    Object.defineProperty(resolve, "__esModule", { value: true });
    resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
    const util_1 = requireUtil();
    const equal2 = requireFastDeepEqual();
    const traverse2 = requireJsonSchemaTraverse();
    const SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit2 = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit2 === true)
        return !hasRef(schema);
      if (!limit2)
        return false;
      return countKeys(schema) <= limit2;
    }
    resolve.inlineRef = inlineRef;
    const REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize) {
      if (normalize !== false)
        id2 = normalizeId(id2);
      const p2 = resolver.parse(id2);
      return _getFullPath(resolver, p2);
    }
    resolve.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    resolve._getFullPath = _getFullPath;
    const TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    resolve.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    resolve.resolveUrl = resolveUrl;
    const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref2) {
          const _resolve = this.opts.uriResolver.resolve;
          ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
          if (schemaRefs.has(ref2))
            throw ambiguos(ref2);
          schemaRefs.add(ref2);
          let schOrRef = this.refs[ref2];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref2);
          } else if (ref2 !== normalizeId(fullPath)) {
            if (ref2[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref2], ref2);
              localRefs[ref2] = sch;
            } else {
              this.refs[ref2] = fullPath;
            }
          }
          return ref2;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref2) {
        if (sch2 !== void 0 && !equal2(sch1, sch2))
          throw ambiguos(ref2);
      }
      function ambiguos(ref2) {
        return new Error(`reference "${ref2}" resolves to more than one schema`);
      }
    }
    resolve.getSchemaRefs = getSchemaRefs;
    return resolve;
  }
  var hasRequiredValidate;
  function requireValidate() {
    if (hasRequiredValidate) return validate;
    hasRequiredValidate = 1;
    Object.defineProperty(validate, "__esModule", { value: true });
    validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
    const boolSchema_1 = requireBoolSchema();
    const dataType_1 = requireDataType();
    const applicability_1 = requireApplicability();
    const dataType_2 = requireDataType();
    const defaults_1 = requireDefaults();
    const keyword_1 = requireKeyword();
    const subschema_1 = requireSubschema();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const resolve_1 = requireResolve();
    const util_1 = requireUtil();
    const errors_1 = requireErrors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    validate.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
      schemaKeywords(it, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items: items2 }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items2 instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
    }
    function schemaKeywords(it, types2, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types2);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types2) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types2);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types2);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types2) {
      if (!types2.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types2;
        return;
      }
      types2.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types2);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules2 = it.self.RULES.all;
      for (const keyword2 in rules2) {
        const rule = rules2[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    class KeywordCxt {
      constructor(it, def2, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword2;
        this.data = it.data;
        this.schema = it.schema[keyword2];
        this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
        this.schemaType = def2.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def2;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
          }
        }
        if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def: def2 } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def2.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def: def2, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def2.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema2, appl);
        const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    }
    validate.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword2, def2, ruleType) {
      const cxt = new KeywordCxt(it, def2, keyword2);
      if ("code" in def2) {
        def2.code(cxt, ruleType);
      } else if (cxt.$data && def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      } else if ("macro" in def2) {
        (0, keyword_1.macroKeywordCode)(cxt, def2);
      } else if (def2.compile || def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    validate.getData = getData;
    return validate;
  }
  var validation_error = {};
  var hasRequiredValidation_error;
  function requireValidation_error() {
    if (hasRequiredValidation_error) return validation_error;
    hasRequiredValidation_error = 1;
    Object.defineProperty(validation_error, "__esModule", { value: true });
    class ValidationError extends Error {
      constructor(errors2) {
        super("validation failed");
        this.errors = errors2;
        this.ajv = this.validation = true;
      }
    }
    validation_error.default = ValidationError;
    return validation_error;
  }
  var ref_error = {};
  var hasRequiredRef_error;
  function requireRef_error() {
    if (hasRequiredRef_error) return ref_error;
    hasRequiredRef_error = 1;
    Object.defineProperty(ref_error, "__esModule", { value: true });
    const resolve_1 = requireResolve();
    class MissingRefError extends Error {
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    }
    ref_error.default = MissingRefError;
    return ref_error;
  }
  var compile = {};
  var hasRequiredCompile;
  function requireCompile() {
    if (hasRequiredCompile) return compile;
    hasRequiredCompile = 1;
    Object.defineProperty(compile, "__esModule", { value: true });
    compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
    const codegen_1 = requireCodegen();
    const validation_error_1 = requireValidation_error();
    const names_1 = requireNames();
    const resolve_1 = requireResolve();
    const util_1 = requireUtil();
    const validate_1 = requireValidate();
    class SchemaEnv {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    }
    compile.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items: items2 } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items2 instanceof codegen_1.Name ? void 0 : items2,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items2 instanceof codegen_1.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    compile.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref2) {
      var _a;
      ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
      const schOrFunc = root.refs[ref2];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve2.call(this, root, ref2);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    compile.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    compile.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve2(root, ref2) {
      let sch;
      while (typeof (sch = this.refs[ref2]) == "string")
        ref2 = sch;
      return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    function resolveSchema(root, ref2) {
      const p2 = this.opts.uriResolver.parse(ref2);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref2)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    compile.resolveSchema = resolveSchema;
    const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
    return compile;
  }
  const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
  const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
  const type$1 = "object";
  const required$1 = ["$data"];
  const properties$2 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
  const additionalProperties$1 = false;
  const require$$9 = {
    $id: $id$1,
    description,
    type: type$1,
    required: required$1,
    properties: properties$2,
    additionalProperties: additionalProperties$1
  };
  var uri = {};
  var fastUri = { exports: {} };
  var scopedChars;
  var hasRequiredScopedChars;
  function requireScopedChars() {
    if (hasRequiredScopedChars) return scopedChars;
    hasRequiredScopedChars = 1;
    const HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    scopedChars = {
      HEX
    };
    return scopedChars;
  }
  var utils;
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils;
    hasRequiredUtils = 1;
    const { HEX } = requireScopedChars();
    const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(IPV4_REG) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer2 = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer2.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer2);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer2.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer2.push(cursor);
          continue;
        }
      }
      if (buffer2.length) {
        if (isZone) {
          output.zone = buffer2.join("");
        } else if (endIpv6) {
          address.push(buffer2.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer2));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    const RDS1 = /^\.\.?\//u;
    const RDS2 = /^\/\.(?:\/|$)/u;
    const RDS3 = /^\/\.\.(?:\/|$)/u;
    const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    utils = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
    return utils;
  }
  var schemes;
  var hasRequiredSchemes;
  function requireSchemes() {
    if (hasRequiredSchemes) return schemes;
    hasRequiredSchemes = 1;
    const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    const http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    const https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    const ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    const wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    const urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    const urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    const SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    schemes = SCHEMES;
    return schemes;
  }
  var hasRequiredFastUri;
  function requireFastUri() {
    if (hasRequiredFastUri) return fastUri.exports;
    hasRequiredFastUri = 1;
    const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils();
    const SCHEMES = requireSchemes();
    function normalize(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse(uri2, options), options);
      } else if (typeof uri2 === "object") {
        uri2 = parse(serialize(uri2, options), options);
      }
      return uri2;
    }
    function resolve2(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal2(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code2 = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code2 = value.charCodeAt(i);
        if (code2 > 126 || hexLookUp[code2]) {
          return true;
        }
      }
      return false;
    }
    const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri2, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri2.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
      const matches = uri2.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    const fastUri$1 = {
      SCHEMES,
      normalize,
      resolve: resolve2,
      resolveComponents,
      equal: equal2,
      serialize,
      parse
    };
    fastUri.exports = fastUri$1;
    fastUri.exports.default = fastUri$1;
    fastUri.exports.fastUri = fastUri$1;
    return fastUri.exports;
  }
  var hasRequiredUri;
  function requireUri() {
    if (hasRequiredUri) return uri;
    hasRequiredUri = 1;
    Object.defineProperty(uri, "__esModule", { value: true });
    const uri$1 = requireFastUri();
    uri$1.code = 'require("ajv/dist/runtime/uri").default';
    uri.default = uri$1;
    return uri;
  }
  var hasRequiredCore$1;
  function requireCore$1() {
    if (hasRequiredCore$1) return core$1;
    hasRequiredCore$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
      var validate_1 = requireValidate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = requireCodegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      const validation_error_1 = requireValidation_error();
      const ref_error_1 = requireRef_error();
      const rules_1 = requireRules();
      const compile_1 = requireCompile();
      const codegen_2 = requireCodegen();
      const resolve_1 = requireResolve();
      const dataType_1 = requireDataType();
      const util_1 = requireUtil();
      const $dataRefSchema = require$$9;
      const uri_1 = requireUri();
      const defaultRegExp = (str, flags) => new RegExp(str, flags);
      defaultRegExp.code = "new RegExp";
      const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
      const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]);
      const removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      };
      const deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      };
      const MAX_EXPRESSION = 200;
      function requiredOptions(o) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        const s = o.strict;
        const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
        const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
        return {
          strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
          strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
          strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
          strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
          strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
          code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
          loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
          loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
          addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver
        };
      }
      class Ajv2 {
        constructor(opts = {}) {
          this.schemas = {};
          this.refs = {};
          this.formats = {};
          this._compilations = /* @__PURE__ */ new Set();
          this._loading = {};
          this._cache = /* @__PURE__ */ new Map();
          opts = this.opts = { ...opts, ...requiredOptions(opts) };
          const { es5, lines } = this.opts.code;
          this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
          this.logger = getLogger(opts.logger);
          const formatOpt = opts.validateFormats;
          opts.validateFormats = false;
          this.RULES = (0, rules_1.getRules)();
          checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
          checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
          this._metaOpts = getMetaSchemaOptions.call(this);
          if (opts.formats)
            addInitialFormats.call(this);
          this._addVocabularies();
          this._addDefaultMetaSchema();
          if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
          if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
          addInitialSchemas.call(this);
          opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts;
          let _dataRefSchema = $dataRefSchema;
          if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts;
          return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
        }
        validate(schemaKeyRef, data) {
          let v;
          if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
          } else {
            v = this.compile(schemaKeyRef);
          }
          const valid = v(data);
          if (!("$async" in v))
            this.errors = v.errors;
          return valid;
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta);
          return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
          }
          const { loadSchema } = this.opts;
          return runCompileAsync.call(this, schema, meta);
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true);
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_1.default))
                throw e;
              checkLoaded.call(this, e);
              await loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          }
          function checkLoaded({ missingSchema: ref2, missingRef }) {
            if (this.refs[ref2]) {
              throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
            }
          }
          async function loadMissingSchema(ref2) {
            const _schema = await _loadSchema.call(this, ref2);
            if (!this.refs[ref2])
              await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref2])
              this.addSchema(_schema, ref2, meta);
          }
          async function _loadSchema(ref2) {
            const p2 = this._loading[ref2];
            if (p2)
              return p2;
            try {
              return await (this._loading[ref2] = loadSchema(ref2));
            } finally {
              delete this._loading[ref2];
            }
          }
        }
        // Adds schema to the instance
        addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, void 0, _meta, _validateSchema);
            return this;
          }
          let id2;
          if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id2 = schema[schemaId];
            if (id2 !== void 0 && typeof id2 != "string") {
              throw new Error(`schema ${schemaId} must be string`);
            }
          }
          key = (0, resolve_1.normalizeId)(key || id2);
          this._checkUnique(key);
          this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
          return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
          this.addSchema(schema, key, true, _validateSchema);
          return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == "boolean")
            return true;
          let $schema2;
          $schema2 = schema.$schema;
          if ($schema2 !== void 0 && typeof $schema2 != "string") {
            throw new Error("$schema must be a string");
          }
          $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
          if (!$schema2) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
          }
          const valid = this.validate($schema2, schema);
          if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(message);
            else
              throw new Error(message);
          }
          return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch;
          while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
          if (sch === void 0) {
            const { schemaId } = this.opts;
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
              return;
            this.refs[keyRef] = sch;
          }
          return sch.validate || this._compileSchemaEnv(sch);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
          }
          switch (typeof schemaKeyRef) {
            case "undefined":
              this._removeAllSchemas(this.schemas);
              this._removeAllSchemas(this.refs);
              this._cache.clear();
              return this;
            case "string": {
              const sch = getSchEnv.call(this, schemaKeyRef);
              if (typeof sch == "object")
                this._cache.delete(sch.schema);
              delete this.schemas[schemaKeyRef];
              delete this.refs[schemaKeyRef];
              return this;
            }
            case "object": {
              const cacheKey = schemaKeyRef;
              this._cache.delete(cacheKey);
              let id2 = schemaKeyRef[this.opts.schemaId];
              if (id2) {
                id2 = (0, resolve_1.normalizeId)(id2);
                delete this.schemas[id2];
                delete this.refs[id2];
              }
              return this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions2) {
          for (const def2 of definitions2)
            this.addKeyword(def2);
          return this;
        }
        addKeyword(kwdOrDef, def2) {
          let keyword2;
          if (typeof kwdOrDef == "string") {
            keyword2 = kwdOrDef;
            if (typeof def2 == "object") {
              this.logger.warn("these parameters are deprecated, see docs for addKeyword");
              def2.keyword = keyword2;
            }
          } else if (typeof kwdOrDef == "object" && def2 === void 0) {
            def2 = kwdOrDef;
            keyword2 = def2.keyword;
            if (Array.isArray(keyword2) && !keyword2.length) {
              throw new Error("addKeywords: keyword must be string or non-empty array");
            }
          } else {
            throw new Error("invalid addKeywords parameters");
          }
          checkKeyword.call(this, keyword2, def2);
          if (!def2) {
            (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
            return this;
          }
          keywordMetaschema.call(this, def2);
          const definition = {
            ...def2,
            type: (0, dataType_1.getJSONTypes)(def2.type),
            schemaType: (0, dataType_1.getJSONTypes)(def2.schemaType)
          };
          (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
          return this;
        }
        getKeyword(keyword2) {
          const rule = this.RULES.all[keyword2];
          return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword2) {
          const { RULES } = this;
          delete RULES.keywords[keyword2];
          delete RULES.all[keyword2];
          for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
            if (i >= 0)
              group.rules.splice(i, 1);
          }
          return this;
        }
        // Add format
        addFormat(name, format2) {
          if (typeof format2 == "string")
            format2 = new RegExp(format2);
          this.formats[name] = format2;
          return this;
        }
        errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
          if (!errors2 || errors2.length === 0)
            return "No errors";
          return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
          const rules2 = this.RULES.all;
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1);
            let keywords = metaSchema;
            for (const seg of segments)
              keywords = keywords[seg];
            for (const key in rules2) {
              const rule = rules2[key];
              if (typeof rule != "object")
                continue;
              const { $data } = rule.definition;
              const schema = keywords[key];
              if ($data && schema)
                keywords[key] = schemaOrData(schema);
            }
          }
          return metaSchema;
        }
        _removeAllSchemas(schemas, regex) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
              if (typeof sch == "string") {
                delete schemas[keyRef];
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema);
                delete schemas[keyRef];
              }
            }
          }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
          let id2;
          const { schemaId } = this.opts;
          if (typeof schema == "object") {
            id2 = schema[schemaId];
          } else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            else if (typeof schema != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let sch = this._cache.get(schema);
          if (sch !== void 0)
            return sch;
          baseId = (0, resolve_1.normalizeId)(id2 || baseId);
          const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
          sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
          this._cache.set(sch.schema, sch);
          if (addSchema && !baseId.startsWith("#")) {
            if (baseId)
              this._checkUnique(baseId);
            this.refs[baseId] = sch;
          }
          if (validateSchema)
            this.validateSchema(schema, true);
          return sch;
        }
        _checkUnique(id2) {
          if (this.schemas[id2] || this.refs[id2]) {
            throw new Error(`schema with key or id "${id2}" already exists`);
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta)
            this._compileMetaSchema(sch);
          else
            compile_1.compileSchema.call(this, sch);
          if (!sch.validate)
            throw new Error("ajv implementation error");
          return sch.validate;
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts;
          this.opts = this._metaOpts;
          try {
            compile_1.compileSchema.call(this, sch);
          } finally {
            this.opts = currentOpts;
          }
        }
      }
      Ajv2.ValidationError = validation_error_1.default;
      Ajv2.MissingRefError = ref_error_1.default;
      exports.default = Ajv2;
      function checkOptions(checkOpts, options, msg, log = "error") {
        for (const key in checkOpts) {
          const opt = key;
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_1.normalizeId)(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
          return;
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format2 = this.opts.formats[name];
          if (format2)
            this.addFormat(name, format2);
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword2 in defs) {
          const def2 = defs[keyword2];
          if (!def2.keyword)
            def2.keyword = keyword2;
          this.addKeyword(def2);
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts };
        for (const opt of META_IGNORE_OPTIONS)
          delete metaOpts[opt];
        return metaOpts;
      }
      const noLogs = { log() {
      }, warn() {
      }, error() {
      } };
      function getLogger(logger) {
        if (logger === false)
          return noLogs;
        if (logger === void 0)
          return console;
        if (logger.log && logger.warn && logger.error)
          return logger;
        throw new Error("logger must implement log, warn and error methods");
      }
      const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
      function checkKeyword(keyword2, def2) {
        const { RULES } = this;
        (0, util_1.eachItem)(keyword2, (kwd) => {
          if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def2)
          return;
        if (def2.$data && !("code" in def2 || "validate" in def2)) {
          throw new Error('$data keyword must have "code" or "validate" function');
        }
      }
      function addRule(keyword2, definition, dataType2) {
        var _a;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType2 && post)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES } = this;
        let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.rules.push(ruleGroup);
        }
        RULES.keywords[keyword2] = true;
        if (!definition)
          return;
        const rule = {
          keyword: keyword2,
          definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
          }
        };
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
          ruleGroup.rules.push(rule);
        RULES.all[keyword2] = rule;
        (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i >= 0) {
          ruleGroup.rules.splice(i, 0, rule);
        } else {
          ruleGroup.rules.push(rule);
          this.logger.warn(`rule ${before} is not defined`);
        }
      }
      function keywordMetaschema(def2) {
        let { metaSchema } = def2;
        if (metaSchema === void 0)
          return;
        if (def2.$data && this.opts.$data)
          metaSchema = schemaOrData(metaSchema);
        def2.validateSchema = this.compile(metaSchema, true);
      }
      const $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
      }
    })(core$1);
    return core$1;
  }
  var draft7 = {};
  var core = {};
  var id = {};
  var hasRequiredId;
  function requireId() {
    if (hasRequiredId) return id;
    hasRequiredId = 1;
    Object.defineProperty(id, "__esModule", { value: true });
    const def2 = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    id.default = def2;
    return id;
  }
  var ref = {};
  var hasRequiredRef;
  function requireRef() {
    if (hasRequiredRef) return ref;
    hasRequiredRef = 1;
    Object.defineProperty(ref, "__esModule", { value: true });
    ref.callRef = ref.getValidate = void 0;
    const ref_error_1 = requireRef_error();
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const compile_1 = requireCompile();
    const util_1 = requireUtil();
    const def2 = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    ref.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items2, it.items, codegen_1.Name);
          }
        }
      }
    }
    ref.callRef = callRef;
    ref.default = def2;
    return ref;
  }
  var hasRequiredCore;
  function requireCore() {
    if (hasRequiredCore) return core;
    hasRequiredCore = 1;
    Object.defineProperty(core, "__esModule", { value: true });
    const id_1 = requireId();
    const ref_1 = requireRef();
    const core$12 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    core.default = core$12;
    return core;
  }
  var validation = {};
  var limitNumber = {};
  var hasRequiredLimitNumber;
  function requireLimitNumber() {
    if (hasRequiredLimitNumber) return limitNumber;
    hasRequiredLimitNumber = 1;
    Object.defineProperty(limitNumber, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const ops = codegen_1.operators;
    const KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    const error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    limitNumber.default = def2;
    return limitNumber;
  }
  var multipleOf = {};
  var hasRequiredMultipleOf;
  function requireMultipleOf() {
    if (hasRequiredMultipleOf) return multipleOf;
    hasRequiredMultipleOf = 1;
    Object.defineProperty(multipleOf, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    const def2 = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    multipleOf.default = def2;
    return multipleOf;
  }
  var limitLength = {};
  var ucs2length = {};
  var hasRequiredUcs2length;
  function requireUcs2length() {
    if (hasRequiredUcs2length) return ucs2length;
    hasRequiredUcs2length = 1;
    Object.defineProperty(ucs2length, "__esModule", { value: true });
    function ucs2length$1(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    ucs2length.default = ucs2length$1;
    ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
    return ucs2length;
  }
  var hasRequiredLimitLength;
  function requireLimitLength() {
    if (hasRequiredLimitLength) return limitLength;
    hasRequiredLimitLength = 1;
    Object.defineProperty(limitLength, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const ucs2length_1 = requireUcs2length();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it } = cxt;
        const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    limitLength.default = def2;
    return limitLength;
  }
  var pattern = {};
  var hasRequiredPattern;
  function requirePattern() {
    if (hasRequiredPattern) return pattern;
    hasRequiredPattern = 1;
    Object.defineProperty(pattern, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    const def2 = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    pattern.default = def2;
    return pattern;
  }
  var limitProperties = {};
  var hasRequiredLimitProperties;
  function requireLimitProperties() {
    if (hasRequiredLimitProperties) return limitProperties;
    hasRequiredLimitProperties = 1;
    Object.defineProperty(limitProperties, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    limitProperties.default = def2;
    return limitProperties;
  }
  var required = {};
  var hasRequiredRequired;
  function requireRequired() {
    if (hasRequiredRequired) return required;
    hasRequiredRequired = 1;
    Object.defineProperty(required, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    const def2 = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    required.default = def2;
    return required;
  }
  var limitItems = {};
  var hasRequiredLimitItems;
  function requireLimitItems() {
    if (hasRequiredLimitItems) return limitItems;
    hasRequiredLimitItems = 1;
    Object.defineProperty(limitItems, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    limitItems.default = def2;
    return limitItems;
  }
  var uniqueItems = {};
  var equal = {};
  var hasRequiredEqual;
  function requireEqual() {
    if (hasRequiredEqual) return equal;
    hasRequiredEqual = 1;
    Object.defineProperty(equal, "__esModule", { value: true });
    const equal$1 = requireFastDeepEqual();
    equal$1.code = 'require("ajv/dist/runtime/equal").default';
    equal.default = equal$1;
    return equal;
  }
  var hasRequiredUniqueItems;
  function requireUniqueItems() {
    if (hasRequiredUniqueItems) return uniqueItems;
    hasRequiredUniqueItems = 1;
    Object.defineProperty(uniqueItems, "__esModule", { value: true });
    const dataType_1 = requireDataType();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    const def2 = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    uniqueItems.default = def2;
    return uniqueItems;
  }
  var _const = {};
  var hasRequired_const;
  function require_const() {
    if (hasRequired_const) return _const;
    hasRequired_const = 1;
    Object.defineProperty(_const, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    const def2 = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    _const.default = def2;
    return _const;
  }
  var _enum = {};
  var hasRequired_enum;
  function require_enum() {
    if (hasRequired_enum) return _enum;
    hasRequired_enum = 1;
    Object.defineProperty(_enum, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    const def2 = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    _enum.default = def2;
    return _enum;
  }
  var hasRequiredValidation;
  function requireValidation() {
    if (hasRequiredValidation) return validation;
    hasRequiredValidation = 1;
    Object.defineProperty(validation, "__esModule", { value: true });
    const limitNumber_1 = requireLimitNumber();
    const multipleOf_1 = requireMultipleOf();
    const limitLength_1 = requireLimitLength();
    const pattern_1 = requirePattern();
    const limitProperties_1 = requireLimitProperties();
    const required_1 = requireRequired();
    const limitItems_1 = requireLimitItems();
    const uniqueItems_1 = requireUniqueItems();
    const const_1 = require_const();
    const enum_1 = require_enum();
    const validation$1 = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    validation.default = validation$1;
    return validation;
  }
  var applicator = {};
  var additionalItems = {};
  var hasRequiredAdditionalItems;
  function requireAdditionalItems() {
    if (hasRequiredAdditionalItems) return additionalItems;
    hasRequiredAdditionalItems = 1;
    Object.defineProperty(additionalItems, "__esModule", { value: true });
    additionalItems.validateAdditionalItems = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    const def2 = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items: items2 } = parentSchema;
        if (!Array.isArray(items2)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items2);
      }
    };
    function validateAdditionalItems(cxt, items2) {
      const { gen, schema, data, keyword: keyword2, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items2.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items2.length, len, (i) => {
          cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    additionalItems.validateAdditionalItems = validateAdditionalItems;
    additionalItems.default = def2;
    return additionalItems;
  }
  var prefixItems = {};
  var items = {};
  var hasRequiredItems;
  function requireItems() {
    if (hasRequiredItems) return items;
    hasRequiredItems = 1;
    Object.defineProperty(items, "__esModule", { value: true });
    items.validateTuple = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const code_1 = requireCode();
    const def2 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    items.validateTuple = validateTuple;
    items.default = def2;
    return items;
  }
  var hasRequiredPrefixItems;
  function requirePrefixItems() {
    if (hasRequiredPrefixItems) return prefixItems;
    hasRequiredPrefixItems = 1;
    Object.defineProperty(prefixItems, "__esModule", { value: true });
    const items_1 = requireItems();
    const def2 = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    prefixItems.default = def2;
    return prefixItems;
  }
  var items2020 = {};
  var hasRequiredItems2020;
  function requireItems2020() {
    if (hasRequiredItems2020) return items2020;
    hasRequiredItems2020 = 1;
    Object.defineProperty(items2020, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const code_1 = requireCode();
    const additionalItems_1 = requireAdditionalItems();
    const error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    const def2 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems: prefixItems2 } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems2)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    items2020.default = def2;
    return items2020;
  }
  var contains = {};
  var hasRequiredContains;
  function requireContains() {
    if (hasRequiredContains) return contains;
    hasRequiredContains = 1;
    Object.defineProperty(contains, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    const def2 = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    contains.default = def2;
    return contains;
  }
  var dependencies = {};
  var hasRequiredDependencies;
  function requireDependencies() {
    if (hasRequiredDependencies) return dependencies;
    hasRequiredDependencies = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const code_1 = requireCode();
      exports.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? "property" : "properties";
          return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        // TODO change to reference
      };
      const def2 = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt);
          validatePropertyDeps(cxt, propDeps);
          validateSchemaDeps(cxt, schDeps);
        }
      };
      function splitDependencies({ schema }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema) {
          if (key === "__proto__")
            continue;
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
          deps[key] = schema[key];
        }
        return [propertyDeps, schemaDeps];
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt;
        if (Object.keys(propertyDeps).length === 0)
          return;
        const missing = gen.let("missing");
        for (const prop in propertyDeps) {
          const deps = propertyDeps[prop];
          if (deps.length === 0)
            continue;
          const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
          cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", ")
          });
          if (it.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                (0, code_1.checkReportMissingProp)(cxt, depProp);
              }
            });
          } else {
            gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
      }
      exports.validatePropertyDeps = validatePropertyDeps;
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword: keyword2, it } = cxt;
        const valid = gen.name("valid");
        for (const prop in schemaDeps) {
          if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
            continue;
          gen.if(
            (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
              cxt.mergeValidEvaluated(schCxt, valid);
            },
            () => gen.var(valid, true)
            // TODO var
          );
          cxt.ok(valid);
        }
      }
      exports.validateSchemaDeps = validateSchemaDeps;
      exports.default = def2;
    })(dependencies);
    return dependencies;
  }
  var propertyNames = {};
  var hasRequiredPropertyNames;
  function requirePropertyNames() {
    if (hasRequiredPropertyNames) return propertyNames;
    hasRequiredPropertyNames = 1;
    Object.defineProperty(propertyNames, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    const def2 = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    propertyNames.default = def2;
    return propertyNames;
  }
  var additionalProperties = {};
  var hasRequiredAdditionalProperties;
  function requireAdditionalProperties() {
    if (hasRequiredAdditionalProperties) return additionalProperties;
    hasRequiredAdditionalProperties = 1;
    Object.defineProperty(additionalProperties, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const util_1 = requireUtil();
    const error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    const def2 = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors2) {
          const subschema2 = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors2 === false) {
            Object.assign(subschema2, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema2, valid);
        }
      }
    };
    additionalProperties.default = def2;
    return additionalProperties;
  }
  var properties$1 = {};
  var hasRequiredProperties;
  function requireProperties() {
    if (hasRequiredProperties) return properties$1;
    hasRequiredProperties = 1;
    Object.defineProperty(properties$1, "__esModule", { value: true });
    const validate_1 = requireValidate();
    const code_1 = requireCode();
    const util_1 = requireUtil();
    const additionalProperties_1 = requireAdditionalProperties();
    const def2 = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties2 = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (properties2.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties2) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    properties$1.default = def2;
    return properties$1;
  }
  var patternProperties = {};
  var hasRequiredPatternProperties;
  function requirePatternProperties() {
    if (hasRequiredPatternProperties) return patternProperties;
    hasRequiredPatternProperties = 1;
    Object.defineProperty(patternProperties, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const util_2 = requireUtil();
    const def2 = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    patternProperties.default = def2;
    return patternProperties;
  }
  var not = {};
  var hasRequiredNot;
  function requireNot() {
    if (hasRequiredNot) return not;
    hasRequiredNot = 1;
    Object.defineProperty(not, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    not.default = def2;
    return not;
  }
  var anyOf = {};
  var hasRequiredAnyOf;
  function requireAnyOf() {
    if (hasRequiredAnyOf) return anyOf;
    hasRequiredAnyOf = 1;
    Object.defineProperty(anyOf, "__esModule", { value: true });
    const code_1 = requireCode();
    const def2 = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    anyOf.default = def2;
    return anyOf;
  }
  var oneOf = {};
  var hasRequiredOneOf;
  function requireOneOf() {
    if (hasRequiredOneOf) return oneOf;
    hasRequiredOneOf = 1;
    Object.defineProperty(oneOf, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    const def2 = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    oneOf.default = def2;
    return oneOf;
  }
  var allOf = {};
  var hasRequiredAllOf;
  function requireAllOf() {
    if (hasRequiredAllOf) return allOf;
    hasRequiredAllOf = 1;
    Object.defineProperty(allOf, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    allOf.default = def2;
    return allOf;
  }
  var _if = {};
  var hasRequired_if;
  function require_if() {
    if (hasRequired_if) return _if;
    hasRequired_if = 1;
    Object.defineProperty(_if, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    const def2 = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it, keyword2) {
      const schema = it.schema[keyword2];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    _if.default = def2;
    return _if;
  }
  var thenElse = {};
  var hasRequiredThenElse;
  function requireThenElse() {
    if (hasRequiredThenElse) return thenElse;
    hasRequiredThenElse = 1;
    Object.defineProperty(thenElse, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
      }
    };
    thenElse.default = def2;
    return thenElse;
  }
  var hasRequiredApplicator;
  function requireApplicator() {
    if (hasRequiredApplicator) return applicator;
    hasRequiredApplicator = 1;
    Object.defineProperty(applicator, "__esModule", { value: true });
    const additionalItems_1 = requireAdditionalItems();
    const prefixItems_1 = requirePrefixItems();
    const items_1 = requireItems();
    const items2020_1 = requireItems2020();
    const contains_1 = requireContains();
    const dependencies_1 = requireDependencies();
    const propertyNames_1 = requirePropertyNames();
    const additionalProperties_1 = requireAdditionalProperties();
    const properties_1 = requireProperties();
    const patternProperties_1 = requirePatternProperties();
    const not_1 = requireNot();
    const anyOf_1 = requireAnyOf();
    const oneOf_1 = requireOneOf();
    const allOf_1 = requireAllOf();
    const if_1 = require_if();
    const thenElse_1 = requireThenElse();
    function getApplicator(draft2020 = false) {
      const applicator2 = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator2.push(prefixItems_1.default, items2020_1.default);
      else
        applicator2.push(additionalItems_1.default, items_1.default);
      applicator2.push(contains_1.default);
      return applicator2;
    }
    applicator.default = getApplicator;
    return applicator;
  }
  var format$1 = {};
  var format = {};
  var hasRequiredFormat$1;
  function requireFormat$1() {
    if (hasRequiredFormat$1) return format;
    hasRequiredFormat$1 = 1;
    Object.defineProperty(format, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    const def2 = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    format.default = def2;
    return format;
  }
  var hasRequiredFormat;
  function requireFormat() {
    if (hasRequiredFormat) return format$1;
    hasRequiredFormat = 1;
    Object.defineProperty(format$1, "__esModule", { value: true });
    const format_1 = requireFormat$1();
    const format2 = [format_1.default];
    format$1.default = format2;
    return format$1;
  }
  var metadata = {};
  var hasRequiredMetadata;
  function requireMetadata() {
    if (hasRequiredMetadata) return metadata;
    hasRequiredMetadata = 1;
    Object.defineProperty(metadata, "__esModule", { value: true });
    metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
    metadata.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    metadata.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
    return metadata;
  }
  var hasRequiredDraft7;
  function requireDraft7() {
    if (hasRequiredDraft7) return draft7;
    hasRequiredDraft7 = 1;
    Object.defineProperty(draft7, "__esModule", { value: true });
    const core_1 = requireCore();
    const validation_1 = requireValidation();
    const applicator_1 = requireApplicator();
    const format_1 = requireFormat();
    const metadata_1 = requireMetadata();
    const draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    draft7.default = draft7Vocabularies;
    return draft7;
  }
  var discriminator = {};
  var types = {};
  var hasRequiredTypes;
  function requireTypes() {
    if (hasRequiredTypes) return types;
    hasRequiredTypes = 1;
    Object.defineProperty(types, "__esModule", { value: true });
    types.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (types.DiscrError = DiscrError = {}));
    return types;
  }
  var hasRequiredDiscriminator;
  function requireDiscriminator() {
    if (hasRequiredDiscriminator) return discriminator;
    hasRequiredDiscriminator = 1;
    Object.defineProperty(discriminator, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const types_1 = requireTypes();
    const compile_1 = requireCompile();
    const ref_error_1 = requireRef_error();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    const def2 = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf: oneOf2 } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf2)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf2.length; i++) {
            let sch = oneOf2[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref2 = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    discriminator.default = def2;
    return discriminator;
  }
  const $schema = "http://json-schema.org/draft-07/schema#";
  const $id = "http://json-schema.org/draft-07/schema#";
  const title = "Core schema meta-schema";
  const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
  const type = ["object", "boolean"];
  const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
  const require$$3 = {
    $schema,
    $id,
    title,
    definitions,
    type,
    properties,
    "default": true
  };
  var hasRequiredAjv;
  function requireAjv() {
    if (hasRequiredAjv) return ajv.exports;
    hasRequiredAjv = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
      const core_1 = requireCore$1();
      const draft7_1 = requireDraft7();
      const discriminator_1 = requireDiscriminator();
      const draft7MetaSchema = require$$3;
      const META_SUPPORT_DATA = ["/properties"];
      const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      class Ajv2 extends core_1.default {
        _addVocabularies() {
          super._addVocabularies();
          draft7_1.default.forEach((v) => this.addVocabulary(v));
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          if (!this.opts.meta)
            return;
          const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
          this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      }
      exports.Ajv = Ajv2;
      module.exports = exports = Ajv2;
      module.exports.Ajv = Ajv2;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = Ajv2;
      var validate_1 = requireValidate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = requireCodegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      var validation_error_1 = requireValidation_error();
      Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
        return validation_error_1.default;
      } });
      var ref_error_1 = requireRef_error();
      Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_1.default;
      } });
    })(ajv, ajv.exports);
    return ajv.exports;
  }
  var ajvExports = requireAjv();
  const Ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
  var dist$1 = { exports: {} };
  var formats = {};
  var hasRequiredFormats;
  function requireFormats() {
    if (hasRequiredFormats) return formats;
    hasRequiredFormats = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
      function fmtDef(validate2, compare) {
        return { validate: validate2, compare };
      }
      exports.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(getTime(true), compareTime),
        "date-time": fmtDef(getDateTime(true), compareDateTime),
        "iso-time": fmtDef(getTime(), compareIsoTime),
        "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: uri2,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports.fastFormats = {
        ...exports.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
        "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      };
      exports.formatNames = Object.keys(exports.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date(str) {
        const matches = DATE.exec(str);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d2) {
        if (!(d1 && d2))
          return void 0;
        if (d1 > d2)
          return 1;
        if (d1 < d2)
          return -1;
        return 0;
      }
      const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
      function getTime(strictTimeZone) {
        return function time(str) {
          const matches = TIME.exec(str);
          if (!matches)
            return false;
          const hr = +matches[1];
          const min = +matches[2];
          const sec = +matches[3];
          const tz = matches[4];
          const tzSign = matches[5] === "-" ? -1 : 1;
          const tzH = +(matches[6] || 0);
          const tzM = +(matches[7] || 0);
          if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
            return false;
          if (hr <= 23 && min <= 59 && sec < 60)
            return true;
          const utcMin = min - tzM * tzSign;
          const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
          return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
        };
      }
      function compareTime(s1, s2) {
        if (!(s1 && s2))
          return void 0;
        const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
        const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
        if (!(t1 && t2))
          return void 0;
        return t1 - t2;
      }
      function compareIsoTime(t1, t2) {
        if (!(t1 && t2))
          return void 0;
        const a1 = TIME.exec(t1);
        const a2 = TIME.exec(t2);
        if (!(a1 && a2))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3];
        t2 = a2[1] + a2[2] + a2[3];
        if (t1 > t2)
          return 1;
        if (t1 < t2)
          return -1;
        return 0;
      }
      const DATE_TIME_SEPARATOR = /t|\s/i;
      function getDateTime(strictTimeZone) {
        const time = getTime(strictTimeZone);
        return function date_time(str) {
          const dateTime = str.split(DATE_TIME_SEPARATOR);
          return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
        };
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const d1 = new Date(dt1).valueOf();
        const d2 = new Date(dt2).valueOf();
        if (!(d1 && d2))
          return void 0;
        return d1 - d2;
      }
      function compareIsoDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d2);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t2);
      }
      const NOT_URI_FRAGMENT = /\/|:/;
      const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri2(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function byte(str) {
        BYTE.lastIndex = 0;
        return BYTE.test(str);
      }
      const MIN_INT32 = -2147483648;
      const MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      const Z_ANCHOR = /[^\\]\\Z/;
      function regex(str) {
        if (Z_ANCHOR.test(str))
          return false;
        try {
          new RegExp(str);
          return true;
        } catch (e) {
          return false;
        }
      }
    })(formats);
    return formats;
  }
  var limit = {};
  var hasRequiredLimit;
  function requireLimit() {
    if (hasRequiredLimit) return limit;
    hasRequiredLimit = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatLimitDefinition = void 0;
      const ajv_1 = requireAjv();
      const codegen_1 = requireCodegen();
      const ops = codegen_1.operators;
      const KWDs = {
        formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      const error = {
        message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
      };
      exports.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
          const { opts, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format2 = fCxt.schema;
            const fmtDef = self2.formats[format2];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format2,
              ref: fmtDef,
              code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const formatLimitPlugin = (ajv2) => {
        ajv2.addKeyword(exports.formatLimitDefinition);
        return ajv2;
      };
      exports.default = formatLimitPlugin;
    })(limit);
    return limit;
  }
  var hasRequiredDist$1;
  function requireDist$1() {
    if (hasRequiredDist$1) return dist$1.exports;
    hasRequiredDist$1 = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      const formats_1 = requireFormats();
      const limit_1 = requireLimit();
      const codegen_1 = requireCodegen();
      const fullName = new codegen_1.Name("fullFormats");
      const fastName = new codegen_1.Name("fastFormats");
      const formatsPlugin = (ajv2, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats2(ajv2, opts, formats_1.fullFormats, fullName);
          return ajv2;
        }
        const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list = opts.formats || formats_1.formatNames;
        addFormats2(ajv2, list, formats2, exportName);
        if (opts.keywords)
          (0, limit_1.default)(ajv2);
        return ajv2;
      };
      formatsPlugin.get = (name, mode = "full") => {
        const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f = formats2[name];
        if (!f)
          throw new Error(`Unknown format "${name}"`);
        return f;
      };
      function addFormats2(ajv2, list, fs, exportName) {
        var _a;
        var _b;
        (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
        for (const f of list)
          ajv2.addFormat(f, fs[f]);
      }
      module.exports = exports = formatsPlugin;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = formatsPlugin;
    })(dist$1, dist$1.exports);
    return dist$1.exports;
  }
  var distExports$1 = requireDist$1();
  const addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports$1);
  var dist = { exports: {} };
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist.exports;
    hasRequiredDist = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      const ajv_1 = requireAjv();
      const codegen_1 = requireCodegen();
      const code_1 = requireCode$1();
      const validate_1 = requireValidate();
      const errors_1 = requireErrors();
      const names_1 = requireNames();
      const keyword2 = "errorMessage";
      const used = new ajv_1.Name("emUsed");
      const KEYWORD_PROPERTY_PARAMS = {
        required: "missingProperty",
        dependencies: "property",
        dependentRequired: "property"
      };
      const INTERPOLATION = /\$\{[^}]+\}/;
      const INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
      const EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
      function errorMessage(options) {
        return {
          keyword: keyword2,
          schemaType: ["string", "object"],
          post: true,
          code(cxt) {
            const { gen, data, schema, schemaValue, it } = cxt;
            if (it.createErrors === false)
              return;
            const sch = schema;
            const instancePath = codegen_1.strConcat(names_1.default.instancePath, it.errorPath);
            gen.if(ajv_1._`${names_1.default.errors} > 0`, () => {
              if (typeof sch == "object") {
                const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
                if (kwdErrors)
                  processKeywordErrors(kwdErrors);
                if (kwdPropErrors)
                  processKeywordPropErrors(kwdPropErrors);
                processChildErrors(childErrorsConfig(sch));
              }
              const schMessage = typeof sch == "string" ? sch : sch._;
              if (schMessage)
                processAllErrors(schMessage);
              if (!options.keepErrors)
                removeUsedErrors();
            });
            function childErrorsConfig({ properties: properties2, items: items2 }) {
              const errors2 = {};
              if (properties2) {
                errors2.props = {};
                for (const p2 in properties2)
                  errors2.props[p2] = [];
              }
              if (items2) {
                errors2.items = {};
                for (let i = 0; i < items2.length; i++)
                  errors2.items[i] = [];
              }
              return errors2;
            }
            function keywordErrorsConfig(emSchema) {
              let propErrors;
              let errors2;
              for (const k in emSchema) {
                if (k === "properties" || k === "items")
                  continue;
                const kwdSch = emSchema[k];
                if (typeof kwdSch == "object") {
                  propErrors || (propErrors = {});
                  const errMap = propErrors[k] = {};
                  for (const p2 in kwdSch)
                    errMap[p2] = [];
                } else {
                  errors2 || (errors2 = {});
                  errors2[k] = [];
                }
              }
              return [propErrors, errors2];
            }
            function processKeywordErrors(kwdErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
              const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              const { singleError } = options;
              if (singleError) {
                const message = gen.let("message", ajv_1._`""`);
                const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
                loopErrors((key) => {
                  gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                  gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                  gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
                });
                errors_1.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
              } else {
                loopErrors((key) => errors_1.reportError(cxt, {
                  message: errMessage(key),
                  params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
                }));
              }
              function loopErrors(body) {
                gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
              }
              function errMessage(key) {
                return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
              }
            }
            function processKeywordPropErrors(kwdPropErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
              const templatesCode = [];
              for (const k in kwdPropErrors) {
                templatesCode.push([
                  k,
                  getTemplatesCode(kwdPropErrors[k], schema[k])
                ]);
              }
              const templates = gen.const("templates", gen.object(...templatesCode));
              const kwdPropParams = gen.scopeValue("obj", {
                ref: KEYWORD_PROPERTY_PARAMS,
                code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
              });
              const propParam = gen.let("emPropParams");
              const paramsErrors = gen.let("emParamsErrors");
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
                gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
                gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
              }));
              gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
                gen.if(ajv_1._`${paramsErrors}.length`, () => {
                  const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                  errors_1.reportError(cxt, {
                    message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                    params: ajv_1._`{errors: ${paramsErrors}}`
                  });
                });
              }));
            }
            function processChildErrors(childErrors) {
              const { props, items: items2 } = childErrors;
              if (!props && !items2)
                return;
              const isObj = ajv_1._`typeof ${data} == "object"`;
              const isArr = ajv_1._`Array.isArray(${data})`;
              const childErrs = gen.let("emErrors");
              let childKwd;
              let childProp;
              const templates = gen.let("templates");
              if (props && items2) {
                childKwd = gen.let("emChildKwd");
                gen.if(isObj);
                gen.if(isArr, () => {
                  init2(items2, schema.items);
                  gen.assign(childKwd, ajv_1.str`items`);
                }, () => {
                  init2(props, schema.properties);
                  gen.assign(childKwd, ajv_1.str`properties`);
                });
                childProp = ajv_1._`[${childKwd}]`;
              } else if (items2) {
                gen.if(isArr);
                init2(items2, schema.items);
                childProp = ajv_1._`.items`;
              } else if (props) {
                gen.if(codegen_1.and(isObj, codegen_1.not(isArr)));
                init2(props, schema.properties);
                childProp = ajv_1._`.properties`;
              }
              gen.forOf("err", names_1.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
                errors_1.reportError(cxt, {
                  message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                  params: ajv_1._`{errors: ${childErrs}[${key}]}`
                });
                gen.assign(ajv_1._`${names_1.default.vErrors}[${names_1.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
              }));
              gen.endIf();
              function init2(children, msgs) {
                gen.assign(childErrs, ajv_1.stringify(children));
                gen.assign(templates, getTemplatesCode(children, msgs));
              }
            }
            function processAllErrors(schMessage) {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.if(ajv_1._`${errs}.length`, () => errors_1.reportError(cxt, {
                message: templateExpr(schMessage),
                params: ajv_1._`{errors: ${errs}}`
              }));
            }
            function removeUsedErrors() {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
              gen.assign(names_1.default.vErrors, errs).assign(names_1.default.errors, ajv_1._`${errs}.length`);
            }
            function matchKeywordError(err, kwdErrs) {
              return codegen_1.and(
                ajv_1._`${err}.keyword !== ${keyword2}`,
                ajv_1._`!${err}.${used}`,
                ajv_1._`${err}.instancePath === ${instancePath}`,
                ajv_1._`${err}.keyword in ${kwdErrs}`,
                // TODO match the end of the string?
                ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,
                ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`
              );
            }
            function ifMatchesChildError(err, childErrs, thenBody) {
              gen.if(codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
                const childRegex = gen.scopeValue("pattern", {
                  ref: /^\/([^/]*)(?:\/|$)/,
                  code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
                });
                const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
                const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
                gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
              });
            }
            function matchAnyError(err) {
              return codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, codegen_1.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_1.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it.errSchemaPath}.length] === "/"`);
            }
            function getTemplatesCode(keys, msgs) {
              const templatesCode = [];
              for (const k in keys) {
                const msg = msgs[k];
                if (INTERPOLATION.test(msg))
                  templatesCode.push([k, templateFunc(msg)]);
              }
              return gen.object(...templatesCode);
            }
            function templateExpr(msg) {
              if (!INTERPOLATION.test(msg))
                return ajv_1.stringify(msg);
              return new code_1._Code(code_1.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_1.getData(ptr, it)}) + "`).replace(EMPTY_STR, ""));
            }
            function templateFunc(msg) {
              return ajv_1._`function(){return ${templateExpr(msg)}}`;
            }
          },
          metaSchema: {
            anyOf: [
              { type: "string" },
              {
                type: "object",
                properties: {
                  properties: { $ref: "#/$defs/stringMap" },
                  items: { $ref: "#/$defs/stringList" },
                  required: { $ref: "#/$defs/stringOrMap" },
                  dependencies: { $ref: "#/$defs/stringOrMap" }
                },
                additionalProperties: { type: "string" }
              }
            ],
            $defs: {
              stringMap: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              stringOrMap: {
                anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
              },
              stringList: { type: "array", items: { type: "string" } }
            }
          }
        };
      }
      const ajvErrors = (ajv2, options = {}) => {
        if (!ajv2.opts.allErrors)
          throw new Error("ajv-errors: Ajv option allErrors must be true");
        if (ajv2.opts.jsPropertySyntax) {
          throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
        }
        return ajv2.addKeyword(errorMessage(options));
      };
      exports.default = ajvErrors;
      module.exports = ajvErrors;
      module.exports.default = ajvErrors;
    })(dist, dist.exports);
    return dist.exports;
  }
  var distExports = requireDist();
  const addErrors = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
  class ValidatorService {
    constructor(options) {
      __publicField(this, "ajv");
      this.ajv = new Ajv({
        allErrors: true,
        useDefaults: "empty",
        verbose: true,
        validateFormats: true,
        strict: true,
        coerceTypes: true,
        ...options
      });
      console.log(this.ajv.schemas);
      addFormats(this.ajv);
      addErrors(this.ajv);
      this.ajv.addKeyword("nodeType");
    }
    createValidator(schema) {
      return this.ajv.compile(schema);
    }
    errors(errors2, options) {
      return this.ajv.errorsText(errors2, options);
    }
  }
  const validatorService = new ValidatorService();
  function createNodeRedVueApp(node, form, validator) {
    const app = createApp(NodeRedVueApp, {
      node,
      validator,
      disableSaveButtonOnError: form.disableSaveButtonOnError
    });
    app.component("NodeRedInput", NodeRedInput);
    app.component("NodeRedTypedInput", NodeRedTypedInput);
    app.component("NodeRedConfigInput", NodeRedConfigInput);
    app.component("NodeRedSelectInput", NodeRedSelectInput);
    app.component("NodeRedEditorInput", NodeRedEditorInput);
    app.component("NodeRedNodeForm", form.component);
    return app;
  }
  function mountApp(node, form, validator) {
    $$1("#app").empty();
    node._newState = cloneDeep(node);
    node._app = createNodeRedVueApp(node._newState, form, validator);
    node._app.mount("#app");
  }
  function unmountApp(node) {
    if (node._app) {
      node._app.unmount();
      node._app = null;
    }
  }
  function getNodeState(node) {
    const state = {
      credentials: {}
    };
    Object.keys(node._def.defaults).forEach((prop) => {
      state[prop] = node[prop];
    });
    Object.keys(node._def.credentials).forEach((prop) => {
      state.credentials[prop] = node.credentials[prop];
      if (node._def.credentials[prop].type === "password") {
        state.credentials[`has_${prop}`] = node.credentials[`has_${prop}`] || false;
      }
    });
    return state;
  }
  function getChanges(o, n) {
    const changes = {};
    Object.keys(o).forEach((prop) => {
      const _o = o[prop];
      const _n = n[prop];
      if (typeof _o === "object") {
        const _changes = getChanges(_o, _n);
        if (Object.keys(_changes).length) {
          changes[prop] = _changes;
        }
      } else if (!isEqual(_o, _n)) {
        changes[prop] = _o;
      }
    });
    return changes;
  }
  function defineNode(options) {
    return options;
  }
  async function registerType(type2, options) {
    try {
      const response = await fetch(`/nrg/nodes/${type2}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const { schema } = await response.json();
      const defaults2 = getDefaultsFromSchema(schema);
      if (defaults2.credentials) delete defaults2.credentials;
      const credentials = getCredentialsFromSchema(schema.properties.credentials);
      console.log("defaults", defaults2);
      console.log("credentials", credentials);
      RED.nodes.registerType(type2, {
        ...options,
        defaults: defaults2,
        credentials,
        type: type2,
        label: function() {
          return this.name;
        },
        oneditprepare: function() {
          console.log("oneditprepare");
          console.log(this);
          const validator = validatorService.createValidator(schema);
          mountApp(this, options.form, validator);
        },
        oneditsave: function() {
          var _a;
          const node = this;
          unmountApp(node);
          const newState = getNodeState(node._newState);
          const oldState = getNodeState(node);
          const changes = getChanges(oldState, newState);
          const changed = !!((_a = Object.keys(changes)) == null ? void 0 : _a.length);
          if (!changed) return false;
          Object.keys(node._def.defaults).forEach((prop) => {
            var _a2, _b;
            if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
              const oldConfigNodeId = node[prop];
              const newConfigNodeId = node._newState[prop];
              if (oldConfigNodeId !== newConfigNodeId) {
                const oldConfigNode = RED.nodes.node(oldConfigNodeId);
                if (oldConfigNode && oldConfigNode._def.category === "config") {
                  const parentNodeIndex = oldConfigNode.users.findIndex(
                    (_node) => _node.id === node.id
                  );
                  if (parentNodeIndex !== -1) {
                    oldConfigNode.users.splice(parentNodeIndex, 1);
                  }
                }
              }
            }
          });
          Object.keys(node._def.defaults).forEach((prop) => {
            var _a2, _b;
            if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
              const newStateConfigNodeId = node._newState[prop];
              const newStateConfigNode = RED.nodes.node(newStateConfigNodeId);
              if (newStateConfigNode && newStateConfigNode._def.category === "config") {
                const parentNodeIndex = newStateConfigNode.users.findIndex(
                  (_node) => _node.id === node.id
                );
                if (parentNodeIndex === -1) {
                  newStateConfigNode.users.push(node);
                }
              }
            }
          });
          merge(node, newState);
          return {
            changed,
            history: [
              {
                t: "edit",
                node,
                changes,
                links: [],
                dirty: RED.nodes.dirty(),
                changed
              }
            ]
          };
        },
        oneditcancel: function() {
          unmountApp(this);
        },
        oneditdelete: function() {
          unmountApp(this);
        },
        onpaletteadd: options.onPaletteAdd,
        onpaltteremove: options.onPaletteRemove
      });
    } catch (error) {
      console.error(`Error fetching node type ${type2}:`, error);
      throw error;
    }
  }
  const _sfc_main$1 = {
    name: "NodeRedNodeForm",
    props: {
      node: {
        type: Object,
        required: true
      },
      errors: {
        type: Object,
        default: () => ({})
      }
    }
  };
  const _hoisted_1$1 = { class: "form-row" };
  const _hoisted_2$1 = { class: "form-row" };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedInput = resolveComponent("NodeRedInput");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1$1, [
        _cache[2] || (_cache[2] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Name")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.name,
          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.name = $event),
          error: $props.errors["node.name"],
          placeholder: "name"
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_2$1, [
        _cache[3] || (_cache[3] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Hostname")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.host,
          "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.host = $event),
          error: $props.errors["node.host"],
          placeholder: "hostname"
        }, null, 8, ["value", "error"])
      ])
    ]);
  }
  const component$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
  const remoteServer = defineNode({
    category: "config",
    color: "#a6bbcf",
    form: {
      component: component$1,
      disableSaveButtonOnError: true
    }
  });
  const logo = "data:image/png;base64,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";
  const _imports_0 = "/resources/red-vue-test/vue.png";
  const _sfc_main = {
    name: "NodeRedNodeForm",
    props: {
      node: {
        type: Object,
        required: true
      },
      errors: {
        type: Object,
        default: () => ({})
      }
    },
    data() {
      return {
        logo,
        types: ["str", "msg", "node"],
        countries: [
          { value: "usa", label: "usa" },
          { value: "argentina", label: "argentina" },
          { value: "brasil", label: "brasil" }
        ],
        fruits: [
          { value: "apple", label: "apple" },
          { value: "melon", label: "melon" },
          { value: "raspberry", label: "raspberry" }
        ],
        numbers: [
          { value: "1", label: "1" },
          { value: "2", label: "2" },
          { value: "3", label: "3" }
        ],
        objects: [
          { value: JSON.stringify({ test: "a" }), label: "a" },
          { value: JSON.stringify({ test: "b" }), label: "b" },
          { value: JSON.stringify({ test: "c" }), label: "c" }
        ],
        arrays: [
          { value: JSON.stringify(["a"]), label: "a" },
          { value: JSON.stringify(["b"]), label: "b" },
          { value: JSON.stringify(["c"]), label: "c" }
        ]
      };
    },
    mounted() {
      console.log("MOUNTED");
      console.log(this.logo);
    }
  };
  const _hoisted_1 = { class: "form-row" };
  const _hoisted_2 = { class: "form-row" };
  const _hoisted_3 = { class: "form-row" };
  const _hoisted_4 = { class: "form-row" };
  const _hoisted_5 = { class: "form-row" };
  const _hoisted_6 = { class: "form-row" };
  const _hoisted_7 = { class: "form-row" };
  const _hoisted_8 = { class: "form-row" };
  const _hoisted_9 = { class: "form-row" };
  const _hoisted_10 = { class: "form-row" };
  const _hoisted_11 = { class: "form-row" };
  const _hoisted_12 = { class: "form-row" };
  const _hoisted_13 = { class: "form-row" };
  const _hoisted_14 = { class: "form-row" };
  const _hoisted_15 = ["src"];
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedInput = resolveComponent("NodeRedInput");
    const _component_NodeRedTypedInput = resolveComponent("NodeRedTypedInput");
    const _component_NodeRedConfigInput = resolveComponent("NodeRedConfigInput");
    const _component_NodeRedSelectInput = resolveComponent("NodeRedSelectInput");
    const _component_NodeRedEditorInput = resolveComponent("NodeRedEditorInput");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1, [
        _cache[14] || (_cache[14] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Username")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.username,
          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.credentials.username = $event),
          error: $props.errors["node.credentials.username"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_2, [
        _cache[15] || (_cache[15] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Password")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.password,
          "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.credentials.password = $event),
          type: "password",
          error: $props.errors["node.credentials.password"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_3, [
        _cache[16] || (_cache[16] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Password 2")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.password2,
          "onUpdate:value": _cache[2] || (_cache[2] = ($event) => $props.node.credentials.password2 = $event),
          type: "password",
          error: $props.errors["node.credentials.password2"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_4, [
        _cache[17] || (_cache[17] = createBaseVNode("label", null, "Typed Input", -1)),
        createVNode(_component_NodeRedTypedInput, {
          value: $props.node.myProperty,
          "onUpdate:value": _cache[3] || (_cache[3] = ($event) => $props.node.myProperty = $event),
          types: $data.types,
          error: $props.errors["node.myProperty"]
        }, null, 8, ["value", "types", "error"])
      ]),
      createBaseVNode("div", _hoisted_5, [
        _cache[18] || (_cache[18] = createBaseVNode("label", null, "Typed Input 2", -1)),
        createVNode(_component_NodeRedTypedInput, {
          value: $props.node.myProperty2,
          "onUpdate:value": _cache[4] || (_cache[4] = ($event) => $props.node.myProperty2 = $event),
          error: $props.errors["node.myProperty2"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_6, [
        _cache[19] || (_cache[19] = createBaseVNode("label", null, "Config Input", -1)),
        createVNode(_component_NodeRedConfigInput, {
          value: $props.node.remoteServer,
          "onUpdate:value": _cache[5] || (_cache[5] = ($event) => $props.node.remoteServer = $event),
          type: "remote-server",
          error: $props.errors["node.remoteServer"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_7, [
        _cache[20] || (_cache[20] = createBaseVNode("label", null, "Config Input", -1)),
        createVNode(_component_NodeRedConfigInput, {
          value: $props.node.anotherRemoteServer,
          "onUpdate:value": _cache[6] || (_cache[6] = ($event) => $props.node.anotherRemoteServer = $event),
          type: "remote-server",
          error: $props.errors["node.anotherRemoteServer"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_8, [
        _cache[21] || (_cache[21] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.country,
          "onUpdate:value": _cache[7] || (_cache[7] = ($event) => $props.node.country = $event),
          options: $data.countries,
          error: $props.errors["node.country"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_9, [
        _cache[22] || (_cache[22] = createBaseVNode("label", null, "MultiSelect Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.fruit,
          "onUpdate:value": _cache[8] || (_cache[8] = ($event) => $props.node.fruit = $event),
          options: $data.fruits,
          multiple: "",
          error: $props.errors["node.fruit"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_10, [
        _cache[23] || (_cache[23] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.number,
          "onUpdate:value": _cache[9] || (_cache[9] = ($event) => $props.node.number = $event),
          options: $data.numbers,
          error: $props.errors["node.number"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_11, [
        _cache[24] || (_cache[24] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.object,
          "onUpdate:value": _cache[10] || (_cache[10] = ($event) => $props.node.object = $event),
          options: $data.objects,
          multiple: "",
          error: $props.errors["node.object"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_12, [
        _cache[25] || (_cache[25] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.array,
          "onUpdate:value": _cache[11] || (_cache[11] = ($event) => $props.node.array = $event),
          options: $data.arrays,
          error: $props.errors["node.array"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_13, [
        _cache[26] || (_cache[26] = createBaseVNode("label", null, "Editor with default height 200px and JSON", -1)),
        createVNode(_component_NodeRedEditorInput, {
          value: $props.node.jsontest,
          "onUpdate:value": _cache[12] || (_cache[12] = ($event) => $props.node.jsontest = $event),
          error: $props.errors["node.jsontest"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_14, [
        _cache[27] || (_cache[27] = createBaseVNode("label", null, "Editor with custom height and CSS", -1)),
        createVNode(_component_NodeRedEditorInput, {
          value: $props.node.csstest,
          "onUpdate:value": _cache[13] || (_cache[13] = ($event) => $props.node.csstest = $event),
          language: "css",
          style: { "height": "100px" },
          error: $props.errors["node.csstest"]
        }, null, 8, ["value", "error"])
      ]),
      _cache[28] || (_cache[28] = createBaseVNode("img", { src: _imports_0 }, null, -1)),
      createBaseVNode("img", {
        src: $data.logo,
        alt: "Logo"
      }, null, 8, _hoisted_15)
    ]);
  }
  const component = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
  const yourNode = defineNode({
    category: "function",
    color: "#FFFFFF",
    inputs: 1,
    outputs: 1,
    icon: "vue.png",
    form: {
      component,
      disableSaveButtonOnError: true
    },
    onPaletteAdd: () => {
      console.log("NODE TYPE REGISTERED ON THE PALETTE");
    }
  });
  async function init() {
    try {
      await Promise.all([
        registerType("remote-server", remoteServer),
        registerType("your-node", yourNode)
      ]);
      console.log("All node types registered in parallel");
    } catch (error) {
      console.error("Error registering node types:", error);
    }
  }
  (async function() {
    try {
      console.log("Running provided init");
      await init();
      console.log("Finished running provided init");
    } catch (error) {
      console.error("Error while running provided init:", error);
    }
  })();
})($);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguQ3gwNHBfanIuanMiLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvZnVuY3Rpb24vbm9vcC5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc1ByaW1pdGl2ZS5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc1R5cGVkQXJyYXkubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvX2ludGVybmFsL2dldFN5bWJvbHMubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvX2ludGVybmFsL2dldFRhZy5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC9faW50ZXJuYWwvdGFncy5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9jbG9uZURlZXBXaXRoLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L2Nsb25lRGVlcC5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc1BsYWluT2JqZWN0Lm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L21lcmdlLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L3V0aWwvZXEubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNFcXVhbFdpdGgubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNFcXVhbC5tanMiLCIuLi8uLi9zcmMvY29yZS91dGlscy50cyIsIi4uLy4uL25vZGVfbW9kdWxlcy9qc29ucG9pbnRlci9qc29ucG9pbnRlci5qcyIsIi4uLy4uL3NyYy9jb3JlL0FwcC52dWUiLCIuLi8uLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRJbnB1dC52dWUiLCIuLi8uLi9zcmMvY29yZS9jb25zdGFudHMudHMiLCIuLi8uLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRUeXBlZElucHV0LnZ1ZSIsIi4uLy4uL3NyYy9jb3JlL2NvbXBvbmVudHMvTm9kZVJlZENvbmZpZ0lucHV0LnZ1ZSIsIi4uLy4uL3NyYy9jb3JlL2NvbXBvbmVudHMvTm9kZVJlZFNlbGVjdElucHV0LnZ1ZSIsIi4uLy4uL3NyYy9jb3JlL2NvbXBvbmVudHMvTm9kZVJlZEVkaXRvcklucHV0LnZ1ZSIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vY29kZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vc2NvcGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL25hbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvZXJyb3JzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYm9vbFNjaGVtYS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3J1bGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYXBwbGljYWJpbGl0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9rZXl3b3JkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3Jlc29sdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZWZfZXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NvcGVkQ2hhcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY2hlbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdXJpLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYtZXJyb3JzL2Rpc3QvaW5kZXguanMiLCIuLi8uLi9zcmMvY29yZS92YWxpZGF0b3Itc2VydmljZS50cyIsIi4uLy4uL3NyYy9jb3JlL3ZhbGlkYXRvci50cyIsIi4uLy4uL3NyYy9jb3JlL2luZGV4LnRzIiwiLi4vLi4vc3JjL25vZGVzL3JlbW90ZS1zZXJ2ZXIvRm9ybS52dWUiLCIuLi8uLi9zcmMvbm9kZXMvcmVtb3RlLXNlcnZlci9pbmRleC50cyIsIi4uLy4uL3NyYy9hc3NldHMvdnVlLnBuZyIsIi4uLy4uLy4uLy4uLy4uL3Z1ZS5wbmciLCIuLi8uLi9zcmMvbm9kZXMveW91ci1ub2RlL0Zvcm0udnVlIiwiLi4vLi4vc3JjL25vZGVzL3lvdXItbm9kZS9pbmRleC50cyIsIi4uLy4uL3NyYy9pbmRleC5jbGllbnQudHMiLCIuLi8uLi9zcmMvY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWtlTWFwKHN0cikge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygc3RyLnNwbGl0KFwiLFwiKSkgbWFwW2tleV0gPSAxO1xuICByZXR1cm4gKHZhbCkgPT4gdmFsIGluIG1hcDtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5mdW5jdGlvbiBnZW5DYWNoZUtleShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNvdXJjZSArIEpTT04uc3RyaW5naWZ5KFxuICAgIG9wdGlvbnMsXG4gICAgKF8sIHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsLnRvU3RyaW5nKCkgOiB2YWxcbiAgKTtcbn1cblxuY29uc3QgUGF0Y2hGbGFncyA9IHtcbiAgXCJURVhUXCI6IDEsXG4gIFwiMVwiOiBcIlRFWFRcIixcbiAgXCJDTEFTU1wiOiAyLFxuICBcIjJcIjogXCJDTEFTU1wiLFxuICBcIlNUWUxFXCI6IDQsXG4gIFwiNFwiOiBcIlNUWUxFXCIsXG4gIFwiUFJPUFNcIjogOCxcbiAgXCI4XCI6IFwiUFJPUFNcIixcbiAgXCJGVUxMX1BST1BTXCI6IDE2LFxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxuICBcIk5FRURfSFlEUkFUSU9OXCI6IDMyLFxuICBcIjMyXCI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXG4gIFwiNjRcIjogXCJTVEFCTEVfRlJBR01FTlRcIixcbiAgXCJLRVlFRF9GUkFHTUVOVFwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcbiAgXCJVTktFWUVEX0ZSQUdNRU5UXCI6IDI1NixcbiAgXCIyNTZcIjogXCJVTktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiTkVFRF9QQVRDSFwiLFxuICBcIkRZTkFNSUNfU0xPVFNcIjogMTAyNCxcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxuICBcIkRFVl9ST09UX0ZSQUdNRU5UXCI6IDIwNDgsXG4gIFwiMjA0OFwiOiBcIkRFVl9ST09UX0ZSQUdNRU5UXCIsXG4gIFwiQ0FDSEVEXCI6IC0xLFxuICBcIi0xXCI6IFwiQ0FDSEVEXCIsXG4gIFwiQkFJTFwiOiAtMixcbiAgXCItMlwiOiBcIkJBSUxcIlxufTtcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgTkVFRF9IWURSQVRJT05gLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBTaGFwZUZsYWdzID0ge1xuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCI6IDIsXG4gIFwiMlwiOiBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCIsXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXG4gIFwiNFwiOiBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiLFxuICBcIlRFWFRfQ0hJTERSRU5cIjogOCxcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxuICBcIkFSUkFZX0NISUxEUkVOXCI6IDE2LFxuICBcIjE2XCI6IFwiQVJSQVlfQ0hJTERSRU5cIixcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcbiAgXCIzMlwiOiBcIlNMT1RTX0NISUxEUkVOXCIsXG4gIFwiVEVMRVBPUlRcIjogNjQsXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxuICBcIlNVU1BFTlNFXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJTVVNQRU5TRVwiLFxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIjogNTEyLFxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVFwiXG59O1xuXG5jb25zdCBTbG90RmxhZ3MgPSB7XG4gIFwiU1RBQkxFXCI6IDEsXG4gIFwiMVwiOiBcIlNUQUJMRVwiLFxuICBcIkRZTkFNSUNcIjogMixcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxuICBcIkZPUldBUkRFRFwiOiAzLFxuICBcIjNcIjogXCJGT1JXQVJERURcIlxufTtcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yLFN5bWJvbFwiO1xuY29uc3QgaXNHbG9iYWxseUFsbG93ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX0FMTE9XRUQpO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBzb3VyY2UubGVuZ3RoKSk7XG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBpZiAoIXN0eWxlcykgcmV0dXJuIFwiXCI7XG4gIGlmIChpc1N0cmluZyhzdHlsZXMpKSByZXR1cm4gc3R5bGVzO1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBNQVRIX1RBR1MgPSBcImFubm90YXRpb24sYW5ub3RhdGlvbi14bWwsbWFjdGlvbixtYWxpZ25ncm91cCxtYWxpZ25tYXJrLG1hdGgsbWVuY2xvc2UsbWVycm9yLG1mZW5jZWQsbWZyYWMsbWZyYWN0aW9uLG1nbHlwaCxtaSxtbGFiZWxlZHRyLG1sb25nZGl2LG1tdWx0aXNjcmlwdHMsbW4sbW8sbW92ZXIsbXBhZGRlZCxtcGhhbnRvbSxtcHJlc2NyaXB0cyxtcm9vdCxtcm93LG1zLG1zY2Fycmllcyxtc2NhcnJ5LG1zZ3JvdXAsbXNsaW5lLG1zcGFjZSxtc3FydCxtc3Jvdyxtc3RhY2ssbXN0eWxlLG1zdWIsbXN1YnN1cCxtc3VwLG10YWJsZSxtdGQsbXRleHQsbXRyLG11bmRlcixtdW5kZXJvdmVyLG5vbmUsc2VtYW50aWNzXCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc01hdGhNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKE1BVEhfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWxuczp4bGluayx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5jb25zdCBpc0tub3duTWF0aE1MQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZW50LGFjY2VudHVuZGVyLGFjdGlvbnR5cGUsYWxpZ24sYWxpZ25tZW50c2NvcGUsYWx0aW1nLGFsdGltZy1oZWlnaHQsYWx0aW1nLXZhbGlnbixhbHRpbWctd2lkdGgsYWx0dGV4dCxiZXZlbGxlZCxjbG9zZSxjb2x1bW5zYWxpZ24sY29sdW1ubGluZXMsY29sdW1uc3BhbixkZW5vbWFsaWduLGRlcHRoLGRpcixkaXNwbGF5LGRpc3BsYXlzdHlsZSxlbmNvZGluZyxlcXVhbGNvbHVtbnMsZXF1YWxyb3dzLGZlbmNlLGZvbnRzdHlsZSxmb250d2VpZ2h0LGZvcm0sZnJhbWUsZnJhbWVzcGFjaW5nLGdyb3VwYWxpZ24saGVpZ2h0LGhyZWYsaWQsaW5kZW50YWxpZ24saW5kZW50YWxpZ25maXJzdCxpbmRlbnRhbGlnbmxhc3QsaW5kZW50c2hpZnQsaW5kZW50c2hpZnRmaXJzdCxpbmRlbnRzaGlmdGxhc3QsaW5kZXh0eXBlLGp1c3RpZnksbGFyZ2V0b3AsbGFyZ2VvcCxscXVvdGUsbHNwYWNlLG1hdGhiYWNrZ3JvdW5kLG1hdGhjb2xvcixtYXRoc2l6ZSxtYXRodmFyaWFudCxtYXhzaXplLG1pbmxhYmVsc3BhY2luZyxtb2RlLG90aGVyLG92ZXJmbG93LHBvc2l0aW9uLHJvd2FsaWduLHJvd2xpbmVzLHJvd3NwYW4scnF1b3RlLHJzcGFjZSxzY3JpcHRsZXZlbCxzY3JpcHRtaW5zaXplLHNjcmlwdHNpemVtdWx0aXBsaWVyLHNlbGVjdGlvbixzZXBhcmF0b3Isc2VwYXJhdG9ycyxzaGlmdCxzaWRlLHNyYyxzdGFja2FsaWduLHN0cmV0Y2h5LHN1YnNjcmlwdHNoaWZ0LHN1cGVyc2NyaXB0c2hpZnQsc3ltbWV0cmljLHZvZmZzZXQsd2lkdGgsd2lkdGhzLHhsaW5rOmhyZWYseGxpbms6c2hvdyx4bGluazp0eXBlLHhtbG5zYFxuKTtcbmZ1bmN0aW9uIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuY29uc3QgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSA9IC9bICFcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXV5ge3x9fl0vZztcbmZ1bmN0aW9uIGdldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZG91YmxlRXNjYXBlKSB7XG4gIHJldHVybiBrZXkucmVwbGFjZShcbiAgICBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFLFxuICAgIChzKSA9PiBkb3VibGVFc2NhcGUgPyBzID09PSAnXCInID8gJ1xcXFxcXFxcXFxcXFwiJyA6IGBcXFxcXFxcXCR7c31gIDogYFxcXFwke3N9YFxuICApO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBlcXVhbCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgfVxuICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IGlzUmVmID0gKHZhbCkgPT4ge1xuICByZXR1cm4gISEodmFsICYmIHZhbFtcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSk7XG59O1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gaXNSZWYodmFsKSA/IHRvRGlzcGxheVN0cmluZyh2YWwudmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKFxuICAgICAgICAoZW50cmllcywgW2tleSwgdmFsMl0sIGkpID0+IHtcbiAgICAgICAgICBlbnRyaWVzW3N0cmluZ2lmeVN5bWJvbChrZXksIGkpICsgXCIgPT5cIl0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBzdHJpbmdpZnlTeW1ib2wodikpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1N5bWJvbCh2YWwpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN5bWJvbCh2YWwpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuY29uc3Qgc3RyaW5naWZ5U3ltYm9sID0gKHYsIGkgPSBcIlwiKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChcbiAgICAvLyBTeW1ib2wuZGVzY3JpcHRpb24gaW4gZXMyMDE5KyBzbyB3ZSBuZWVkIHRvIGNhc3QgaGVyZSB0byBwYXNzXG4gICAgLy8gdGhlIGxpYjogZXMyMDE2IGNoZWNrXG4gICAgaXNTeW1ib2wodikgPyBgU3ltYm9sKCR7KF9hID0gdi5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hIDogaX0pYCA6IHZcbiAgKTtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIFBhdGNoRmxhZ3MsIFNoYXBlRmxhZ3MsIFNsb3RGbGFncywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuQ2FjaGVLZXksIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93bk1hdGhNTEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNYXRoTUxUYWcsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIi8qKlxuKiBAdnVlL3JlYWN0aXZpdHkgdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgaGFzQ2hhbmdlZCwgZXh0ZW5kLCBpc0FycmF5LCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBpc01hcCwgaGFzT3duLCBpc09iamVjdCwgbWFrZU1hcCwgdG9SYXdUeXBlLCBjYXBpdGFsaXplLCBkZWYsIGlzRnVuY3Rpb24sIEVNUFRZX09CSiwgaXNTZXQsIGlzUGxhaW5PYmplY3QsIE5PT1AsIHJlbW92ZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnfWAsIC4uLmFyZ3MpO1xufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XG5jbGFzcyBFZmZlY3RTY29wZSB7XG4gIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgIHRoaXMuaW5kZXggPSAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICAgIHRoaXNcbiAgICAgICkgLSAxO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyB0aGUgZWZmZWN0IHNjb3BlLCBpbmNsdWRpbmcgYWxsIGNoaWxkIHNjb3BlcyBhbmQgZWZmZWN0cy5cbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGksIGw7XG4gICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBydW4oZm4pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xuICB9XG4gIHN0b3AoZnJvbVBhcmVudCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhbnVwcy5sZW5ndGggPSAwO1xuICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NvcGVzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSkge1xuICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbn1cblxubGV0IGFjdGl2ZVN1YjtcbmNvbnN0IEVmZmVjdEZsYWdzID0ge1xuICBcIkFDVElWRVwiOiAxLFxuICBcIjFcIjogXCJBQ1RJVkVcIixcbiAgXCJSVU5OSU5HXCI6IDIsXG4gIFwiMlwiOiBcIlJVTk5JTkdcIixcbiAgXCJUUkFDS0lOR1wiOiA0LFxuICBcIjRcIjogXCJUUkFDS0lOR1wiLFxuICBcIk5PVElGSUVEXCI6IDgsXG4gIFwiOFwiOiBcIk5PVElGSUVEXCIsXG4gIFwiRElSVFlcIjogMTYsXG4gIFwiMTZcIjogXCJESVJUWVwiLFxuICBcIkFMTE9XX1JFQ1VSU0VcIjogMzIsXG4gIFwiMzJcIjogXCJBTExPV19SRUNVUlNFXCIsXG4gIFwiUEFVU0VEXCI6IDY0LFxuICBcIjY0XCI6IFwiUEFVU0VEXCJcbn07XG5jb25zdCBwYXVzZWRRdWV1ZUVmZmVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgY29uc3RydWN0b3IoZm4pIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDEgfCA0O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXAgPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSB2b2lkIDA7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlICYmIGFjdGl2ZUVmZmVjdFNjb3BlLmFjdGl2ZSkge1xuICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmZsYWdzIHw9IDY0O1xuICB9XG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICB0aGlzLmZsYWdzICY9IH42NDtcbiAgICAgIGlmIChwYXVzZWRRdWV1ZUVmZmVjdHMuaGFzKHRoaXMpKSB7XG4gICAgICAgIHBhdXNlZFF1ZXVlRWZmZWN0cy5kZWxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAyICYmICEodGhpcy5mbGFncyAmIDMyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0aGlzLmZsYWdzICYgOCkpIHtcbiAgICAgIGJhdGNoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBydW4oKSB7XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH1cbiAgICB0aGlzLmZsYWdzIHw9IDI7XG4gICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICBwcmVwYXJlRGVwcyh0aGlzKTtcbiAgICBjb25zdCBwcmV2RWZmZWN0ID0gYWN0aXZlU3ViO1xuICAgIGNvbnN0IHByZXZTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xuICAgIGFjdGl2ZVN1YiA9IHRoaXM7XG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVTdWIgIT09IHRoaXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkFjdGl2ZSBlZmZlY3Qgd2FzIG5vdCByZXN0b3JlZCBjb3JyZWN0bHkgLSB0aGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbCBidWcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNsZWFudXBEZXBzKHRoaXMpO1xuICAgICAgYWN0aXZlU3ViID0gcHJldkVmZmVjdDtcbiAgICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgICAgdGhpcy5mbGFncyAmPSB+MjtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDEpIHtcbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICAgICAgcmVtb3ZlU3ViKGxpbmspO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXBzID0gdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcbiAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICB0aGlzLm9uU3RvcCAmJiB0aGlzLm9uU3RvcCgpO1xuICAgICAgdGhpcy5mbGFncyAmPSB+MTtcbiAgICB9XG4gIH1cbiAgdHJpZ2dlcigpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuYWRkKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVuSWZEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBydW5JZkRpcnR5KCkge1xuICAgIGlmIChpc0RpcnR5KHRoaXMpKSB7XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH1cbiAgfVxuICBnZXQgZGlydHkoKSB7XG4gICAgcmV0dXJuIGlzRGlydHkodGhpcyk7XG4gIH1cbn1cbmxldCBiYXRjaERlcHRoID0gMDtcbmxldCBiYXRjaGVkU3ViO1xubGV0IGJhdGNoZWRDb21wdXRlZDtcbmZ1bmN0aW9uIGJhdGNoKHN1YiwgaXNDb21wdXRlZCA9IGZhbHNlKSB7XG4gIHN1Yi5mbGFncyB8PSA4O1xuICBpZiAoaXNDb21wdXRlZCkge1xuICAgIHN1Yi5uZXh0ID0gYmF0Y2hlZENvbXB1dGVkO1xuICAgIGJhdGNoZWRDb21wdXRlZCA9IHN1YjtcbiAgICByZXR1cm47XG4gIH1cbiAgc3ViLm5leHQgPSBiYXRjaGVkU3ViO1xuICBiYXRjaGVkU3ViID0gc3ViO1xufVxuZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgYmF0Y2hEZXB0aCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gIGlmICgtLWJhdGNoRGVwdGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChiYXRjaGVkQ29tcHV0ZWQpIHtcbiAgICBsZXQgZSA9IGJhdGNoZWRDb21wdXRlZDtcbiAgICBiYXRjaGVkQ29tcHV0ZWQgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XG4gICAgICBlLm5leHQgPSB2b2lkIDA7XG4gICAgICBlLmZsYWdzICY9IH44O1xuICAgICAgZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIGxldCBlcnJvcjtcbiAgd2hpbGUgKGJhdGNoZWRTdWIpIHtcbiAgICBsZXQgZSA9IGJhdGNoZWRTdWI7XG4gICAgYmF0Y2hlZFN1YiA9IHZvaWQgMDtcbiAgICB3aGlsZSAoZSkge1xuICAgICAgY29uc3QgbmV4dCA9IGUubmV4dDtcbiAgICAgIGUubmV4dCA9IHZvaWQgMDtcbiAgICAgIGUuZmxhZ3MgJj0gfjg7XG4gICAgICBpZiAoZS5mbGFncyAmIDEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZS50cmlnZ2VyKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVEZXBzKHN1Yikge1xuICBmb3IgKGxldCBsaW5rID0gc3ViLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICBsaW5rLnZlcnNpb24gPSAtMTtcbiAgICBsaW5rLnByZXZBY3RpdmVMaW5rID0gbGluay5kZXAuYWN0aXZlTGluaztcbiAgICBsaW5rLmRlcC5hY3RpdmVMaW5rID0gbGluaztcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW51cERlcHMoc3ViKSB7XG4gIGxldCBoZWFkO1xuICBsZXQgdGFpbCA9IHN1Yi5kZXBzVGFpbDtcbiAgbGV0IGxpbmsgPSB0YWlsO1xuICB3aGlsZSAobGluaykge1xuICAgIGNvbnN0IHByZXYgPSBsaW5rLnByZXZEZXA7XG4gICAgaWYgKGxpbmsudmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgIGlmIChsaW5rID09PSB0YWlsKSB0YWlsID0gcHJldjtcbiAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIHJlbW92ZURlcChsaW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGxpbms7XG4gICAgfVxuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rLnByZXZBY3RpdmVMaW5rO1xuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gICAgbGluayA9IHByZXY7XG4gIH1cbiAgc3ViLmRlcHMgPSBoZWFkO1xuICBzdWIuZGVwc1RhaWwgPSB0YWlsO1xufVxuZnVuY3Rpb24gaXNEaXJ0eShzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgaWYgKGxpbmsuZGVwLnZlcnNpb24gIT09IGxpbmsudmVyc2lvbiB8fCBsaW5rLmRlcC5jb21wdXRlZCAmJiAocmVmcmVzaENvbXB1dGVkKGxpbmsuZGVwLmNvbXB1dGVkKSB8fCBsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHN1Yi5fZGlydHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWZyZXNoQ29tcHV0ZWQoY29tcHV0ZWQpIHtcbiAgaWYgKGNvbXB1dGVkLmZsYWdzICYgNCAmJiAhKGNvbXB1dGVkLmZsYWdzICYgMTYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmZsYWdzICY9IH4xNjtcbiAgaWYgKGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPT09IGdsb2JhbFZlcnNpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb247XG4gIGNvbnN0IGRlcCA9IGNvbXB1dGVkLmRlcDtcbiAgY29tcHV0ZWQuZmxhZ3MgfD0gMjtcbiAgaWYgKGRlcC52ZXJzaW9uID4gMCAmJiAhY29tcHV0ZWQuaXNTU1IgJiYgY29tcHV0ZWQuZGVwcyAmJiAhaXNEaXJ0eShjb21wdXRlZCkpIHtcbiAgICBjb21wdXRlZC5mbGFncyAmPSB+MjtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJldlN1YiA9IGFjdGl2ZVN1YjtcbiAgY29uc3QgcHJldlNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gIGFjdGl2ZVN1YiA9IGNvbXB1dGVkO1xuICBzaG91bGRUcmFjayA9IHRydWU7XG4gIHRyeSB7XG4gICAgcHJlcGFyZURlcHMoY29tcHV0ZWQpO1xuICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWQuZm4oY29tcHV0ZWQuX3ZhbHVlKTtcbiAgICBpZiAoZGVwLnZlcnNpb24gPT09IDAgfHwgaGFzQ2hhbmdlZCh2YWx1ZSwgY29tcHV0ZWQuX3ZhbHVlKSkge1xuICAgICAgY29tcHV0ZWQuX3ZhbHVlID0gdmFsdWU7XG4gICAgICBkZXAudmVyc2lvbisrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVwLnZlcnNpb24rKztcbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZlU3ViID0gcHJldlN1YjtcbiAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcbiAgICBjbGVhbnVwRGVwcyhjb21wdXRlZCk7XG4gICAgY29tcHV0ZWQuZmxhZ3MgJj0gfjI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVN1YihsaW5rLCBzb2Z0ID0gZmFsc2UpIHtcbiAgY29uc3QgeyBkZXAsIHByZXZTdWIsIG5leHRTdWIgfSA9IGxpbms7XG4gIGlmIChwcmV2U3ViKSB7XG4gICAgcHJldlN1Yi5uZXh0U3ViID0gbmV4dFN1YjtcbiAgICBsaW5rLnByZXZTdWIgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHRTdWIpIHtcbiAgICBuZXh0U3ViLnByZXZTdWIgPSBwcmV2U3ViO1xuICAgIGxpbmsubmV4dFN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZXAuc3Vic0hlYWQgPT09IGxpbmspIHtcbiAgICBkZXAuc3Vic0hlYWQgPSBuZXh0U3ViO1xuICB9XG4gIGlmIChkZXAuc3VicyA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzID0gcHJldlN1YjtcbiAgICBpZiAoIXByZXZTdWIgJiYgZGVwLmNvbXB1dGVkKSB7XG4gICAgICBkZXAuY29tcHV0ZWQuZmxhZ3MgJj0gfjQ7XG4gICAgICBmb3IgKGxldCBsID0gZGVwLmNvbXB1dGVkLmRlcHM7IGw7IGwgPSBsLm5leHREZXApIHtcbiAgICAgICAgcmVtb3ZlU3ViKGwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXNvZnQgJiYgIS0tZGVwLnNjICYmIGRlcC5tYXApIHtcbiAgICBkZXAubWFwLmRlbGV0ZShkZXAua2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRGVwKGxpbmspIHtcbiAgY29uc3QgeyBwcmV2RGVwLCBuZXh0RGVwIH0gPSBsaW5rO1xuICBpZiAocHJldkRlcCkge1xuICAgIHByZXZEZXAubmV4dERlcCA9IG5leHREZXA7XG4gICAgbGluay5wcmV2RGVwID0gdm9pZCAwO1xuICB9XG4gIGlmIChuZXh0RGVwKSB7XG4gICAgbmV4dERlcC5wcmV2RGVwID0gcHJldkRlcDtcbiAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xuICBpZiAoZm4uZWZmZWN0IGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcbiAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgfVxuICBjb25zdCBlID0gbmV3IFJlYWN0aXZlRWZmZWN0KGZuKTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQoZSwgb3B0aW9ucyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBlLnJ1bigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlLnN0b3AoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY29uc3QgcnVubmVyID0gZS5ydW4uYmluZChlKTtcbiAgcnVubmVyLmVmZmVjdCA9IGU7XG4gIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBzaG91bGRUcmFjayA9IHRydWU7XG5jb25zdCB0cmFja1N0YWNrID0gW107XG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XG4gIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xufVxuZnVuY3Rpb24gb25FZmZlY3RDbGVhbnVwKGZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSkge1xuICBpZiAoYWN0aXZlU3ViIGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcbiAgICBhY3RpdmVTdWIuY2xlYW51cCA9IGZuO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25FZmZlY3RDbGVhbnVwKCkgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBhY3RpdmUgZWZmZWN0IHRvIGFzc29jaWF0ZSB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGUpIHtcbiAgY29uc3QgeyBjbGVhbnVwIH0gPSBlO1xuICBlLmNsZWFudXAgPSB2b2lkIDA7XG4gIGlmIChjbGVhbnVwKSB7XG4gICAgY29uc3QgcHJldlN1YiA9IGFjdGl2ZVN1YjtcbiAgICBhY3RpdmVTdWIgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWN0aXZlU3ViID0gcHJldlN1YjtcbiAgICB9XG4gIH1cbn1cblxubGV0IGdsb2JhbFZlcnNpb24gPSAwO1xuY2xhc3MgTGluayB7XG4gIGNvbnN0cnVjdG9yKHN1YiwgZGVwKSB7XG4gICAgdGhpcy5zdWIgPSBzdWI7XG4gICAgdGhpcy5kZXAgPSBkZXA7XG4gICAgdGhpcy52ZXJzaW9uID0gZGVwLnZlcnNpb247XG4gICAgdGhpcy5uZXh0RGVwID0gdGhpcy5wcmV2RGVwID0gdGhpcy5uZXh0U3ViID0gdGhpcy5wcmV2U3ViID0gdGhpcy5wcmV2QWN0aXZlTGluayA9IHZvaWQgMDtcbiAgfVxufVxuY2xhc3MgRGVwIHtcbiAgY29uc3RydWN0b3IoY29tcHV0ZWQpIHtcbiAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBMaW5rIGJldHdlZW4gdGhpcyBkZXAgYW5kIHRoZSBjdXJyZW50IGFjdGl2ZSBlZmZlY3RcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogRG91Ymx5IGxpbmtlZCBsaXN0IHJlcHJlc2VudGluZyB0aGUgc3Vic2NyaWJpbmcgZWZmZWN0cyAodGFpbClcbiAgICAgKi9cbiAgICB0aGlzLnN1YnMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogRm9yIG9iamVjdCBwcm9wZXJ0eSBkZXBzIGNsZWFudXBcbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVyIGNvdW50ZXJcbiAgICAgKi9cbiAgICB0aGlzLnNjID0gMDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5zdWJzSGVhZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgdHJhY2soZGVidWdJbmZvKSB7XG4gICAgaWYgKCFhY3RpdmVTdWIgfHwgIXNob3VsZFRyYWNrIHx8IGFjdGl2ZVN1YiA9PT0gdGhpcy5jb21wdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbGluayA9IHRoaXMuYWN0aXZlTGluaztcbiAgICBpZiAobGluayA9PT0gdm9pZCAwIHx8IGxpbmsuc3ViICE9PSBhY3RpdmVTdWIpIHtcbiAgICAgIGxpbmsgPSB0aGlzLmFjdGl2ZUxpbmsgPSBuZXcgTGluayhhY3RpdmVTdWIsIHRoaXMpO1xuICAgICAgaWYgKCFhY3RpdmVTdWIuZGVwcykge1xuICAgICAgICBhY3RpdmVTdWIuZGVwcyA9IGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5rLnByZXZEZXAgPSBhY3RpdmVTdWIuZGVwc1RhaWw7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH1cbiAgICAgIGFkZFN1YihsaW5rKTtcbiAgICB9IGVsc2UgaWYgKGxpbmsudmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGlmIChsaW5rLm5leHREZXApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxpbmsubmV4dERlcDtcbiAgICAgICAgbmV4dC5wcmV2RGVwID0gbGluay5wcmV2RGVwO1xuICAgICAgICBpZiAobGluay5wcmV2RGVwKSB7XG4gICAgICAgICAgbGluay5wcmV2RGVwLm5leHREZXAgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgbGluay5uZXh0RGVwID0gdm9pZCAwO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwubmV4dERlcCA9IGxpbms7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICAgIGlmIChhY3RpdmVTdWIuZGVwcyA9PT0gbGluaykge1xuICAgICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVTdWIub25UcmFjaykge1xuICAgICAgYWN0aXZlU3ViLm9uVHJhY2soXG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZVN1YlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVidWdJbmZvXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBsaW5rO1xuICB9XG4gIHRyaWdnZXIoZGVidWdJbmZvKSB7XG4gICAgdGhpcy52ZXJzaW9uKys7XG4gICAgZ2xvYmFsVmVyc2lvbisrO1xuICAgIHRoaXMubm90aWZ5KGRlYnVnSW5mbyk7XG4gIH1cbiAgbm90aWZ5KGRlYnVnSW5mbykge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB0cnkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZm9yIChsZXQgaGVhZCA9IHRoaXMuc3Vic0hlYWQ7IGhlYWQ7IGhlYWQgPSBoZWFkLm5leHRTdWIpIHtcbiAgICAgICAgICBpZiAoaGVhZC5zdWIub25UcmlnZ2VyICYmICEoaGVhZC5zdWIuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgaGVhZC5zdWIub25UcmlnZ2VyKFxuICAgICAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWZmZWN0OiBoZWFkLnN1YlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5zdWJzOyBsaW5rOyBsaW5rID0gbGluay5wcmV2U3ViKSB7XG4gICAgICAgIGlmIChsaW5rLnN1Yi5ub3RpZnkoKSkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBsaW5rLnN1Yi5kZXAubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFN1YihsaW5rKSB7XG4gIGxpbmsuZGVwLnNjKys7XG4gIGlmIChsaW5rLnN1Yi5mbGFncyAmIDQpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IGxpbmsuZGVwLmNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCAmJiAhbGluay5kZXAuc3Vicykge1xuICAgICAgY29tcHV0ZWQuZmxhZ3MgfD0gNCB8IDE2O1xuICAgICAgZm9yIChsZXQgbCA9IGNvbXB1dGVkLmRlcHM7IGw7IGwgPSBsLm5leHREZXApIHtcbiAgICAgICAgYWRkU3ViKGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGFpbCA9IGxpbmsuZGVwLnN1YnM7XG4gICAgaWYgKGN1cnJlbnRUYWlsICE9PSBsaW5rKSB7XG4gICAgICBsaW5rLnByZXZTdWIgPSBjdXJyZW50VGFpbDtcbiAgICAgIGlmIChjdXJyZW50VGFpbCkgY3VycmVudFRhaWwubmV4dFN1YiA9IGxpbms7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGxpbmsuZGVwLnN1YnNIZWFkID09PSB2b2lkIDApIHtcbiAgICAgIGxpbmsuZGVwLnN1YnNIZWFkID0gbGluaztcbiAgICB9XG4gICAgbGluay5kZXAuc3VicyA9IGxpbms7XG4gIH1cbn1cbmNvbnN0IHRhcmdldE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk9iamVjdCBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiTWFwIGtleXMgaXRlcmF0ZVwiIDogXCJcIlxuKTtcbmNvbnN0IEFSUkFZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJBcnJheSBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZVN1Yikge1xuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gbmV3IERlcCgpKTtcbiAgICAgIGRlcC5tYXAgPSBkZXBzTWFwO1xuICAgICAgZGVwLmtleSA9IGtleTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGRlcC50cmFjayh7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVwLnRyYWNrKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xuICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJ1biA9IChkZXApID0+IHtcbiAgICBpZiAoZGVwKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBkZXAudHJpZ2dlcih7XG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgIG9sZFRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcC50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGFydEJhdGNoKCk7XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzTWFwLmZvckVhY2gocnVuKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGNvbnN0IGlzQXJyYXlJbmRleCA9IHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSk7XG4gICAgaWYgKHRhcmdldElzQXJyYXkgJiYga2V5ID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleTIpID0+IHtcbiAgICAgICAgaWYgKGtleTIgPT09IFwibGVuZ3RoXCIgfHwga2V5MiA9PT0gQVJSQVlfSVRFUkFURV9LRVkgfHwgIWlzU3ltYm9sKGtleTIpICYmIGtleTIgPj0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgcnVuKGRlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5ICE9PSB2b2lkIDAgfHwgZGVwc01hcC5oYXModm9pZCAwKSkge1xuICAgICAgICBydW4oZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgIHJ1bihkZXBzTWFwLmdldChBUlJBWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlJbmRleCkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbmRCYXRjaCgpO1xufVxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XG4gIGNvbnN0IGRlcE1hcCA9IHRhcmdldE1hcC5nZXQob2JqZWN0KTtcbiAgcmV0dXJuIGRlcE1hcCAmJiBkZXBNYXAuZ2V0KGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0aXZlUmVhZEFycmF5KGFycmF5KSB7XG4gIGNvbnN0IHJhdyA9IHRvUmF3KGFycmF5KTtcbiAgaWYgKHJhdyA9PT0gYXJyYXkpIHJldHVybiByYXc7XG4gIHRyYWNrKHJhdywgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGlzU2hhbGxvdyhhcnJheSkgPyByYXcgOiByYXcubWFwKHRvUmVhY3RpdmUpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRBcnJheShhcnIpIHtcbiAgdHJhY2soYXJyID0gdG9SYXcoYXJyKSwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgU3ltYm9sLml0ZXJhdG9yLCB0b1JlYWN0aXZlKTtcbiAgfSxcbiAgY29uY2F0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuY29uY2F0KFxuICAgICAgLi4uYXJncy5tYXAoKHgpID0+IGlzQXJyYXkoeCkgPyByZWFjdGl2ZVJlYWRBcnJheSh4KSA6IHgpXG4gICAgKTtcbiAgfSxcbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgXCJlbnRyaWVzXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgdmFsdWVbMV0gPSB0b1JlYWN0aXZlKHZhbHVlWzFdKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSxcbiAgZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJldmVyeVwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaWx0ZXIoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaWx0ZXJcIiwgZm4sIHRoaXNBcmcsICh2KSA9PiB2Lm1hcCh0b1JlYWN0aXZlKSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRcIiwgZm4sIHRoaXNBcmcsIHRvUmVhY3RpdmUsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRJbmRleChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRJbmRleFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kTGFzdChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRMYXN0XCIsIGZuLCB0aGlzQXJnLCB0b1JlYWN0aXZlLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kTGFzdEluZGV4KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZExhc3RJbmRleFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICAvLyBmbGF0LCBmbGF0TWFwIGNvdWxkIGJlbmVmaXQgZnJvbSBBUlJBWV9JVEVSQVRFIGJ1dCBhcmUgbm90IHN0cmFpZ2h0LWZvcndhcmQgdG8gaW1wbGVtZW50XG4gIGZvckVhY2goZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmb3JFYWNoXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGluY2x1ZGVzKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmNsdWRlc1wiLCBhcmdzKTtcbiAgfSxcbiAgaW5kZXhPZiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwiaW5kZXhPZlwiLCBhcmdzKTtcbiAgfSxcbiAgam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuam9pbihzZXBhcmF0b3IpO1xuICB9LFxuICAvLyBrZXlzKCkgaXRlcmF0b3Igb25seSByZWFkcyBgbGVuZ3RoYCwgbm8gb3B0aW1pc2F0aW9uIHJlcXVpcmVkXG4gIGxhc3RJbmRleE9mKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJsYXN0SW5kZXhPZlwiLCBhcmdzKTtcbiAgfSxcbiAgbWFwKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwibWFwXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIHBvcCgpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInBvcFwiKTtcbiAgfSxcbiAgcHVzaCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJwdXNoXCIsIGFyZ3MpO1xuICB9LFxuICByZWR1Y2UoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIFwicmVkdWNlXCIsIGZuLCBhcmdzKTtcbiAgfSxcbiAgcmVkdWNlUmlnaHQoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIFwicmVkdWNlUmlnaHRcIiwgZm4sIGFyZ3MpO1xuICB9LFxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInNoaWZ0XCIpO1xuICB9LFxuICAvLyBzbGljZSBjb3VsZCB1c2UgQVJSQVlfSVRFUkFURSBidXQgYWxzbyBzZWVtcyB0byBiZWcgZm9yIHJhbmdlIHRyYWNraW5nXG4gIHNvbWUoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJzb21lXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIHNwbGljZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJzcGxpY2VcIiwgYXJncyk7XG4gIH0sXG4gIHRvUmV2ZXJzZWQoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvUmV2ZXJzZWQoKTtcbiAgfSxcbiAgdG9Tb3J0ZWQoY29tcGFyZXIpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9Tb3J0ZWQoY29tcGFyZXIpO1xuICB9LFxuICB0b1NwbGljZWQoLi4uYXJncykge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1NwbGljZWQoLi4uYXJncyk7XG4gIH0sXG4gIHVuc2hpZnQoLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwidW5zaGlmdFwiLCBhcmdzKTtcbiAgfSxcbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcInZhbHVlc1wiLCB0b1JlYWN0aXZlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGl0ZXJhdG9yKHNlbGYsIG1ldGhvZCwgd3JhcFZhbHVlKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGNvbnN0IGl0ZXIgPSBhcnJbbWV0aG9kXSgpO1xuICBpZiAoYXJyICE9PSBzZWxmICYmICFpc1NoYWxsb3coc2VsZikpIHtcbiAgICBpdGVyLl9uZXh0ID0gaXRlci5uZXh0O1xuICAgIGl0ZXIubmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXIuX25leHQoKTtcbiAgICAgIGlmIChyZXN1bHQudmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gd3JhcFZhbHVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGl0ZXI7XG59XG5jb25zdCBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuZnVuY3Rpb24gYXBwbHkoc2VsZiwgbWV0aG9kLCBmbiwgdGhpc0FyZywgd3JhcHBlZFJldEZuLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGNvbnN0IG5lZWRzV3JhcCA9IGFyciAhPT0gc2VsZiAmJiAhaXNTaGFsbG93KHNlbGYpO1xuICBjb25zdCBtZXRob2RGbiA9IGFyclttZXRob2RdO1xuICBpZiAobWV0aG9kRm4gIT09IGFycmF5UHJvdG9bbWV0aG9kXSkge1xuICAgIGNvbnN0IHJlc3VsdDIgPSBtZXRob2RGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICByZXR1cm4gbmVlZHNXcmFwID8gdG9SZWFjdGl2ZShyZXN1bHQyKSA6IHJlc3VsdDI7XG4gIH1cbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKG5lZWRzV3JhcCkge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZuLmxlbmd0aCA+IDIpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG1ldGhvZEZuLmNhbGwoYXJyLCB3cmFwcGVkRm4sIHRoaXNBcmcpO1xuICByZXR1cm4gbmVlZHNXcmFwICYmIHdyYXBwZWRSZXRGbiA/IHdyYXBwZWRSZXRGbihyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVkdWNlKHNlbGYsIG1ldGhvZCwgZm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKCFpc1NoYWxsb3coc2VsZikpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYWNjLCB0b1JlYWN0aXZlKGl0ZW0pLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm4ubGVuZ3RoID4gMykge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJbbWV0aG9kXSh3cmFwcGVkRm4sIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc2VhcmNoUHJveHkoc2VsZiwgbWV0aG9kLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHRvUmF3KHNlbGYpO1xuICB0cmFjayhhcnIsIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIGNvbnN0IHJlcyA9IGFyclttZXRob2RdKC4uLmFyZ3MpO1xuICBpZiAoKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkgJiYgaXNQcm94eShhcmdzWzBdKSkge1xuICAgIGFyZ3NbMF0gPSB0b1JhdyhhcmdzWzBdKTtcbiAgICByZXR1cm4gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5vVHJhY2tpbmcoc2VsZiwgbWV0aG9kLCBhcmdzID0gW10pIHtcbiAgcGF1c2VUcmFja2luZygpO1xuICBzdGFydEJhdGNoKCk7XG4gIGNvbnN0IHJlcyA9IHRvUmF3KHNlbGYpW21ldGhvZF0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVuZEJhdGNoKCk7XG4gIHJlc2V0VHJhY2tpbmcoKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcImFyZ3VtZW50c1wiICYmIGtleSAhPT0gXCJjYWxsZXJcIikubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpXG4pO1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gIGlmICghaXNTeW1ib2woa2V5KSkga2V5ID0gU3RyaW5nKGtleSk7XG4gIGNvbnN0IG9iaiA9IHRvUmF3KHRoaXMpO1xuICB0cmFjayhvYmosIFwiaGFzXCIsIGtleSk7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn1cbmNsYXNzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihfaXNSZWFkb25seSA9IGZhbHNlLCBfaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9pc1JlYWRvbmx5ID0gX2lzUmVhZG9ubHk7XG4gICAgdGhpcy5faXNTaGFsbG93ID0gX2lzU2hhbGxvdztcbiAgfVxuICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiKSByZXR1cm4gdGFyZ2V0W1wiX192X3NraXBcIl07XG4gICAgY29uc3QgaXNSZWFkb25seTIgPSB0aGlzLl9pc1JlYWRvbmx5LCBpc1NoYWxsb3cyID0gdGhpcy5faXNTaGFsbG93O1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiKSB7XG4gICAgICByZXR1cm4gaXNTaGFsbG93MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIpIHtcbiAgICAgIGlmIChyZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkyID8gaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFkb25seU1hcCA6IHJlYWRvbmx5TWFwIDogaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFjdGl2ZU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSB8fCAvLyByZWNlaXZlciBpcyBub3QgdGhlIHJlYWN0aXZlIHByb3h5LCBidXQgaGFzIHRoZSBzYW1lIHByb3RvdHlwZVxuICAgICAgLy8gdGhpcyBtZWFucyB0aGUgcmVjZWl2ZXIgaXMgYSB1c2VyIHByb3h5IG9mIHRoZSByZWFjdGl2ZSBwcm94eVxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihyZWNlaXZlcikpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICBsZXQgZm47XG4gICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiAoZm4gPSBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgcHJveHkgd3JhcHBpbmcgYSByZWYsIHJldHVybiBtZXRob2RzIHVzaW5nIHRoZSByYXcgcmVmXG4gICAgICAvLyBhcyByZWNlaXZlciBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2FsbCBgdG9SYXdgIG9uIHRoZSByZWYgaW4gYWxsXG4gICAgICAvLyBpdHMgY2xhc3MgbWV0aG9kc1xuICAgICAgaXNSZWYodGFyZ2V0KSA/IHRhcmdldCA6IHJlY2VpdmVyXG4gICAgKTtcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICB9XG4gICAgaWYgKGlzU2hhbGxvdzIpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5jbGFzcyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKGZhbHNlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmICghdGhpcy5faXNTaGFsbG93KSB7XG4gICAgICBjb25zdCBpc09sZFZhbHVlUmVhZG9ubHkgPSBpc1JlYWRvbmx5KG9sZFZhbHVlKTtcbiAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzT2xkVmFsdWVSZWFkb25seSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGlzUmVmKHRhcmdldCkgPyB0YXJnZXQgOiByZWNlaXZlclxuICAgICk7XG4gICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG93bktleXModGFyZ2V0KSB7XG4gICAgdHJhY2soXG4gICAgICB0YXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9XG59XG5jbGFzcyBSZWFkb25seVJlYWN0aXZlSGFuZGxlciBleHRlbmRzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihpc1NoYWxsb3cyID0gZmFsc2UpIHtcbiAgICBzdXBlcih0cnVlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCByZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcigpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5MiwgaXNTaGFsbG93Mikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xuICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gXCJlbnRyaWVzXCIgfHwgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSBcImtleXNcIiAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdzIgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5MiA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhcbiAgICAgIHJhd1RhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgdmFsdWUsIGRvbmUgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdG9SYXcodGhpcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0eXBlID09PSBcImNsZWFyXCIgPyB2b2lkIDAgOiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucyhyZWFkb25seSwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgICBpZiAoIXJlYWRvbmx5KSB7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xuICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgICAgIGNvbnN0IHdyYXAgPSBzaGFsbG93ID8gdG9TaGFsbG93IDogcmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgIGlmICghcmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwgcmF3S2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG4gICAgfSxcbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3Qgd3JhcCA9IHNoYWxsb3cgPyB0b1NoYWxsb3cgOiByZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgIXJlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGV4dGVuZChcbiAgICBpbnN0cnVtZW50YXRpb25zLFxuICAgIHJlYWRvbmx5ID8ge1xuICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiksXG4gICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIilcbiAgICB9IDoge1xuICAgICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgICAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgICAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmIChoYWRLZXkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgICAgICAgY29uc3Qgb2xkVGFyZ2V0ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGlzTWFwKHRhcmdldCkgPyBuZXcgTWFwKHRhcmdldCkgOiBuZXcgU2V0KHRhcmdldCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xuICAgICAgICBpZiAoaGFkSXRlbXMpIHtcbiAgICAgICAgICB0cmlnZ2VyKFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgXCJjbGVhclwiLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gW1xuICAgIFwia2V5c1wiLFxuICAgIFwidmFsdWVzXCIsXG4gICAgXCJlbnRyaWVzXCIsXG4gICAgU3ltYm9sLml0ZXJhdG9yXG4gIF07XG4gIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBpbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHJlYWRvbmx5LCBzaGFsbG93KTtcbiAgfSk7XG4gIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHkyLCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBjcmVhdGVJbnN0cnVtZW50YXRpb25zKGlzUmVhZG9ubHkyLCBzaGFsbG93KTtcbiAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KFxuICAgICAgaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldCA/IGluc3RydW1lbnRhdGlvbnMgOiB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICByZWNlaXZlclxuICAgICk7XG4gIH07XG59XG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xuICAgIHdhcm4oXG4gICAgICBgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gIHN3aXRjaCAocmF3VHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIl0gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpID8gMCAvKiBJTlZBTElEICovIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIG11dGFibGVIYW5kbGVycyxcbiAgICBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsXG4gICAgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgcmVhZG9ubHlIYW5kbGVycyxcbiAgICByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5MiwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgdmFsdWUgY2Fubm90IGJlIG1hZGUgJHtpc1JlYWRvbmx5MiA/IFwicmVhZG9ubHlcIiA6IFwicmVhY3RpdmVcIn06ICR7U3RyaW5nKFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIl0gJiYgIShpc1JlYWRvbmx5MiAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiXSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgfVxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShcbiAgICB0YXJnZXQsXG4gICAgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzXG4gICk7XG4gIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIl0pO1xuICB9XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCJdKTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIl0pO1xufVxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIl0pO1xufVxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyAhIXZhbHVlW1wiX192X3Jhd1wiXSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICBpZiAoIWhhc093bih2YWx1ZSwgXCJfX3Zfc2tpcFwiKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuXG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gIHJldHVybiByID8gcltcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xufVxuY2xhc3MgUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBpc1NoYWxsb3cyKSB7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBmYWxzZTtcbiAgICB0aGlzLl9yYXdWYWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICAgIHRoaXNbXCJfX3ZfaXNTaGFsbG93XCJdID0gaXNTaGFsbG93MjtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICB0eXBlOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3Jhd1ZhbHVlO1xuICAgIGNvbnN0IHVzZURpcmVjdFZhbHVlID0gdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gfHwgaXNTaGFsbG93KG5ld1ZhbHVlKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbHVlKTtcbiAgICBuZXdWYWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsdWUgOiB0b1JhdyhuZXdWYWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmVhY3RpdmUobmV3VmFsdWUpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdGhpcy5kZXAudHJpZ2dlcih7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZjIpIHtcbiAgaWYgKHJlZjIuZGVwKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoe1xuICAgICAgICB0YXJnZXQ6IHJlZjIsXG4gICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgICAgICBuZXdWYWx1ZTogcmVmMi5fdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYyLmRlcC50cmlnZ2VyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1bnJlZihyZWYyKSB7XG4gIHJldHVybiBpc1JlZihyZWYyKSA/IHJlZjIudmFsdWUgOiByZWYyO1xufVxuZnVuY3Rpb24gdG9WYWx1ZShzb3VyY2UpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlKSA/IHNvdXJjZSgpIDogdW5yZWYoc291cmNlKTtcbn1cbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcbiAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiBrZXkgPT09IFwiX192X3Jhd1wiID8gdGFyZ2V0IDogdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICBjb25zdCBkZXAgPSB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KGRlcC50cmFjay5iaW5kKGRlcCksIGRlcC50cmlnZ2VyLmJpbmQoZGVwKSk7XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICAgIHRoaXMuX3NldCA9IHNldDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0KCk7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICB9XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICB3YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgfVxuICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmV0W2tleV0gPSBwcm9wZXJ0eVRvUmVmKG9iamVjdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXksIF9kZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gX2RlZmF1bHRWYWx1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdmFsID09PSB2b2lkIDAgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICB9XG4gIGdldCBkZXAoKSB7XG4gICAgcmV0dXJuIGdldERlcEZyb21SZWFjdGl2ZSh0b1Jhdyh0aGlzLl9vYmplY3QpLCB0aGlzLl9rZXkpO1xuICB9XG59XG5jbGFzcyBHZXR0ZXJSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xuICAgIHRoaXMuX2dldHRlciA9IF9nZXR0ZXI7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgR2V0dGVyUmVmSW1wbChzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgcmV0dXJuIGlzUmVmKHZhbCkgPyB2YWwgOiBuZXcgT2JqZWN0UmVmSW1wbChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZm4sIHNldHRlciwgaXNTU1IpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAvLyBUT0RPIGlzb2xhdGVkRGVjbGFyYXRpb25zIFwiX192X2lzUmVhZG9ubHlcIlxuICAgIC8vIEEgY29tcHV0ZWQgaXMgYWxzbyBhIHN1YnNjcmliZXIgdGhhdCB0cmFja3Mgb3RoZXIgZGVwc1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxNjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uIC0gMTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICB0aGlzLmVmZmVjdCA9IHRoaXM7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gIXNldHRlcjtcbiAgICB0aGlzLmlzU1NSID0gaXNTU1I7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5KCkge1xuICAgIHRoaXMuZmxhZ3MgfD0gMTY7XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpICYmIC8vIGF2b2lkIGluZmluaXRlIHNlbGYgcmVjdXJzaW9uXG4gICAgYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICBiYXRjaCh0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBsaW5rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwidmFsdWVcIlxuICAgIH0pIDogdGhpcy5kZXAudHJhY2soKTtcbiAgICByZWZyZXNoQ29tcHV0ZWQodGhpcyk7XG4gICAgaWYgKGxpbmspIHtcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMuZGVwLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBpZiAodGhpcy5zZXR0ZXIpIHtcbiAgICAgIHRoaXMuc2V0dGVyKG5ld1ZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXCJXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBzZXR0ZXI7XG4gIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICB9XG4gIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc1NTUik7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICBjUmVmLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICBjUmVmLm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgcmV0dXJuIGNSZWY7XG59XG5cbmNvbnN0IFRyYWNrT3BUeXBlcyA9IHtcbiAgXCJHRVRcIjogXCJnZXRcIixcbiAgXCJIQVNcIjogXCJoYXNcIixcbiAgXCJJVEVSQVRFXCI6IFwiaXRlcmF0ZVwiXG59O1xuY29uc3QgVHJpZ2dlck9wVHlwZXMgPSB7XG4gIFwiU0VUXCI6IFwic2V0XCIsXG4gIFwiQUREXCI6IFwiYWRkXCIsXG4gIFwiREVMRVRFXCI6IFwiZGVsZXRlXCIsXG4gIFwiQ0xFQVJcIjogXCJjbGVhclwiXG59O1xuY29uc3QgUmVhY3RpdmVGbGFncyA9IHtcbiAgXCJTS0lQXCI6IFwiX192X3NraXBcIixcbiAgXCJJU19SRUFDVElWRVwiOiBcIl9fdl9pc1JlYWN0aXZlXCIsXG4gIFwiSVNfUkVBRE9OTFlcIjogXCJfX3ZfaXNSZWFkb25seVwiLFxuICBcIklTX1NIQUxMT1dcIjogXCJfX3ZfaXNTaGFsbG93XCIsXG4gIFwiUkFXXCI6IFwiX192X3Jhd1wiLFxuICBcIklTX1JFRlwiOiBcIl9fdl9pc1JlZlwiXG59O1xuXG5jb25zdCBXYXRjaEVycm9yQ29kZXMgPSB7XG4gIFwiV0FUQ0hfR0VUVEVSXCI6IDIsXG4gIFwiMlwiOiBcIldBVENIX0dFVFRFUlwiLFxuICBcIldBVENIX0NBTExCQUNLXCI6IDMsXG4gIFwiM1wiOiBcIldBVENIX0NBTExCQUNLXCIsXG4gIFwiV0FUQ0hfQ0xFQU5VUFwiOiA0LFxuICBcIjRcIjogXCJXQVRDSF9DTEVBTlVQXCJcbn07XG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbmNvbnN0IGNsZWFudXBNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmxldCBhY3RpdmVXYXRjaGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFdhdGNoZXIoKSB7XG4gIHJldHVybiBhY3RpdmVXYXRjaGVyO1xufVxuZnVuY3Rpb24gb25XYXRjaGVyQ2xlYW51cChjbGVhbnVwRm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlLCBvd25lciA9IGFjdGl2ZVdhdGNoZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgbGV0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQob3duZXIpO1xuICAgIGlmICghY2xlYW51cHMpIGNsZWFudXBNYXAuc2V0KG93bmVyLCBjbGVhbnVwcyA9IFtdKTtcbiAgICBjbGVhbnVwcy5wdXNoKGNsZWFudXBGbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbldhdGNoZXJDbGVhbnVwKCkgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBhY3RpdmUgd2F0Y2hlciB0byBhc3NvY2lhdGUgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCB7IGltbWVkaWF0ZSwgZGVlcCwgb25jZSwgc2NoZWR1bGVyLCBhdWdtZW50Sm9iLCBjYWxsIH0gPSBvcHRpb25zO1xuICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgKG9wdGlvbnMub25XYXJuIHx8IHdhcm4pKFxuICAgICAgYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLFxuICAgICAgcyxcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHJlYWN0aXZlR2V0dGVyID0gKHNvdXJjZTIpID0+IHtcbiAgICBpZiAoZGVlcCkgcmV0dXJuIHNvdXJjZTI7XG4gICAgaWYgKGlzU2hhbGxvdyhzb3VyY2UyKSB8fCBkZWVwID09PSBmYWxzZSB8fCBkZWVwID09PSAwKVxuICAgICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIsIDEpO1xuICAgIHJldHVybiB0cmF2ZXJzZShzb3VyY2UyKTtcbiAgfTtcbiAgbGV0IGVmZmVjdDtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IGNsZWFudXA7XG4gIGxldCBib3VuZENsZWFudXA7XG4gIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gcmVhY3RpdmVHZXR0ZXIoc291cmNlKTtcbiAgICBmb3JjZVRyaWdnZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKChzKSA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyhzKSk7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcCgocykgPT4ge1xuICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgIHJldHVybiByZWFjdGl2ZUdldHRlcihzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgICAgICByZXR1cm4gY2FsbCA/IGNhbGwocywgMikgOiBzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIGlmIChjYikge1xuICAgICAgZ2V0dGVyID0gY2FsbCA/ICgpID0+IGNhbGwoc291cmNlLCAyKSA6IHNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3QgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzb3VyY2UsIDMsIFtib3VuZENsZWFudXBdKSA6IHNvdXJjZShib3VuZENsZWFudXApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBjdXJyZW50RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBOT09QO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICBpZiAoY2IgJiYgZGVlcCkge1xuICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgY29uc3QgZGVwdGggPSBkZWVwID09PSB0cnVlID8gSW5maW5pdHkgOiBkZWVwO1xuICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSwgZGVwdGgpO1xuICB9XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IHdhdGNoSGFuZGxlID0gKCkgPT4ge1xuICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgICAgcmVtb3ZlKHNjb3BlLmVmZmVjdHMsIGVmZmVjdCk7XG4gICAgfVxuICB9O1xuICBpZiAob25jZSAmJiBjYikge1xuICAgIGNvbnN0IF9jYiA9IGNiO1xuICAgIGNiID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIF9jYiguLi5hcmdzKTtcbiAgICAgIHdhdGNoSGFuZGxlKCk7XG4gICAgfTtcbiAgfVxuICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpLmZpbGwoSU5JVElBTF9XQVRDSEVSX1ZBTFVFKSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcbiAgY29uc3Qgam9iID0gKGltbWVkaWF0ZUZpcnN0UnVuKSA9PiB7XG4gICAgaWYgKCEoZWZmZWN0LmZsYWdzICYgMSkgfHwgIWVmZmVjdC5kaXJ0eSAmJiAhaW1tZWRpYXRlRmlyc3RSdW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNiKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCAoaXNNdWx0aVNvdXJjZSA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKSA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFdhdGNoZXIgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdm9pZCAwIDogaXNNdWx0aVNvdXJjZSAmJiBvbGRWYWx1ZVswXSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gW10gOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIGJvdW5kQ2xlYW51cFxuICAgICAgICAgIF07XG4gICAgICAgICAgY2FsbCA/IGNhbGwoY2IsIDMsIGFyZ3MpIDogKFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY2IoLi4uYXJncylcbiAgICAgICAgICApO1xuICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRXYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH07XG4gIGlmIChhdWdtZW50Sm9iKSB7XG4gICAgYXVnbWVudEpvYihqb2IpO1xuICB9XG4gIGVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIpO1xuICBlZmZlY3Quc2NoZWR1bGVyID0gc2NoZWR1bGVyID8gKCkgPT4gc2NoZWR1bGVyKGpvYiwgZmFsc2UpIDogam9iO1xuICBib3VuZENsZWFudXAgPSAoZm4pID0+IG9uV2F0Y2hlckNsZWFudXAoZm4sIGZhbHNlLCBlZmZlY3QpO1xuICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwcyA9IGNsZWFudXBNYXAuZ2V0KGVmZmVjdCk7XG4gICAgaWYgKGNsZWFudXBzKSB7XG4gICAgICBpZiAoY2FsbCkge1xuICAgICAgICBjYWxsKGNsZWFudXBzLCA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgY2xlYW51cDIgb2YgY2xlYW51cHMpIGNsZWFudXAyKCk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwTWFwLmRlbGV0ZShlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBlZmZlY3Qub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcbiAgICBlZmZlY3Qub25UcmlnZ2VyID0gb3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgam9iKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2NoZWR1bGVyKSB7XG4gICAgc2NoZWR1bGVyKGpvYi5iaW5kKG51bGwsIHRydWUpLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QucnVuKCk7XG4gIH1cbiAgd2F0Y2hIYW5kbGUucGF1c2UgPSBlZmZlY3QucGF1c2UuYmluZChlZmZlY3QpO1xuICB3YXRjaEhhbmRsZS5yZXN1bWUgPSBlZmZlY3QucmVzdW1lLmJpbmQoZWZmZWN0KTtcbiAgd2F0Y2hIYW5kbGUuc3RvcCA9IHdhdGNoSGFuZGxlO1xuICByZXR1cm4gd2F0Y2hIYW5kbGU7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgZGVwdGggPSBJbmZpbml0eSwgc2Vlbikge1xuICBpZiAoZGVwdGggPD0gMCB8fCAhaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIl0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuLmFkZCh2YWx1ZSk7XG4gIGRlcHRoLS07XG4gIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgZGVwdGgsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgIHRyYXZlcnNlKHYsIGRlcHRoLCBzZWVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyBBUlJBWV9JVEVSQVRFX0tFWSwgRWZmZWN0RmxhZ3MsIEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgTUFQX0tFWV9JVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIFJlYWN0aXZlRmxhZ3MsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIFdhdGNoRXJyb3JDb2RlcywgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uRWZmZWN0Q2xlYW51cCwgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWN0aXZlUmVhZEFycmF5LCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkQXJyYXksIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVhY3RpdmUsIHRvUmVhZG9ubHksIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmF2ZXJzZSwgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYsIHdhdGNoIH07XG4iLCIvKipcbiogQHZ1ZS9ydW50aW1lLWNvcmUgdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCB0cmF2ZXJzZSwgc2hhbGxvd1JlZiwgcmVhZG9ubHksIGlzUmVhY3RpdmUsIHJlZiwgaXNTaGFsbG93LCBzaGFsbG93UmVhZEFycmF5LCB0b1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBSZWFjdGl2ZUVmZmVjdCwgd2F0Y2ggYXMgd2F0Y2gkMSwgY3VzdG9tUmVmLCBpc1Byb3h5LCBwcm94eVJlZnMsIG1hcmtSYXcsIEVmZmVjdFNjb3BlLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgVHJhY2tPcFR5cGVzLCBUcmlnZ2VyT3BUeXBlcywgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGdldEN1cnJlbnRXYXRjaGVyLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgb25XYXRjaGVyQ2xlYW51cCwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBFTVBUWV9PQkosIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgaXNCdWlsdEluRGlyZWN0aXZlLCBoYXNPd24sIHJlbW92ZSwgZGVmLCBpc09uLCBpc1Jlc2VydmVkUHJvcCwgbm9ybWFsaXplQ2xhc3MsIHN0cmluZ2lmeVN0eWxlLCBub3JtYWxpemVTdHlsZSwgaXNLbm93blN2Z0F0dHIsIGlzQm9vbGVhbkF0dHIsIGlzS25vd25IdG1sQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc1JlbmRlcmFibGVBdHRyVmFsdWUsIGdldEVzY2FwZWRDc3NWYXJOYW1lLCBpc09iamVjdCwgaXNSZWdFeHAsIGludm9rZUFycmF5Rm5zLCB0b0hhbmRsZXJLZXksIGNhcGl0YWxpemUsIGNhbWVsaXplLCBpc1N5bWJvbCwgaXNHbG9iYWxseUFsbG93ZWQsIE5PLCBoeXBoZW5hdGUsIEVNUFRZX0FSUiwgdG9SYXdUeXBlLCBtYWtlTWFwLCBoYXNDaGFuZ2VkLCBsb29zZVRvTnVtYmVyLCBpc01vZGVsTGlzdGVuZXIsIHRvTnVtYmVyIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gIHN0YWNrLnB1c2godm5vZGUpO1xufVxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XG4gIHN0YWNrLnBvcCgpO1xufVxubGV0IGlzV2FybmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybiQxKG1zZywgLi4uYXJncykge1xuICBpZiAoaXNXYXJuaW5nKSByZXR1cm47XG4gIGlzV2FybmluZyA9IHRydWU7XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xuICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XG4gIGlmIChhcHBXYXJuSGFuZGxlcikge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIGFwcFdhcm5IYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAxMSxcbiAgICAgIFtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIG1zZyArIGFyZ3MubWFwKChhKSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gYS50b1N0cmluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoYSkpICE9IG51bGwgPyBfYiA6IEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcbiAgICAgICAgdHJhY2UubWFwKFxuICAgICAgICAgICh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YFxuICAgICAgICApLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHRyYWNlXG4gICAgICBdXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XG4gICAgaWYgKHRyYWNlLmxlbmd0aCAmJiAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xuICAgIHRydWUpIHtcbiAgICAgIHdhcm5BcmdzLnB1c2goYFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcbiAgfVxuICByZXNldFRyYWNraW5nKCk7XG4gIGlzV2FybmluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XG4gIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XG4gIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcbiAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xuICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xuICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xuICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxuICAgICAgICByZWN1cnNlQ291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XG4gICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XG4gIGNvbnN0IGxvZ3MgPSBbXTtcbiAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICBsb2dzLnB1c2goLi4uaSA9PT0gMCA/IFtdIDogW2BcbmBdLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XG4gIH0pO1xuICByZXR1cm4gbG9ncztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcbiAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcbiAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XG4gIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgdm5vZGUuY29tcG9uZW50LFxuICAgIHZub2RlLnR5cGUsXG4gICAgaXNSb290XG4gICl9YDtcbiAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xuICByZXR1cm4gdm5vZGUucHJvcHMgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV0gOiBbb3BlbiArIGNsb3NlXTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XG4gIH0pO1xuICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XG4gICAgcmVzLnB1c2goYCAuLi5gKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHZhbCwgdHlwZSkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHJldHVybjtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICB3YXJuJDEoYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4kMShgJHt0eXBlfSBpcyBOYU4gLSB0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuYCk7XG4gIH1cbn1cblxuY29uc3QgRXJyb3JDb2RlcyA9IHtcbiAgXCJTRVRVUF9GVU5DVElPTlwiOiAwLFxuICBcIjBcIjogXCJTRVRVUF9GVU5DVElPTlwiLFxuICBcIlJFTkRFUl9GVU5DVElPTlwiOiAxLFxuICBcIjFcIjogXCJSRU5ERVJfRlVOQ1RJT05cIixcbiAgXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiOiA1LFxuICBcIjVcIjogXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiLFxuICBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCIsXG4gIFwiVk5PREVfSE9PS1wiOiA3LFxuICBcIjdcIjogXCJWTk9ERV9IT09LXCIsXG4gIFwiRElSRUNUSVZFX0hPT0tcIjogOCxcbiAgXCI4XCI6IFwiRElSRUNUSVZFX0hPT0tcIixcbiAgXCJUUkFOU0lUSU9OX0hPT0tcIjogOSxcbiAgXCI5XCI6IFwiVFJBTlNJVElPTl9IT09LXCIsXG4gIFwiQVBQX0VSUk9SX0hBTkRMRVJcIjogMTAsXG4gIFwiMTBcIjogXCJBUFBfRVJST1JfSEFORExFUlwiLFxuICBcIkFQUF9XQVJOX0hBTkRMRVJcIjogMTEsXG4gIFwiMTFcIjogXCJBUFBfV0FSTl9IQU5ETEVSXCIsXG4gIFwiRlVOQ1RJT05fUkVGXCI6IDEyLFxuICBcIjEyXCI6IFwiRlVOQ1RJT05fUkVGXCIsXG4gIFwiQVNZTkNfQ09NUE9ORU5UX0xPQURFUlwiOiAxMyxcbiAgXCIxM1wiOiBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIixcbiAgXCJTQ0hFRFVMRVJcIjogMTQsXG4gIFwiMTRcIjogXCJTQ0hFRFVMRVJcIixcbiAgXCJDT01QT05FTlRfVVBEQVRFXCI6IDE1LFxuICBcIjE1XCI6IFwiQ09NUE9ORU5UX1VQREFURVwiLFxuICBcIkFQUF9VTk1PVU5UX0NMRUFOVVBcIjogMTYsXG4gIFwiMTZcIjogXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCJcbn07XG5jb25zdCBFcnJvclR5cGVTdHJpbmdzJDEgPSB7XG4gIFtcInNwXCJdOiBcInNlcnZlclByZWZldGNoIGhvb2tcIixcbiAgW1wiYmNcIl06IFwiYmVmb3JlQ3JlYXRlIGhvb2tcIixcbiAgW1wiY1wiXTogXCJjcmVhdGVkIGhvb2tcIixcbiAgW1wiYm1cIl06IFwiYmVmb3JlTW91bnQgaG9va1wiLFxuICBbXCJtXCJdOiBcIm1vdW50ZWQgaG9va1wiLFxuICBbXCJidVwiXTogXCJiZWZvcmVVcGRhdGUgaG9va1wiLFxuICBbXCJ1XCJdOiBcInVwZGF0ZWRcIixcbiAgW1wiYnVtXCJdOiBcImJlZm9yZVVubW91bnQgaG9va1wiLFxuICBbXCJ1bVwiXTogXCJ1bm1vdW50ZWQgaG9va1wiLFxuICBbXCJhXCJdOiBcImFjdGl2YXRlZCBob29rXCIsXG4gIFtcImRhXCJdOiBcImRlYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZWNcIl06IFwiZXJyb3JDYXB0dXJlZCBob29rXCIsXG4gIFtcInJ0Y1wiXTogXCJyZW5kZXJUcmFja2VkIGhvb2tcIixcbiAgW1wicnRnXCJdOiBcInJlbmRlclRyaWdnZXJlZCBob29rXCIsXG4gIFswXTogXCJzZXR1cCBmdW5jdGlvblwiLFxuICBbMV06IFwicmVuZGVyIGZ1bmN0aW9uXCIsXG4gIFsyXTogXCJ3YXRjaGVyIGdldHRlclwiLFxuICBbM106IFwid2F0Y2hlciBjYWxsYmFja1wiLFxuICBbNF06IFwid2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uXCIsXG4gIFs1XTogXCJuYXRpdmUgZXZlbnQgaGFuZGxlclwiLFxuICBbNl06IFwiY29tcG9uZW50IGV2ZW50IGhhbmRsZXJcIixcbiAgWzddOiBcInZub2RlIGhvb2tcIixcbiAgWzhdOiBcImRpcmVjdGl2ZSBob29rXCIsXG4gIFs5XTogXCJ0cmFuc2l0aW9uIGhvb2tcIixcbiAgWzEwXTogXCJhcHAgZXJyb3JIYW5kbGVyXCIsXG4gIFsxMV06IFwiYXBwIHdhcm5IYW5kbGVyXCIsXG4gIFsxMl06IFwicmVmIGZ1bmN0aW9uXCIsXG4gIFsxM106IFwiYXN5bmMgY29tcG9uZW50IGxvYWRlclwiLFxuICBbMTRdOiBcInNjaGVkdWxlciBmbHVzaFwiLFxuICBbMTVdOiBcImNvbXBvbmVudCB1cGRhdGVcIixcbiAgWzE2XTogXCJhcHAgdW5tb3VudCBjbGVhbnVwIGZ1bmN0aW9uXCJcbn07XG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoaXNBcnJheShmbikpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYEludmFsaWQgdmFsdWUgdHlwZSBwYXNzZWQgdG8gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoKTogJHt0eXBlb2YgZm59YFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xuICBjb25zdCB7IGVycm9ySGFuZGxlciwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbiB9ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcgfHwgRU1QVFlfT0JKO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGVycm9ySW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0gOiBgaHR0cHM6Ly92dWVqcy5vcmcvZXJyb3ItcmVmZXJlbmNlLyNydW50aW1lLSR7dHlwZX1gO1xuICAgIHdoaWxlIChjdXIpIHtcbiAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcbiAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKGVycm9ySGFuZGxlcikge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGVycm9ySGFuZGxlciwgbnVsbCwgMTAsIFtcbiAgICAgICAgZXJyLFxuICAgICAgICBleHBvc2VkSW5zdGFuY2UsXG4gICAgICAgIGVycm9ySW5mb1xuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2LCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSwgdGhyb3dJblByb2QgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV07XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XG4gICAgfVxuICAgIHdhcm4kMShgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKHRocm93SW5EZXYpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aHJvd0luUHJvZCkge1xuICAgIHRocm93IGVycjtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuY29uc3QgcXVldWUgPSBbXTtcbmxldCBmbHVzaEluZGV4ID0gLTE7XG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XG4gIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XG59XG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcbiAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XG4gIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+PiAxO1xuICAgIGNvbnN0IG1pZGRsZUpvYiA9IHF1ZXVlW21pZGRsZV07XG4gICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChtaWRkbGVKb2IpO1xuICAgIGlmIChtaWRkbGVKb2JJZCA8IGlkIHx8IG1pZGRsZUpvYklkID09PSBpZCAmJiBtaWRkbGVKb2IuZmxhZ3MgJiAyKSB7XG4gICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IG1pZGRsZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gIGlmICghKGpvYi5mbGFncyAmIDEpKSB7XG4gICAgY29uc3Qgam9iSWQgPSBnZXRJZChqb2IpO1xuICAgIGNvbnN0IGxhc3RKb2IgPSBxdWV1ZVtxdWV1ZS5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWxhc3RKb2IgfHwgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIGpvYiBpZCBpcyBsYXJnZXIgdGhhbiB0aGUgdGFpbFxuICAgICEoam9iLmZsYWdzICYgMikgJiYgam9iSWQgPj0gZ2V0SWQobGFzdEpvYikpIHtcbiAgICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2JJZCksIDAsIGpvYik7XG4gICAgfVxuICAgIGpvYi5mbGFncyB8PSAxO1xuICAgIHF1ZXVlRmx1c2goKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFjdXJyZW50Rmx1c2hQcm9taXNlKSB7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcbiAgaWYgKCFpc0FycmF5KGNiKSkge1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMgJiYgY2IuaWQgPT09IC0xKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc3BsaWNlKHBvc3RGbHVzaEluZGV4ICsgMSwgMCwgY2IpO1xuICAgIH0gZWxzZSBpZiAoIShjYi5mbGFncyAmIDEpKSB7XG4gICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goY2IpO1xuICAgICAgY2IuZmxhZ3MgfD0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgfVxuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKGluc3RhbmNlLCBzZWVuLCBpID0gZmx1c2hJbmRleCArIDEpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjYiA9IHF1ZXVlW2ldO1xuICAgIGlmIChjYiAmJiBjYi5mbGFncyAmIDIpIHtcbiAgICAgIGlmIChpbnN0YW5jZSAmJiBjYi5pZCAhPT0gaW5zdGFuY2UudWlkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICAgIGlmIChjYi5mbGFncyAmIDQpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgICBjYigpO1xuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA0KSkge1xuICAgICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcbiAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYilcbiAgICApO1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3QgY2IgPSBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5mbGFncyAmIDQpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgICBpZiAoIShjYi5mbGFncyAmIDgpKSBjYigpO1xuICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG4gICAgcG9zdEZsdXNoSW5kZXggPSAwO1xuICB9XG59XG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gam9iLmZsYWdzICYgMiA/IC0xIDogSW5maW5pdHkgOiBqb2IuaWQ7XG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY29uc3QgY2hlY2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYikgOiBOT09QO1xuICB0cnkge1xuICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iICYmICEoam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2soam9iKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICBqb2IsXG4gICAgICAgICAgam9iLmksXG4gICAgICAgICAgam9iLmkgPyAxNSA6IDE0XG4gICAgICAgICk7XG4gICAgICAgIGlmICghKGpvYi5mbGFncyAmIDQpKSB7XG4gICAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGZvciAoOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgaWYgKGpvYikge1xuICAgICAgICBqb2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoSW5kZXggPSAtMTtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggfHwgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICAgIGZsdXNoSm9icyhzZWVuKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xuICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKSB8fCAwO1xuICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZuLmk7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XG4gICAgaGFuZGxlRXJyb3IoXG4gICAgICBgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3Igd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCxcbiAgICAgIG51bGwsXG4gICAgICAxMFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcbiAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcbiAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXG4gICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcbiAgfTtcbn1cbmNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcbiAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XG4gICAgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIH1cbiAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGluaXRpYWxEZWYpIHtcbiAgaWYgKG1hcC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1hcC5zZXQoaWQsIHtcbiAgICBpbml0aWFsRGVmOiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbml0aWFsRGVmKSxcbiAgICBpbnN0YW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50O1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xuICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAobmV3UmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XG4gICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHJldHVybjtcbiAgbmV3Q29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KG5ld0NvbXApO1xuICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xuICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xuICAgIGxldCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQob2xkQ29tcCk7XG4gICAgaWYgKCFkaXJ0eUluc3RhbmNlcykge1xuICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcbiAgICAgIH1cbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5zZXQob2xkQ29tcCwgZGlydHlJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnByb3BzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQuZW1pdHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xuICAgICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIHF1ZXVlSm9iKCgpID0+IHtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICBkaXJ0eUluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xuICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5yb290LmNlICYmIGluc3RhbmNlICE9PSBpbnN0YW5jZS5yb290KSB7XG4gICAgICBpbnN0YW5jZS5yb290LmNlLl9yZW1vdmVDaGlsZFN0eWxlKG9sZENvbXApO1xuICAgIH1cbiAgfVxuICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcbiAgICBobXJEaXJ0eUNvbXBvbmVudHMuY2xlYXIoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xuICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9sZENvbXApIHtcbiAgICBpZiAoa2V5ICE9PSBcIl9fZmlsZVwiICYmICEoa2V5IGluIG5ld0NvbXApKSB7XG4gICAgICBkZWxldGUgb2xkQ29tcFtrZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gKGlkLCBhcmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGRldnRvb2xzJDE7XG5sZXQgYnVmZmVyID0gW107XG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVtaXQkMShldmVudCwgLi4uYXJncykge1xuICBpZiAoZGV2dG9vbHMkMSkge1xuICAgIGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoIWRldnRvb2xzTm90SW5zdGFsbGVkKSB7XG4gICAgYnVmZmVyLnB1c2goeyBldmVudCwgYXJncyB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rJDEoaG9vaywgdGFyZ2V0KSB7XG4gIHZhciBfYSwgX2I7XG4gIGRldnRvb2xzJDEgPSBob29rO1xuICBpZiAoZGV2dG9vbHMkMSkge1xuICAgIGRldnRvb2xzJDEuZW5hYmxlZCA9IHRydWU7XG4gICAgYnVmZmVyLmZvckVhY2goKHsgZXZlbnQsIGFyZ3MgfSkgPT4gZGV2dG9vbHMkMS5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG4gICAgYnVmZmVyID0gW107XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIHNvbWUgZW52cyBtb2NrIHdpbmRvdyBidXQgbm90IGZ1bGx5XG4gICAgd2luZG93LkhUTUxFbGVtZW50ICYmIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwianNkb21cIikpXG4gICkge1xuICAgIGNvbnN0IHJlcGxheSA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW107XG4gICAgcmVwbGF5LnB1c2goKG5ld0hvb2spID0+IHtcbiAgICAgIHNldERldnRvb2xzSG9vayQxKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWRldnRvb2xzJDEpIHtcbiAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgfVxuICAgIH0sIDNlMyk7XG4gIH0gZWxzZSB7XG4gICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9XG59XG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XG4gIGVtaXQkMShcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xuICAgIEZyYWdtZW50LFxuICAgIFRleHQsXG4gICAgQ29tbWVudCxcbiAgICBTdGF0aWNcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XG4gIGVtaXQkMShcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGFwcCk7XG59XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XG5jb25zdCBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcbiAgXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovXG4pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gKGNvbXBvbmVudCkgPT4ge1xuICBpZiAoZGV2dG9vbHMkMSAmJiB0eXBlb2YgZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gcmVtb3ZlIHRoZSBjb21wb25lbnQgaWYgaXQgd2Fzbid0IGJ1ZmZlcmVkXG4gICFkZXZ0b29scyQxLmNsZWFudXBCdWZmZXIoY29tcG9uZW50KSkge1xuICAgIF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoY29tcG9uZW50KTtcbiAgfVxufTtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50KSA9PiB7XG4gICAgZW1pdCQxKFxuICAgICAgaG9vayxcbiAgICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICAgIGNvbXBvbmVudC51aWQsXG4gICAgICBjb21wb25lbnQucGFyZW50ID8gY29tcG9uZW50LnBhcmVudC51aWQgOiB2b2lkIDAsXG4gICAgICBjb21wb25lbnRcbiAgICApO1xuICB9O1xufVxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xuICAgIGVtaXQkMShob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudCwgdHlwZSwgdGltZSk7XG4gIH07XG59XG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XG4gIGVtaXQkMShcbiAgICBcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sXG4gICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgIGNvbXBvbmVudCxcbiAgICBldmVudCxcbiAgICBwYXJhbXNcbiAgKTtcbn1cblxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xuICBjdXJyZW50U2NvcGVJZCA9IGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkIHx8IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBpZDtcbn1cbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbn1cbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90KSB7XG4gIGlmICghY3R4KSByZXR1cm4gZm47XG4gIGlmIChmbi5fbikge1xuICAgIHJldHVybiBmbjtcbiAgfVxuICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGZuKC4uLmFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcbiAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XG4gIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xuICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XG4gICAgd2FybiQxKFwiRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6IFwiICsgbmFtZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBkaXJlY3RpdmVzKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpO1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcbiAgICBpZiAoZGlyKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XG4gICAgICAgIGRpciA9IHtcbiAgICAgICAgICBtb3VudGVkOiBkaXIsXG4gICAgICAgICAgdXBkYXRlZDogZGlyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZGlyLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgYmluZGluZ3MucHVzaCh7XG4gICAgICAgIGRpcixcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxuICAgICAgICBhcmcsXG4gICAgICAgIG1vZGlmaWVyc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xuICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICBpZiAob2xkQmluZGluZ3MpIHtcbiAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcbiAgICB9XG4gICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcbiAgICBpZiAoaG9vaykge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDgsIFtcbiAgICAgICAgdm5vZGUuZWwsXG4gICAgICAgIGJpbmRpbmcsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBwcmV2Vk5vZGVcbiAgICAgIF0pO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBUZWxlcG9ydEVuZEtleSA9IFN5bWJvbChcIl92dGVcIik7XG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09IFwiXCIpO1xuY29uc3QgaXNUZWxlcG9ydERlZmVycmVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGVmZXIgfHwgcHJvcHMuZGVmZXIgPT09IFwiXCIpO1xuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuY29uc3QgaXNUYXJnZXRNYXRoTUwgPSAodGFyZ2V0KSA9PiB0eXBlb2YgTWF0aE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIHRhcmdldCBpbnN0YW5jZW9mIE1hdGhNTEVsZW1lbnQ7XG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcbiAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcbiAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xuICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0YXJnZXQgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XG4gIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gIG5hbWU6IFwiVGVsZXBvcnRcIixcbiAgX19pc1RlbGVwb3J0OiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xuICAgIGNvbnN0IHtcbiAgICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICAgIG86IHsgaW5zZXJ0LCBxdWVyeVNlbGVjdG9yLCBjcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50IH1cbiAgICB9ID0gaW50ZXJuYWxzO1xuICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gbjIuZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IHN0YXJ0XCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IGVuZFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIyLCBhbmNob3IyKSA9PiB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LmlzQ0UpIHtcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jZS5fdGVsZXBvcnRUYXJnZXQgPSBjb250YWluZXIyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vdW50VG9UYXJnZXQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBwcmVwYXJlQW5jaG9yKHRhcmdldCwgbjIsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlICE9PSBcInN2Z1wiICYmIGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgIT09IFwibWF0aG1sXCIgJiYgaXNUYXJnZXRNYXRoTUwodGFyZ2V0KSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6XCIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcbiAgICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZWxlcG9ydERlZmVycmVkKG4yLnByb3BzKSkge1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG1vdW50VG9UYXJnZXQoKTtcbiAgICAgICAgICBuMi5lbC5fX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50VG9UYXJnZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGVsZXBvcnREZWZlcnJlZChuMi5wcm9wcykgJiYgIW4xLmVsLl9faXNNb3VudGVkKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgVGVsZXBvcnRJbXBsLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRlbGV0ZSBuMS5lbC5fX2lzTW91bnRlZDtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIudGFyZ2V0U3RhcnQgPSBuMS50YXJnZXRTdGFydDtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSBuMS50YXJnZXQ7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3I7XG4gICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJzdmdcIiB8fCBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiB8fCBpc1RhcmdldE1hdGhNTCh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICB9XG4gICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50QW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbWFpbkFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuMi5wcm9wcyAmJiBuMS5wcm9wcyAmJiBuMi5wcm9wcy50byAhPT0gbjEucHJvcHMudG8pIHtcbiAgICAgICAgICAgIG4yLnByb3BzLnRvID0gbjEucHJvcHMudG87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgICAgICAgICAgbjIucHJvcHMsXG4gICAgICAgICAgICBxdWVyeVNlbGVjdG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xuICAgICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgbmV4dFRhcmdldCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTpcIixcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVDc3NWYXJzKG4yLCBkaXNhYmxlZCk7XG4gICAgfVxuICB9LFxuICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHsgdW06IHVubW91bnQsIG86IHsgcmVtb3ZlOiBob3N0UmVtb3ZlIH0gfSwgZG9SZW1vdmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGFuY2hvcixcbiAgICAgIHRhcmdldFN0YXJ0LFxuICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJvcHNcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRTdGFydCk7XG4gICAgICBob3N0UmVtb3ZlKHRhcmdldEFuY2hvcik7XG4gICAgfVxuICAgIGRvUmVtb3ZlICYmIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGNvbnN0IHNob3VsZFJlbW92ZSA9IGRvUmVtb3ZlIHx8ICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzaG91bGRSZW1vdmUsXG4gICAgICAgICAgISFjaGlsZC5keW5hbWljQ2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdmU6IG1vdmVUZWxlcG9ydCxcbiAgaHlkcmF0ZTogaHlkcmF0ZVRlbGVwb3J0XG59O1xuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMikge1xuICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICBpbnNlcnQodm5vZGUudGFyZ2V0QW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzUmVvcmRlciA9IG1vdmVUeXBlID09PSAyO1xuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKFxuICAgICAgICAgIGNoaWxkcmVuW2ldLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRBbmNob3IsXG4gICAgICAgICAgMlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7XG4gIG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IsIGluc2VydCwgY3JlYXRlVGV4dCB9XG59LCBoeWRyYXRlQ2hpbGRyZW4pIHtcbiAgY29uc3QgdGFyZ2V0ID0gdm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICB2bm9kZS5wcm9wcyxcbiAgICBxdWVyeVNlbGVjdG9yXG4gICk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcyk7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNikge1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHZub2RlLnRhcmdldFN0YXJ0ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiYgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPSB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldEFuY2hvciA9IG5leHRTaWJsaW5nKHRhcmdldEFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2bm9kZS50YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIHRhcmdldE5vZGUgJiYgbmV4dFNpYmxpbmcodGFyZ2V0Tm9kZSksXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNzc1ZhcnModm5vZGUsIGRpc2FibGVkKTtcbiAgfVxuICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XG59XG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcbmZ1bmN0aW9uIHVwZGF0ZUNzc1ZhcnModm5vZGUsIGlzRGlzYWJsZWQpIHtcbiAgY29uc3QgY3R4ID0gdm5vZGUuY3R4O1xuICBpZiAoY3R4ICYmIGN0eC51dCkge1xuICAgIGxldCBub2RlLCBhbmNob3I7XG4gICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgIG5vZGUgPSB2bm9kZS5lbDtcbiAgICAgIGFuY2hvciA9IHZub2RlLmFuY2hvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHZub2RlLnRhcmdldFN0YXJ0O1xuICAgICAgYW5jaG9yID0gdm5vZGUudGFyZ2V0QW5jaG9yO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBhbmNob3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdi1vd25lclwiLCBjdHgudWlkKTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBjdHgudXQoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUFuY2hvcih0YXJnZXQsIHZub2RlLCBjcmVhdGVUZXh0LCBpbnNlcnQpIHtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB2bm9kZS50YXJnZXRTdGFydCA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIGNvbnN0IHRhcmdldEFuY2hvciA9IHZub2RlLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIHRhcmdldFN0YXJ0W1RlbGVwb3J0RW5kS2V5XSA9IHRhcmdldEFuY2hvcjtcbiAgaWYgKHRhcmdldCkge1xuICAgIGluc2VydCh0YXJnZXRTdGFydCwgdGFyZ2V0KTtcbiAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xuICB9XG4gIHJldHVybiB0YXJnZXRBbmNob3I7XG59XG5cbmNvbnN0IGxlYXZlQ2JLZXkgPSBTeW1ib2woXCJfbGVhdmVDYlwiKTtcbmNvbnN0IGVudGVyQ2JLZXkgPSBTeW1ib2woXCJfZW50ZXJDYlwiKTtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc0xlYXZpbmc6IGZhbHNlLFxuICAgIGlzVW5tb3VudGluZzogZmFsc2UsXG4gICAgbGVhdmluZ1ZOb2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gIH0pO1xuICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xuY29uc3QgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG1vZGU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXG4gIC8vIGVudGVyXG4gIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGxlYXZlXG4gIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGFwcGVhclxuICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxufTtcbmNvbnN0IHJlY3Vyc2l2ZUdldFN1YnRyZWUgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIHJldHVybiBzdWJUcmVlLmNvbXBvbmVudCA/IHJlY3Vyc2l2ZUdldFN1YnRyZWUoc3ViVHJlZS5jb21wb25lbnQpIDogc3ViVHJlZTtcbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XG4gIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXG4gIHByb3BzOiBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xuICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gZmluZE5vbkNvbW1lbnRDaGlsZChjaGlsZHJlbik7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtb2RlICYmIG1vZGUgIT09IFwiaW4tb3V0XCIgJiYgbW9kZSAhPT0gXCJvdXQtaW5cIiAmJiBtb2RlICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICB3YXJuJDEoYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldElubmVyQ2hpbGQkMShjaGlsZCk7XG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgbGV0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICBpbm5lckNoaWxkLFxuICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICAvLyAjMTEwNjEsIGVuc3VyZSBlbnRlckhvb2tzIGlzIGZyZXNoIGFmdGVyIGNsb25lXG4gICAgICAgIChob29rcykgPT4gZW50ZXJIb29rcyA9IGhvb2tzXG4gICAgICApO1xuICAgICAgaWYgKGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XG4gICAgICB9XG4gICAgICBsZXQgb2xkSW5uZXJDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWUgJiYgZ2V0SW5uZXJDaGlsZCQxKGluc3RhbmNlLnN1YlRyZWUpO1xuICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiYgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50ICYmICFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgJiYgcmVjdXJzaXZlR2V0U3VidHJlZShpbnN0YW5jZSkudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBsZXQgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICBvbGRJbm5lckNoaWxkLFxuICAgICAgICAgIHJhd1Byb3BzLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJvdXQtaW5cIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZS5qb2IuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZTtcbiAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJpbi1vdXRcIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRJbm5lckNoaWxkKSB7XG4gICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pIHtcbiAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoYy50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGhhc0ZvdW5kKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgXCI8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlIDx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xuICAgICAgICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XG4gIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlLCBwb3N0Q2xvbmUpIHtcbiAgY29uc3Qge1xuICAgIGFwcGVhcixcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCA9IGZhbHNlLFxuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkFmdGVyRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUxlYXZlLFxuICAgIG9uTGVhdmUsXG4gICAgb25BZnRlckxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIsXG4gICAgb25BcHBlYXIsXG4gICAgb25BZnRlckFwcGVhcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XG4gIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBob29rICYmIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaG9vayxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgOSxcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9O1xuICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkb25lID0gYXJnc1sxXTtcbiAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaWYgKGhvb2suZXZlcnkoKGhvb2syKSA9PiBob29rMi5sZW5ndGggPD0gMSkpIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhvb2tzID0ge1xuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkLFxuICAgIGJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgZWxbbGVhdmVDYktleV0oXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XG4gICAgICBpZiAobGVhdmluZ1ZOb2RlICYmIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJiBsZWF2aW5nVk5vZGUuZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICB9LFxuICAgIGVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XG4gICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xuICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xuICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2VudGVyQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtlbnRlckNiS2V5XSA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgY29uc3Qga2V5MiA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICAgICAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgICAgIGVsW2VudGVyQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWxbbGVhdmVDYktleV0gPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID09PSB2bm9kZSkge1xuICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPSB2bm9kZTtcbiAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZSh2bm9kZTIpIHtcbiAgICAgIGNvbnN0IGhvb2tzMiA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIHZub2RlMixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgcG9zdENsb25lXG4gICAgICApO1xuICAgICAgaWYgKHBvc3RDbG9uZSkgcG9zdENsb25lKGhvb2tzMik7XG4gICAgICByZXR1cm4gaG9va3MyO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xuICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkJDEodm5vZGUpIHtcbiAgaWYgKCFpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICBpZiAoaXNUZWxlcG9ydCh2bm9kZS50eXBlKSAmJiB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGZpbmROb25Db21tZW50Q2hpbGQodm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMzIgJiYgaXNGdW5jdGlvbihjaGlsZHJlbi5kZWZhdWx0KSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuLmRlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xuICB9IGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcbiAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSwgcGFyZW50S2V5KSB7XG4gIGxldCByZXQgPSBbXTtcbiAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbCA/IGNoaWxkLmtleSA6IFN0cmluZyhwYXJlbnRLZXkpICsgU3RyaW5nKGNoaWxkLmtleSAhPSBudWxsID8gY2hpbGQua2V5IDogaSk7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4KSBrZXllZEZyYWdtZW50Q291bnQrKztcbiAgICAgIHJldCA9IHJldC5jb25jYXQoXG4gICAgICAgIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChrZWVwQ29tbWVudCB8fCBjaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICByZXQucHVzaChrZXkgIT0gbnVsbCA/IGNsb25lVk5vZGUoY2hpbGQsIHsga2V5IH0pIDogY2hpbGQpO1xuICAgIH1cbiAgfVxuICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyAoXG4gICAgLy8gIzgyMzY6IGV4dGVuZCBjYWxsIGFuZCBvcHRpb25zLm5hbWUgYWNjZXNzIGFyZSBjb25zaWRlcmVkIHNpZGUtZWZmZWN0c1xuICAgIC8vIGJ5IFJvbGx1cCwgc28gd2UgaGF2ZSB0byB3cmFwIGl0IGluIGEgcHVyZS1hbm5vdGF0ZWQgSUlGRS5cbiAgICAvKiBAX19QVVJFX18gKi8gKCgpID0+IGV4dGVuZCh7IG5hbWU6IG9wdGlvbnMubmFtZSB9LCBleHRyYU9wdGlvbnMsIHsgc2V0dXA6IG9wdGlvbnMgfSkpKClcbiAgKSA6IG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpKSB7XG4gICAgcmV0dXJuIChpLmFwcENvbnRleHQuY29uZmlnLmlkUHJlZml4IHx8IFwidlwiKSArIFwiLVwiICsgaS5pZHNbMF0gKyBpLmlkc1sxXSsrO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlSWQoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLmlkcyA9IFtpbnN0YW5jZS5pZHNbMF0gKyBpbnN0YW5jZS5pZHNbMl0rKyArIFwiLVwiLCAwLCAwXTtcbn1cblxuY29uc3Qga25vd25UZW1wbGF0ZVJlZnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIHVzZVRlbXBsYXRlUmVmKGtleSkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IHIgPSBzaGFsbG93UmVmKG51bGwpO1xuICBpZiAoaSkge1xuICAgIGNvbnN0IHJlZnMgPSBpLnJlZnMgPT09IEVNUFRZX09CSiA/IGkucmVmcyA9IHt9IDogaS5yZWZzO1xuICAgIGxldCBkZXNjO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWZzLCBrZXkpKSAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgIHdhcm4kMShgdXNlVGVtcGxhdGVSZWYoJyR7a2V5fScpIGFscmVhZHkgZXhpc3RzLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVmcywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gci52YWx1ZSxcbiAgICAgICAgc2V0OiAodmFsKSA9PiByLnZhbHVlID0gdmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGB1c2VUZW1wbGF0ZVJlZigpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHJldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyByZWFkb25seShyKSA6IHI7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAga25vd25UZW1wbGF0ZVJlZnMuYWRkKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSB7XG4gIGlmIChpc0FycmF5KHJhd1JlZikpIHtcbiAgICByYXdSZWYuZm9yRWFjaChcbiAgICAgIChyLCBpKSA9PiBzZXRSZWYoXG4gICAgICAgIHIsXG4gICAgICAgIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBpc1VubW91bnRcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNTEyICYmIHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkICYmIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLmNvbXBvbmVudCkge1xuICAgICAgc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0ID8gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2Uodm5vZGUuY29tcG9uZW50KSA6IHZub2RlLmVsO1xuICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFvd25lcikge1xuICAgIHdhcm4kMShcbiAgICAgIGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyBvd25lci5yZWZzID0ge30gOiBvd25lci5yZWZzO1xuICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgY29uc3QgcmF3U2V0dXBTdGF0ZSA9IHRvUmF3KHNldHVwU3RhdGUpO1xuICBjb25zdCBjYW5TZXRTZXR1cFJlZiA9IHNldHVwU3RhdGUgPT09IEVNUFRZX09CSiA/ICgpID0+IGZhbHNlIDogKGtleSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaGFzT3duKHJhd1NldHVwU3RhdGUsIGtleSkgJiYgIWlzUmVmKHJhd1NldHVwU3RhdGVba2V5XSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBUZW1wbGF0ZSByZWYgXCIke2tleX1cIiB1c2VkIG9uIGEgbm9uLXJlZiB2YWx1ZS4gSXQgd2lsbCBub3Qgd29yayBpbiB0aGUgcHJvZHVjdGlvbiBidWlsZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoa25vd25UZW1wbGF0ZVJlZnMuaGFzKHJhd1NldHVwU3RhdGVba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzT3duKHJhd1NldHVwU3RhdGUsIGtleSk7XG4gIH07XG4gIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xuICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XG4gICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xuICAgICAgaWYgKGNhblNldFNldHVwUmVmKG9sZFJlZikpIHtcbiAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcbiAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIsIFt2YWx1ZSwgcmVmc10pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XG4gICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChyYXdSZWYuZikge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gY2FuU2V0U2V0dXBSZWYocmVmKSA/IHNldHVwU3RhdGVbcmVmXSA6IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcbiAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XG4gICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUoZXhpc3RpbmcsIHJlZlZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuU2V0U2V0dXBSZWYocmVmKSkge1xuICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaykgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcbiAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNSZWYpIHtcbiAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAocmF3UmVmLmspIHJlZnNbcmF3UmVmLmtdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvU2V0LmlkID0gLTE7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9TZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvciA9IGZhbHNlO1xuY29uc3QgbG9nTWlzbWF0Y2hFcnJvciA9ICgpID0+IHtcbiAgaWYgKGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5lcnJvcihcIkh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuXCIpO1xuICBoYXNMb2dnZWRNaXNtYXRjaEVycm9yID0gdHJ1ZTtcbn07XG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJzdmdcIikgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuY29uc3QgaXNNYXRoTUxDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiBjb250YWluZXIubmFtZXNwYWNlVVJJLmluY2x1ZGVzKFwiTWF0aE1MXCIpO1xuY29uc3QgZ2V0Q29udGFpbmVyVHlwZSA9IChjb250YWluZXIpID0+IHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lcikpIHJldHVybiBcInN2Z1wiO1xuICBpZiAoaXNNYXRoTUxDb250YWluZXIoY29udGFpbmVyKSkgcmV0dXJuIFwibWF0aG1sXCI7XG4gIHJldHVybiB2b2lkIDA7XG59O1xuY29uc3QgaXNDb21tZW50ID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDg7XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgY29uc3Qge1xuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7XG4gICAgICBwYXRjaFByb3AsXG4gICAgICBjcmVhdGVUZXh0LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICBwYXJlbnROb2RlLFxuICAgICAgcmVtb3ZlLFxuICAgICAgaW5zZXJ0LFxuICAgICAgY3JlYXRlQ29tbWVudFxuICAgIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gXG4gICAgICApO1xuICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIjtcbiAgICBjb25zdCBvbk1pc21hdGNoID0gKCkgPT4gaGFuZGxlTWlzbWF0Y2goXG4gICAgICBub2RlLFxuICAgICAgdm5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIGlzRnJhZ21lbnRTdGFydFxuICAgICk7XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZywgcGF0Y2hGbGFnIH0gPSB2bm9kZTtcbiAgICBsZXQgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgdm5vZGUuZWwgPSBub2RlO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGVmKG5vZGUsIFwiX192bm9kZVwiLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICBkZWYobm9kZSwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCBwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMykge1xuICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgcGFyZW50Tm9kZShub2RlKSwgbm9kZSk7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBtaXNtYXRjaCBpbmAsXG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgYFxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBub2RlLmRhdGFcbiAgICAgICAgICAgICAgKX1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICByZXBsYWNlTm9kZShcbiAgICAgICAgICAgIHZub2RlLmVsID0gbm9kZS5jb250ZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb21UeXBlICE9PSA4IHx8IGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tVHlwZSA9PT0gMSB8fCBkb21UeXBlID09PSAzKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxuICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPSBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMSA/IG5leHROb2RlLm91dGVySFRNTCA6IG5leHROb2RlLmRhdGE7XG4gICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0ZyYWdtZW50U3RhcnQgPyBuZXh0U2libGluZyhuZXh0Tm9kZSkgOiBuZXh0Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk1pc21hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBpZiAoIWlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEpIHtcbiAgICAgICAgICBpZiAoKGRvbVR5cGUgIT09IDEgfHwgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgIWlzVGVtcGxhdGVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBzdGFydFwiKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSwgbm9kZS5kYXRhLCBcInRlbGVwb3J0IGVuZFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nIDogY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKFwiXCIpIDogY3JlYXRlVk5vZGUoXCJkaXZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgICBoeWRyYXRlQ2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUeXBlKHBhcmVudE5vZGUobm9kZSkpLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICBoeWRyYXRlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHROb2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBjb25zdCBmb3JjZVBhdGNoID0gdHlwZSA9PT0gXCJpbnB1dFwiIHx8IHR5cGUgPT09IFwib3B0aW9uXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZm9yY2VQYXRjaCB8fCBwYXRjaEZsYWcgIT09IC0xKSB7XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IGZhbHNlO1xuICAgICAgaWYgKGlzVGVtcGxhdGVOb2RlKGVsKSkge1xuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IG5lZWRUcmFuc2l0aW9uKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gbm8gbmVlZCBjaGVjayBwYXJlbnRTdXNwZW5zZSBpbiBoeWRyYXRpb25cbiAgICAgICAgICB0cmFuc2l0aW9uXG4gICAgICAgICkgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcyAmJiBwYXJlbnRDb21wb25lbnQudm5vZGUucHJvcHMuYXBwZWFyO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZWwuY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VOb2RlKGNvbnRlbnQsIGVsLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB2bm9kZS5lbCA9IGVsID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAmJiAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAhKHByb3BzICYmIChwcm9wcy5pbm5lckhUTUwgfHwgcHJvcHMudGV4dENvbnRlbnQpKSkge1xuICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBlbC5maXJzdENoaWxkLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgYFxuU2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcbiAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICByZW1vdmUoY3VyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgIGxldCBjbGllbnRUZXh0ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChjbGllbnRUZXh0WzBdID09PSBcIlxcblwiICYmIChlbC50YWdOYW1lID09PSBcIlBSRVwiIHx8IGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikpIHtcbiAgICAgICAgICBjbGllbnRUZXh0ID0gY2xpZW50VGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IGNsaWVudFRleHQpIHtcbiAgICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCAwIC8qIFRFWFQgKi8pKSB7XG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgYFxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtlbC50ZXh0Q29udGVudH1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7dm5vZGUuY2hpbGRyZW59YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyB8fCBmb3JjZVBhdGNoIHx8ICFvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnICYgKDE2IHwgMzIpKSB7XG4gICAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gZWwudGFnTmFtZS5pbmNsdWRlcyhcIi1cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIC8vICMxMTE4OSBza2lwIGlmIHRoaXMgbm9kZSBoYXMgZGlyZWN0aXZlcyB0aGF0IGhhdmUgY3JlYXRlZCBob29rc1xuICAgICAgICAgICAgLy8gYXMgaXQgY291bGQgaGF2ZSBtdXRhdGVkIHRoZSBET00gaW4gYW55IHBvc3NpYmxlIHdheVxuICAgICAgICAgICAgIShkaXJzICYmIGRpcnMuc29tZSgoZCkgPT4gZC5kaXIuY3JlYXRlZCkpICYmIHByb3BIYXNNaXNtYXRjaChlbCwga2V5LCBwcm9wc1trZXldLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50KSkge1xuICAgICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2VQYXRjaCAmJiAoa2V5LmVuZHNXaXRoKFwidmFsdWVcIikgfHwga2V5ID09PSBcImluZGV0ZXJtaW5hdGVcIikgfHwgaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpIHx8IC8vIGZvcmNlIGh5ZHJhdGUgdi1iaW5kIHdpdGggLnByb3AgbW9kaWZpZXJzXG4gICAgICAgICAgICBrZXlbMF0gPT09IFwiLlwiIHx8IGlzQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgdm9pZCAwLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgICAgcGF0Y2hQcm9wKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBcIm9uQ2xpY2tcIixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wcy5vbkNsaWNrLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA0ICYmIGlzUmVhY3RpdmUocHJvcHMuc3R5bGUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMuc3R5bGUpIHByb3BzLnN0eWxlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZUhvb2tzO1xuICAgICAgaWYgKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMgfHwgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xuICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xuICB9O1xuICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWQgPyBjaGlsZHJlbltpXSA6IGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdm5vZGUudHlwZSA9PT0gVGV4dDtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChpc1RleHQgJiYgIW9wdGltaXplZCkge1xuICAgICAgICAgIGlmIChpICsgMSA8IGwgJiYgbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baSArIDFdKS50eXBlID09PSBUZXh0KSB7XG4gICAgICAgICAgICBpbnNlcnQoXG4gICAgICAgICAgICAgIGNyZWF0ZVRleHQoXG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLnNsaWNlKHZub2RlLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBuZXh0U2libGluZyhub2RlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpc1RleHQgJiYgIXZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGluc2VydCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoXCJcIiksIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGNvbnRhaW5lciwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIGBcblNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgeyBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSB2bm9kZTtcbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgdm5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgIHJldHVybiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IgPSBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgaW5zZXJ0KHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSwgY29udGFpbmVyLCBuZXh0KTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xuICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQobm9kZS5wYXJlbnRFbGVtZW50LCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgIGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcbi0gcmVuZGVyZWQgb24gc2VydmVyOmAsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBgKHRleHQpYCA6IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiID8gYChzdGFydCBvZiBmcmFnbWVudClgIDogYGAsXG4gICAgICAgIGBcbi0gZXhwZWN0ZWQgb24gY2xpZW50OmAsXG4gICAgICAgIHZub2RlLnR5cGVcbiAgICAgICk7XG4gICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgfVxuICAgIHZub2RlLmVsID0gbnVsbDtcbiAgICBpZiAoaXNGcmFnbWVudCkge1xuICAgICAgY29uc3QgZW5kID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5leHQyID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIGlmIChuZXh0MiAmJiBuZXh0MiAhPT0gZW5kKSB7XG4gICAgICAgICAgcmVtb3ZlKG5leHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICByZW1vdmUobm9kZSk7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBuZXh0LFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IHZub2RlLmVsO1xuICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgdm5vZGUuZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbiAgfTtcbiAgY29uc3QgbG9jYXRlQ2xvc2luZ0FuY2hvciA9IChub2RlLCBvcGVuID0gXCJbXCIsIGNsb3NlID0gXCJdXCIpID0+IHtcbiAgICBsZXQgbWF0Y2ggPSAwO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gb3BlbikgbWF0Y2grKztcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gY2xvc2UpIHtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2gtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIGNvbnN0IHJlcGxhY2VOb2RlID0gKG5ld05vZGUsIG9sZE5vZGUsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudE5vZGUyID0gb2xkTm9kZS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlMikge1xuICAgICAgcGFyZW50Tm9kZTIucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gcGFyZW50Q29tcG9uZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQudm5vZGUuZWwgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgcGFyZW50LnZub2RlLmVsID0gcGFyZW50LnN1YlRyZWUuZWwgPSBuZXdOb2RlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGlzVGVtcGxhdGVOb2RlID0gKG5vZGUpID0+IHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLnRhZ05hbWUgPT09IFwiVEVNUExBVEVcIjtcbiAgfTtcbiAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XG59XG5mdW5jdGlvbiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgY2xpZW50VmFsdWUsIHZub2RlLCBpbnN0YW5jZSkge1xuICBsZXQgbWlzbWF0Y2hUeXBlO1xuICBsZXQgbWlzbWF0Y2hLZXk7XG4gIGxldCBhY3R1YWw7XG4gIGxldCBleHBlY3RlZDtcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgZXhwZWN0ZWQgPSBub3JtYWxpemVDbGFzcyhjbGllbnRWYWx1ZSk7XG4gICAgaWYgKCFpc1NldEVxdWFsKHRvQ2xhc3NTZXQoYWN0dWFsIHx8IFwiXCIpLCB0b0NsYXNzU2V0KGV4cGVjdGVkKSkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDIgLyogQ0xBU1MgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGBjbGFzc2A7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgfHwgXCJcIjtcbiAgICBleHBlY3RlZCA9IGlzU3RyaW5nKGNsaWVudFZhbHVlKSA/IGNsaWVudFZhbHVlIDogc3RyaW5naWZ5U3R5bGUobm9ybWFsaXplU3R5bGUoY2xpZW50VmFsdWUpKTtcbiAgICBjb25zdCBhY3R1YWxNYXAgPSB0b1N0eWxlTWFwKGFjdHVhbCk7XG4gICAgY29uc3QgZXhwZWN0ZWRNYXAgPSB0b1N0eWxlTWFwKGV4cGVjdGVkKTtcbiAgICBpZiAodm5vZGUuZGlycykge1xuICAgICAgZm9yIChjb25zdCB7IGRpciwgdmFsdWUgfSBvZiB2bm9kZS5kaXJzKSB7XG4gICAgICAgIGlmIChkaXIubmFtZSA9PT0gXCJzaG93XCIgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgZXhwZWN0ZWRNYXAuc2V0KFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZSwgdm5vZGUsIGV4cGVjdGVkTWFwKTtcbiAgICB9XG4gICAgaWYgKCFpc01hcEVxdWFsKGFjdHVhbE1hcCwgZXhwZWN0ZWRNYXApKSB7XG4gICAgICBtaXNtYXRjaFR5cGUgPSAzIC8qIFNUWUxFICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBcInN0eWxlXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBpc0tub3duU3ZnQXR0cihrZXkpIHx8IGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKGlzQm9vbGVhbkF0dHIoa2V5KSB8fCBpc0tub3duSHRtbEF0dHIoa2V5KSkpIHtcbiAgICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgICBhY3R1YWwgPSBlbC5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGV4cGVjdGVkID0gaW5jbHVkZUJvb2xlYW5BdHRyKGNsaWVudFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudFZhbHVlID09IG51bGwpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgYWN0dWFsID0gZWwudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV4cGVjdGVkID0gaXNSZW5kZXJhYmxlQXR0clZhbHVlKGNsaWVudFZhbHVlKSA/IFN0cmluZyhjbGllbnRWYWx1ZSkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDQgLyogQVRUUklCVVRFICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBrZXk7XG4gICAgfVxuICB9XG4gIGlmIChtaXNtYXRjaFR5cGUgIT0gbnVsbCAmJiAhaXNNaXNtYXRjaEFsbG93ZWQoZWwsIG1pc21hdGNoVHlwZSkpIHtcbiAgICBjb25zdCBmb3JtYXQgPSAodikgPT4gdiA9PT0gZmFsc2UgPyBgKG5vdCByZW5kZXJlZClgIDogYCR7bWlzbWF0Y2hLZXl9PVwiJHt2fVwiYDtcbiAgICBjb25zdCBwcmVTZWdtZW50ID0gYEh5ZHJhdGlvbiAke01pc21hdGNoVHlwZVN0cmluZ1ttaXNtYXRjaFR5cGVdfSBtaXNtYXRjaCBvbmA7XG4gICAgY29uc3QgcG9zdFNlZ21lbnQgPSBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2Zvcm1hdChhY3R1YWwpfVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtmb3JtYXQoZXhwZWN0ZWQpfVxuICBOb3RlOiB0aGlzIG1pc21hdGNoIGlzIGNoZWNrLW9ubHkuIFRoZSBET00gd2lsbCBub3QgYmUgcmVjdGlmaWVkIGluIHByb2R1Y3Rpb24gZHVlIHRvIHBlcmZvcm1hbmNlIG92ZXJoZWFkLlxuICBZb3Ugc2hvdWxkIGZpeCB0aGUgc291cmNlIG9mIHRoZSBtaXNtYXRjaC5gO1xuICAgIHtcbiAgICAgIHdhcm4kMShwcmVTZWdtZW50LCBlbCwgcG9zdFNlZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0b0NsYXNzU2V0KHN0cikge1xuICByZXR1cm4gbmV3IFNldChzdHIudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xufVxuZnVuY3Rpb24gaXNTZXRFcXVhbChhLCBiKSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IHMgb2YgYSkge1xuICAgIGlmICghYi5oYXMocykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0b1N0eWxlTWFwKHN0cikge1xuICBjb25zdCBzdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBzdHIuc3BsaXQoXCI7XCIpKSB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IGl0ZW0uc3BsaXQoXCI6XCIpO1xuICAgIGtleSA9IGtleS50cmltKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS50cmltKCk7XG4gICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgc3R5bGVNYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVNYXA7XG59XG5mdW5jdGlvbiBpc01hcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGEpIHtcbiAgICBpZiAodmFsdWUgIT09IGIuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZSwgdm5vZGUsIGV4cGVjdGVkTWFwKSB7XG4gIGNvbnN0IHJvb3QgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICBpZiAoaW5zdGFuY2UuZ2V0Q3NzVmFycyAmJiAodm5vZGUgPT09IHJvb3QgfHwgcm9vdCAmJiByb290LnR5cGUgPT09IEZyYWdtZW50ICYmIHJvb3QuY2hpbGRyZW4uaW5jbHVkZXModm5vZGUpKSkge1xuICAgIGNvbnN0IGNzc1ZhcnMgPSBpbnN0YW5jZS5nZXRDc3NWYXJzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY3NzVmFycykge1xuICAgICAgZXhwZWN0ZWRNYXAuc2V0KFxuICAgICAgICBgLS0ke2dldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZmFsc2UpfWAsXG4gICAgICAgIFN0cmluZyhjc3NWYXJzW2tleV0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodm5vZGUgPT09IHJvb3QgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UucGFyZW50LCBpbnN0YW5jZS52bm9kZSwgZXhwZWN0ZWRNYXApO1xuICB9XG59XG5jb25zdCBhbGxvd01pc21hdGNoQXR0ciA9IFwiZGF0YS1hbGxvdy1taXNtYXRjaFwiO1xuY29uc3QgTWlzbWF0Y2hUeXBlU3RyaW5nID0ge1xuICBbMCAvKiBURVhUICovXTogXCJ0ZXh0XCIsXG4gIFsxIC8qIENISUxEUkVOICovXTogXCJjaGlsZHJlblwiLFxuICBbMiAvKiBDTEFTUyAqL106IFwiY2xhc3NcIixcbiAgWzMgLyogU1RZTEUgKi9dOiBcInN0eWxlXCIsXG4gIFs0IC8qIEFUVFJJQlVURSAqL106IFwiYXR0cmlidXRlXCJcbn07XG5mdW5jdGlvbiBpc01pc21hdGNoQWxsb3dlZChlbCwgYWxsb3dlZFR5cGUpIHtcbiAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gfHwgYWxsb3dlZFR5cGUgPT09IDEgLyogQ0hJTERSRU4gKi8pIHtcbiAgICB3aGlsZSAoZWwgJiYgIWVsLmhhc0F0dHJpYnV0ZShhbGxvd01pc21hdGNoQXR0cikpIHtcbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYWxsb3dlZEF0dHIgPSBlbCAmJiBlbC5nZXRBdHRyaWJ1dGUoYWxsb3dNaXNtYXRjaEF0dHIpO1xuICBpZiAoYWxsb3dlZEF0dHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChhbGxvd2VkQXR0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxpc3QgPSBhbGxvd2VkQXR0ci5zcGxpdChcIixcIik7XG4gICAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gJiYgbGlzdC5pbmNsdWRlcyhcImNoaWxkcmVuXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhNaXNtYXRjaFR5cGVTdHJpbmdbYWxsb3dlZFR5cGVdKTtcbiAgfVxufVxuXG5jb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID0gZ2V0R2xvYmFsVGhpcygpLnJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgKChjYikgPT4gc2V0VGltZW91dChjYiwgMSkpO1xuY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID0gZ2V0R2xvYmFsVGhpcygpLmNhbmNlbElkbGVDYWxsYmFjayB8fCAoKGlkKSA9PiBjbGVhclRpbWVvdXQoaWQpKTtcbmNvbnN0IGh5ZHJhdGVPbklkbGUgPSAodGltZW91dCA9IDFlNCkgPT4gKGh5ZHJhdGUpID0+IHtcbiAgY29uc3QgaWQgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGh5ZHJhdGUsIHsgdGltZW91dCB9KTtcbiAgcmV0dXJuICgpID0+IGNhbmNlbElkbGVDYWxsYmFjayhpZCk7XG59O1xuZnVuY3Rpb24gZWxlbWVudElzVmlzaWJsZUluVmlld3BvcnQoZWwpIHtcbiAgY29uc3QgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7IGlubmVySGVpZ2h0LCBpbm5lcldpZHRoIH0gPSB3aW5kb3c7XG4gIHJldHVybiAodG9wID4gMCAmJiB0b3AgPCBpbm5lckhlaWdodCB8fCBib3R0b20gPiAwICYmIGJvdHRvbSA8IGlubmVySGVpZ2h0KSAmJiAobGVmdCA+IDAgJiYgbGVmdCA8IGlubmVyV2lkdGggfHwgcmlnaHQgPiAwICYmIHJpZ2h0IDwgaW5uZXJXaWR0aCk7XG59XG5jb25zdCBoeWRyYXRlT25WaXNpYmxlID0gKG9wdHMpID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGNvbnN0IG9iID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgIGlmICghZS5pc0ludGVyc2VjdGluZykgY29udGludWU7XG4gICAgICBvYi5kaXNjb25uZWN0KCk7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0sIG9wdHMpO1xuICBmb3JFYWNoKChlbCkgPT4ge1xuICAgIGlmICghKGVsIGluc3RhbmNlb2YgRWxlbWVudCkpIHJldHVybjtcbiAgICBpZiAoZWxlbWVudElzVmlzaWJsZUluVmlld3BvcnQoZWwpKSB7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBvYi5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iLm9ic2VydmUoZWwpO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IG9iLmRpc2Nvbm5lY3QoKTtcbn07XG5jb25zdCBoeWRyYXRlT25NZWRpYVF1ZXJ5ID0gKHF1ZXJ5KSA9PiAoaHlkcmF0ZSkgPT4ge1xuICBpZiAocXVlcnkpIHtcbiAgICBjb25zdCBtcWwgPSBtYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICBpZiAobXFsLm1hdGNoZXMpIHtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXFsLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaHlkcmF0ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuICgpID0+IG1xbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGh5ZHJhdGVPbkludGVyYWN0aW9uID0gKGludGVyYWN0aW9ucyA9IFtdKSA9PiAoaHlkcmF0ZSwgZm9yRWFjaCkgPT4ge1xuICBpZiAoaXNTdHJpbmcoaW50ZXJhY3Rpb25zKSkgaW50ZXJhY3Rpb25zID0gW2ludGVyYWN0aW9uc107XG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xuICBjb25zdCBkb0h5ZHJhdGUgPSAoZSkgPT4ge1xuICAgIGlmICghaGFzSHlkcmF0ZWQpIHtcbiAgICAgIGhhc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgIHRlYXJkb3duKCk7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGVhcmRvd24gPSAoKSA9PiB7XG4gICAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBpbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3JFYWNoKChlbCkgPT4ge1xuICAgIGZvciAoY29uc3QgaSBvZiBpbnRlcmFjdGlvbnMpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoaSwgZG9IeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRlYXJkb3duO1xufTtcbmZ1bmN0aW9uIGZvckVhY2hFbGVtZW50KG5vZGUsIGNiKSB7XG4gIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIikge1xuICAgIGxldCBkZXB0aCA9IDE7XG4gICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjYihuZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobmV4dCkpIHtcbiAgICAgICAgaWYgKG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICBpZiAoLS1kZXB0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dC5kYXRhID09PSBcIltcIikge1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYihub2RlKTtcbiAgfVxufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGxvYWRlcixcbiAgICBsb2FkaW5nQ29tcG9uZW50LFxuICAgIGVycm9yQ29tcG9uZW50LFxuICAgIGRlbGF5ID0gMjAwLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdHJhdGVneSxcbiAgICB0aW1lb3V0LFxuICAgIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSxcbiAgICBvbkVycm9yOiB1c2VyT25FcnJvclxuICB9ID0gc291cmNlO1xuICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICBsZXQgcmVzb2x2ZWRDb21wO1xuICBsZXQgcmV0cmllcyA9IDA7XG4gIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgIHJldHJpZXMrKztcbiAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgcmV0dXJuIGxvYWQoKTtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBsZXQgdGhpc1JlcXVlc3Q7XG4gICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0IHx8ICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcbiAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xuICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KS50aGVuKChjb21wKSA9PiB7XG4gICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjb21wKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wICYmIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIk1vZHVsZVwiKSkge1xuICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29tcCAmJiAhaXNPYmplY3QoY29tcCkgJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH0pKTtcbiAgfTtcbiAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XG4gICAgbmFtZTogXCJBc3luY0NvbXBvbmVudFdyYXBwZXJcIixcbiAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxuICAgIF9fYXN5bmNIeWRyYXRlKGVsLCBpbnN0YW5jZSwgaHlkcmF0ZSkge1xuICAgICAgY29uc3QgZG9IeWRyYXRlID0gaHlkcmF0ZVN0cmF0ZWd5ID8gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZWFyZG93biA9IGh5ZHJhdGVTdHJhdGVneShcbiAgICAgICAgICBoeWRyYXRlLFxuICAgICAgICAgIChjYikgPT4gZm9yRWFjaEVsZW1lbnQoZWwsIGNiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGVhcmRvd24pIHtcbiAgICAgICAgICAoaW5zdGFuY2UuYnVtIHx8IChpbnN0YW5jZS5idW0gPSBbXSkpLnB1c2godGVhcmRvd24pO1xuICAgICAgICB9XG4gICAgICB9IDogaHlkcmF0ZTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgZG9IeWRyYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkKCkudGhlbigoKSA9PiAhaW5zdGFuY2UuaXNVbm1vdW50ZWQgJiYgZG9IeWRyYXRlKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XG4gICAgfSxcbiAgICBzZXR1cCgpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICBoYW5kbGVFcnJvcihcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgMTMsXG4gICAgICAgICAgIWVycm9yQ29tcG9uZW50XG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgaWYgKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlIHx8IGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICByZXR1cm4gbG9hZCgpLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnQgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgICBsb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgIGluc3RhbmNlLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobG9hZGVkLnZhbHVlICYmIHJlc29sdmVkQ29tcCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUobG9hZGluZ0NvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCBwYXJlbnQpIHtcbiAgY29uc3QgeyByZWY6IHJlZjIsIHByb3BzLCBjaGlsZHJlbiwgY2UgfSA9IHBhcmVudC52bm9kZTtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xuICB2bm9kZS5yZWYgPSByZWYyO1xuICB2bm9kZS5jZSA9IGNlO1xuICBkZWxldGUgcGFyZW50LnZub2RlLmNlO1xuICByZXR1cm4gdm5vZGU7XG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xuICBuYW1lOiBgS2VlcEFsaXZlYCxcbiAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcbiAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxuICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xuICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgcDogcGF0Y2gsXG4gICAgICAgIG06IG1vdmUsXG4gICAgICAgIHVtOiBfdW5tb3VudCxcbiAgICAgICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgICAgIH1cbiAgICB9ID0gc2hhcmVkQ29udGV4dDtcbiAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgaW5zdGFuY2UyLnZub2RlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGluc3RhbmNlMixcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIubSk7XG4gICAgICBpbnZhbGlkYXRlTW91bnQoaW5zdGFuY2UyLmEpO1xuICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5kYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5kYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IHRydWU7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xuICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XG4gICAgICBjYWNoZS5mb3JFYWNoKCh2bm9kZSwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xuICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoa2V5KSB7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmIChjYWNoZWQgJiYgKCFjdXJyZW50IHx8ICFpc1NhbWVWTm9kZVR5cGUoY2FjaGVkLCBjdXJyZW50KSkpIHtcbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICB3YXRjaChcbiAgICAgICgpID0+IFtwcm9wcy5pbmNsdWRlLCBwcm9wcy5leGNsdWRlXSxcbiAgICAgIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcbiAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKChuYW1lKSA9PiBtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKTtcbiAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKChuYW1lKSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XG4gICAgICB9LFxuICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgIHsgZmx1c2g6IFwicG9zdFwiLCBkZWVwOiB0cnVlIH1cbiAgICApO1xuICAgIGxldCBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcbiAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNTdXNwZW5zZShpbnN0YW5jZS5zdWJUcmVlLnR5cGUpKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgICAgIH0sIGluc3RhbmNlLnN1YlRyZWUuc3VzcGVuc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcbiAgICBvblVwZGF0ZWQoY2FjaGVTdWJ0cmVlKTtcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgY2FjaGUuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCB2bm9kZSA9IGdldElubmVyQ2hpbGQoc3ViVHJlZSk7XG4gICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSAmJiBjYWNoZWQua2V5ID09PSB2bm9kZS5rZXkpIHtcbiAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICAgICAgY29uc3QgZGEgPSB2bm9kZS5jb21wb25lbnQuZGE7XG4gICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fCAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDQpICYmICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSkge1xuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XG4gICAgICBpZiAodm5vZGUudHlwZSA9PT0gQ29tbWVudCkge1xuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgaXNBc3luY1dyYXBwZXIodm5vZGUpID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge30gOiBjb21wXG4gICAgICApO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xuICAgICAgaWYgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSB8fCBleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkge1xuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XG4gICAgICBjb25zdCBjYWNoZWRWTm9kZSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKHZub2RlLmVsKSB7XG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xuICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XG4gICAgICAgIHZub2RlLmVsID0gY2FjaGVkVk5vZGUuZWw7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTI7XG4gICAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NjtcbiAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgIHJldHVybiBpc1N1c3BlbnNlKHJhd1ZOb2RlLnR5cGUpID8gcmF3Vk5vZGUgOiB2bm9kZTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcbmZ1bmN0aW9uIG1hdGNoZXMocGF0dGVybiwgbmFtZSkge1xuICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoXCIsXCIpLmluY2x1ZGVzKG5hbWUpO1xuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImRhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fCAoaG9vay5fX3dkYyA9ICgpID0+IHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBob29rKCk7XG4gIH0pO1xuICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQucGFyZW50KSB7XG4gICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgIGluamVjdFRvS2VlcEFsaXZlUm9vdCh3cmFwcGVkSG9vaywgdHlwZSwgdGFyZ2V0LCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdFRvS2VlcEFsaXZlUm9vdChob29rLCB0eXBlLCB0YXJnZXQsIGtlZXBBbGl2ZVJvb3QpIHtcbiAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKFxuICAgIHR5cGUsXG4gICAgaG9vayxcbiAgICBrZWVwQWxpdmVSb290LFxuICAgIHRydWVcbiAgICAvKiBwcmVwZW5kICovXG4gICk7XG4gIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xuICB9LCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTY7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+NTEyO1xufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4ID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2VoIHx8IChob29rLl9fd2VoID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XG4gICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgaWYgKHByZXBlbmQpIHtcbiAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCBcIlwiKSk7XG4gICAgd2FybiQxKFxuICAgICAgYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguIExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICsgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmAgKVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gIGlmICghaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiKSB7XG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsICguLi5hcmdzKSA9PiBob29rKC4uLmFyZ3MpLCB0YXJnZXQpO1xuICB9XG59O1xuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIpO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFxuICBcImJ1XCJcbik7XG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXG4gIFwiYnVtXCJcbik7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiKTtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFxuICBcInNwXCJcbik7XG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIik7XG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIpO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBpbmplY3RIb29rKFwiZWNcIiwgaG9vaywgdGFyZ2V0KTtcbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9IFwiY29tcG9uZW50c1wiO1xuY29uc3QgRElSRUNUSVZFUyA9IFwiZGlyZWN0aXZlc1wiO1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sLmZvcihcInYtbmRjXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xuICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaWYgKHNlbGZOYW1lICYmIChzZWxmTmFtZSA9PT0gbmFtZSB8fCBzZWxmTmFtZSA9PT0gY2FtZWxpemUobmFtZSkgfHwgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSAoXG4gICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxuICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8IC8vIGdsb2JhbCByZWdpc3RyYXRpb25cbiAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSlcbiAgICApO1xuICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgICAgY29uc3QgZXh0cmEgPSB0eXBlID09PSBDT01QT05FTlRTID8gYFxuSWYgdGhpcyBpcyBhIG5hdGl2ZSBjdXN0b20gZWxlbWVudCwgbWFrZSBzdXJlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gIDogYGA7XG4gICAgICB3YXJuJDEoYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcbiAgcmV0dXJuIHJlZ2lzdHJ5ICYmIChyZWdpc3RyeVtuYW1lXSB8fCByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHwgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xuICBsZXQgcmV0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVtpbmRleF07XG4gIGNvbnN0IHNvdXJjZUlzQXJyYXkgPSBpc0FycmF5KHNvdXJjZSk7XG4gIGlmIChzb3VyY2VJc0FycmF5IHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICBjb25zdCBzb3VyY2VJc1JlYWN0aXZlQXJyYXkgPSBzb3VyY2VJc0FycmF5ICYmIGlzUmVhY3RpdmUoc291cmNlKTtcbiAgICBsZXQgbmVlZHNXcmFwID0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZUlzUmVhY3RpdmVBcnJheSkge1xuICAgICAgbmVlZHNXcmFwID0gIWlzU2hhbGxvdyhzb3VyY2UpO1xuICAgICAgc291cmNlID0gc2hhbGxvd1JlYWRBcnJheShzb3VyY2UpO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKFxuICAgICAgICBuZWVkc1dyYXAgPyB0b1JlYWN0aXZlKHNvdXJjZVtpXSkgOiBzb3VyY2VbaV0sXG4gICAgICAgIGksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgY2FjaGVkICYmIGNhY2hlZFtpXVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcbiAgICAgIHdhcm4kMShgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXkgPyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBzbG90LmZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzKSByZXMua2V5ID0gc2xvdC5rZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IDogc2xvdC5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBmYWxsYmFjaywgbm9TbG90dGVkKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmNlKSB7XG4gICAgaWYgKG5hbWUgIT09IFwiZGVmYXVsdFwiKSBwcm9wcy5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gb3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgW2NyZWF0ZVZOb2RlKFwic2xvdFwiLCBwcm9wcywgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSldLFxuICAgICAgNjRcbiAgICApO1xuICB9XG4gIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XG4gICAgd2FybiQxKFxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxuICAgICk7XG4gICAgc2xvdCA9ICgpID0+IFtdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gZmFsc2U7XG4gIH1cbiAgb3BlbkJsb2NrKCk7XG4gIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICBjb25zdCBzbG90S2V5ID0gcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgdmFsaWRTbG90Q29udGVudCAmJiB2YWxpZFNsb3RDb250ZW50LmtleTtcbiAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhcbiAgICBGcmFnbWVudCxcbiAgICB7XG4gICAgICBrZXk6IChzbG90S2V5ICYmICFpc1N5bWJvbChzbG90S2V5KSA/IHNsb3RLZXkgOiBgXyR7bmFtZX1gKSArIC8vICM3MjU2IGZvcmNlIGRpZmZlcmVudGlhdGUgZmFsbGJhY2sgY29udGVudCBmcm9tIGFjdHVhbCBjb250ZW50XG4gICAgICAoIXZhbGlkU2xvdENvbnRlbnQgJiYgZmFsbGJhY2sgPyBcIl9mYlwiIDogXCJcIilcbiAgICB9LFxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcbiAgICB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgPyA2NCA6IC0yXG4gICk7XG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArIFwiLXNcIl07XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJiAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pID8gdm5vZGVzIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgIHdhcm4kMShgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmV0W3ByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5ICYmIC9bQS1aXS8udGVzdChrZXkpID8gYG9uOiR7a2V5fWAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gIGlmICghaSkgcmV0dXJuIG51bGw7XG4gIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKSByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaSk7XG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XG59O1xuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogKGkpID0+IGksXG4gICAgJGVsOiAoaSkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogKGkpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcbiAgICAkYXR0cnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyxcbiAgICAkc2xvdHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyxcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcbiAgICAkcGFyZW50OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcbiAgICAkaG9zdDogKGkpID0+IGkuY2UsXG4gICAgJGVtaXQ6IChpKSA9PiBpLmVtaXQsXG4gICAgJG9wdGlvbnM6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUsXG4gICAgJGZvcmNlVXBkYXRlOiAoaSkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiB7XG4gICAgICBxdWV1ZUpvYihpLnVwZGF0ZSk7XG4gICAgfSksXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcbiAgICAkd2F0Y2g6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUFxuICB9KVxuKTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkXCI7XG5jb25zdCBoYXNTZXR1cEJpbmRpbmcgPSAoc3RhdGUsIGtleSkgPT4gc3RhdGUgIT09IEVNUFRZX09CSiAmJiAhc3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgaWYgKGtleVswXSAhPT0gXCIkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgIGNhc2UgMiAvKiBEQVRBICovOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcbiAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpXG4gICAgICApIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogT1RIRVIgKi87XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcbiAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xuICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiJGF0dHJzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UuYXR0cnMsIFwiZ2V0XCIsIFwiXCIpO1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIiRzbG90c1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXG4gICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSlcbiAgICApIHtcbiAgICAgIHJldHVybiBjc3NNb2R1bGU7XG4gICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpXG4gICAgKSB7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJiAoIWlzU3RyaW5nKGtleSkgfHwgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcbiAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcbiAgICBrZXkuaW5kZXhPZihcIl9fdlwiKSAhPT0gMCkpIHtcbiAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgd2FybiQxKGBDYW5ub3QgbXV0YXRlIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmcgXCIke2tleX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gPT09IFwiJFwiICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBoYXMoe1xuICAgIF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH1cbiAgfSwga2V5KSB7XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICByZXR1cm4gISFhY2Nlc3NDYWNoZVtrZXldIHx8IGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSB8fCBoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSB8fCAobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpIHx8IGhhc093bihjdHgsIGtleSkgfHwgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHwgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSk7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcbiAgICAgIHRhcmdldC5fLmFjY2Vzc0NhY2hlW2tleV0gPSAwO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsIFwidmFsdWVcIikpIHtcbiAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLnZhbHVlLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICB9XG59O1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcbiAgICB3YXJuJDEoXG4gICAgICBgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBrZXlzIHdpbGwgYmUgZW1wdHkgaW4gcHJvZHVjdGlvbiBtb2RlIHRvIGF2b2lkIHBlcmZvcm1hbmNlIG92ZXJoZWFkLmBcbiAgICApO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgfTtcbn1cbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XG4gIH0sXG4gIGhhcyhfLCBrZXkpIHtcbiAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09IFwiX1wiICYmICFpc0dsb2JhbGx5QWxsb3dlZChrZXkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIGtleVxuICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaGFzO1xuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6ICgpID0+IGluc3RhbmNlXG4gIH0pO1xuICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxuICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcbiAgICAgIHNldDogTk9PUFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBjdHgsXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICB9ID0gaW5zdGFuY2U7XG4gIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXApIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBzZXR1cCgpIHJldHVybiBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuJDEoXG4gIGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gXG4pO1xuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUV4cG9zZWApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVPcHRpb25zYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZVNsb3RzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVNsb3RzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVNb2RlbCgpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKFwiZGVmaW5lTW9kZWxcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybiQxKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICB9XG4gIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPckVtaXRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FycmF5KHByb3BzKSA/IHByb3BzLnJlZHVjZShcbiAgICAobm9ybWFsaXplZCwgcCkgPT4gKG5vcm1hbGl6ZWRbcF0gPSBudWxsLCBub3JtYWxpemVkKSxcbiAgICB7fVxuICApIDogcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgY29uc3QgcHJvcHMgPSBub3JtYWxpemVQcm9wc09yRW1pdHMocmF3KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX3NraXBcIikpIGNvbnRpbnVlO1xuICAgIGxldCBvcHQgPSBwcm9wc1trZXldO1xuICAgIGlmIChvcHQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICBvcHQgPSBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgfVxuICAgIGlmIChvcHQgJiYgZGVmYXVsdHNbYF9fc2tpcF8ke2tleX1gXSkge1xuICAgICAgb3B0LnNraXBGYWN0b3J5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VNb2RlbHMoYSwgYikge1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBhIHx8IGI7XG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpIHJldHVybiBhLmNvbmNhdChiKTtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGEpLCBub3JtYWxpemVQcm9wc09yRW1pdHMoYikpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvcHNSZXN0UHJveHkocHJvcHMsIGV4Y2x1ZGVkS2V5cykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBwcm9wc1trZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY3R4KSB7XG4gICAgd2FybiQxKFxuICAgICAgYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIFRoaXMgaXMgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICB9XG4gIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XG4gICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKChlKSA9PiB7XG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgd2FybiQxKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xuICAgIH1cbiAgfTtcbn1cbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcbiAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xuICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XG4gIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xuICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgLy8gc3RhdGVcbiAgICBkYXRhOiBkYXRhT3B0aW9ucyxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLFxuICAgIG1ldGhvZHMsXG4gICAgd2F0Y2g6IHdhdGNoT3B0aW9ucyxcbiAgICBwcm92aWRlOiBwcm92aWRlT3B0aW9ucyxcbiAgICBpbmplY3Q6IGluamVjdE9wdGlvbnMsXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgY3JlYXRlZCxcbiAgICBiZWZvcmVNb3VudCxcbiAgICBtb3VudGVkLFxuICAgIGJlZm9yZVVwZGF0ZSxcbiAgICB1cGRhdGVkLFxuICAgIGFjdGl2YXRlZCxcbiAgICBkZWFjdGl2YXRlZCxcbiAgICBiZWZvcmVEZXN0cm95LFxuICAgIGJlZm9yZVVubW91bnQsXG4gICAgZGVzdHJveWVkLFxuICAgIHVubW91bnRlZCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyVHJhY2tlZCxcbiAgICByZW5kZXJUcmlnZ2VyZWQsXG4gICAgZXJyb3JDYXB0dXJlZCxcbiAgICBzZXJ2ZXJQcmVmZXRjaCxcbiAgICAvLyBwdWJsaWMgQVBJXG4gICAgZXhwb3NlLFxuICAgIGluaGVyaXRBdHRycyxcbiAgICAvLyBhc3NldHNcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZXMsXG4gICAgZmlsdGVyc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbmplY3RPcHRpb25zKSB7XG4gICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xuICB9XG4gIGlmIChtZXRob2RzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkYXRhT3B0aW9ucykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxuICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG4gIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xuICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogTk9PUDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGdldCA9PT0gTk9PUCkge1xuICAgICAgICB3YXJuJDEoYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uKG9wdCkgJiYgaXNGdW5jdGlvbihvcHQuc2V0KSA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKSA6ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoKSA9PiB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gXG4gICAgICAgICk7XG4gICAgICB9IDogTk9PUDtcbiAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gYy52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHdhdGNoT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKSA6IHByb3ZpZGVPcHRpb25zO1xuICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNyZWF0ZWQpIHtcbiAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBob29rLmZvckVhY2goKF9ob29rKSA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XG4gICAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcbiAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xuICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcbiAgICAgIGV4cG9zZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxuICAgICAgICAgIHNldDogKHZhbCkgPT4gcHVibGljVGhpc1trZXldID0gdmFsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xuICAgIH1cbiAgfVxuICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xuICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcbiAgfVxuICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcbiAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMpIGluc3RhbmNlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICBpZiAoZGlyZWN0aXZlcykgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gIGlmIChzZXJ2ZXJQcmVmZXRjaCkge1xuICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QKSB7XG4gIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XG4gICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3RPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gaW5qZWN0T3B0aW9uc1trZXldO1xuICAgIGxldCBpbmplY3RlZDtcbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIG9wdCkge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChcbiAgICAgICAgICBvcHQuZnJvbSB8fCBrZXksXG4gICAgICAgICAgb3B0LmRlZmF1bHQsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0LmZyb20gfHwga2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0KTtcbiAgICB9XG4gICAgaWYgKGlzUmVmKGluamVjdGVkKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gaW5qZWN0ZWQudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4W2tleV0gPSBpbmplY3RlZDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgIGlzQXJyYXkoaG9vaykgPyBob29rLm1hcCgoaCkgPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSkgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLFxuICAgIGluc3RhbmNlLFxuICAgIHR5cGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xuICBsZXQgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KSA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgaWYgKGlzU3RyaW5nKHJhdykpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XG4gICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgIHtcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcbiAgICB7XG4gICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xuICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgIHJhdy5mb3JFYWNoKChyKSA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKSA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcykgOiBjdHhbcmF3LmhhbmRsZXJdO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcbiAgY29uc3Qge1xuICAgIG1peGluczogZ2xvYmFsTWl4aW5zLFxuICAgIG9wdGlvbnNDYWNoZTogY2FjaGUsXG4gICAgY29uZmlnOiB7IG9wdGlvbk1lcmdlU3RyYXRlZ2llcyB9XG4gIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XG4gIGxldCByZXNvbHZlZDtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJlc29sdmVkID0gY2FjaGVkO1xuICB9IGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XG4gICAge1xuICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZCA9IHt9O1xuICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XG4gICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChcbiAgICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKVxuICAgICAgKTtcbiAgICB9XG4gICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xuICB9XG4gIGlmIChpc09iamVjdChiYXNlKSkge1xuICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XG4gIGlmIChleHRlbmRzT3B0aW9ucykge1xuICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XG4gIH1cbiAgaWYgKG1peGlucykge1xuICAgIG1peGlucy5mb3JFYWNoKFxuICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKVxuICAgICk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIGlmIChhc01peGluICYmIGtleSA9PT0gXCJleHBvc2VcIikge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgc3RyYXRzICYmIHN0cmF0c1trZXldO1xuICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcbiAgZGF0YTogbWVyZ2VEYXRhRm4sXG4gIHByb3BzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIGVtaXRzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIC8vIG9iamVjdHNcbiAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyBsaWZlY3ljbGVcbiAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXG4gIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlTW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcbiAgdXBkYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgZGVzdHJveWVkOiBtZXJnZUFzQXJyYXksXG4gIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZGVhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxuICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxuICAvLyBhc3NldHNcbiAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIHdhdGNoXG4gIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcbiAgLy8gcHJvdmlkZSAvIGluamVjdFxuICBwcm92aWRlOiBtZXJnZURhdGFGbixcbiAgaW5qZWN0OiBtZXJnZUluamVjdFxufTtcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkge1xuICAgIHJldHVybiB0bztcbiAgfVxuICBpZiAoIXRvKSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICByZXR1cm4gKGV4dGVuZCkoXG4gICAgICBpc0Z1bmN0aW9uKHRvKSA/IHRvLmNhbGwodGhpcywgdGhpcykgOiB0byxcbiAgICAgIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XG4gIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChyYXcpIHtcbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gcmF3O1xufVxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0bywgZnJvbSkgOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICh0bykge1xuICAgIGlmIChpc0FycmF5KHRvKSAmJiBpc0FycmF5KGZyb20pKSB7XG4gICAgICByZXR1cm4gWy4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi50bywgLi4uZnJvbV0pXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZChcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKHRvKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhmcm9tICE9IG51bGwgPyBmcm9tIDoge30pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKCF0bykgcmV0dXJuIGZyb207XG4gIGlmICghZnJvbSkgcmV0dXJuIHRvO1xuICBjb25zdCBtZXJnZWQgPSBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhcHA6IG51bGwsXG4gICAgY29uZmlnOiB7XG4gICAgICBpc05hdGl2ZVRhZzogTk8sXG4gICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcbiAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXG4gICAgICBlcnJvckhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHdhcm5IYW5kbGVyOiB2b2lkIDAsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHt9XG4gICAgfSxcbiAgICBtaXhpbnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgIHByb3ZpZGVzOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBvcHRpb25zQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIHByb3BzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIGVtaXRzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gIH07XG59XG5sZXQgdWlkJDEgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcbiAgICAgIHJvb3RDb21wb25lbnQgPSBleHRlbmQoe30sIHJvb3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHBsdWdpbkNsZWFudXBGbnMgPSBbXTtcbiAgICBsZXQgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgY29uc3QgYXBwID0gY29udGV4dC5hcHAgPSB7XG4gICAgICBfdWlkOiB1aWQkMSsrLFxuICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcbiAgICAgIF9wcm9wczogcm9vdFByb3BzLFxuICAgICAgX2NvbnRhaW5lcjogbnVsbCxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2luc3RhbmNlOiBudWxsLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcbiAgICAgIH0sXG4gICAgICBzZXQgY29uZmlnKHYpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBmdW5jdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1peGluKG1peGluKSB7XG4gICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XG4gICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcbiAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBcIk1peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwXCIgKyAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMShgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlyZWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuJDEoYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cbiBJZiB5b3Ugd2FudCB0byBtb3VudCBhbm90aGVyIGFwcCBvbiB0aGUgc2FtZSBob3N0IGNvbnRhaW5lciwgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2bm9kZSA9IGFwcC5fY2VWTm9kZSB8fCBjcmVhdGVWTm9kZShyb290Q29tcG9uZW50LCByb290UHJvcHMpO1xuICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmVuZGVyKFxuICAgICAgICAgICAgICAgIGNsb25lVk5vZGUodm5vZGUpLFxuICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcbiAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xuICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSh2bm9kZS5jb21wb25lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cbklmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Vbm1vdW50KGNsZWFudXBGbikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0eXBlb2YgY2xlYW51cEZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnQgdG8gYXBwLm9uVW5tb3VudCgpLCBidXQgZ290ICR7dHlwZW9mIGNsZWFudXBGbn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwbHVnaW5DbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuKTtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICAgICAgICBwbHVnaW5DbGVhbnVwRm5zLFxuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSxcbiAgICAgICAgICAgIDE2XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICBkZXZ0b29sc1VubW91bnRBcHAoYXBwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgcnVuV2l0aENvbnRleHQoZm4pIHtcbiAgICAgICAgY29uc3QgbGFzdEFwcCA9IGN1cnJlbnRBcHA7XG4gICAgICAgIGN1cnJlbnRBcHAgPSBhcHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudEFwcCA9IGxhc3RBcHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhcHA7XG4gIH07XG59XG5sZXQgY3VycmVudEFwcCA9IG51bGw7XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICB9XG4gICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlIHx8IGN1cnJlbnRBcHApIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGN1cnJlbnRBcHAgPyBjdXJyZW50QXBwLl9jb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UgPyBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbCA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlcyA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcyA6IHZvaWQgMDtcbiAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XG4gICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5KSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xuICB9XG59XG5mdW5jdGlvbiBoYXNJbmplY3Rpb25Db250ZXh0KCkge1xuICByZXR1cm4gISEoY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50QXBwKTtcbn1cblxuY29uc3QgaW50ZXJuYWxPYmplY3RQcm90byA9IHt9O1xuY29uc3QgY3JlYXRlSW50ZXJuYWxPYmplY3QgPSAoKSA9PiBPYmplY3QuY3JlYXRlKGludGVybmFsT2JqZWN0UHJvdG8pO1xuY29uc3QgaXNJbnRlcm5hbE9iamVjdCA9IChvYmopID0+IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBpbnRlcm5hbE9iamVjdFByb3RvO1xuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGNvbnN0IHByb3BzID0ge307XG4gIGNvbnN0IGF0dHJzID0gY3JlYXRlSW50ZXJuYWxPYmplY3QoKTtcbiAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcbiAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICBwcm9wc1trZXldID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGlzU3RhdGVmdWwpIHtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYXR0cnMgPSBhdHRycztcbn1cbmZ1bmN0aW9uIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIHdoaWxlIChpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS50eXBlLl9faG1ySWQpIHJldHVybiB0cnVlO1xuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50O1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHJhd1ByZXZQcm9wcywgb3B0aW1pemVkKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9wcyxcbiAgICBhdHRycyxcbiAgICB2bm9kZTogeyBwYXRjaEZsYWcgfVxuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3QgW29wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxuICAgIC8vIC0gIzE5NDIgaWYgaG1yIGlzIGVuYWJsZWQgd2l0aCBzZmMgY29tcG9uZW50XG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcbiAgICAhKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpKSAmJiAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmICEocGF0Y2hGbGFnICYgMTYpXG4gICkge1xuICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xuICAgICAgICBpZiAoaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBjYW1lbGl6ZWRLZXksXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcbiAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGxldCBrZWJhYktleTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgIGlmICghcmF3UHJvcHMgfHwgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAvLyBpdCdzIHBvc3NpYmxlIHRoZSBvcmlnaW5hbCBwcm9wcyB3YXMgcGFzc2VkIGluIGFzIGtlYmFiLWNhc2VcbiAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxuICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmIC8vIGZvciBjYW1lbENhc2VcbiAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHZvaWQgMCB8fCAvLyBmb3Iga2ViYWItY2FzZVxuICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHZvaWQgMCkpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJzICE9PSByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmICghcmF3UHJvcHMgfHwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XG4gICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XG4gICAgdHJpZ2dlcihpbnN0YW5jZS5hdHRycywgXCJzZXRcIiwgXCJcIik7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcbiAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgbGV0IHJhd0Nhc3RWYWx1ZXM7XG4gIGlmIChyYXdQcm9wcykge1xuICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICBsZXQgY2FtZWxLZXk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkge1xuICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xuICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChyYXdDYXN0VmFsdWVzIHx8IChyYXdDYXN0VmFsdWVzID0ge30pKVtjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmVlZENhc3RLZXlzKSB7XG4gICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICAgIGNvbnN0IGNhc3RWYWx1ZXMgPSByYXdDYXN0VmFsdWVzIHx8IEVNUFRZX09CSjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAga2V5LFxuICAgICAgICBjYXN0VmFsdWVzW2tleV0sXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICAhaGFzT3duKGNhc3RWYWx1ZXMsIGtleSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNBdHRyc0NoYW5nZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSwgaXNBYnNlbnQpIHtcbiAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xuICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdCwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xuICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiAhb3B0LnNraXBGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoa2V5IGluIHByb3BzRGVmYXVsdHMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdGFuY2UuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuY2UuX3NldFByb3Aoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xuICAgICAgaWYgKGlzQWJzZW50ICYmICFoYXNEZWZhdWx0KSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IG1peGluUHJvcHNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IF9fVlVFX09QVElPTlNfQVBJX18gJiYgYXNNaXhpbiA/IG1peGluUHJvcHNDYWNoZSA6IGFwcENvbnRleHQucHJvcHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdzIpID0+IHtcbiAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XG4gICAgICBpZiAoa2V5cykgbmVlZENhc3RLZXlzLnB1c2goLi4ua2V5cyk7XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBFTVBUWV9BUlIpO1xuICAgIH1cbiAgICByZXR1cm4gRU1QVFlfQVJSO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzU3RyaW5nKHJhd1tpXSkpIHtcbiAgICAgICAgd2FybiQxKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShyYXdbaV0pO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmF3KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KHJhdykpIHtcbiAgICAgIHdhcm4kMShgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xuICAgICAgICBjb25zdCBwcm9wID0gbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogZXh0ZW5kKHt9LCBvcHQpO1xuICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHByb3AudHlwZTtcbiAgICAgICAgbGV0IHNob3VsZENhc3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNob3VsZENhc3RUcnVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzQXJyYXkocHJvcFR5cGUpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb3BUeXBlLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHByb3BUeXBlW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID0gaXNGdW5jdGlvbih0eXBlKSAmJiB0eXBlLm5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZU5hbWUgPT09IFwiQm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgIHNob3VsZENhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgc2hvdWxkQ2FzdFRydWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvdWxkQ2FzdCA9IGlzRnVuY3Rpb24ocHJvcFR5cGUpICYmIHByb3BUeXBlLm5hbWUgPT09IFwiQm9vbGVhblwiO1xuICAgICAgICB9XG4gICAgICAgIHByb3BbMCAvKiBzaG91bGRDYXN0ICovXSA9IHNob3VsZENhc3Q7XG4gICAgICAgIHByb3BbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gPSBzaG91bGRDYXN0VHJ1ZTtcbiAgICAgICAgaWYgKHNob3VsZENhc3QgfHwgaGFzT3duKHByb3AsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdO1xuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wTmFtZShrZXkpIHtcbiAgaWYgKGtleVswXSAhPT0gXCIkXCIgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xuICBpZiAoY3RvciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAodHlwZW9mIGN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjdG9yLm5hbWUgfHwgXCJcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY3RvciA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IG5hbWUgPSBjdG9yLmNvbnN0cnVjdG9yICYmIGN0b3IuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gbmFtZSB8fCBcIlwiO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xuICBjb25zdCBjYW1lbGl6ZVByb3BzS2V5ID0gT2JqZWN0LmtleXMocmF3UHJvcHMpLm1hcCgoa2V5KSA9PiBjYW1lbGl6ZShrZXkpKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XG4gICAgaWYgKG9wdCA9PSBudWxsKSBjb250aW51ZTtcbiAgICB2YWxpZGF0ZVByb3AoXG4gICAgICBrZXksXG4gICAgICByZXNvbHZlZFZhbHVlc1trZXldLFxuICAgICAgb3B0LFxuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShyZXNvbHZlZFZhbHVlcykgOiByZXNvbHZlZFZhbHVlcyxcbiAgICAgICFjYW1lbGl6ZVByb3BzS2V5LmluY2x1ZGVzKGtleSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIHByb3BzLCBpc0Fic2VudCkge1xuICBjb25zdCB7IHR5cGUsIHJlcXVpcmVkLCB2YWxpZGF0b3IsIHNraXBDaGVjayB9ID0gcHJvcDtcbiAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XG4gICAgd2FybiQxKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXJlcXVpcmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZSAhPT0gdHJ1ZSAmJiAhc2tpcENoZWNrKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChleHBlY3RlZFR5cGUgfHwgXCJcIik7XG4gICAgICBpc1ZhbGlkID0gdmFsaWQ7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgd2FybiQxKGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUsIHByb3BzKSkge1xuICAgIHdhcm4kMSgnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xuICB9XG59XG5jb25zdCBpc1NpbXBsZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgXCJTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludFwiXG4pO1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICBsZXQgdmFsaWQ7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgdmFsaWQgPSB2YWx1ZSA9PT0gbnVsbDtcbiAgfSBlbHNlIGlmIChpc1NpbXBsZVR5cGUoZXhwZWN0ZWRUeXBlKSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwiT2JqZWN0XCIpIHtcbiAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwiQXJyYXlcIikge1xuICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYFByb3AgdHlwZSBbXSBmb3IgcHJvcCBcIiR7bmFtZX1cIiB3b24ndCBtYXRjaCBhbnl0aGluZy4gRGlkIHlvdSBtZWFuIHRvIHVzZSB0eXBlIEFycmF5IGluc3RlYWQ/YDtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLiBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oXCIgfCBcIil9YDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiYgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiYgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgfVxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBcIlN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiTnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICB9XG59XG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xuICBjb25zdCBleHBsaWNpdFR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZSgoZWxlbSkgPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnNvbWUoKGVsZW0pID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gXCJib29sZWFuXCIpO1xufVxuXG5jb25zdCBpc0ludGVybmFsS2V5ID0gKGtleSkgPT4ga2V5WzBdID09PSBcIl9cIiB8fCBrZXkgPT09IFwiJHN0YWJsZVwiO1xuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSkgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcbiAgaWYgKHJhd1Nsb3QuX24pIHtcbiAgICByZXR1cm4gcmF3U2xvdDtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgoLi4uYXJncykgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRJbnN0YW5jZSAmJiAoIWN0eCB8fCBjdHgucm9vdCA9PT0gY3VycmVudEluc3RhbmNlLnJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdCguLi5hcmdzKSk7XG4gIH0sIGN0eCk7XG4gIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xuICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHZhbHVlID0gcmF3U2xvdHNba2V5XTtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHNsb3RzW2tleV0gPSBub3JtYWxpemVTbG90KGtleSwgdmFsdWUsIGN0eCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBzbG90IFwiJHtrZXl9XCIuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xuICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSAmJiB0cnVlKSB7XG4gICAgd2FybiQxKFxuICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcbiAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XG59O1xuY29uc3QgYXNzaWduU2xvdHMgPSAoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRyZW4pIHtcbiAgICBpZiAob3B0aW1pemVkIHx8IGtleSAhPT0gXCJfXCIpIHtcbiAgICAgIHNsb3RzW2tleV0gPSBjaGlsZHJlbltrZXldO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGluaXRTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBjb25zdCBzbG90cyA9IGluc3RhbmNlLnNsb3RzID0gY3JlYXRlSW50ZXJuYWxPYmplY3QoKTtcbiAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgIGlmIChvcHRpbWl6ZWQpIHtcbiAgICAgICAgZGVmKHNsb3RzLCBcIl9cIiwgdHlwZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICB9XG59O1xuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xuICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xuICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIsIFwiJHNsb3RzXCIpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSkge1xuICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICB9XG4gICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XG4gIH1cbiAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldFtrZXldID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5sZXQgc3VwcG9ydGVkO1xubGV0IHBlcmY7XG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBwZXJmLm1hcmsoYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWApO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YDtcbiAgICBjb25zdCBlbmRUYWcgPSBzdGFydFRhZyArIGA6ZW5kYDtcbiAgICBwZXJmLm1hcmsoZW5kVGFnKTtcbiAgICBwZXJmLm1lYXN1cmUoXG4gICAgICBgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCxcbiAgICAgIHN0YXJ0VGFnLFxuICAgICAgZW5kVGFnXG4gICAgKTtcbiAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzUGVyZkVuZChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XG4gIGNvbnN0IG5lZWRXYXJuID0gW107XG4gIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX09QVElPTlNfQVBJX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0RFVlRPT0xTX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fID0gZmFsc2U7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XG4gICAgY29uc3QgbXVsdGkgPSBuZWVkV2Fybi5sZW5ndGggPiAxO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbihcIiwgXCIpfSAke211bHRpID8gYGFyZWAgOiBgaXNgfSBub3QgZXhwbGljaXRseSBkZWZpbmVkLiBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZSwgd2hpY2ggZXhwZWN0cyB0aGVzZSBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyB0byBiZSBnbG9iYWxseSBpbmplY3RlZCB2aWEgdGhlIGJ1bmRsZXIgY29uZmlnIGluIG9yZGVyIHRvIGdldCBiZXR0ZXIgdHJlZS1zaGFraW5nIGluIHRoZSBwcm9kdWN0aW9uIGJ1bmRsZS5cblxuRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QgPSBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSA7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcbn1cbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAge1xuICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIHRhcmdldC5fX1ZVRV9fID0gdHJ1ZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgc2V0RGV2dG9vbHNIb29rJDEodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sIHRhcmdldCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGluc2VydDogaG9zdEluc2VydCxcbiAgICByZW1vdmU6IGhvc3RSZW1vdmUsXG4gICAgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LFxuICAgIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LFxuICAgIHNldFRleHQ6IGhvc3RTZXRUZXh0LFxuICAgIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsXG4gICAgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZyxcbiAgICBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIG5hbWVzcGFjZSA9IHZvaWQgMCwgc2xvdFNjb3BlSWRzID0gbnVsbCwgb3B0aW1pemVkID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xuICAgIGlmIChuMSA9PT0gbjIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4xICYmICFpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcbiAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgbjEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEpIHtcbiAgICAgICAgICBwcm9jZXNzRWxlbWVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xuICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCBcIlwiKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpID0+IHtcbiAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbjIuZWwsXG4gICAgICBuMi5hbmNob3JcbiAgICApO1xuICB9O1xuICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XG4gICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICB9O1xuICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgaWYgKG4yLnR5cGUgPT09IFwic3ZnXCIpIHtcbiAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgfSBlbHNlIGlmIChuMi50eXBlID09PSBcIm1hdGhcIikge1xuICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50RWxlbWVudChcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaEVsZW1lbnQoXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgZWw7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBjb25zdCB7IHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIGRpcnMgfSA9IHZub2RlO1xuICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudChcbiAgICAgIHZub2RlLnR5cGUsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBwcm9wcyAmJiBwcm9wcy5pcyxcbiAgICAgIHByb3BzXG4gICAgKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCB2bm9kZS5jaGlsZHJlbik7XG4gICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2Uodm5vZGUsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgfVxuICAgIHNldFNjb3BlSWQoZWwsIHZub2RlLCB2bm9kZS5zY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCk7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoa2V5ICE9PSBcInZhbHVlXCIgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBwcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG51bGwsIHByb3BzLnZhbHVlLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlSG9vayA9IHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZWYoZWwsIFwiX192bm9kZVwiLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICBkZWYoZWwsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwgcGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihwYXJlbnRTdXNwZW5zZSwgdHJhbnNpdGlvbik7XG4gICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9XG4gICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBpZiAoc2NvcGVJZCkge1xuICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xuICAgIH1cbiAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RTY29wZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgbGV0IHN1YlRyZWUgPSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJiBzdWJUcmVlLnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICAgICAgc3ViVHJlZSA9IGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZSA9PT0gc3ViVHJlZSB8fCBpc1N1c3BlbnNlKHN1YlRyZWUudHlwZSkgJiYgKHN1YlRyZWUuc3NDb250ZW50ID09PSB2bm9kZSB8fCBzdWJUcmVlLnNzRmFsbGJhY2sgPT09IHZub2RlKSkge1xuICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcbiAgICAgICAgc2V0U2NvcGVJZChcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRWTm9kZSxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zY29wZUlkLFxuICAgICAgICAgIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQucGFyZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSkgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGVsLl9fdm5vZGUgPSBuMjtcbiAgICB9XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xuICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNjtcbiAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGlmICh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgICB9XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAob2xkUHJvcHMuaW5uZXJIVE1MICYmIG5ld1Byb3BzLmlubmVySFRNTCA9PSBudWxsIHx8IG9sZFByb3BzLnRleHRDb250ZW50ICYmIG5ld1Byb3BzLnRleHRDb250ZW50ID09IG51bGwpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgXCJcIik7XG4gICAgfVxuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UobjIsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZShuMiwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgICBwYXRjaFByb3BzKGVsLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAyKSB7XG4gICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJjbGFzc1wiLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgbmFtZXNwYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInN0eWxlXCIsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8IGtleSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEpIHtcbiAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICBwYXRjaFByb3BzKGVsLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlKTtcbiAgICB9XG4gICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcbiAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcInVwZGF0ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEJsb2NrQ2hpbGRyZW4gPSAob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBmYWxsYmFja0NvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IChcbiAgICAgICAgLy8gb2xkVk5vZGUgbWF5IGJlIGFuIGVycm9yZWQgYXN5bmMgc2V0dXAoKSBjb21wb25lbnQgaW5zaWRlIFN1c3BlbnNlXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcbiAgICAgICAgb2xkVk5vZGUuZWwgJiYgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXG4gICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxuICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXG4gICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IHwgNjQpKSA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKSA6IChcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcbiAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXG4gICAgICAgICAgZmFsbGJhY2tDb250YWluZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBvbGRWTm9kZSxcbiAgICAgICAgbmV3Vk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRQcm9wc1trZXldLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICBpZiAobmV4dCAhPT0gcHJldiAmJiBrZXkgIT09IFwidmFsdWVcIikge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gbjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgY29uc3QgZnJhZ21lbnRFbmRBbmNob3IgPSBuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgKGlzSG1yVXBkYXRpbmcgfHwgcGF0Y2hGbGFnICYgMjA0OCkpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgLy8gIzEwMDA3XG4gICAgICAgIC8vIHN1Y2ggZnJhZ21lbnQgbGlrZSBgPD48Lz5gIHdpbGwgYmUgY29tcGlsZWQgaW50b1xuICAgICAgICAvLyBhIGZyYWdtZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIGNoaWxkcmVuLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UgZmFsbGJhY2sgdG8gYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgbjIuY2hpbGRyZW4gfHwgW10sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0ICYmIGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjMjcxNSB0aGUgcHJldmlvdXMgZnJhZ21lbnQgY291bGQndmUgYmVlbiBhIEJBSUxlZCBvbmUgYXMgYSByZXN1bHRcbiAgICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXG4gICAgICBuMS5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxuICAgICAgICAgIC8vICBnZXQgbW92ZWQgYXJvdW5kLiBNYWtlIHN1cmUgYWxsIHJvb3QgbGV2ZWwgdm5vZGVzIGluaGVyaXQgZWwuXG4gICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXG4gICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cbiAgICAgICAgICBuMi5rZXkgIT0gbnVsbCB8fCBwYXJlbnRDb21wb25lbnQgJiYgbjIgPT09IHBhcmVudENvbXBvbmVudC5zdWJUcmVlXG4gICAgICAgICkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgLyogc2hhbGxvdyAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyKSB7XG4gICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShcbiAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgKSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcbiAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XG4gICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XG4gICAgfVxuICAgIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICAgIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBmYWxzZSwgb3B0aW1pemVkKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykgaW5pdGlhbFZOb2RlLmVsID0gbnVsbDtcbiAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkKTtcbiAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBpbml0aWFsVk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG4yLmNvbXBvbmVudCA9IG4xLmNvbXBvbmVudDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG4yLCBvcHRpbWl6ZWQpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50VXBkYXRlRm4gPSAoKSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQsIHJvb3QsIHR5cGUgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcbiAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgdHlwZS5fX2FzeW5jSHlkcmF0ZSkge1xuICAgICAgICAgICAgdHlwZS5fX2FzeW5jSHlkcmF0ZShcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBoeWRyYXRlU3ViVHJlZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJvb3QuY2UpIHtcbiAgICAgICAgICAgIHJvb3QuY2UuX2luamVjdENoaWxkU3R5bGUodHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3ViVHJlZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkpIHtcbiAgICAgICAgICBjb25zdCBzY29wZWRJbml0aWFsVk5vZGUgPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IHx8IHBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihwYXJlbnQudm5vZGUpICYmIHBhcmVudC52bm9kZS5zaGFwZUZsYWcgJiAyNTYpIHtcbiAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbFZOb2RlID0gY29udGFpbmVyID0gYW5jaG9yID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vbkh5ZHJhdGVkQXN5bmNSb290ID0gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChub25IeWRyYXRlZEFzeW5jUm9vdCkge1xuICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub25IeWRyYXRlZEFzeW5jUm9vdC5hc3luY0RlcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFVwZGF0ZUZuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JpZ2luTmV4dCA9IG5leHQ7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnUpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBwcmV2VHJlZSxcbiAgICAgICAgICBuZXh0VHJlZSxcbiAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XG4gICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmVsID0gbmV4dFRyZWUuZWw7XG4gICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCBuZXh0VHJlZS5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZVVwZGF0ZWQpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbiAgICBjb25zdCBlZmZlY3QgPSBpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoY29tcG9uZW50VXBkYXRlRm4pO1xuICAgIGluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IGluc3RhbmNlLnVwZGF0ZSA9IGVmZmVjdC5ydW4uYmluZChlZmZlY3QpO1xuICAgIGNvbnN0IGpvYiA9IGluc3RhbmNlLmpvYiA9IGVmZmVjdC5ydW5JZkRpcnR5LmJpbmQoZWZmZWN0KTtcbiAgICBqb2IuaSA9IGluc3RhbmNlO1xuICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICBlZmZlY3Quc2NoZWR1bGVyID0gKCkgPT4gcXVldWVKb2Ioam9iKTtcbiAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZWZmZWN0Lm9uVHJhY2sgPSBpbnN0YW5jZS5ydGMgPyAoZSkgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRjLCBlKSA6IHZvaWQgMDtcbiAgICAgIGVmZmVjdC5vblRyaWdnZXIgPSBpbnN0YW5jZS5ydGcgPyAoZSkgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRnLCBlKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdXBkYXRlKCk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XG4gICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XG4gICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGZsdXNoUHJlRmx1c2hDYnMoaW5zdGFuY2UpO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xuICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcbiAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCkge1xuICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYpIHtcbiAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGMyICE9PSBjMSkge1xuICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxuICAgICAgICAgICAgYzEsXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcbiAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcbiAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XG4gICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xuICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGMxW2ldLFxuICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xuICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICBjMSxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgYzIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICBjb21tb25MZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsMiA9IGMyLmxlbmd0aDtcbiAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxO1xuICAgIGxldCBlMiA9IGwyIC0gMTtcbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2ldO1xuICAgICAgY29uc3QgbjIgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbZTJdID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGUxLS07XG4gICAgICBlMi0tO1xuICAgIH1cbiAgICBpZiAoaSA+IGUxKSB7XG4gICAgICBpZiAoaSA8PSBlMikge1xuICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgd2hpbGUgKGkgPD0gZTIpIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGkgPiBlMikge1xuICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcbiAgICAgICAgdW5tb3VudChjMVtpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgczEgPSBpO1xuICAgICAgY29uc3QgczIgPSBpO1xuICAgICAgY29uc3Qga2V5VG9OZXdJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGkgPSBzMjsgaSA8PSBlMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksXG4gICAgICAgICAgICAgIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBwYXRjaGVkID0gMDtcbiAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XG4gICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcbiAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdG9CZVBhdGNoZWQ7IGkrKykgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcbiAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldkNoaWxkID0gYzFbaV07XG4gICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdJbmRleDtcbiAgICAgICAgaWYgKHByZXZDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gczI7IGogPD0gZTI7IGorKykge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xuICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcbiAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xuICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgcHJldkNoaWxkLFxuICAgICAgICAgICAgYzJbbmV3SW5kZXhdLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwYXRjaGVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlID0gbW92ZWQgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApIDogRU1QVFlfQVJSO1xuICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHMyICsgaTtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPT09IDApIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uMiA9IG1vdmVUeXBlICE9PSAyICYmIHNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbjtcbiAgICBpZiAobmVlZFRyYW5zaXRpb24yKSB7XG4gICAgICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCByZW1vdmUyID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZTIoKTtcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZTIsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGRpcnMsXG4gICAgICBjYWNoZUluZGV4XG4gICAgfSA9IHZub2RlO1xuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoY2FjaGVJbmRleCAhPSBudWxsKSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQucmVuZGVyQ2FjaGVbY2FjaGVJbmRleF0gPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxICYmIGRpcnM7XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50KHZub2RlLmNvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVbm1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmIC8vICM1MTU0XG4gICAgICAvLyB3aGVuIHYtb25jZSBpcyB1c2VkIGluc2lkZSBhIGJsb2NrLCBzZXRCbG9ja1RyYWNraW5nKC0xKSBtYXJrcyB0aGVcbiAgICAgIC8vIHBhcmVudCBibG9jayB3aXRoIGhhc09uY2U6IHRydWVcbiAgICAgIC8vIHNvIHRoYXQgaXQgZG9lc24ndCB0YWtlIHRoZSBmYXN0IHBhdGggZHVyaW5nIHVubW91bnQgLSBvdGhlcndpc2VcbiAgICAgIC8vIGNvbXBvbmVudHMgbmVzdGVkIGluIHYtb25jZSBhcmUgbmV2ZXIgdW5tb3VudGVkLlxuICAgICAgIWR5bmFtaWNDaGlsZHJlbi5oYXNPbmNlICYmIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8IHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQpKSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRnJhZ21lbnQgJiYgcGF0Y2hGbGFnICYgKDEyOCB8IDI1NikgfHwgIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVtb3ZlKSB7XG4gICAgICAgIHJlbW92ZSh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwidW5tb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLnBhdGNoRmxhZyA+IDAgJiYgdm5vZGUucGF0Y2hGbGFnICYgMjA0OCAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQgJiYgdHJhbnNpdGlvbi5hZnRlckxlYXZlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICBkZWxheUxlYXZlKHZub2RlLmVsLCBwZXJmb3JtUmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGN1ciAhPT0gZW5kKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XG4gICAgICBob3N0UmVtb3ZlKGN1cik7XG4gICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGVuZCk7XG4gIH07XG4gIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgdW5yZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgam9iLCBzdWJUcmVlLCB1bSwgbSwgYSB9ID0gaW5zdGFuY2U7XG4gICAgaW52YWxpZGF0ZU1vdW50KG0pO1xuICAgIGludmFsaWRhdGVNb3VudChhKTtcbiAgICBpZiAoYnVtKSB7XG4gICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgIH1cbiAgICBzY29wZS5zdG9wKCk7XG4gICAgaWYgKGpvYikge1xuICAgICAgam9iLmZsYWdzIHw9IDg7XG4gICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH1cbiAgICBpZiAodW0pIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1bSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiYgaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgJiYgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldE5leHRIb3N0Tm9kZSA9ICh2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgcmV0dXJuIHZub2RlLnN1c3BlbnNlLm5leHQoKTtcbiAgICB9XG4gICAgY29uc3QgZWwgPSBob3N0TmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yIHx8IHZub2RlLmVsKTtcbiAgICBjb25zdCB0ZWxlcG9ydEVuZCA9IGVsICYmIGVsW1RlbGVwb3J0RW5kS2V5XTtcbiAgICByZXR1cm4gdGVsZXBvcnRFbmQgPyBob3N0TmV4dFNpYmxpbmcodGVsZXBvcnRFbmQpIDogZWw7XG4gIH07XG4gIGxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAodm5vZGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5fdm5vZGUpIHtcbiAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2goXG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcDogcGF0Y2gsXG4gICAgdW06IHVubW91bnQsXG4gICAgbTogbW92ZSxcbiAgICByOiByZW1vdmUsXG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgIG46IGdldE5leHRIb3N0Tm9kZSxcbiAgICBvOiBvcHRpb25zXG4gIH07XG4gIGxldCBoeWRyYXRlO1xuICBsZXQgaHlkcmF0ZU5vZGU7XG4gIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKFxuICAgICAgaW50ZXJuYWxzXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbmRlcixcbiAgICBoeWRyYXRlLFxuICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZSh7IHR5cGUsIHByb3BzIH0sIGN1cnJlbnROYW1lc3BhY2UpIHtcbiAgcmV0dXJuIGN1cnJlbnROYW1lc3BhY2UgPT09IFwic3ZnXCIgJiYgdHlwZSA9PT0gXCJmb3JlaWduT2JqZWN0XCIgfHwgY3VycmVudE5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiAmJiB0eXBlID09PSBcImFubm90YXRpb24teG1sXCIgJiYgcHJvcHMgJiYgcHJvcHMuZW5jb2RpbmcgJiYgcHJvcHMuZW5jb2RpbmcuaW5jbHVkZXMoXCJodG1sXCIpID8gdm9pZCAwIDogY3VycmVudE5hbWVzcGFjZTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVJlY3Vyc2UoeyBlZmZlY3QsIGpvYiB9LCBhbGxvd2VkKSB7XG4gIGlmIChhbGxvd2VkKSB7XG4gICAgZWZmZWN0LmZsYWdzIHw9IDMyO1xuICAgIGpvYi5mbGFncyB8PSA0O1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5mbGFncyAmPSB+MzI7XG4gICAgam9iLmZsYWdzICY9IH40O1xuICB9XG59XG5mdW5jdGlvbiBuZWVkVHJhbnNpdGlvbihwYXJlbnRTdXNwZW5zZSwgdHJhbnNpdGlvbikge1xuICByZXR1cm4gKCFwYXJlbnRTdXNwZW5zZSB8fCBwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xuICBjb25zdCBjaDIgPSBuMi5jaGlsZHJlbjtcbiAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYzEgPSBjaDFbaV07XG4gICAgICBsZXQgYzIgPSBjaDJbaV07XG4gICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyKSB7XG4gICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xuICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFsbG93ICYmIGMyLnBhdGNoRmxhZyAhPT0gLTIpXG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xuICAgICAgfVxuICAgICAgaWYgKGMyLnR5cGUgPT09IFRleHQpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGMyLnR5cGUgPT09IENvbW1lbnQgJiYgIWMyLmVsKSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcbiAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xuICBjb25zdCByZXN1bHQgPSBbMF07XG4gIGxldCBpLCBqLCB1LCB2LCBjO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBhcnJJID0gYXJyW2ldO1xuICAgIGlmIChhcnJJICE9PSAwKSB7XG4gICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgIHBbaV0gPSBqO1xuICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB1ID0gMDtcbiAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICh1IDwgdikge1xuICAgICAgICBjID0gdSArIHYgPj4gMTtcbiAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xuICAgICAgICAgIHUgPSBjICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xuICAgICAgICBpZiAodSA+IDApIHtcbiAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1ID0gcmVzdWx0Lmxlbmd0aDtcbiAgdiA9IHJlc3VsdFt1IC0gMV07XG4gIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgcmVzdWx0W3VdID0gdjtcbiAgICB2ID0gcFt2XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qgc3ViQ29tcG9uZW50ID0gaW5zdGFuY2Uuc3ViVHJlZS5jb21wb25lbnQ7XG4gIGlmIChzdWJDb21wb25lbnQpIHtcbiAgICBpZiAoc3ViQ29tcG9uZW50LmFzeW5jRGVwICYmICFzdWJDb21wb25lbnQuYXN5bmNSZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIHN1YkNvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KHN1YkNvbXBvbmVudCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlTW91bnQoaG9va3MpIHtcbiAgaWYgKGhvb2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKylcbiAgICAgIGhvb2tzW2ldLmZsYWdzIHw9IDg7XG4gIH1cbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbC5mb3IoXCJ2LXNjeFwiKTtcbmNvbnN0IHVzZVNTUkNvbnRleHQgPSAoKSA9PiB7XG4gIHtcbiAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInBvc3RcIiB9KSA6IHsgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJzeW5jXCIgfSkgOiB7IGZsdXNoOiBcInN5bmNcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGNiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uY2UgfSA9IG9wdGlvbnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjYikge1xuICAgIGlmIChpbW1lZGlhdGUgIT09IHZvaWQgMCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWVwICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9uY2UgIT09IHZvaWQgMCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgd2F0Y2goKSBcIm9uY2VcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBiYXNlV2F0Y2hPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIGJhc2VXYXRjaE9wdGlvbnMub25XYXJuID0gd2FybiQxO1xuICBjb25zdCBydW5zSW1tZWRpYXRlbHkgPSBjYiAmJiBpbW1lZGlhdGUgfHwgIWNiICYmIGZsdXNoICE9PSBcInBvc3RcIjtcbiAgbGV0IHNzckNsZWFudXA7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBpZiAoZmx1c2ggPT09IFwic3luY1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB1c2VTU1JDb250ZXh0KCk7XG4gICAgICBzc3JDbGVhbnVwID0gY3R4Ll9fd2F0Y2hlckhhbmRsZXMgfHwgKGN0eC5fX3dhdGNoZXJIYW5kbGVzID0gW10pO1xuICAgIH0gZWxzZSBpZiAoIXJ1bnNJbW1lZGlhdGVseSkge1xuICAgICAgY29uc3Qgd2F0Y2hTdG9wSGFuZGxlID0gKCkgPT4ge1xuICAgICAgfTtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5zdG9wID0gTk9PUDtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5yZXN1bWUgPSBOT09QO1xuICAgICAgd2F0Y2hTdG9wSGFuZGxlLnBhdXNlID0gTk9PUDtcbiAgICAgIHJldHVybiB3YXRjaFN0b3BIYW5kbGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICBiYXNlV2F0Y2hPcHRpb25zLmNhbGwgPSAoZm4sIHR5cGUsIGFyZ3MpID0+IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gIGxldCBpc1ByZSA9IGZhbHNlO1xuICBpZiAoZmx1c2ggPT09IFwicG9zdFwiKSB7XG4gICAgYmFzZVdhdGNoT3B0aW9ucy5zY2hlZHVsZXIgPSAoam9iKSA9PiB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmbHVzaCAhPT0gXCJzeW5jXCIpIHtcbiAgICBpc1ByZSA9IHRydWU7XG4gICAgYmFzZVdhdGNoT3B0aW9ucy5zY2hlZHVsZXIgPSAoam9iLCBpc0ZpcnN0UnVuKSA9PiB7XG4gICAgICBpZiAoaXNGaXJzdFJ1bikge1xuICAgICAgICBqb2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSm9iKGpvYik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBiYXNlV2F0Y2hPcHRpb25zLmF1Z21lbnRKb2IgPSAoam9iKSA9PiB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgaWYgKGlzUHJlKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gMjtcbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB3YXRjaEhhbmRsZSA9IHdhdGNoJDEoc291cmNlLCBjYiwgYmFzZVdhdGNoT3B0aW9ucyk7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBpZiAoc3NyQ2xlYW51cCkge1xuICAgICAgc3NyQ2xlYW51cC5wdXNoKHdhdGNoSGFuZGxlKTtcbiAgICB9IGVsc2UgaWYgKHJ1bnNJbW1lZGlhdGVseSkge1xuICAgICAgd2F0Y2hIYW5kbGUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdhdGNoSGFuZGxlO1xufVxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xuICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpID8gc291cmNlLmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKSA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXSA6IHNvdXJjZS5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICBsZXQgY2I7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGNiID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xuICAgIG9wdGlvbnMgPSB2YWx1ZTtcbiAgfVxuICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZSh0aGlzKTtcbiAgY29uc3QgcmVzID0gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMpO1xuICByZXNldCgpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgY3VyID0gY3R4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoICYmIGN1cjsgaSsrKSB7XG4gICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VNb2RlbChwcm9wcywgbmFtZSwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybiQxKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgY29uc3QgY2FtZWxpemVkTmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaS5wcm9wc09wdGlvbnNbMF1bY2FtZWxpemVkTmFtZV0pIHtcbiAgICB3YXJuJDEoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGggcHJvcCBcIiR7bmFtZX1cIiB3aGljaCBpcyBub3QgZGVjbGFyZWQuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGNvbnN0IGh5cGhlbmF0ZWROYW1lID0gaHlwaGVuYXRlKG5hbWUpO1xuICBjb25zdCBtb2RpZmllcnMgPSBnZXRNb2RlbE1vZGlmaWVycyhwcm9wcywgY2FtZWxpemVkTmFtZSk7XG4gIGNvbnN0IHJlcyA9IGN1c3RvbVJlZigodHJhY2ssIHRyaWdnZXIpID0+IHtcbiAgICBsZXQgbG9jYWxWYWx1ZTtcbiAgICBsZXQgcHJldlNldFZhbHVlID0gRU1QVFlfT0JKO1xuICAgIGxldCBwcmV2RW1pdHRlZFZhbHVlO1xuICAgIHdhdGNoU3luY0VmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wc1tjYW1lbGl6ZWROYW1lXTtcbiAgICAgIGlmIChoYXNDaGFuZ2VkKGxvY2FsVmFsdWUsIHByb3BWYWx1ZSkpIHtcbiAgICAgICAgbG9jYWxWYWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHRyYWNrKCk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmdldCA/IG9wdGlvbnMuZ2V0KGxvY2FsVmFsdWUpIDogbG9jYWxWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZW1pdHRlZFZhbHVlID0gb3B0aW9ucy5zZXQgPyBvcHRpb25zLnNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgbG9jYWxWYWx1ZSkgJiYgIShwcmV2U2V0VmFsdWUgIT09IEVNUFRZX09CSiAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdQcm9wcyA9IGkudm5vZGUucHJvcHM7XG4gICAgICAgIGlmICghKHJhd1Byb3BzICYmIC8vIGNoZWNrIGlmIHBhcmVudCBoYXMgcGFzc2VkIHYtbW9kZWxcbiAgICAgICAgKG5hbWUgaW4gcmF3UHJvcHMgfHwgY2FtZWxpemVkTmFtZSBpbiByYXdQcm9wcyB8fCBoeXBoZW5hdGVkTmFtZSBpbiByYXdQcm9wcykgJiYgKGBvblVwZGF0ZToke25hbWV9YCBpbiByYXdQcm9wcyB8fCBgb25VcGRhdGU6JHtjYW1lbGl6ZWROYW1lfWAgaW4gcmF3UHJvcHMgfHwgYG9uVXBkYXRlOiR7aHlwaGVuYXRlZE5hbWV9YCBpbiByYXdQcm9wcykpKSB7XG4gICAgICAgICAgbG9jYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpLmVtaXQoYHVwZGF0ZToke25hbWV9YCwgZW1pdHRlZFZhbHVlKTtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQodmFsdWUsIGVtaXR0ZWRWYWx1ZSkgJiYgaGFzQ2hhbmdlZCh2YWx1ZSwgcHJldlNldFZhbHVlKSAmJiAhaGFzQ2hhbmdlZChlbWl0dGVkVmFsdWUsIHByZXZFbWl0dGVkVmFsdWUpKSB7XG4gICAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZTZXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBwcmV2RW1pdHRlZFZhbHVlID0gZW1pdHRlZFZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXNbU3ltYm9sLml0ZXJhdG9yXSA9ICgpID0+IHtcbiAgICBsZXQgaTIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBpZiAoaTIgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGkyKysgPyBtb2RpZmllcnMgfHwgRU1QVFlfT0JKIDogcmVzLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBnZXRNb2RlbE1vZGlmaWVycyA9IChwcm9wcywgbW9kZWxOYW1lKSA9PiB7XG4gIHJldHVybiBtb2RlbE5hbWUgPT09IFwibW9kZWxWYWx1ZVwiIHx8IG1vZGVsTmFtZSA9PT0gXCJtb2RlbC12YWx1ZVwiID8gcHJvcHMubW9kZWxNb2RpZmllcnMgOiBwcm9wc1tgJHttb2RlbE5hbWV9TW9kaWZpZXJzYF0gfHwgcHJvcHNbYCR7Y2FtZWxpemUobW9kZWxOYW1lKX1Nb2RpZmllcnNgXSB8fCBwcm9wc1tgJHtoeXBoZW5hdGUobW9kZWxOYW1lKX1Nb2RpZmllcnNgXTtcbn07XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XG4gIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCkgcmV0dXJuO1xuICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbWl0c09wdGlvbnMsXG4gICAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gICAgfSA9IGluc3RhbmNlO1xuICAgIGlmIChlbWl0c09wdGlvbnMpIHtcbiAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiYgdHJ1ZSkge1xuICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpIGluIHByb3BzT3B0aW9ucykpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKX1cIiBwcm9wLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBlbWl0c09wdGlvbnNbZXZlbnRdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcbiAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBhcmdzID0gcmF3QXJncztcbiAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aChcInVwZGF0ZTpcIik7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBnZXRNb2RlbE1vZGlmaWVycyhwcm9wcywgZXZlbnQuc2xpY2UoNykpO1xuICBpZiAobW9kaWZpZXJzKSB7XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAoKGEpID0+IGlzU3RyaW5nKGEpID8gYS50cmltKCkgOiBhKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChsb29zZVRvTnVtYmVyKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50ICR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS50eXBlXG4gICAgICAgICl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKFxuICAgICAgICAgIGV2ZW50XG4gICAgICAgICl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbGV0IGhhbmRsZXJOYW1lO1xuICBsZXQgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KV0gfHwgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxuICBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpXTtcbiAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xuICAgIGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKV07XG4gIH1cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcbiAgaWYgKG9uY2VIYW5kbGVyKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XG4gICAgICBpbnN0YW5jZS5lbWl0dGVkID0ge307XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBvbmNlSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcbiAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcyKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xuICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgcmF3LmZvckVhY2goKGtleSkgPT4gbm9ybWFsaXplZFtrZXldID0gbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XG4gIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sIFwiXCIpO1xuICByZXR1cm4gaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fCBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8IGhhc093bihvcHRpb25zLCBrZXkpO1xufVxuXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XG4gIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgdHlwZTogQ29tcG9uZW50LFxuICAgIHZub2RlLFxuICAgIHByb3h5LFxuICAgIHdpdGhQcm94eSxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLFxuICAgIHNsb3RzLFxuICAgIGF0dHJzLFxuICAgIGVtaXQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlckNhY2hlLFxuICAgIHByb3BzLFxuICAgIGRhdGEsXG4gICAgc2V0dXBTdGF0ZSxcbiAgICBjdHgsXG4gICAgaW5oZXJpdEF0dHJzXG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0KSB7XG4gICAgICBjb25zdCBwcm94eVRvVXNlID0gd2l0aFByb3h5IHx8IHByb3h5O1xuICAgICAgY29uc3QgdGhpc1Byb3h5ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCA/IG5ldyBQcm94eShwcm94eVRvVXNlLCB7XG4gICAgICAgIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgUHJvcGVydHkgJyR7U3RyaW5nKFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICl9JyB3YXMgYWNjZXNzZWQgdmlhICd0aGlzJy4gQXZvaWQgdXNpbmcgJ3RoaXMnIGluIHRlbXBsYXRlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgfSkgOiBwcm94eVRvVXNlO1xuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlci5jYWxsKFxuICAgICAgICAgIHRoaXNQcm94eSxcbiAgICAgICAgICBwcm94eVRvVXNlLFxuICAgICAgICAgIHJlbmRlckNhY2hlLFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXG4gICAgICAgICAgc2V0dXBTdGF0ZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGN0eFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZW5kZXIyID0gQ29tcG9uZW50O1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYXR0cnMgPT09IHByb3BzKSB7XG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyMi5sZW5ndGggPiAxID8gcmVuZGVyMihcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoYXR0cnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3RzLFxuICAgICAgICAgICAgZW1pdFxuICAgICAgICAgIH0gOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9XG4gICAgICAgICkgOiByZW5kZXIyKFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wcyA/IGF0dHJzIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcbiAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxKTtcbiAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfVxuICBsZXQgcm9vdCA9IHJlc3VsdDtcbiAgbGV0IHNldFJvb3QgPSB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgW3Jvb3QsIHNldFJvb3RdID0gZ2V0Q2hpbGRSb290KHJlc3VsdCk7XG4gIH1cbiAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDYpKSB7XG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcbiAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzLFxuICAgICAgICAgICAgcHJvcHNPcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XG4gICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBhbGxBdHRyc1tpXTtcbiAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoJHtleHRyYUF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCBvciB0ZWxlcG9ydCByb290IG5vZGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudEF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKCR7ZXZlbnRBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBUaGUgZGlyZWN0aXZlcyB3aWxsIG5vdCBmdW5jdGlvbiBhcyBpbnRlbmRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBudWxsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XG4gIH1cbiAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHJvb3QsIHZub2RlLnRyYW5zaXRpb24pO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldFJvb3QpIHtcbiAgICBzZXRSb290KHJvb3QpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHJvb3Q7XG4gIH1cbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbiwgZmFsc2UpO1xuICBpZiAoIWNoaWxkUm9vdCkge1xuICAgIHJldHVybiBbdm5vZGUsIHZvaWQgMF07XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGlsZFJvb3QucGF0Y2hGbGFnID4gMCAmJiBjaGlsZFJvb3QucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIHJldHVybiBnZXRDaGlsZFJvb3QoY2hpbGRSb290KTtcbiAgfVxuICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcbiAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xuICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XG4gICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcbn07XG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuLCByZWN1cnNlID0gdHJ1ZSkge1xuICBsZXQgc2luZ2xlUm9vdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gXCJ2LWlmXCIpIHtcbiAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJlY3Vyc2UgJiYgc2luZ2xlUm9vdC5wYXRjaEZsYWcgPiAwICYmIHNpbmdsZVJvb3QucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlclNpbmdsZVJvb3Qoc2luZ2xlUm9vdC5jaGlsZHJlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbmdsZVJvb3Q7XG59XG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcbiAgbGV0IHJlcztcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIgfHwga2V5ID09PSBcInN0eWxlXCIgfHwgaXNPbihrZXkpKSB7XG4gICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xuICBjb25zdCByZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xuICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmICg2IHwgMSkgfHwgdm5vZGUudHlwZSA9PT0gQ29tbWVudDtcbn07XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xuICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xuICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xuICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xuICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgIH1cbiAgICBpZiAoIW5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xuICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XG4gIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xuICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwpIHtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGNvbnN0IHJvb3QgPSBwYXJlbnQuc3ViVHJlZTtcbiAgICBpZiAocm9vdC5zdXNwZW5zZSAmJiByb290LnN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9PT0gdm5vZGUpIHtcbiAgICAgIHJvb3QuZWwgPSB2bm9kZS5lbDtcbiAgICB9XG4gICAgaWYgKHJvb3QgPT09IHZub2RlKSB7XG4gICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcbmxldCBzdXNwZW5zZUlkID0gMDtcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcbiAgbmFtZTogXCJTdXNwZW5zZVwiLFxuICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XG4gIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxuICAvLyBpbnRlcm5hbHMuXG4gIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudFN1c3BlbnNlKFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UuZGVwcyA+IDAgJiYgIW4xLnN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICAgICAgICBuMi5zdXNwZW5zZS52bm9kZSA9IG4yO1xuICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXRjaFN1c3BlbnNlKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxuICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cbn07XG5jb25zdCBTdXNwZW5zZSA9IFN1c3BlbnNlSW1wbCA7XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xuICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xuICAgIGV2ZW50TGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFsc1xuICApO1xuICBwYXRjaChcbiAgICBudWxsLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIG51bGwsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHNcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uUGVuZGluZ1wiKTtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25GYWxsYmFja1wiKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZS5zc0ZhbGxiYWNrLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICBjb25zdCBzdXNwZW5zZSA9IG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gIG4yLmVsID0gbjEuZWw7XG4gIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcbiAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XG4gIGlmIChwZW5kaW5nQnJhbmNoKSB7XG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gc3VzcGVuc2VJZCsrO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckV2ZW50KG4yLCBcIm9uUGVuZGluZ1wiKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICBpZiAobmV3QnJhbmNoLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBuZXdCcmFuY2guY29tcG9uZW50LnN1c3BlbnNlSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBzdXNwZW5zZUlkKys7XG4gICAgICB9XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUgJiYgIWhhc1dhcm5lZCkge1xuICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyBcImluZm9cIiA6IFwibG9nXCJdKFxuICAgICAgYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBtOiBtb3ZlLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG46IG5leHQsXG4gICAgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGxldCBwYXJlbnRTdXNwZW5zZUlkO1xuICBjb25zdCBpc1N1c3BlbnNpYmxlID0gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKTtcbiAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgcGFyZW50U3VzcGVuc2VJZCA9IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZDtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgdGltZW91dCA9IHZub2RlLnByb3BzID8gdG9OdW1iZXIodm5vZGUucHJvcHMudGltZW91dCkgOiB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHRpbWVvdXQsIGBTdXNwZW5zZSB0aW1lb3V0YCk7XG4gIH1cbiAgY29uc3QgaW5pdGlhbEFuY2hvciA9IGFuY2hvcjtcbiAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbmFtZXNwYWNlLFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgZGVwczogMCxcbiAgICBwZW5kaW5nSWQ6IHN1c3BlbnNlSWQrKyxcbiAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIiA/IHRpbWVvdXQgOiAtMSxcbiAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcbiAgICBpc0luRmFsbGJhY2s6ICFpc0h5ZHJhdGluZyxcbiAgICBpc0h5ZHJhdGluZyxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgZWZmZWN0czogW10sXG4gICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSwgc3luYyA9IGZhbHNlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB2bm9kZTogdm5vZGUyLFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdJZCxcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcjJcbiAgICAgIH0gPSBzdXNwZW5zZTtcbiAgICAgIGxldCBkZWxheUVudGVyID0gZmFsc2U7XG4gICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIG1vdmUoXG4gICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgICAgIGFuY2hvciA9PT0gaW5pdGlhbEFuY2hvciA/IG5leHQoYWN0aXZlQnJhbmNoKSA6IGFuY2hvcixcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgaWYgKHBhcmVudE5vZGUoYWN0aXZlQnJhbmNoLmVsKSA9PT0gY29udGFpbmVyMikge1xuICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50Miwgc3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBwZW5kaW5nQnJhbmNoKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XG4gICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xuICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xuICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yICYmICFkZWxheUVudGVyKSB7XG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XG4gICAgICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiBwYXJlbnRTdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDAgJiYgIXN5bmMpIHtcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25SZXNvbHZlXCIpO1xuICAgIH0sXG4gICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xuICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsIGNvbnRhaW5lcjogY29udGFpbmVyMiwgbmFtZXNwYWNlOiBuYW1lc3BhY2UyIH0gPSBzdXNwZW5zZTtcbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25GYWxsYmFja1wiKTtcbiAgICAgIGNvbnN0IGFuY2hvcjIgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZhbGxiYWNrVk5vZGUsXG4gICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgIG5hbWVzcGFjZTIsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XG4gICAgICB1bm1vdW50KFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcbiAgICAgICAgdHJ1ZVxuICAgICAgICAvLyBzaG91bGRSZW1vdmVcbiAgICAgICk7XG4gICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgbW91bnRGYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW92ZShjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKSB7XG4gICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpO1xuICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyMjtcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkMikge1xuICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcbiAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XG4gICAgICAgIHN1c3BlbnNlLmRlcHMrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcbiAgICAgIGluc3RhbmNlLmFzeW5jRGVwLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCk7XG4gICAgICB9KS50aGVuKChhc3luY1NldHVwUmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcbiAgICAgICAgICB2bm9kZTIuZWwgPSBoeWRyYXRlZEVsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgdm5vZGUyLFxuICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIG1vdmVkIGJlZm9yZSByZXNvbHZlLlxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cbiAgICAgICAgICBwYXJlbnROb2RlKGh5ZHJhdGVkRWwgfHwgaW5zdGFuY2Uuc3ViVHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWQyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZTIuZWwpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UyLCBkb1JlbW92ZSkge1xuICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgaWYgKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCkge1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHN1c3BlbnNlO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgdm5vZGUsXG4gICAgcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIG5vZGUucGFyZW50Tm9kZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICBudWxsLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gaHlkcmF0ZU5vZGUoXG4gICAgbm9kZSxcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBzdXNwZW5zZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4odm5vZGUpIHtcbiAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMjtcbiAgdm5vZGUuc3NDb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KFxuICAgIGlzU2xvdENoaWxkcmVuID8gY2hpbGRyZW4uZGVmYXVsdCA6IGNoaWxkcmVuXG4gICk7XG4gIHZub2RlLnNzRmFsbGJhY2sgPSBpc1Nsb3RDaGlsZHJlbiA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaykgOiBjcmVhdGVWTm9kZShDb21tZW50KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XG4gIGxldCBibG9jaztcbiAgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICBjb25zdCB0cmFja0Jsb2NrID0gaXNCbG9ja1RyZWVFbmFibGVkICYmIHMuX2M7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSBmYWxzZTtcbiAgICAgIG9wZW5CbG9jaygpO1xuICAgIH1cbiAgICBzID0gcygpO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gdHJ1ZTtcbiAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xuICAgICAgY2xvc2VCbG9jaygpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNBcnJheShzKSkge1xuICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhc2luZ2xlQ2hpbGQgJiYgcy5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZCAhPT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkubGVuZ3RoID4gMCkge1xuICAgICAgd2FybiQxKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XG4gICAgfVxuICAgIHMgPSBzaW5nbGVDaGlsZDtcbiAgfVxuICBzID0gbm9ybWFsaXplVk5vZGUocyk7XG4gIGlmIChibG9jayAmJiAhcy5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICBzLmR5bmFtaWNDaGlsZHJlbiA9IGJsb2NrLmZpbHRlcigoYykgPT4gYyAhPT0gcyk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcbiAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICBpZiAoaXNBcnJheShmbikpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGJyYW5jaCkge1xuICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XG4gIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XG4gIGxldCBlbCA9IGJyYW5jaC5lbDtcbiAgd2hpbGUgKCFlbCAmJiBicmFuY2guY29tcG9uZW50KSB7XG4gICAgYnJhbmNoID0gYnJhbmNoLmNvbXBvbmVudC5zdWJUcmVlO1xuICAgIGVsID0gYnJhbmNoLmVsO1xuICB9XG4gIHZub2RlLmVsID0gZWw7XG4gIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XG4gICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpIHtcbiAgY29uc3Qgc3VzcGVuc2libGUgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5zdXNwZW5zaWJsZTtcbiAgcmV0dXJuIHN1c3BlbnNpYmxlICE9IG51bGwgJiYgc3VzcGVuc2libGUgIT09IGZhbHNlO1xufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWZndFwiKTtcbmNvbnN0IFRleHQgPSBTeW1ib2wuZm9yKFwidi10eHRcIik7XG5jb25zdCBDb21tZW50ID0gU3ltYm9sLmZvcihcInYtY210XCIpO1xuY29uc3QgU3RhdGljID0gU3ltYm9sLmZvcihcInYtc3RjXCIpO1xuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcbiAgYmxvY2tTdGFjay5wdXNoKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSk7XG59XG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xuICBibG9ja1N0YWNrLnBvcCgpO1xuICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xuZnVuY3Rpb24gc2V0QmxvY2tUcmFja2luZyh2YWx1ZSwgaW5WT25jZSA9IGZhbHNlKSB7XG4gIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbiAgaWYgKHZhbHVlIDwgMCAmJiBjdXJyZW50QmxvY2sgJiYgaW5WT25jZSkge1xuICAgIGN1cnJlbnRCbG9jay5oYXNPbmNlID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XG4gIGNsb3NlQmxvY2soKTtcbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlQmFzZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICB0cnVlXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbjIuc2hhcGVGbGFnICYgNiAmJiBuMS5jb21wb25lbnQpIHtcbiAgICBjb25zdCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQobjIudHlwZSk7XG4gICAgaWYgKGRpcnR5SW5zdGFuY2VzICYmIGRpcnR5SW5zdGFuY2VzLmhhcyhuMS5jb21wb25lbnQpKSB7XG4gICAgICBuMS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgICAgIG4yLnNoYXBlRmxhZyAmPSB+NTEyO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcbn1cbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xuICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xufVxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBfY3JlYXRlVk5vZGUoXG4gICAgLi4udm5vZGVBcmdzVHJhbnNmb3JtZXIgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIDogYXJnc1xuICApO1xufTtcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XG5jb25zdCBub3JtYWxpemVSZWYgPSAoe1xuICByZWYsXG4gIHJlZl9rZXksXG4gIHJlZl9mb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZWYgPSBcIlwiICsgcmVmO1xuICB9XG4gIHJldHVybiByZWYgIT0gbnVsbCA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZikgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfSA6IHJlZiA6IG51bGw7XG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHZub2RlID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAga2V5OiBwcm9wcyAmJiBub3JtYWxpemVLZXkocHJvcHMpLFxuICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcbiAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IG51bGwsXG4gICAgY2hpbGRyZW4sXG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIHN1c3BlbnNlOiBudWxsLFxuICAgIHNzQ29udGVudDogbnVsbCxcbiAgICBzc0ZhbGxiYWNrOiBudWxsLFxuICAgIGRpcnM6IG51bGwsXG4gICAgdHJhbnNpdGlvbjogbnVsbCxcbiAgICBlbDogbnVsbCxcbiAgICBhbmNob3I6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRhcmdldFN0YXJ0OiBudWxsLFxuICAgIHRhcmdldEFuY2hvcjogbnVsbCxcbiAgICBzdGF0aWNDb3VudDogMCxcbiAgICBzaGFwZUZsYWcsXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXG4gICAgYXBwQ29udGV4dDogbnVsbCxcbiAgICBjdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZVxuICB9O1xuICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gaXNTdHJpbmcoY2hpbGRyZW4pID8gOCA6IDE2O1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XG4gICAgd2FybiQxKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXG4gICFpc0Jsb2NrTm9kZSAmJiAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAgY3VycmVudEJsb2NrICYmIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXG4gIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxuICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cbiAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxuICAodm5vZGUucGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2KSAmJiAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcbiAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cbiAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMikge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlO1xuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXR5cGUpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XG4gICAgfVxuICAgIHR5cGUgPSBDb21tZW50O1xuICB9XG4gIGlmIChpc1ZOb2RlKHR5cGUpKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lZC5wYXRjaEZsYWcgPSAtMjtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XG4gICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICB9XG4gIGlmIChwcm9wcykge1xuICAgIHByb3BzID0gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKTtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcbiAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKSA/IDEgOiBpc1N1c3BlbnNlKHR5cGUpID8gMTI4IDogaXNUZWxlcG9ydCh0eXBlKSA/IDY0IDogaXNPYmplY3QodHlwZSkgPyA0IDogaXNGdW5jdGlvbih0eXBlKSA/IDIgOiAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzaGFwZUZsYWcgJiA0ICYmIGlzUHJveHkodHlwZSkpIHtcbiAgICB0eXBlID0gdG9SYXcodHlwZSk7XG4gICAgd2FybiQxKFxuICAgICAgYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB0aGF0IHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgaW5zdGVhZCBvZiBcXGByZWZcXGAuYCxcbiAgICAgIGBcbkNvbXBvbmVudCB0aGF0IHdhcyBtYWRlIHJlYWN0aXZlOiBgLFxuICAgICAgdHlwZVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJhc2VWTm9kZShcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgc2hhcGVGbGFnLFxuICAgIGlzQmxvY2tOb2RlLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IGlzSW50ZXJuYWxPYmplY3QocHJvcHMpID8gZXh0ZW5kKHt9LCBwcm9wcykgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UsIGNsb25lVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IGNsb25lZCA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlOiB2bm9kZS50eXBlLFxuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXG4gICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmID8gKFxuICAgICAgLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcbiAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXG4gICAgICBtZXJnZVJlZiAmJiByZWYgPyBpc0FycmF5KHJlZikgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSkgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXG4gICAgKSA6IHJlZixcbiAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgIGNoaWxkcmVuOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHBhdGNoRmxhZyA9PT0gLTEgJiYgaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpIDogY2hpbGRyZW4sXG4gICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXG4gICAgdGFyZ2V0U3RhcnQ6IHZub2RlLnRhcmdldFN0YXJ0LFxuICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxuICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcbiAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcbiAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xuICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgIC8vIGZhc3QgcGF0aHMgb25seS5cbiAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnQgPyBwYXRjaEZsYWcgPT09IC0xID8gMTYgOiBwYXRjaEZsYWcgfCAxNiA6IHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcbiAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxuICAgIGRpcnM6IHZub2RlLmRpcnMsXG4gICAgdHJhbnNpdGlvbixcbiAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXG4gICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcbiAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXG4gICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxuICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcbiAgICBlbDogdm5vZGUuZWwsXG4gICAgYW5jaG9yOiB2bm9kZS5hbmNob3IsXG4gICAgY3R4OiB2bm9kZS5jdHgsXG4gICAgY2U6IHZub2RlLmNlXG4gIH07XG4gIGlmICh0cmFuc2l0aW9uICYmIGNsb25lVHJhbnNpdGlvbikge1xuICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgIGNsb25lZCxcbiAgICAgIHRyYW5zaXRpb24uY2xvbmUoY2xvbmVkKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XG4gIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9IFwiIFwiLCBmbGFnID0gMCkge1xuICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcbiAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9IFwiXCIsIGFzQmxvY2sgPSBmYWxzZSkge1xuICByZXR1cm4gYXNCbG9jayA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xuICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXG4gICAgICBjaGlsZC5zbGljZSgpXG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgIHJldHVybiBjbG9uZUlmTW91bnRlZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xuICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgJiYgY2hpbGQucGF0Y2hGbGFnICE9PSAtMSB8fCBjaGlsZC5tZW1vID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbikge1xuICBsZXQgdHlwZSA9IDA7XG4gIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICB0eXBlID0gMTY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNjQpKSB7XG4gICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSAzMjtcbiAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcbiAgICAgIGlmICghc2xvdEZsYWcgJiYgIWlzSW50ZXJuYWxPYmplY3QoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKHNsb3RGbGFnID09PSAzICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEpIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMjtcbiAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XG4gICAgdHlwZSA9IDMyO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUgPSAxNjtcbiAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gODtcbiAgICB9XG4gIH1cbiAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XG4gICAgICAgICAgcmV0LmNsYXNzID0gbm9ybWFsaXplQ2xhc3MoW3JldC5jbGFzcywgdG9NZXJnZS5jbGFzc10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XG4gICAgICAgIGNvbnN0IGluY29taW5nID0gdG9NZXJnZVtrZXldO1xuICAgICAgICBpZiAoaW5jb21pbmcgJiYgZXhpc3RpbmcgIT09IGluY29taW5nICYmICEoaXNBcnJheShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xuICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKSA6IGluY29taW5nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSAhPT0gXCJcIikge1xuICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcsIFtcbiAgICB2bm9kZSxcbiAgICBwcmV2Vk5vZGVcbiAgXSk7XG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbmxldCB1aWQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcbiAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XG4gIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHVpZDogdWlkKyssXG4gICAgdm5vZGUsXG4gICAgdHlwZSxcbiAgICBwYXJlbnQsXG4gICAgYXBwQ29udGV4dCxcbiAgICByb290OiBudWxsLFxuICAgIC8vIHRvIGJlIGltbWVkaWF0ZWx5IHNldFxuICAgIG5leHQ6IG51bGwsXG4gICAgc3ViVHJlZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgZWZmZWN0OiBudWxsLFxuICAgIHVwZGF0ZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgam9iOiBudWxsLFxuICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUoXG4gICAgICB0cnVlXG4gICAgICAvKiBkZXRhY2hlZCAqL1xuICAgICksXG4gICAgcmVuZGVyOiBudWxsLFxuICAgIHByb3h5OiBudWxsLFxuICAgIGV4cG9zZWQ6IG51bGwsXG4gICAgZXhwb3NlUHJveHk6IG51bGwsXG4gICAgd2l0aFByb3h5OiBudWxsLFxuICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxuICAgIGlkczogcGFyZW50ID8gcGFyZW50LmlkcyA6IFtcIlwiLCAwLCAwXSxcbiAgICBhY2Nlc3NDYWNoZTogbnVsbCxcbiAgICByZW5kZXJDYWNoZTogW10sXG4gICAgLy8gbG9jYWwgcmVzb2x2ZWQgYXNzZXRzXG4gICAgY29tcG9uZW50czogbnVsbCxcbiAgICBkaXJlY3RpdmVzOiBudWxsLFxuICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXG4gICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgLy8gZW1pdFxuICAgIGVtaXQ6IG51bGwsXG4gICAgLy8gdG8gYmUgc2V0IGltbWVkaWF0ZWx5XG4gICAgZW1pdHRlZDogbnVsbCxcbiAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXG4gICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxuICAgIC8vIGluaGVyaXRBdHRyc1xuICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXG4gICAgLy8gc3RhdGVcbiAgICBjdHg6IEVNUFRZX09CSixcbiAgICBkYXRhOiBFTVBUWV9PQkosXG4gICAgcHJvcHM6IEVNUFRZX09CSixcbiAgICBhdHRyczogRU1QVFlfT0JKLFxuICAgIHNsb3RzOiBFTVBUWV9PQkosXG4gICAgcmVmczogRU1QVFlfT0JKLFxuICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcbiAgICBzZXR1cENvbnRleHQ6IG51bGwsXG4gICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxuICAgIHN1c3BlbnNlLFxuICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcbiAgICBhc3luY0RlcDogbnVsbCxcbiAgICBhc3luY1Jlc29sdmVkOiBmYWxzZSxcbiAgICAvLyBsaWZlY3ljbGUgaG9va3NcbiAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxuICAgIGJjOiBudWxsLFxuICAgIGM6IG51bGwsXG4gICAgYm06IG51bGwsXG4gICAgbTogbnVsbCxcbiAgICBidTogbnVsbCxcbiAgICB1OiBudWxsLFxuICAgIHVtOiBudWxsLFxuICAgIGJ1bTogbnVsbCxcbiAgICBkYTogbnVsbCxcbiAgICBhOiBudWxsLFxuICAgIHJ0ZzogbnVsbCxcbiAgICBydGM6IG51bGwsXG4gICAgZWM6IG51bGwsXG4gICAgc3A6IG51bGxcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XG4gIH1cbiAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XG4gIGluc3RhbmNlLmVtaXQgPSBlbWl0LmJpbmQobnVsbCwgaW5zdGFuY2UpO1xuICBpZiAodm5vZGUuY2UpIHtcbiAgICB2bm9kZS5jZShpbnN0YW5jZSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG5jb25zdCBnZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xubGV0IGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlO1xubGV0IHNldEluU1NSU2V0dXBTdGF0ZTtcbntcbiAgY29uc3QgZyA9IGdldEdsb2JhbFRoaXMoKTtcbiAgY29uc3QgcmVnaXN0ZXJHbG9iYWxTZXR0ZXIgPSAoa2V5LCBzZXR0ZXIpID0+IHtcbiAgICBsZXQgc2V0dGVycztcbiAgICBpZiAoIShzZXR0ZXJzID0gZ1trZXldKSkgc2V0dGVycyA9IGdba2V5XSA9IFtdO1xuICAgIHNldHRlcnMucHVzaChzZXR0ZXIpO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgaWYgKHNldHRlcnMubGVuZ3RoID4gMSkgc2V0dGVycy5mb3JFYWNoKChzZXQpID0+IHNldCh2KSk7XG4gICAgICBlbHNlIHNldHRlcnNbMF0odik7XG4gICAgfTtcbiAgfTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UgPSByZWdpc3Rlckdsb2JhbFNldHRlcihcbiAgICBgX19WVUVfSU5TVEFOQ0VfU0VUVEVSU19fYCxcbiAgICAodikgPT4gY3VycmVudEluc3RhbmNlID0gdlxuICApO1xuICBzZXRJblNTUlNldHVwU3RhdGUgPSByZWdpc3Rlckdsb2JhbFNldHRlcihcbiAgICBgX19WVUVfU1NSX1NFVFRFUlNfX2AsXG4gICAgKHYpID0+IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IHZcbiAgKTtcbn1cbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBwcmV2ID0gY3VycmVudEluc3RhbmNlO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gIGluc3RhbmNlLnNjb3BlLm9uKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UocHJldik7XG4gIH07XG59O1xuY29uc3QgdW5zZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiB7XG4gIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xufTtcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFwic2xvdCxjb21wb25lbnRcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgeyBpc05hdGl2ZVRhZyB9KSB7XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgaXNOYXRpdmVUYWcobmFtZSkpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIkRvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6IFwiICsgbmFtZVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDQ7XG59XG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpIHtcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGlzU1NSKTtcbiAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IGluc3RhbmNlLnZub2RlO1xuICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XG4gIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcbiAgaW5pdFNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIDogdm9pZCAwO1xuICBpc1NTUiAmJiBzZXRJblNTUlNldHVwU3RhdGUoZmFsc2UpO1xuICByZXR1cm4gc2V0dXBSZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xuICB2YXIgX2E7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKENvbXBvbmVudC5uYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuZGlyZWN0aXZlcykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpbnN0YW5jZS5wcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9XG4gIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcbiAgaWYgKHNldHVwKSB7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IGluc3RhbmNlLnNldHVwQ29udGV4dCA9IHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbDtcbiAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICBzZXR1cCxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgMCxcbiAgICAgIFtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcyxcbiAgICAgICAgc2V0dXBDb250ZXh0XG4gICAgICBdXG4gICAgKTtcbiAgICBjb25zdCBpc0FzeW5jU2V0dXAgPSBpc1Byb21pc2Uoc2V0dXBSZXN1bHQpO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICByZXNldCgpO1xuICAgIGlmICgoaXNBc3luY1NldHVwIHx8IGluc3RhbmNlLnNwKSAmJiAhaXNBc3luY1dyYXBwZXIoaW5zdGFuY2UpKSB7XG4gICAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChpc0FzeW5jU2V0dXApIHtcbiAgICAgIHNldHVwUmVzdWx0LnRoZW4odW5zZXRDdXJyZW50SW5zdGFuY2UsIHVuc2V0Q3VycmVudEluc3RhbmNlKTtcbiAgICAgIGlmIChpc1NTUikge1xuICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHQudGhlbigocmVzb2x2ZWRSZXN1bHQpID0+IHtcbiAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQsIGlzU1NSKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IChfYSA9IENvbXBvbmVudC5uYW1lKSAhPSBudWxsID8gX2EgOiBcIkFub255bW91c1wiO1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBDb21wb25lbnQgPCR7bmFtZX0+OiBzZXR1cCBmdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UsIGJ1dCBubyA8U3VzcGVuc2U+IGJvdW5kYXJ5IHdhcyBmb3VuZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB0cmVlLiBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIHNldHVwKCkgbXVzdCBiZSBuZXN0ZWQgaW4gYSA8U3VzcGVuc2U+IGluIG9yZGVyIHRvIGJlIHJlbmRlcmVkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xuICAgIGlmIChpbnN0YW5jZS50eXBlLl9fc3NySW5saW5lUmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5zc3JSZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzVk5vZGUoc2V0dXBSZXN1bHQpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XG4gICAgfVxuICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YFxuICAgICk7XG4gIH1cbiAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbn1cbmxldCBjb21waWxlO1xubGV0IGluc3RhbGxXaXRoUHJveHk7XG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xuICBjb21waWxlID0gX2NvbXBpbGU7XG4gIGluc3RhbGxXaXRoUHJveHkgPSAoaSkgPT4ge1xuICAgIGlmIChpLnJlbmRlci5fcmMpIHtcbiAgICAgIGkud2l0aFByb3h5ID0gbmV3IFByb3h5KGkuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcbiAgICBpZiAoIWlzU1NSICYmIGNvbXBpbGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gQ29tcG9uZW50LnRlbXBsYXRlIHx8IF9fVlVFX09QVElPTlNfQVBJX18gJiYgcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpLnRlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50LCBjb21waWxlck9wdGlvbnMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xuICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKFxuICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICBkZWxpbWl0ZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb21wb25lbnRDb21waWxlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlciA9IENvbXBvbmVudC5yZW5kZXIgfHwgTk9PUDtcbiAgICBpZiAoaW5zdGFsbFdpdGhQcm94eSkge1xuICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHRydWUpIHtcbiAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIHRyeSB7XG4gICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XG4gICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMShgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uOiBgLCBDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgYXR0cnNQcm94eUhhbmRsZXJzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIFwiXCIpO1xuICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgfSxcbiAgc2V0KCkge1xuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59IDoge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIFwiXCIpO1xuICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFNsb3RzUHJveHkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZS5zbG90cywge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIFwiJHNsb3RzXCIpO1xuICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgZXhwb3NlID0gKGV4cG9zZWQpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgICAgd2FybiQxKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGV4cG9zZWRUeXBlID0gdHlwZW9mIGV4cG9zZWQ7XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVmKGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwicmVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBleHBvc2UoKSBzaG91bGQgYmUgcGFzc2VkIGEgcGxhaW4gb2JqZWN0LCByZWNlaXZlZCAke2V4cG9zZWRUeXBlfS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBsZXQgYXR0cnNQcm94eTtcbiAgICBsZXQgc2xvdHNQcm94eTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1Byb3h5IHx8IChhdHRyc1Byb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRyc1Byb3h5SGFuZGxlcnMpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgc2xvdHMoKSB7XG4gICAgICAgIHJldHVybiBzbG90c1Byb3h5IHx8IChzbG90c1Byb3h5ID0gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkpO1xuICAgICAgfSxcbiAgICAgIGdldCBlbWl0KCkge1xuICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBleHBvc2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cnM6IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSxcbiAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcbiAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXG4gICAgICBleHBvc2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5leHBvc2VQcm94eSB8fCAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcbiAgICAgICAgICByZXR1cm4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHRhcmdldCB8fCBrZXkgaW4gcHVibGljUHJvcGVydGllc01hcDtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnByb3h5O1xuICB9XG59XG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGluY2x1ZGVJbmZlcnJlZCA9IHRydWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KSA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSA6IENvbXBvbmVudC5uYW1lIHx8IGluY2x1ZGVJbmZlcnJlZCAmJiBDb21wb25lbnQuX19uYW1lO1xufVxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xuICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcbiAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH1cbiAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xuICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbmFtZSA9IGluZmVyRnJvbVJlZ2lzdHJ5KFxuICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyB8fCBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzXG4gICAgKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xuICB9XG4gIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgXCJfX3ZjY09wdHNcIiBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcbiAgY29uc3QgYyA9IGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmIChpICYmIGkuYXBwQ29udGV4dC5jb25maWcud2FyblJlY3Vyc2l2ZUNvbXB1dGVkKSB7XG4gICAgICBjLl93YXJuUmVjdXJzaXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGM7XG59O1xuXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChsID09PSAyKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobCA+IDMpIHtcbiAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB9IGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcbiAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojM2JhNzc2XCIgfTtcbiAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMxNjc3ZmZcIiB9O1xuICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2Y1MjIyZFwiIH07XG4gIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2ViMmY5NlwiIH07XG4gIGNvbnN0IGZvcm1hdHRlciA9IHtcbiAgICBfX3Z1ZV9jdXN0b21fZm9ybWF0dGVyOiB0cnVlLFxuICAgIGhlYWRlcihvYmopIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1wiZGl2XCIsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICAvLyBhdm9pZCBkZWJ1Z2dlciBhY2Nlc3NpbmcgdmFsdWUgYWZmZWN0aW5nIGJlaGF2aW9yXG4gICAgICAgICAgZm9ybWF0VmFsdWUoXCJfdmFsdWVcIiBpbiBvYmogPyBvYmouX3ZhbHVlIDogb2JqKSxcbiAgICAgICAgICBgPmBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWN0aXZlXCIgOiBcIlJlYWN0aXZlXCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZG9ubHkob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFkb25seVwiIDogXCJSZWFkb25seVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIFwiPlwiXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGhhc0JvZHkob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xuICAgIH0sXG4gICAgYm9keShvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInByb3BzXCIsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwic2V0dXBcIiwgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiZGF0YVwiLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImNvbXB1dGVkXCIpO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImNvbXB1dGVkXCIsIGNvbXB1dGVkKSk7XG4gICAgfVxuICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiaW5qZWN0XCIpO1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImluamVjdGVkXCIsIGluamVjdGVkKSk7XG4gICAgfVxuICAgIGJsb2Nrcy5wdXNoKFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7fSxcbiAgICAgIFtcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgXCI7b3BhY2l0eTowLjY2XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCIkIChpbnRlcm5hbCk6IFwiXG4gICAgICBdLFxuICAgICAgW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxuICAgIF0pO1xuICAgIHJldHVybiBibG9ja3M7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwge31dO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3R5bGU6IFwibGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW1cIiB9LFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwiY29sb3I6IzQ3NjU4MlwiXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJwYWRkaW5nLWxlZnQ6MS4yNWVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwga2V5ICsgXCI6IFwiXSxcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcbiAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICAgXVxuICAgIF07XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBudW1iZXJTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHYpKSB7XG4gICAgICByZXR1cm4gW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XG4gICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFjdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XG4gICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xuICAgICAgICBleHRyYWN0ZWRba2V5XSA9IGluc3RhbmNlLmN0eFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdGVkO1xuICB9XG4gIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xuICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xuICAgIGlmIChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSB8fCBpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUoKG0pID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XG4gICAgaWYgKGlzU2hhbGxvdyh2KSkge1xuICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcbiAgICB9XG4gICAgaWYgKHYuZWZmZWN0KSB7XG4gICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcbiAgICB9XG4gICAgcmV0dXJuIGBSZWZgO1xuICB9XG4gIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2luZGV4XTtcbiAgaWYgKGNhY2hlZCAmJiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJldCA9IHJlbmRlcigpO1xuICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcbiAgcmV0LmNhY2hlSW5kZXggPSBpbmRleDtcbiAgcmV0dXJuIGNhY2hlW2luZGV4XSA9IHJldDtcbn1cbmZ1bmN0aW9uIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSB7XG4gIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcbiAgaWYgKHByZXYubGVuZ3RoICE9IG1lbW8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChoYXNDaGFuZ2VkKHByZXZbaV0sIG1lbW9baV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IHZlcnNpb24gPSBcIjMuNS4xM1wiO1xuY29uc3Qgd2FybiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB3YXJuJDEgOiBOT09QO1xuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IEVycm9yVHlwZVN0cmluZ3MkMSA7XG5jb25zdCBkZXZ0b29scyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHJ1ZSA/IGRldnRvb2xzJDEgOiB2b2lkIDA7XG5jb25zdCBzZXREZXZ0b29sc0hvb2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBzZXREZXZ0b29sc0hvb2skMSA6IE5PT1A7XG5jb25zdCBfc3NyVXRpbHMgPSB7XG4gIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlLFxuICBzZXR1cENvbXBvbmVudCxcbiAgcmVuZGVyQ29tcG9uZW50Um9vdCxcbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlLFxuICBpc1ZOb2RlOiBpc1ZOb2RlLFxuICBub3JtYWxpemVWTm9kZSxcbiAgZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UsXG4gIGVuc3VyZVZhbGlkVk5vZGUsXG4gIHB1c2hXYXJuaW5nQ29udGV4dCxcbiAgcG9wV2FybmluZ0NvbnRleHRcbn07XG5jb25zdCBzc3JVdGlscyA9IF9zc3JVdGlscyA7XG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcbmNvbnN0IGNvbXBhdFV0aWxzID0gbnVsbDtcbmNvbnN0IERlcHJlY2F0aW9uVHlwZXMgPSBudWxsO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIENvbW1lbnQsIERlcHJlY2F0aW9uVHlwZXMsIEVycm9yQ29kZXMsIEVycm9yVHlwZVN0cmluZ3MsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBhc3NlcnROdW1iZXIsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBjYWxsV2l0aEVycm9ySGFuZGxpbmcsIGNsb25lVk5vZGUsIGNvbXBhdFV0aWxzLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudEJsb2NrLCBjcmVhdGVCYXNlVk5vZGUgYXMgY3JlYXRlRWxlbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUHJvcHNSZXN0UHJveHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXRzLCBkZWZpbmVFeHBvc2UsIGRlZmluZU1vZGVsLCBkZWZpbmVPcHRpb25zLCBkZWZpbmVQcm9wcywgZGVmaW5lU2xvdHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgZ3VhcmRSZWFjdGl2ZVByb3BzLCBoLCBoYW5kbGVFcnJvciwgaGFzSW5qZWN0aW9uQ29udGV4dCwgaHlkcmF0ZU9uSWRsZSwgaHlkcmF0ZU9uSW50ZXJhY3Rpb24sIGh5ZHJhdGVPbk1lZGlhUXVlcnksIGh5ZHJhdGVPblZpc2libGUsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNNZW1vU2FtZSwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VNb2RlbHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VJZCwgdXNlTW9kZWwsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUZW1wbGF0ZVJlZiwgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoTWVtbywgd2l0aFNjb3BlSWQgfTtcbiIsIi8qKlxuKiBAdnVlL3J1bnRpbWUtZG9tIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IHdhcm4sIGgsIEJhc2VUcmFuc2l0aW9uLCBhc3NlcnROdW1iZXIsIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBnZXRDdXJyZW50SW5zdGFuY2UsIG9uQmVmb3JlVXBkYXRlLCBxdWV1ZVBvc3RGbHVzaENiLCBvbk1vdW50ZWQsIHdhdGNoLCBvblVubW91bnRlZCwgRnJhZ21lbnQsIFN0YXRpYywgY2FtZWxpemUsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCB1bnJlZiwgY3JlYXRlVk5vZGUsIHVzZVRyYW5zaXRpb25TdGF0ZSwgb25VcGRhdGVkLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIFRleHQsIGlzUnVudGltZU9ubHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGV4dGVuZCwgaXNPYmplY3QsIHRvTnVtYmVyLCBpc0FycmF5LCBOT09QLCBpc1N0cmluZywgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzU3ltYm9sLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNGdW5jdGlvbiwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBpc1BsYWluT2JqZWN0LCBoYXNPd24sIEVNUFRZX09CSiwgbG9vc2VUb051bWJlciwgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaW52b2tlQXJyYXlGbnMsIGlzSFRNTFRhZywgaXNTVkdUYWcsIGlzTWF0aE1MVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5sZXQgcG9saWN5ID0gdm9pZCAwO1xuY29uc3QgdHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy50cnVzdGVkVHlwZXM7XG5pZiAodHQpIHtcbiAgdHJ5IHtcbiAgICBwb2xpY3kgPSAvKiBAX19QVVJFX18gKi8gdHQuY3JlYXRlUG9saWN5KFwidnVlXCIsIHtcbiAgICAgIGNyZWF0ZUhUTUw6ICh2YWwpID0+IHZhbFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBFcnJvciBjcmVhdGluZyB0cnVzdGVkIHR5cGVzIHBvbGljeTogJHtlfWApO1xuICB9XG59XG5jb25zdCB1bnNhZmVUb1RydXN0ZWRIVE1MID0gcG9saWN5ID8gKHZhbCkgPT4gcG9saWN5LmNyZWF0ZUhUTUwodmFsKSA6ICh2YWwpID0+IHZhbDtcbmNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgbWF0aG1sTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qIEBfX1BVUkVfXyAqLyBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuY29uc3Qgbm9kZU9wcyA9IHtcbiAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xuICB9LFxuICByZW1vdmU6IChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIG5hbWVzcGFjZSwgaXMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgZWwgPSBuYW1lc3BhY2UgPT09IFwic3ZnXCIgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpIDogbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhtYXRobWxOUywgdGFnKSA6IGlzID8gZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7IGlzIH0pIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGFnID09PSBcInNlbGVjdFwiICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsIHByb3BzLm11bHRpcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9LFxuICBjcmVhdGVUZXh0OiAodGV4dCkgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpLFxuICBjcmVhdGVDb21tZW50OiAodGV4dCkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXG4gIHNldFRleHQ6IChub2RlLCB0ZXh0KSA9PiB7XG4gICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICB9LFxuICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9LFxuICBwYXJlbnROb2RlOiAobm9kZSkgPT4gbm9kZS5wYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogKG5vZGUpID0+IG5vZGUubmV4dFNpYmxpbmcsXG4gIHF1ZXJ5U2VsZWN0b3I6IChzZWxlY3RvcikgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICBzZXRTY29wZUlkKGVsLCBpZCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gIH0sXG4gIC8vIF9fVU5TQUZFX19cbiAgLy8gUmVhc29uOiBpbm5lckhUTUwuXG4gIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cbiAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgbmFtZXNwYWNlLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgaWYgKHN0YXJ0ICYmIChzdGFydCA9PT0gZW5kIHx8IHN0YXJ0Lm5leHRTaWJsaW5nKSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kIHx8ICEoc3RhcnQgPSBzdGFydC5uZXh0U2libGluZykpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSB1bnNhZmVUb1RydXN0ZWRIVE1MKFxuICAgICAgICBuYW1lc3BhY2UgPT09IFwic3ZnXCIgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiA/IGA8bWF0aD4ke2NvbnRlbnR9PC9tYXRoPmAgOiBjb250ZW50XG4gICAgICApO1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbnRhaW5lci5jb250ZW50O1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJzdmdcIiB8fCBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgYW5jaG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIGZpcnN0XG4gICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcbiAgICAgIC8vIGxhc3RcbiAgICAgIGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkXG4gICAgXTtcbiAgfVxufTtcblxuY29uc3QgVFJBTlNJVElPTiA9IFwidHJhbnNpdGlvblwiO1xuY29uc3QgQU5JTUFUSU9OID0gXCJhbmltYXRpb25cIjtcbmNvbnN0IHZ0Y0tleSA9IFN5bWJvbChcIl92dGNcIik7XG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgY3NzOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXG4gIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcbn07XG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgZGVjb3JhdGUkMSA9ICh0KSA9PiB7XG4gIHQuZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbiAgdC5wcm9wcyA9IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnM7XG4gIHJldHVybiB0O1xufTtcbmNvbnN0IFRyYW5zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gZGVjb3JhdGUkMShcbiAgKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cylcbik7XG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcbiAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICBob29rLmZvckVhY2goKGgyKSA9PiBoMiguLi5hcmdzKSk7XG4gIH0gZWxzZSBpZiAoaG9vaykge1xuICAgIGhvb2soLi4uYXJncyk7XG4gIH1cbn07XG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcbiAgcmV0dXJuIGhvb2sgPyBpc0FycmF5KGhvb2spID8gaG9vay5zb21lKChoMikgPT4gaDIubGVuZ3RoID4gMSkgOiBob29rLmxlbmd0aCA+IDEgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XG4gIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xuICAgIHJldHVybiBiYXNlUHJvcHM7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcInZcIixcbiAgICB0eXBlLFxuICAgIGR1cmF0aW9uLFxuICAgIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLFxuICAgIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsXG4gICAgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gXG4gIH0gPSByYXdQcm9wcztcbiAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xuICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XG4gIGNvbnN0IHtcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLFxuICAgIG9uQXBwZWFyID0gb25FbnRlcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWRcbiAgfSA9IGJhc2VQcm9wcztcbiAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lLCBpc0NhbmNlbGxlZCkgPT4ge1xuICAgIGVsLl9lbnRlckNhbmNlbGxlZCA9IGlzQ2FuY2VsbGVkO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBpZiAoIWVsLl9lbnRlckNhbmNlbGxlZCkge1xuICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIH1cbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlLCB2b2lkIDAsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIHRydWUsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICBjYWxsSG9vayhvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hMZWF2ZShlbCk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcbiAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xuICAgIHJldHVybiBbbiwgbl07XG4gIH1cbn1cbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xuICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcihyZXMsIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAoZWxbdnRjS2V5XSB8fCAoZWxbdnRjS2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpKS5hZGQoY2xzKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZGVsZXRlKGNscyk7XG4gICAgaWYgKCFfdnRjLnNpemUpIHtcbiAgICAgIGVsW3Z0Y0tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICB9KTtcbn1cbmxldCBlbmRJZCA9IDA7XG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XG4gIGNvbnN0IGlkID0gZWwuX2VuZElkID0gKytlbmRJZDtcbiAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XG4gICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGlmIChleHBsaWNpdFRpbWVvdXQgIT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyBcImVuZFwiO1xuICBsZXQgZW5kZWQgPSAwO1xuICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgXCJcIikuc3BsaXQoXCIsIFwiKTtcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfURlbGF5YCk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RGVsYXlgKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRpbWVvdXQgPSAwO1xuICBsZXQgcHJvcENvdW50ID0gMDtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMCA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dCA/IFRSQU5TSVRJT04gOiBBTklNQVRJT04gOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGUgPyB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGggOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChcbiAgICBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1Qcm9wZXJ0eWApLnRvU3RyaW5nKClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHRvTXMocykge1xuICBpZiAocyA9PT0gXCJhdXRvXCIpIHJldHVybiAwO1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiAxZTM7XG59XG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbFt2dGNLZXldO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbihcIiBcIik7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCB2U2hvd09yaWdpbmFsRGlzcGxheSA9IFN5bWJvbChcIl92b2RcIik7XG5jb25zdCB2U2hvd0hpZGRlbiA9IFN5bWJvbChcIl92c2hcIik7XG5jb25zdCB2U2hvdyA9IHtcbiAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gPSBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSByZXR1cm47XG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XG4gICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIHZTaG93Lm5hbWUgPSBcInNob3dcIjtcbn1cbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA6IFwibm9uZVwiO1xuICBlbFt2U2hvd0hpZGRlbl0gPSAhdmFsdWU7XG59XG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XG4gIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IENTU19WQVJfVEVYVCA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJDU1NfVkFSX1RFWFRcIiA6IFwiXCIpO1xuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgQXJyYXkuZnJvbShcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuZ2V0Q3NzVmFycyA9ICgpID0+IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gIH1cbiAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHtcbiAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICBpZiAoaW5zdGFuY2UuY2UpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoaW5zdGFuY2UuY2UsIHZhcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCB2YXJzKTtcbiAgICB9XG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICB9O1xuICBvbkJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihzZXRWYXJzKTtcbiAgfSk7XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgd2F0Y2goc2V0VmFycywgTk9PUCwgeyBmbHVzaDogXCJwb3N0XCIgfSk7XG4gICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdm5vZGUuZWwpIHtcbiAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgaWYgKGVsID09PSBhbmNob3IpIGJyZWFrO1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBsZXQgY3NzVGV4dCA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgIGNzc1RleHQgKz0gYC0tJHtrZXl9OiAke3ZhcnNba2V5XX07YDtcbiAgICB9XG4gICAgc3R5bGVbQ1NTX1ZBUl9URVhUXSA9IGNzc1RleHQ7XG4gIH1cbn1cblxuY29uc3QgZGlzcGxheVJFID0gLyhefDspXFxzKmRpc3BsYXlcXHMqOi87XG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGxldCBoYXNDb250cm9sbGVkRGlzcGxheSA9IGZhbHNlO1xuICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKCFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJldlN0eWxlIG9mIHByZXYuc3BsaXQoXCI7XCIpKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcHJldlN0eWxlLnNsaWNlKDAsIHByZXZTdHlsZS5pbmRleE9mKFwiOlwiKSkudHJpbSgpO1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0Nzc1N0cmluZykge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgY29uc3QgY3NzVmFyVGV4dCA9IHN0eWxlW0NTU19WQVJfVEVYVF07XG4gICAgICAgIGlmIChjc3NWYXJUZXh0KSB7XG4gICAgICAgICAgbmV4dCArPSBcIjtcIiArIGNzc1ZhclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gZGlzcGxheVJFLnRlc3QobmV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZTaG93T3JpZ2luYWxEaXNwbGF5IGluIGVsKSB7XG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gaGFzQ29udHJvbGxlZERpc3BsYXkgPyBzdHlsZS5kaXNwbGF5IDogXCJcIjtcbiAgICBpZiAoZWxbdlNob3dIaWRkZW5dKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XG4gIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaCgodikgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09IG51bGwpIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UsIGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSkpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIGtleSxcbiAgICAgICAgaXNCb29sZWFuID8gXCJcIiA6IGlzU3ltYm9sKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBwYXJlbnRDb21wb25lbnQsIGF0dHJOYW1lKSB7XG4gIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZWxba2V5XSA9IGtleSA9PT0gXCJpbm5lckhUTUxcIiA/IHVuc2FmZVRvVHJ1c3RlZEhUTUwodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgdGFnICE9PSBcIlBST0dSRVNTXCIgJiYgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcbiAgIXRhZy5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhZyA9PT0gXCJPUFRJT05cIiA/IGVsLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCIgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAoXG4gICAgICAvLyAjMTE2NDc6IHZhbHVlIHNob3VsZCBiZSBzZXQgYXMgZW1wdHkgc3RyaW5nIGZvciBudWxsIGFuZCB1bmRlZmluZWQsXG4gICAgICAvLyBidXQgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiPiBzaG91bGQgYmUgc2V0IGFzICdvbicuXG4gICAgICBlbC50eXBlID09PSBcImNoZWNrYm94XCIgPyBcIm9uXCIgOiBcIlwiXG4gICAgKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSB8fCAhKFwiX3ZhbHVlXCIgaW4gZWwpKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lIHx8IGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5jb25zdCB2ZWlLZXkgPSBTeW1ib2woXCJfdmVpXCIpO1xuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xuICBjb25zdCBpbnZva2VycyA9IGVsW3ZlaUtleV0gfHwgKGVsW3ZlaUtleV0gPSB7fSk7XG4gIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xuICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xuICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzYW5pdGl6ZUV2ZW50VmFsdWUobmV4dFZhbHVlLCByYXdOYW1lKSA6IG5leHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XG4gICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgY29uc3QgaW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlLFxuICAgICAgICBpbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gIGxldCBvcHRpb25zO1xuICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgbTtcbiAgICB3aGlsZSAobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gXCI6XCIgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xuICByZXR1cm4gW2V2ZW50LCBvcHRpb25zXTtcbn1cbmxldCBjYWNoZWROb3cgPSAwO1xuY29uc3QgcCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IGNhY2hlZE5vdyA9IDApLCBjYWNoZWROb3cgPSBEYXRlLm5vdygpKTtcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xuICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICBpZiAoIWUuX3Z0cykge1xuICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDUsXG4gICAgICBbZV1cbiAgICApO1xuICB9O1xuICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XG4gIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gc2FuaXRpemVFdmVudFZhbHVlKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgd2FybihcbiAgICBgV3JvbmcgdHlwZSBwYXNzZWQgYXMgZXZlbnQgaGFuZGxlciB0byAke3Byb3BOYW1lfSAtIGRpZCB5b3UgZm9yZ2V0IEAgb3IgOiBpbiBmcm9udCBvZiB5b3VyIHByb3A/XG5FeHBlY3RlZCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMsIHJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgdmFsdWV9LmBcbiAgKTtcbiAgcmV0dXJuIE5PT1A7XG59XG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xuICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWUubWFwKFxuICAgICAgKGZuKSA9PiAoZTIpID0+ICFlMi5fc3RvcHBlZCAmJiBmbiAmJiBmbihlMilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCBpc05hdGl2ZU9uID0gKGtleSkgPT4ga2V5LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBrZXkuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIC8vIGxvd2VyY2FzZSBsZXR0ZXJcbmtleS5jaGFyQ29kZUF0KDIpID4gOTYgJiYga2V5LmNoYXJDb2RlQXQoMikgPCAxMjM7XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gIGNvbnN0IGlzU1ZHID0gbmFtZXNwYWNlID09PSBcInN2Z1wiO1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXlbMF0gPT09IFwiLlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgdHJ1ZSkgOiBrZXlbMF0gPT09IFwiXlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgZmFsc2UpIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XG4gICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSk7XG4gICAgaWYgKCFlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSAmJiAoa2V5ID09PSBcInZhbHVlXCIgfHwga2V5ID09PSBcImNoZWNrZWRcIiB8fCBrZXkgPT09IFwic2VsZWN0ZWRcIikpIHtcbiAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHLCBwYXJlbnRDb21wb25lbnQsIGtleSAhPT0gXCJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gIzExMDgxIGZvcmNlIHNldCBwcm9wcyBmb3IgcG9zc2libGUgYXN5bmMgY3VzdG9tIGVsZW1lbnRcbiAgICBlbC5faXNWdWVDRSAmJiAoL1tBLVpdLy50ZXN0KGtleSkgfHwgIWlzU3RyaW5nKG5leHRWYWx1ZSkpXG4gICkge1xuICAgIHBhdGNoRE9NUHJvcChlbCwgY2FtZWxpemUkMShrZXkpLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCwga2V5KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ID09PSBcInRydWUtdmFsdWVcIikge1xuICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJmYWxzZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xuICBpZiAoaXNTVkcpIHtcbiAgICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleSBpbiBlbCAmJiBpc05hdGl2ZU9uKGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJzcGVsbGNoZWNrXCIgfHwga2V5ID09PSBcImRyYWdnYWJsZVwiIHx8IGtleSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwid2lkdGhcIiB8fCBrZXkgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICAgIGlmICh0YWcgPT09IFwiSU1HXCIgfHwgdGFnID09PSBcIlZJREVPXCIgfHwgdGFnID09PSBcIkNBTlZBU1wiIHx8IHRhZyA9PT0gXCJTT1VSQ0VcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYXRpdmVPbihrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5IGluIGVsO1xufVxuXG5jb25zdCBSRU1PVkFMID0ge307XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgX2NyZWF0ZUFwcCkge1xuICBjb25zdCBDb21wID0gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gIGlmIChpc1BsYWluT2JqZWN0KENvbXApKSBleHRlbmQoQ29tcCwgZXh0cmFPcHRpb25zKTtcbiAgY2xhc3MgVnVlQ3VzdG9tRWxlbWVudCBleHRlbmRzIFZ1ZUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxQcm9wcykge1xuICAgICAgc3VwZXIoQ29tcCwgaW5pdGlhbFByb3BzLCBfY3JlYXRlQXBwKTtcbiAgICB9XG4gIH1cbiAgVnVlQ3VzdG9tRWxlbWVudC5kZWYgPSBDb21wO1xuICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcbn1cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChvcHRpb25zLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgY3JlYXRlU1NSQXBwKTtcbn07XG5jb25zdCBCYXNlQ2xhc3MgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn07XG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIF9jcmVhdGVBcHAgPSBjcmVhdGVBcHApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RlZiA9IF9kZWY7XG4gICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XG4gICAgdGhpcy5fY3JlYXRlQXBwID0gX2NyZWF0ZUFwcDtcbiAgICB0aGlzLl9pc1Z1ZUNFID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYXBwID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9ub25jZSA9IHRoaXMuX2RlZi5ub25jZTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcbiAgICB0aGlzLl9zdHlsZUNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fb2IgPSBudWxsO1xuICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgX2NyZWF0ZUFwcCAhPT0gY3JlYXRlQXBwKSB7XG4gICAgICB0aGlzLl9yb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGRlZmluZWQgYXMgaHlkcmF0YWJsZS4gVXNlIFxcYGRlZmluZVNTUkN1c3RvbUVsZW1lbnRcXGAuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKF9kZWYuc2hhZG93Um9vdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlUHJvcHModGhpcy5fZGVmKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIHRoaXMuX3BhcnNlU2xvdHMoKTtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpIHtcbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5fcGVuZGluZ1Jlc29sdmUpIHtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IHBhcmVudC5fcGVuZGluZ1Jlc29sdmUudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldFBhcmVudChwYXJlbnQgPSB0aGlzLl9wYXJlbnQpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZS5wYXJlbnQgPSBwYXJlbnQuX2luc3RhbmNlO1xuICAgICAgdGhpcy5faW5zdGFuY2UucHJvdmlkZXMgPSBwYXJlbnQuX2luc3RhbmNlLnByb3ZpZGVzO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICBpZiAodGhpcy5fb2IpIHtcbiAgICAgICAgICB0aGlzLl9vYi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgdGhpcy5fb2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcCAmJiB0aGlzLl9hcHAudW5tb3VudCgpO1xuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHRoaXMuX2luc3RhbmNlLmNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9hcHAgPSB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAqL1xuICBfcmVzb2x2ZURlZigpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ1Jlc29sdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9vYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cihtLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX29iLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoZGVmLCBpc0FzeW5jID0gZmFsc2UpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gdm9pZCAwO1xuICAgICAgY29uc3QgeyBwcm9wcywgc3R5bGVzIH0gPSBkZWY7XG4gICAgICBsZXQgbnVtYmVyUHJvcHM7XG4gICAgICBpZiAocHJvcHMgJiYgIWlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcbiAgICAgICAgICBpZiAob3B0ID09PSBOdW1iZXIgfHwgb3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRvTnVtYmVyKHRoaXMuX3Byb3BzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSlbY2FtZWxpemUkMShrZXkpXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bWJlclByb3BzO1xuICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKGRlZik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3R5bGVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJDdXN0b20gZWxlbWVudCBzdHlsZSBpbmplY3Rpb24gaXMgbm90IHN1cHBvcnRlZCB3aGVuIHVzaW5nIHNoYWRvd1Jvb3Q6IGZhbHNlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vdW50KGRlZik7XG4gICAgfTtcbiAgICBjb25zdCBhc3luY0RlZiA9IHRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyO1xuICAgIGlmIChhc3luY0RlZikge1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBhc3luY0RlZigpLnRoZW4oXG4gICAgICAgIChkZWYpID0+IHJlc29sdmUodGhpcy5fZGVmID0gZGVmLCB0cnVlKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBfbW91bnQoZGVmKSB7XG4gICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgIWRlZi5uYW1lKSB7XG4gICAgICBkZWYubmFtZSA9IFwiVnVlRWxlbWVudFwiO1xuICAgIH1cbiAgICB0aGlzLl9hcHAgPSB0aGlzLl9jcmVhdGVBcHAoZGVmKTtcbiAgICBpZiAoZGVmLmNvbmZpZ3VyZUFwcCkge1xuICAgICAgZGVmLmNvbmZpZ3VyZUFwcCh0aGlzLl9hcHApO1xuICAgIH1cbiAgICB0aGlzLl9hcHAuX2NlVk5vZGUgPSB0aGlzLl9jcmVhdGVWTm9kZSgpO1xuICAgIHRoaXMuX2FwcC5tb3VudCh0aGlzLl9yb290KTtcbiAgICBjb25zdCBleHBvc2VkID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuZXhwb3NlZDtcbiAgICBpZiAoIWV4cG9zZWQpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBleHBvc2VkKSB7XG4gICAgICBpZiAoIWhhc093bih0aGlzLCBrZXkpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICAvLyB1bndyYXAgcmVmIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBwdWJsaWMgaW5zdGFuY2UgYmVoYXZpb3JcbiAgICAgICAgICBnZXQ6ICgpID0+IHVucmVmKGV4cG9zZWRba2V5XSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybihgRXhwb3NlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGFscmVhZHkgZXhpc3RzIG9uIGN1c3RvbSBlbGVtZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcmVzb2x2ZVByb3BzKGRlZikge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IGRlZjtcbiAgICBjb25zdCBkZWNsYXJlZFByb3BLZXlzID0gaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IE9iamVjdC5rZXlzKHByb3BzIHx8IHt9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgaWYgKGtleVswXSAhPT0gXCJfXCIgJiYgZGVjbGFyZWRQcm9wS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB0aGlzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWNsYXJlZFByb3BLZXlzLm1hcChjYW1lbGl6ZSQxKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB2YWwsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEF0dHIoa2V5KSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwiZGF0YS12LVwiKSkgcmV0dXJuO1xuICAgIGNvbnN0IGhhcyA9IHRoaXMuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgbGV0IHZhbHVlID0gaGFzID8gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KSA6IFJFTU9WQUw7XG4gICAgY29uc3QgY2FtZWxLZXkgPSBjYW1lbGl6ZSQxKGtleSk7XG4gICAgaWYgKGhhcyAmJiB0aGlzLl9udW1iZXJQcm9wcyAmJiB0aGlzLl9udW1iZXJQcm9wc1tjYW1lbEtleV0pIHtcbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRQcm9wKGNhbWVsS2V5LCB2YWx1ZSwgZmFsc2UsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRQcm9wKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRQcm9wKGtleSwgdmFsLCBzaG91bGRSZWZsZWN0ID0gdHJ1ZSwgc2hvdWxkVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XG4gICAgICBpZiAodmFsID09PSBSRU1PVkFMKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9wc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJrZXlcIiAmJiB0aGlzLl9hcHApIHtcbiAgICAgICAgICB0aGlzLl9hcHAuX2NlVk5vZGUua2V5ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlZmxlY3QpIHtcbiAgICAgICAgY29uc3Qgb2IgPSB0aGlzLl9vYjtcbiAgICAgICAgb2IgJiYgb2IuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIG9iICYmIG9iLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfdXBkYXRlKCkge1xuICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLl9yb290KTtcbiAgfVxuICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGJhc2VQcm9wcy5vblZub2RlTW91bnRlZCA9IGJhc2VQcm9wcy5vblZub2RlVXBkYXRlZCA9IHRoaXMuX3JlbmRlclNsb3RzLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoYmFzZVByb3BzLCB0aGlzLl9wcm9wcykpO1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHZub2RlLmNlID0gKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLmNlID0gdGhpcztcbiAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSAobmV3U3R5bGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKChzKSA9PiB0aGlzLl9yb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhuZXdTdHlsZXMpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwYXRjaCA9IChldmVudCwgYXJncykgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgIGlzUGxhaW5PYmplY3QoYXJnc1swXSkgPyBleHRlbmQoeyBkZXRhaWw6IGFyZ3MgfSwgYXJnc1swXSkgOiB7IGRldGFpbDogYXJncyB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICBpZiAoaHlwaGVuYXRlKGV2ZW50KSAhPT0gZXZlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGh5cGhlbmF0ZShldmVudCksIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgX2FwcGx5U3R5bGVzKHN0eWxlcywgb3duZXIpIHtcbiAgICBpZiAoIXN0eWxlcykgcmV0dXJuO1xuICAgIGlmIChvd25lcikge1xuICAgICAgaWYgKG93bmVyID09PSB0aGlzLl9kZWYgfHwgdGhpcy5fc3R5bGVDaGlsZHJlbi5oYXMob3duZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4uYWRkKG93bmVyKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSB0aGlzLl9ub25jZTtcbiAgICBmb3IgKGxldCBpID0gc3R5bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgaWYgKG5vbmNlKSBzLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgICAgIHMudGV4dENvbnRlbnQgPSBzdHlsZXNbaV07XG4gICAgICB0aGlzLnNoYWRvd1Jvb3QucHJlcGVuZChzKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGlmIChvd25lcikge1xuICAgICAgICAgIGlmIChvd25lci5fX2htcklkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NoaWxkU3R5bGVzKSB0aGlzLl9jaGlsZFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSB0aGlzLl9jaGlsZFN0eWxlcy5nZXQob3duZXIuX19obXJJZCk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NoaWxkU3R5bGVzLnNldChvd25lci5fX2htcklkLCBlbnRyeSA9IFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5LnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT25seSBjYWxsZWQgd2hlbiBzaGFkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcGFyc2VTbG90cygpIHtcbiAgICBjb25zdCBzbG90cyA9IHRoaXMuX3Nsb3RzID0ge307XG4gICAgbGV0IG47XG4gICAgd2hpbGUgKG4gPSB0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gbi5ub2RlVHlwZSA9PT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcInNsb3RcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAoc2xvdHNbc2xvdE5hbWVdIHx8IChzbG90c1tzbG90TmFtZV0gPSBbXSkpLnB1c2gobik7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKG4pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT25seSBjYWxsZWQgd2hlbiBzaGFkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcmVuZGVyU2xvdHMoKSB7XG4gICAgY29uc3Qgb3V0bGV0cyA9ICh0aGlzLl90ZWxlcG9ydFRhcmdldCB8fCB0aGlzKS5xdWVyeVNlbGVjdG9yQWxsKFwic2xvdFwiKTtcbiAgICBjb25zdCBzY29wZUlkID0gdGhpcy5faW5zdGFuY2UudHlwZS5fX3Njb3BlSWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gb3V0bGV0c1tpXTtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gby5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX3Nsb3RzW3Nsb3ROYW1lXTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG8ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBjb250ZW50KSB7XG4gICAgICAgICAgaWYgKHNjb3BlSWQgJiYgbi5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBzY29wZUlkICsgXCItc1wiO1xuICAgICAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihuLCAxKTtcbiAgICAgICAgICAgIG4uc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCA9IHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobiwgbyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChvLmZpcnN0Q2hpbGQpIHBhcmVudC5pbnNlcnRCZWZvcmUoby5maXJzdENoaWxkLCBvKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChvKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2luamVjdENoaWxkU3R5bGUoY29tcCkge1xuICAgIHRoaXMuX2FwcGx5U3R5bGVzKGNvbXAuc3R5bGVzLCBjb21wKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmVtb3ZlQ2hpbGRTdHlsZShjb21wKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4uZGVsZXRlKGNvbXApO1xuICAgICAgaWYgKHRoaXMuX2NoaWxkU3R5bGVzICYmIGNvbXAuX19obXJJZCkge1xuICAgICAgICBjb25zdCBvbGRTdHlsZXMgPSB0aGlzLl9jaGlsZFN0eWxlcy5nZXQoY29tcC5fX2htcklkKTtcbiAgICAgICAgaWYgKG9sZFN0eWxlcykge1xuICAgICAgICAgIG9sZFN0eWxlcy5mb3JFYWNoKChzKSA9PiB0aGlzLl9yb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICBvbGRTdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdXNlSG9zdChjYWxsZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgZWwgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jZTtcbiAgaWYgKGVsKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYWxsZXIgfHwgXCJ1c2VIb3N0XCJ9IGNhbGxlZCB3aXRob3V0IGFuIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FsbGVyIHx8IFwidXNlSG9zdFwifSBjYW4gb25seSBiZSB1c2VkIGluIGNvbXBvbmVudHMgZGVmaW5lZCB2aWEgZGVmaW5lQ3VzdG9tRWxlbWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNoYWRvd1Jvb3QoKSB7XG4gIGNvbnN0IGVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHVzZUhvc3QoXCJ1c2VTaGFkb3dSb290XCIpIDogdXNlSG9zdCgpO1xuICByZXR1cm4gZWwgJiYgZWwuc2hhZG93Um9vdDtcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSBcIiRzdHlsZVwiKSB7XG4gIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XG4gICAgaWYgKCFtb2R1bGVzKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlcyBpbmplY3RlZC5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XG4gICAgaWYgKCFtb2QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICByZXR1cm4gbW9kO1xuICB9XG59XG5cbmNvbnN0IHBvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbW92ZUNiS2V5ID0gU3ltYm9sKFwiX21vdmVDYlwiKTtcbmNvbnN0IGVudGVyQ2JLZXkgPSBTeW1ib2woXCJfZW50ZXJDYlwiKTtcbmNvbnN0IGRlY29yYXRlID0gKHQpID0+IHtcbiAgZGVsZXRlIHQucHJvcHMubW9kZTtcbiAgcmV0dXJuIHQ7XG59O1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IC8qIEBfX1BVUkVfXyAqLyBkZWNvcmF0ZSh7XG4gIG5hbWU6IFwiVHJhbnNpdGlvbkdyb3VwXCIsXG4gIHByb3BzOiAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XG4gICAgdGFnOiBTdHJpbmcsXG4gICAgbW92ZUNsYXNzOiBTdHJpbmdcbiAgfSksXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgbGV0IHByZXZDaGlsZHJlbjtcbiAgICBsZXQgY2hpbGRyZW47XG4gICAgb25VcGRhdGVkKCgpID0+IHtcbiAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCBcInZcIn0tbW92ZWA7XG4gICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShcbiAgICAgICAgcHJldkNoaWxkcmVuWzBdLmVsLFxuICAgICAgICBpbnN0YW5jZS52bm9kZS5lbCxcbiAgICAgICAgbW92ZUNsYXNzXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG1vdmVkQ2hpbGRyZW4gPSBwcmV2Q2hpbGRyZW4uZmlsdGVyKGFwcGx5VHJhbnNsYXRpb24pO1xuICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCJcIjtcbiAgICAgICAgY29uc3QgY2IgPSBlbFttb3ZlQ2JLZXldID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgICAgICAgZWxbbW92ZUNiS2V5XSA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcbiAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XG4gICAgICBwcmV2Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBpZiAoY2hpbGQuZWwgJiYgY2hpbGQuZWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICAgIGNzc1RyYW5zaXRpb25Qcm9wcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KFxuICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGlsZC50eXBlICE9PSBUZXh0KSB7XG4gICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgY29uc3QgZWwgPSBjLmVsO1xuICBpZiAoZWxbbW92ZUNiS2V5XSkge1xuICAgIGVsW21vdmVDYktleV0oKTtcbiAgfVxuICBpZiAoZWxbZW50ZXJDYktleV0pIHtcbiAgICBlbFtlbnRlckNiS2V5XSgpO1xuICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xuICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiMHNcIjtcbiAgICByZXR1cm4gYztcbiAgfVxufVxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcbiAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgfSk7XG4gIH1cbiAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgY2xvbmUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICBjb25zdCBjb250YWluZXIgPSByb290Lm5vZGVUeXBlID09PSAxID8gcm9vdCA6IHJvb3QucGFyZW50Tm9kZTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCBmbiA9IHZub2RlLnByb3BzW1wib25VcGRhdGU6bW9kZWxWYWx1ZVwiXSB8fCBmYWxzZTtcbiAgcmV0dXJuIGlzQXJyYXkoZm4pID8gKHZhbHVlKSA9PiBpbnZva2VBcnJheUZucyhmbiwgdmFsdWUpIDogZm47XG59O1xuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xuICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcbiAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIikpO1xuICB9XG59XG5jb25zdCBhc3NpZ25LZXkgPSBTeW1ib2woXCJfYXNzaWduXCIpO1xuY29uc3Qgdk1vZGVsVGV4dCA9IHtcbiAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09IFwibnVtYmVyXCI7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKSByZXR1cm47XG4gICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgIGlmICh0cmltKSB7XG4gICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc3RUb051bWJlcikge1xuICAgICAgICBkb21WYWx1ZSA9IGxvb3NlVG9OdW1iZXIoZG9tVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxbYXNzaWduS2V5XShkb21WYWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFsYXp5KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25lbmRcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICB9XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKGVsLmNvbXBvc2luZykgcmV0dXJuO1xuICAgIGNvbnN0IGVsVmFsdWUgPSAobnVtYmVyIHx8IGVsLnR5cGUgPT09IFwibnVtYmVyXCIpICYmICEvXjBcXGQvLnRlc3QoZWwudmFsdWUpID8gbG9vc2VUb051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gICAgaWYgKGVsVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCAmJiBlbC50eXBlICE9PSBcInJhbmdlXCIpIHtcbiAgICAgIGlmIChsYXp5ICYmIHZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgfVxufTtcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xuICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xuICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgICBjb25zdCBhc3NpZ24gPSBlbFthc3NpZ25LZXldO1xuICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XG4gICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xuICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xuICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgU2V0KG1vZGVsVmFsdWUpO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKGNsb25lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcbiAgbW91bnRlZDogc2V0Q2hlY2tlZCxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xuICBsZXQgY2hlY2tlZDtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuICAgIGNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XG4gIH1cbiAgaWYgKGVsLmNoZWNrZWQgIT09IGNoZWNrZWQpIHtcbiAgICBlbC5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxufVxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBlbFthc3NpZ25LZXldKGdldFZhbHVlKGVsKSk7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB2TW9kZWxTZWxlY3QgPSB7XG4gIC8vIDxzZWxlY3QgbXVsdGlwbGU+IHZhbHVlIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZCkubWFwKFxuICAgICAgICAobykgPT4gbnVtYmVyID8gbG9vc2VUb051bWJlcihnZXRWYWx1ZShvKSkgOiBnZXRWYWx1ZShvKVxuICAgICAgKTtcbiAgICAgIGVsW2Fzc2lnbktleV0oXG4gICAgICAgIGVsLm11bHRpcGxlID8gaXNTZXRNb2RlbCA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpIDogc2VsZWN0ZWRWYWwgOiBzZWxlY3RlZFZhbFswXVxuICAgICAgKTtcbiAgICAgIGVsLl9hc3NpZ25pbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBlbC5fYXNzaWduaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cbiAgLy8gPG9wdGlvbj5zLlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgaWYgKCFlbC5fYXNzaWduaW5nKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xuICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGNvbnN0IGlzQXJyYXlWYWx1ZSA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheVZhbHVlICYmICFpc1NldCh2YWx1ZSkpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICBgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZ2V0VmFsdWUob3B0aW9uKTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICBjb25zdCBvcHRpb25UeXBlID0gdHlwZW9mIG9wdGlvblZhbHVlO1xuICAgICAgICBpZiAob3B0aW9uVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvcHRpb25UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuc29tZSgodikgPT4gU3RyaW5nKHYpID09PSBTdHJpbmcob3B0aW9uVmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5oYXMob3B0aW9uVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xuICByZXR1cm4gXCJfdmFsdWVcIiBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xuICBjb25zdCBrZXkgPSBjaGVja2VkID8gXCJfdHJ1ZVZhbHVlXCIgOiBcIl9mYWxzZVZhbHVlXCI7XG4gIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcbn1cbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XG4gIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwiY3JlYXRlZFwiKTtcbiAgfSxcbiAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJtb3VudGVkXCIpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwidXBkYXRlZFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljTW9kZWwodGFnTmFtZSwgdHlwZSkge1xuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiU0VMRUNUXCI6XG4gICAgICByZXR1cm4gdk1vZGVsU2VsZWN0O1xuICAgIGNhc2UgXCJURVhUQVJFQVwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsQ2hlY2tib3g7XG4gICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xuICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICBlbC50YWdOYW1lLFxuICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgKTtcbiAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xuICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XG59XG5mdW5jdGlvbiBpbml0Vk1vZGVsRm9yU1NSKCkge1xuICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XG4gIHZNb2RlbFJhZGlvLmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VFcXVhbCh2bm9kZS5wcm9wcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxEeW5hbWljLmdldFNTUlByb3BzID0gKGJpbmRpbmcsIHZub2RlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2bm9kZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgICAgLy8gcmVzb2x2ZUR5bmFtaWNNb2RlbCBleHBlY3RzIGFuIHVwcGVyY2FzZSB0YWcgbmFtZSwgYnV0IHZub2RlLnR5cGUgaXMgbG93ZXJjYXNlXG4gICAgICB2bm9kZS50eXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICAgKTtcbiAgICBpZiAobW9kZWxUb1VzZS5nZXRTU1JQcm9wcykge1xuICAgICAgcmV0dXJuIG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMoYmluZGluZywgdm5vZGUpO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gW1wiY3RybFwiLCBcInNoaWZ0XCIsIFwiYWx0XCIsIFwibWV0YVwiXTtcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xuICBzdG9wOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcbiAgcHJldmVudDogKGUpID0+IGUucHJldmVudERlZmF1bHQoKSxcbiAgc2VsZjogKGUpID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXG4gIGN0cmw6IChlKSA9PiAhZS5jdHJsS2V5LFxuICBzaGlmdDogKGUpID0+ICFlLnNoaWZ0S2V5LFxuICBhbHQ6IChlKSA9PiAhZS5hbHRLZXksXG4gIG1ldGE6IChlKSA9PiAhZS5tZXRhS2V5LFxuICBsZWZ0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxuICBtaWRkbGU6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDEsXG4gIHJpZ2h0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxuICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUoKG0pID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxufTtcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICBjb25zdCBjYWNoZSA9IGZuLl93aXRoTW9kcyB8fCAoZm4uX3dpdGhNb2RzID0ge30pO1xuICBjb25zdCBjYWNoZUtleSA9IG1vZGlmaWVycy5qb2luKFwiLlwiKTtcbiAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XSB8fCAoY2FjaGVbY2FjaGVLZXldID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcbiAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSkgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xuICB9KTtcbn07XG5jb25zdCBrZXlOYW1lcyA9IHtcbiAgZXNjOiBcImVzY2FwZVwiLFxuICBzcGFjZTogXCIgXCIsXG4gIHVwOiBcImFycm93LXVwXCIsXG4gIGxlZnQ6IFwiYXJyb3ctbGVmdFwiLFxuICByaWdodDogXCJhcnJvdy1yaWdodFwiLFxuICBkb3duOiBcImFycm93LWRvd25cIixcbiAgZGVsZXRlOiBcImJhY2tzcGFjZVwiXG59O1xuY29uc3Qgd2l0aEtleXMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICBjb25zdCBjYWNoZSA9IGZuLl93aXRoS2V5cyB8fCAoZm4uX3dpdGhLZXlzID0ge30pO1xuICBjb25zdCBjYWNoZUtleSA9IG1vZGlmaWVycy5qb2luKFwiLlwiKTtcbiAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XSB8fCAoY2FjaGVbY2FjaGVLZXldID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCEoXCJrZXlcIiBpbiBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcbiAgICBpZiAobW9kaWZpZXJzLnNvbWUoXG4gICAgICAoaykgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5XG4gICAgKSkge1xuICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcbmxldCByZW5kZXJlcjtcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcbiAgcmV0dXJuIHJlbmRlcmVyIHx8IChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpO1xufVxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XG4gIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvbiA/IHJlbmRlcmVyIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcbiAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XG4gIHJldHVybiByZW5kZXJlcjtcbn1cbmNvbnN0IHJlbmRlciA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGh5ZHJhdGUgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XG59O1xuY29uc3QgY3JlYXRlQXBwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICB9XG4gIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcbiAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcbiAgICBpZiAoIWlzRnVuY3Rpb24oY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikpO1xuICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKFwidi1jbG9ha1wiKTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtYXBwXCIsIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuY29uc3QgY3JlYXRlU1NSQXBwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICB9XG4gIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmZ1bmN0aW9uIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikge1xuICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIHJldHVybiBcInN2Z1wiO1xuICB9XG4gIGlmICh0eXBlb2YgTWF0aE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIE1hdGhNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJtYXRobWxcIjtcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzTmF0aXZlVGFnXCIsIHtcbiAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSB8fCBpc01hdGhNTFRhZyh0YWcpLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xuICBpZiAoaXNSdW50aW1lT25seSgpKSB7XG4gICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNDdXN0b21FbGVtZW50XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudDtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucztcbiAgICBjb25zdCBtc2cgPSBgVGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUuanMgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlciAoYWthIFwiZnVsbCBidWlsZFwiKS4gU2luY2UgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBjb21waWxlck9wdGlvbnNcXGAgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXG4tIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXG4tIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxuLSBGb3Igdml0ZTogcGFzcyBpdCB2aWEgQHZpdGVqcy9wbHVnaW4tdnVlIG9wdGlvbnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUtcGx1Z2luLXZ1ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItc2ZjYDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJjb21waWxlck9wdGlvbnNcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcbiAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIubW9kZSA9PT0gXCJjbG9zZWRcIikge1xuICAgIHdhcm4oXG4gICAgICBgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2BcbiAgICApO1xuICB9XG4gIHJldHVybiBjb250YWluZXI7XG59XG5sZXQgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmNvbnN0IGluaXREaXJlY3RpdmVzRm9yU1NSID0gKCkgPT4ge1xuICBpZiAoIXNzckRpcmVjdGl2ZUluaXRpYWxpemVkKSB7XG4gICAgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGluaXRWTW9kZWxGb3JTU1IoKTtcbiAgICBpbml0VlNob3dGb3JTU1IoKTtcbiAgfVxufSA7XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgVnVlRWxlbWVudCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRlZmluZVNTUkN1c3RvbUVsZW1lbnQsIGh5ZHJhdGUsIGluaXREaXJlY3RpdmVzRm9yU1NSLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdXNlSG9zdCwgdXNlU2hhZG93Um9vdCwgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIiwiLyoqXG4qIHZ1ZSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBpbml0Q3VzdG9tRm9ybWF0dGVyLCB3YXJuIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcbiAge1xuICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcbiAgfVxufVxuXG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBpbml0RGV2KCk7XG59XG5jb25zdCBjb21waWxlID0gKCkgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oXG4gICAgICBgUnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgeyBjb21waWxlIH07XG4iLCJmdW5jdGlvbiBub29wKCkgeyB9XG5cbmV4cG9ydCB7IG5vb3AgfTtcbiIsImZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IHsgaXNQcmltaXRpdmUgfTtcbiIsImZ1bmN0aW9uIGlzVHlwZWRBcnJheSh4KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG5cbmV4cG9ydCB7IGlzVHlwZWRBcnJheSB9O1xuIiwiZnVuY3Rpb24gZ2V0U3ltYm9scyhvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpLmZpbHRlcihzeW1ib2wgPT4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKSk7XG59XG5cbmV4cG9ydCB7IGdldFN5bWJvbHMgfTtcbiIsImZ1bmN0aW9uIGdldFRhZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJ1tvYmplY3QgVW5kZWZpbmVkXScgOiAnW29iamVjdCBOdWxsXSc7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgeyBnZXRUYWcgfTtcbiIsImNvbnN0IHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuY29uc3Qgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5jb25zdCBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJztcbmNvbnN0IGJvb2xlYW5UYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5jb25zdCBhcmd1bWVudHNUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbmNvbnN0IHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuY29uc3QgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJztcbmNvbnN0IG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuY29uc3Qgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG5jb25zdCBmdW5jdGlvblRhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5jb25zdCBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG5jb25zdCBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcbmNvbnN0IGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcbmNvbnN0IHVpbnQ4QXJyYXlUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XSc7XG5jb25zdCB1aW50OENsYW1wZWRBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc7XG5jb25zdCB1aW50MTZBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XSc7XG5jb25zdCB1aW50MzJBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5jb25zdCBiaWdVaW50NjRBcnJheVRhZyA9ICdbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XSc7XG5jb25zdCBpbnQ4QXJyYXlUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJztcbmNvbnN0IGludDE2QXJyYXlUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XSc7XG5jb25zdCBpbnQzMkFycmF5VGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nO1xuY29uc3QgYmlnSW50NjRBcnJheVRhZyA9ICdbb2JqZWN0IEJpZ0ludDY0QXJyYXldJztcbmNvbnN0IGZsb2F0MzJBcnJheVRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nO1xuY29uc3QgZmxvYXQ2NEFycmF5VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7XG5cbmV4cG9ydCB7IGFyZ3VtZW50c1RhZywgYXJyYXlCdWZmZXJUYWcsIGFycmF5VGFnLCBiaWdJbnQ2NEFycmF5VGFnLCBiaWdVaW50NjRBcnJheVRhZywgYm9vbGVhblRhZywgZGF0YVZpZXdUYWcsIGRhdGVUYWcsIGVycm9yVGFnLCBmbG9hdDMyQXJyYXlUYWcsIGZsb2F0NjRBcnJheVRhZywgZnVuY3Rpb25UYWcsIGludDE2QXJyYXlUYWcsIGludDMyQXJyYXlUYWcsIGludDhBcnJheVRhZywgbWFwVGFnLCBudW1iZXJUYWcsIG9iamVjdFRhZywgcmVnZXhwVGFnLCBzZXRUYWcsIHN0cmluZ1RhZywgc3ltYm9sVGFnLCB1aW50MTZBcnJheVRhZywgdWludDMyQXJyYXlUYWcsIHVpbnQ4QXJyYXlUYWcsIHVpbnQ4Q2xhbXBlZEFycmF5VGFnIH07XG4iLCJpbXBvcnQgeyBnZXRTeW1ib2xzIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRTeW1ib2xzLm1qcyc7XG5pbXBvcnQgeyBnZXRUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL2dldFRhZy5tanMnO1xuaW1wb3J0IHsgdWludDMyQXJyYXlUYWcsIHVpbnQxNkFycmF5VGFnLCB1aW50OENsYW1wZWRBcnJheVRhZywgdWludDhBcnJheVRhZywgc3ltYm9sVGFnLCBzdHJpbmdUYWcsIHNldFRhZywgcmVnZXhwVGFnLCBvYmplY3RUYWcsIG51bWJlclRhZywgbWFwVGFnLCBpbnQzMkFycmF5VGFnLCBpbnQxNkFycmF5VGFnLCBpbnQ4QXJyYXlUYWcsIGZsb2F0NjRBcnJheVRhZywgZmxvYXQzMkFycmF5VGFnLCBkYXRlVGFnLCBib29sZWFuVGFnLCBkYXRhVmlld1RhZywgYXJyYXlCdWZmZXJUYWcsIGFycmF5VGFnLCBhcmd1bWVudHNUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL3RhZ3MubWpzJztcbmltcG9ydCB7IGlzUHJpbWl0aXZlIH0gZnJvbSAnLi4vcHJlZGljYXRlL2lzUHJpbWl0aXZlLm1qcyc7XG5pbXBvcnQgeyBpc1R5cGVkQXJyYXkgfSBmcm9tICcuLi9wcmVkaWNhdGUvaXNUeXBlZEFycmF5Lm1qcyc7XG5cbmZ1bmN0aW9uIGNsb25lRGVlcFdpdGgob2JqLCBjbG9uZVZhbHVlKSB7XG4gICAgcmV0dXJuIGNsb25lRGVlcFdpdGhJbXBsKG9iaiwgdW5kZWZpbmVkLCBvYmosIG5ldyBNYXAoKSwgY2xvbmVWYWx1ZSk7XG59XG5mdW5jdGlvbiBjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZVRvQ2xvbmUsIGtleVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrID0gbmV3IE1hcCgpLCBjbG9uZVZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWYWx1ZT8uKHZhbHVlVG9DbG9uZSwga2V5VG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2spO1xuICAgIGlmIChjbG9uZWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgICBpZiAoaXNQcmltaXRpdmUodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVUb0Nsb25lO1xuICAgIH1cbiAgICBpZiAoc3RhY2suaGFzKHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrLmdldCh2YWx1ZVRvQ2xvbmUpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSh2YWx1ZVRvQ2xvbmUubGVuZ3RoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZVRvQ2xvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlVG9DbG9uZVtpXSwgaSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHZhbHVlVG9DbG9uZSwgJ2luZGV4JykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlVG9DbG9uZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih2YWx1ZVRvQ2xvbmUsICdpbnB1dCcpKSB7XG4gICAgICAgICAgICByZXN1bHQuaW5wdXQgPSB2YWx1ZVRvQ2xvbmUuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlVG9DbG9uZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSZWdFeHAodmFsdWVUb0Nsb25lLnNvdXJjZSwgdmFsdWVUb0Nsb25lLmZsYWdzKTtcbiAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHZhbHVlVG9DbG9uZS5sYXN0SW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWx1ZVRvQ2xvbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZSwga2V5LCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlVG9DbG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZSwgdW5kZWZpbmVkLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVUb0Nsb25lLnN1YmFycmF5KCk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVkQXJyYXkodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZVRvQ2xvbmUpLmNvbnN0cnVjdG9yKSh2YWx1ZVRvQ2xvbmUubGVuZ3RoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZVRvQ2xvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlVG9DbG9uZVtpXSwgaSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9DbG9uZS5zbGljZSgwKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRhVmlldyh2YWx1ZVRvQ2xvbmUuYnVmZmVyLnNsaWNlKDApLCB2YWx1ZVRvQ2xvbmUuYnl0ZU9mZnNldCwgdmFsdWVUb0Nsb25lLmJ5dGVMZW5ndGgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZpbGUoW3ZhbHVlVG9DbG9uZV0sIHZhbHVlVG9DbG9uZS5uYW1lLCB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZVRvQ2xvbmUudHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBCbG9iKFt2YWx1ZVRvQ2xvbmVdLCB7IHR5cGU6IHZhbHVlVG9DbG9uZS50eXBlIH0pO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IHZhbHVlVG9DbG9uZS5jb25zdHJ1Y3RvcigpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQubWVzc2FnZSA9IHZhbHVlVG9DbG9uZS5tZXNzYWdlO1xuICAgICAgICByZXN1bHQubmFtZSA9IHZhbHVlVG9DbG9uZS5uYW1lO1xuICAgICAgICByZXN1bHQuc3RhY2sgPSB2YWx1ZVRvQ2xvbmUuc3RhY2s7XG4gICAgICAgIHJlc3VsdC5jYXVzZSA9IHZhbHVlVG9DbG9uZS5jYXVzZTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZVRvQ2xvbmUgPT09ICdvYmplY3QnICYmIGlzQ2xvbmVhYmxlT2JqZWN0KHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWVUb0Nsb25lKSk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVRvQ2xvbmU7XG59XG5mdW5jdGlvbiBjb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgb2JqZWN0VG9DbG9uZSA9IHRhcmdldCwgc3RhY2ssIGNsb25lVmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5rZXlzKHNvdXJjZSksIC4uLmdldFN5bWJvbHMoc291cmNlKV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgPT0gbnVsbCB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lRGVlcFdpdGhJbXBsKHNvdXJjZVtrZXldLCBrZXksIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ2xvbmVhYmxlT2JqZWN0KG9iamVjdCkge1xuICAgIHN3aXRjaCAoZ2V0VGFnKG9iamVjdCkpIHtcbiAgICAgICAgY2FzZSBhcmd1bWVudHNUYWc6XG4gICAgICAgIGNhc2UgYXJyYXlUYWc6XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgIGNhc2UgYm9vbGVhblRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIGZsb2F0MzJBcnJheVRhZzpcbiAgICAgICAgY2FzZSBmbG9hdDY0QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgaW50OEFycmF5VGFnOlxuICAgICAgICBjYXNlIGludDE2QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgaW50MzJBcnJheVRhZzpcbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIG9iamVjdFRhZzpcbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgIGNhc2UgdWludDhBcnJheVRhZzpcbiAgICAgICAgY2FzZSB1aW50OENsYW1wZWRBcnJheVRhZzpcbiAgICAgICAgY2FzZSB1aW50MTZBcnJheVRhZzpcbiAgICAgICAgY2FzZSB1aW50MzJBcnJheVRhZzoge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBjbG9uZURlZXBXaXRoLCBjbG9uZURlZXBXaXRoSW1wbCwgY29weVByb3BlcnRpZXMgfTtcbiIsImltcG9ydCB7IGNsb25lRGVlcFdpdGhJbXBsIH0gZnJvbSAnLi9jbG9uZURlZXBXaXRoLm1qcyc7XG5cbmZ1bmN0aW9uIGNsb25lRGVlcChvYmopIHtcbiAgICByZXR1cm4gY2xvbmVEZWVwV2l0aEltcGwob2JqLCB1bmRlZmluZWQsIG9iaiwgbmV3IE1hcCgpLCB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgeyBjbG9uZURlZXAgfTtcbiIsImZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgY29uc3QgaGFzT2JqZWN0UHJvdG90eXBlID0gcHJvdG8gPT09IG51bGwgfHxcbiAgICAgICAgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSA9PT0gbnVsbDtcbiAgICBpZiAoIWhhc09iamVjdFByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZXhwb3J0IHsgaXNQbGFpbk9iamVjdCB9O1xuIiwiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uL3ByZWRpY2F0ZS9pc1BsYWluT2JqZWN0Lm1qcyc7XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gICAgY29uc3Qgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZShbXSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHt9LCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCB7IG1lcmdlIH07XG4iLCJmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IChOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc05hTihvdGhlcikpO1xufVxuXG5leHBvcnQgeyBlcSB9O1xuIiwiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdC5tanMnO1xuaW1wb3J0IHsgZ2V0U3ltYm9scyB9IGZyb20gJy4uL2NvbXBhdC9faW50ZXJuYWwvZ2V0U3ltYm9scy5tanMnO1xuaW1wb3J0IHsgZ2V0VGFnIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRUYWcubWpzJztcbmltcG9ydCB7IGZ1bmN0aW9uVGFnLCByZWdleHBUYWcsIHN5bWJvbFRhZywgZGF0ZVRhZywgYm9vbGVhblRhZywgbnVtYmVyVGFnLCBzdHJpbmdUYWcsIG9iamVjdFRhZywgZXJyb3JUYWcsIGRhdGFWaWV3VGFnLCBhcnJheUJ1ZmZlclRhZywgZmxvYXQ2NEFycmF5VGFnLCBmbG9hdDMyQXJyYXlUYWcsIGJpZ0ludDY0QXJyYXlUYWcsIGludDMyQXJyYXlUYWcsIGludDE2QXJyYXlUYWcsIGludDhBcnJheVRhZywgYmlnVWludDY0QXJyYXlUYWcsIHVpbnQzMkFycmF5VGFnLCB1aW50MTZBcnJheVRhZywgdWludDhDbGFtcGVkQXJyYXlUYWcsIHVpbnQ4QXJyYXlUYWcsIGFycmF5VGFnLCBzZXRUYWcsIG1hcFRhZywgYXJndW1lbnRzVGFnIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC90YWdzLm1qcyc7XG5pbXBvcnQgeyBlcSB9IGZyb20gJy4uL2NvbXBhdC91dGlsL2VxLm1qcyc7XG5cbmZ1bmN0aW9uIGlzRXF1YWxXaXRoKGEsIGIsIGFyZVZhbHVlc0VxdWFsKSB7XG4gICAgcmV0dXJuIGlzRXF1YWxXaXRoSW1wbChhLCBiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZVZhbHVlc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxXaXRoSW1wbChhLCBiLCBwcm9wZXJ0eSwgYVBhcmVudCwgYlBhcmVudCwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXJlVmFsdWVzRXF1YWwoYSwgYiwgcHJvcGVydHksIGFQYXJlbnQsIGJQYXJlbnQsIHN0YWNrKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSB0eXBlb2YgYikge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYiB8fCBPYmplY3QuaXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xufVxuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCkge1xuICAgIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBhVGFnID0gZ2V0VGFnKGEpO1xuICAgIGxldCBiVGFnID0gZ2V0VGFnKGIpO1xuICAgIGlmIChhVGFnID09PSBhcmd1bWVudHNUYWcpIHtcbiAgICAgICAgYVRhZyA9IG9iamVjdFRhZztcbiAgICB9XG4gICAgaWYgKGJUYWcgPT09IGFyZ3VtZW50c1RhZykge1xuICAgICAgICBiVGFnID0gb2JqZWN0VGFnO1xuICAgIH1cbiAgICBpZiAoYVRhZyAhPT0gYlRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoYVRhZykge1xuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBiLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiBlcSh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGJvb2xlYW5UYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmlzKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSk7XG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOiB7XG4gICAgICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBmdW5jdGlvblRhZzoge1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sgPSBzdGFjayA/PyBuZXcgTWFwKCk7XG4gICAgY29uc3QgYVN0YWNrID0gc3RhY2suZ2V0KGEpO1xuICAgIGNvbnN0IGJTdGFjayA9IHN0YWNrLmdldChiKTtcbiAgICBpZiAoYVN0YWNrICE9IG51bGwgJiYgYlN0YWNrICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFTdGFjayA9PT0gYjtcbiAgICB9XG4gICAgc3RhY2suc2V0KGEsIGIpO1xuICAgIHN0YWNrLnNldChiLCBhKTtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKGFUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgbWFwVGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiLmhhcyhrZXkpIHx8ICFpc0VxdWFsV2l0aEltcGwodmFsdWUsIGIuZ2V0KGtleSksIGtleSwgYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBzZXRUYWc6IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhVmFsdWVzID0gQXJyYXkuZnJvbShhLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiVmFsdWVzID0gQXJyYXkuZnJvbShiLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVZhbHVlID0gYVZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBiVmFsdWVzLmZpbmRJbmRleChiVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWxXaXRoSW1wbChhVmFsdWUsIGJWYWx1ZSwgdW5kZWZpbmVkLCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJWYWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50OEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50OENsYW1wZWRBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDE2QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQzMkFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBiaWdVaW50NjRBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50OEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBpbnQxNkFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBpbnQzMkFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBiaWdJbnQ2NEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBmbG9hdDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGZsb2F0NjRBcnJheVRhZzoge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIoYSkgIT09IEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsV2l0aEltcGwoYVtpXSwgYltpXSwgaSwgYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzoge1xuICAgICAgICAgICAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwobmV3IFVpbnQ4QXJyYXkoYSksIG5ldyBVaW50OEFycmF5KGIpLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBkYXRhVmlld1RhZzoge1xuICAgICAgICAgICAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCB8fCBhLmJ5dGVPZmZzZXQgIT09IGIuYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwobmV3IFVpbnQ4QXJyYXkoYSksIG5ldyBVaW50OEFycmF5KGIpLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBlcnJvclRhZzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUgPT09IGIubmFtZSAmJiBhLm1lc3NhZ2UgPT09IGIubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2Ugb2JqZWN0VGFnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJlRXF1YWxJbnN0YW5jZXMgPSBhcmVPYmplY3RzRXF1YWwoYS5jb25zdHJ1Y3RvciwgYi5jb25zdHJ1Y3Rvciwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYUtleXMgPSBbLi4uT2JqZWN0LmtleXMoYSksIC4uLmdldFN5bWJvbHMoYSldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJLZXlzID0gWy4uLk9iamVjdC5rZXlzKGIpLCAuLi5nZXRTeW1ib2xzKGIpXTtcbiAgICAgICAgICAgICAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BLZXkgPSBhS2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVByb3AgPSBhW3Byb3BLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oYiwgcHJvcEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiUHJvcCA9IGJbcHJvcEtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcXVhbFdpdGhJbXBsKGFQcm9wLCBiUHJvcCwgcHJvcEtleSwgYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc3RhY2suZGVsZXRlKGEpO1xuICAgICAgICBzdGFjay5kZWxldGUoYik7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpc0VxdWFsV2l0aCB9O1xuIiwiaW1wb3J0IHsgaXNFcXVhbFdpdGggfSBmcm9tICcuL2lzRXF1YWxXaXRoLm1qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vZnVuY3Rpb24vbm9vcC5tanMnO1xuXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gaXNFcXVhbFdpdGgoYSwgYiwgbm9vcCk7XG59XG5cbmV4cG9ydCB7IGlzRXF1YWwgfTtcbiIsImltcG9ydCB7IEFueVNjaGVtYU9iamVjdCB9IGZyb20gXCJhanZcIjtcbmltcG9ydCB7IFR5cGUgfSBmcm9tIFwiQHNpbmNsYWlyL3R5cGVib3hcIjtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdHNGcm9tU2NoZW1hKFxuICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdFxuKTogUmVjb3JkPHN0cmluZywgeyB0eXBlPzogc3RyaW5nOyByZXF1aXJlZDogYm9vbGVhbjsgdmFsdWU6IGFueSB9PiB7XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IHR5cGU/OiBzdHJpbmc7IHJlcXVpcmVkOiBib29sZWFuOyB2YWx1ZTogYW55IH1cbiAgPiA9IHt9O1xuXG4gIGNvbnNvbGUubG9nKFwiZ2V0RGVmYXVsdHNGcm9tU2NoZW1hXCIpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgZXhjbHVkZWQgZnJvbSBkZWZhdWx0cyBiZWNhdXNlIHRoZXkgbXVzdCBiZSBzZXQgYnkgdGhlIGVkaXRvclxuICAgIGlmIChbXCJ4XCIsIFwieVwiLCBcInpcIiwgXCJnXCIsIFwid2lyZXNcIiwgXCJ0eXBlXCIsIFwiaWRcIl0uaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZSBhcyB7IGRlZmF1bHQ/OiBhbnk7IG5vZGVUeXBlPzogc3RyaW5nIH07XG4gICAgY29uc29sZS5sb2coa2V5KTtcbiAgICBjb25zb2xlLmxvZyhwcm9wZXJ0eSk7XG5cbiAgICByZXN1bHRba2V5XSA9IHtcbiAgICAgIC8vIE5PVEU6IHJlcXVpcmVkIGlzIGRlZmluZWQgYnkgdGhlIEpTT04gU2NoZW1hXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogcHJvcGVydHkuZGVmYXVsdCA/PyB1bmRlZmluZWQsXG4gICAgICAvLyBOT1RFOiBJJ20gdXNpbmcgYSBjdXN0b20ganNvbiBzY2hlbWEga2V5d29yZCB0byBkZXRlcm1pbmUgdGhlIG5vZGUgdHlwZVxuICAgICAgdHlwZTogcHJvcGVydHkubm9kZVR5cGUsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldENyZWRlbnRpYWxzRnJvbVNjaGVtYShcbiAgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3Rcbik6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyByZXF1aXJlZDogYm9vbGVhbjsgdmFsdWU6IGFueSB9PiB7XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IHR5cGU6IHN0cmluZzsgcmVxdWlyZWQ6IGJvb2xlYW47IHZhbHVlOiBhbnkgfVxuICA+ID0ge307XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZSBhcyB7XG4gICAgICBkZWZhdWx0PzogYW55O1xuICAgICAgZm9ybWF0OiBzdHJpbmc7XG4gICAgICBub2RlVHlwZT86IHN0cmluZztcbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKHByb3BlcnR5KTtcbiAgICBjb25zdCBpc1Bhc3N3b3JkID0gcHJvcGVydHkuZm9ybWF0ID09PSBcInBhc3N3b3JkXCI7XG4gICAgcmVzdWx0W2tleV0gPSB7XG4gICAgICAvLyBOT1RFOiByZXF1aXJlZCBpcyBkZWZpbmVkIGJ5IHRoZSBKU09OIFNjaGVtYVxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgdHlwZTogaXNQYXNzd29yZCA/IFwicGFzc3dvcmRcIiA6IFwidGV4dFwiLFxuICAgICAgdmFsdWU6IHByb3BlcnR5LmRlZmF1bHQgPz8gdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBnZXREZWZhdWx0c0Zyb21TY2hlbWEsIGdldENyZWRlbnRpYWxzRnJvbVNjaGVtYSB9O1xuIiwidmFyIGhhc0V4Y2FwZSA9IC9+L1xudmFyIGVzY2FwZU1hdGNoZXIgPSAvflswMV0vZ1xuZnVuY3Rpb24gZXNjYXBlUmVwbGFjZXIgKG0pIHtcbiAgc3dpdGNoIChtKSB7XG4gICAgY2FzZSAnfjEnOiByZXR1cm4gJy8nXG4gICAgY2FzZSAnfjAnOiByZXR1cm4gJ34nXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRpbGRlIGVzY2FwZTogJyArIG0pXG59XG5cbmZ1bmN0aW9uIHVudGlsZGUgKHN0cikge1xuICBpZiAoIWhhc0V4Y2FwZS50ZXN0KHN0cikpIHJldHVybiBzdHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGVzY2FwZU1hdGNoZXIsIGVzY2FwZVJlcGxhY2VyKVxufVxuXG5mdW5jdGlvbiBzZXR0ZXIgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgdmFyIHBhcnRcbiAgdmFyIGhhc05leHRQYXJ0XG5cbiAgZm9yICh2YXIgcCA9IDEsIGxlbiA9IHBvaW50ZXIubGVuZ3RoOyBwIDwgbGVuOykge1xuICAgIGlmIChwb2ludGVyW3BdID09PSAnY29uc3RydWN0b3InIHx8IHBvaW50ZXJbcF0gPT09ICdwcm90b3R5cGUnIHx8IHBvaW50ZXJbcF0gPT09ICdfX3Byb3RvX18nKSByZXR1cm4gb2JqXG5cbiAgICBwYXJ0ID0gdW50aWxkZShwb2ludGVyW3ArK10pXG4gICAgaGFzTmV4dFBhcnQgPSBsZW4gPiBwXG5cbiAgICBpZiAodHlwZW9mIG9ialtwYXJ0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHN1cHBvcnQgc2V0dGluZyBvZiAvLVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJiBwYXJ0ID09PSAnLScpIHtcbiAgICAgICAgcGFydCA9IG9iai5sZW5ndGhcbiAgICAgIH1cblxuICAgICAgLy8gc3VwcG9ydCBuZXN0ZWQgb2JqZWN0cy9hcnJheSB3aGVuIHNldHRpbmcgdmFsdWVzXG4gICAgICBpZiAoaGFzTmV4dFBhcnQpIHtcbiAgICAgICAgaWYgKChwb2ludGVyW3BdICE9PSAnJyAmJiBwb2ludGVyW3BdIDwgSW5maW5pdHkpIHx8IHBvaW50ZXJbcF0gPT09ICctJykgb2JqW3BhcnRdID0gW11cbiAgICAgICAgZWxzZSBvYmpbcGFydF0gPSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzTmV4dFBhcnQpIGJyZWFrXG4gICAgb2JqID0gb2JqW3BhcnRdXG4gIH1cblxuICB2YXIgb2xkVmFsdWUgPSBvYmpbcGFydF1cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGRlbGV0ZSBvYmpbcGFydF1cbiAgZWxzZSBvYmpbcGFydF0gPSB2YWx1ZVxuICByZXR1cm4gb2xkVmFsdWVcbn1cblxuZnVuY3Rpb24gY29tcGlsZVBvaW50ZXIgKHBvaW50ZXIpIHtcbiAgaWYgKHR5cGVvZiBwb2ludGVyID09PSAnc3RyaW5nJykge1xuICAgIHBvaW50ZXIgPSBwb2ludGVyLnNwbGl0KCcvJylcbiAgICBpZiAocG9pbnRlclswXSA9PT0gJycpIHJldHVybiBwb2ludGVyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4nKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRlcikpIHtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcG9pbnRlcikge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGFydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4gTXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciBudW1iZXIuJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvaW50ZXJcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIuJylcbn1cblxuZnVuY3Rpb24gZ2V0IChvYmosIHBvaW50ZXIpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgb2JqZWN0LicpXG4gIHBvaW50ZXIgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICB2YXIgbGVuID0gcG9pbnRlci5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMSkgcmV0dXJuIG9ialxuXG4gIGZvciAodmFyIHAgPSAxOyBwIDwgbGVuOykge1xuICAgIG9iaiA9IG9ialt1bnRpbGRlKHBvaW50ZXJbcCsrXSldXG4gICAgaWYgKGxlbiA9PT0gcCkgcmV0dXJuIG9ialxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQgKG9iaiwgcG9pbnRlciwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgb2JqZWN0LicpXG4gIHBvaW50ZXIgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICBpZiAocG9pbnRlci5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIgZm9yIHNldC4nKVxuICByZXR1cm4gc2V0dGVyKG9iaiwgcG9pbnRlciwgdmFsdWUpXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUgKHBvaW50ZXIpIHtcbiAgdmFyIGNvbXBpbGVkID0gY29tcGlsZVBvaW50ZXIocG9pbnRlcilcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiBnZXQob2JqZWN0LCBjb21waWxlZClcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKG9iamVjdCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXQob2JqZWN0LCBjb21waWxlZCwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZ2V0ID0gZ2V0XG5leHBvcnRzLnNldCA9IHNldFxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwid2lkdGg6IDEwMCVcIj5cbiAgICA8Tm9kZVJlZE5vZGVGb3JtIDpub2RlPVwibG9jYWxOb2RlXCIgOmVycm9ycz1cImVycm9yc1wiIHN0eWxlPVwid2lkdGg6IDEwMCVcIiAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5pbXBvcnQgeyB2YWxpZGF0b3JTZXJ2aWNlIH0gZnJvbSBcIi4vdmFsaWRhdG9yXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb25wb2ludGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJOb2RlUmVkVnVlQXBwXCIsXG4gIHByb3BzOiB7XG4gICAgbm9kZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICB2YWxpZGF0b3I6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBkaXNhYmxlU2F2ZUJ1dHRvbk9uRXJyb3I6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB9LFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbE5vZGU6IHRoaXMubm9kZSxcbiAgICAgIGVycm9yczoge30sXG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlTW91bnQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IodGhpcy5sb2NhbE5vZGUpO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5sb2NhbE5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgdGhpcy4kd2F0Y2goXG4gICAgICAgICgpID0+IHRoaXMubG9jYWxOb2RlW3Byb3BdLFxuICAgICAgICAobmV3VmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICB7IGRlZXA6IHRydWUgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuX2RlZi5jcmVkZW50aWFsc1twcm9wXS50eXBlID09PSBcInBhc3N3b3JkXCIgJiZcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF1cbiAgICAgICkge1xuICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1twcm9wXSA9IFwiX19QV0RfX1wiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiR3YXRjaChcbiAgICAgICAgKCkgPT4gdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbcHJvcF0sXG4gICAgICAgIChuZXdWYWwsIG9sZFZhbCkgPT4ge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHNbcHJvcF0udHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgICAgICBuZXdWYWwgIT09IG9sZFZhbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF0gPSAhIW5ld1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVTYXZlQnV0dG9uT25FcnJvcikge1xuICAgICAgJChcIiNub2RlLWRpYWxvZy1va1wiKT8ucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKS5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgJChcIiNub2RlLWNvbmZpZy1kaWFsb2ctb2tcIilcbiAgICAgICAgPy5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgJChcIiNyZWQtdWktd29ya3NwYWNlXCIpLmdldCgwKS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwiXCIpO1xuICAgICAgLy8gJChcIiNyZWQtdWktd29ya3NwYWNlLWNoYXJ0IHN2Z1wiKVxuICAgICAgLy8gICAuZ2V0KDApXG4gICAgICAvLyAgIC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpO1xuICAgIH1cblxuICAgIC8vIE5PVEU6IG11c3Qgc2V0IGNyZWRlbnRpYWxzIHByb3AgdG8gdW5kZWZpbmVkIHRvIGF2b2lkIHVwZGF0aW5nIGl0IHRvIF9fUFdEX18gaW4gdGhlIHNlcnZlclxuICAgIE9iamVjdC5rZXlzKHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuX2RlZi5jcmVkZW50aWFsc1twcm9wXS50eXBlID09PSBcInBhc3N3b3JkXCIgJiZcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF0gJiZcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbcHJvcF0gPT09IFwiX19QV0RfX1wiXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0b3IodGhpcy5sb2NhbE5vZGUpO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLnZhbGlkYXRvci5lcnJvcnM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzLnJlZHVjZSgoYWNjLCBlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yVmFsdWUgPSBqc29ucG9pbnRlci5nZXQoXG4gICAgICAgICAgICB0aGlzLmxvY2FsTm9kZSxcbiAgICAgICAgICAgIGVycm9yLmluc3RhbmNlUGF0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXJyb3IucGFyZW50U2NoZW1hLmZvcm1hdCA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgICAgICBlcnJvclZhbHVlID09PSBcIl9fUFdEX19cIlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIFwicGFzc3dvcmQgZmllbGRzIHdpdGggdmFsdWUgZXF1YWwgdG8gX19QV0RfXyBzaG91bGQgbm90IGJlIGFuIGVycm9yXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgbm9kZSR7ZXJyb3IuaW5zdGFuY2VQYXRoLnJlcGxhY2VBbGwoXCIvXCIsIFwiLlwiKX1gO1xuICAgICAgICAgICAgYWNjW2tleV0gPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRpc2FibGVTYXZlQnV0dG9uT25FcnJvcikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5lcnJvcnMpLmxlbmd0aCkge1xuICAgICAgICAgICQoXCIjbm9kZS1kaWFsb2ctb2tcIik/LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKS5hZGRDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgICAgICQoXCIjbm9kZS1jb25maWctZGlhbG9nLW9rXCIpXG4gICAgICAgICAgICA/LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKVxuICAgICAgICAgICAgLmFkZENsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgJChcIiNyZWQtdWktd29ya3NwYWNlXCIpXG4gICAgICAgICAgICAuZ2V0KDApXG4gICAgICAgICAgICAuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgLy8gJChcIiNyZWQtdWktd29ya3NwYWNlLWNoYXJ0IHN2Z1wiKVxuICAgICAgICAgIC8vICAgLmdldCgwKVxuICAgICAgICAgIC8vICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIsIFwiaW1wb3J0YW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQoXCIjbm9kZS1kaWFsb2ctb2tcIikucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKS5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgICAgICQoXCIjbm9kZS1jb25maWctZGlhbG9nLW9rXCIpXG4gICAgICAgICAgICAucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgJChcIiNyZWQtdWktd29ya3NwYWNlXCIpLmdldCgwKS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwiXCIpO1xuICAgICAgICAgIC8vICQoXCIjcmVkLXVpLXdvcmtzcGFjZS1jaGFydCBzdmdcIilcbiAgICAgICAgICAvLyAgIC5nZXQoMClcbiAgICAgICAgICAvLyAgIC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuI2FwcCAubm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2Uge1xuICBjb2xvcjogdmFyKC0tcmVkLXVpLWZvcm0taW5wdXQtYm9yZGVyLWVycm9yLWNvbG9yKTtcbn1cblxuI2FwcCBsYWJlbCB7XG4gIHdpZHRoOiAxMDAlO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlXCI+XG4gICAgPGlucHV0XG4gICAgICByZWY9XCJpbnB1dEZpZWxkXCJcbiAgICAgIDp0eXBlPVwidHlwZVwiXG4gICAgICA6dmFsdWU9XCJpbnRlcm5hbFZhbHVlXCJcbiAgICAgIDpwbGFjZWhvbGRlcj1cInBsYWNlaG9sZGVyXCJcbiAgICAgIEBpbnB1dD1cIm9uSW5wdXRcIlxuICAgICAgQGZvY3VzPVwib25Gb2N1c1wiXG4gICAgICBAYmx1cj1cIm9uQmx1clwiXG4gICAgICBzdHlsZT1cImZsZXg6IDE7IHdpZHRoOiAxMDAlXCJcbiAgICAvPlxuICAgIDxkaXYgdi1pZj1cImVycm9yXCIgY2xhc3M9XCJub2RlLXJlZC12dWUtaW5wdXQtZXJyb3ItbWVzc2FnZVwiPlxuICAgICAge3sgZXJyb3IgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBwbGFjZWhvbGRlcjogU3RyaW5nLFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlwiLFxuICAgIH0sXG4gIH0sXG4gIGVtaXRzOiBbXCJ1cGRhdGU6dmFsdWVcIiwgXCJpbnB1dFwiXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJuYWxWYWx1ZTogXCJcIixcbiAgICAgIHNlY3JldFBhdHRlcm46IFwiKioqKioqKioqKioqKlwiLFxuICAgIH07XG4gIH0sXG4gIGJlZm9yZU1vdW50KCkge1xuICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgdGhpcy5vbkJsdXIoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uSW5wdXQoZXZlbnQpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgIHRoaXMuJGVtaXQoXCJ1cGRhdGU6dmFsdWVcIiwgdGhpcy5pbnRlcm5hbFZhbHVlKTtcbiAgICAgIHRoaXMuJGVtaXQoXCJpbnB1dFwiLCB0aGlzLmludGVybmFsVmFsdWUpO1xuICAgIH0sXG4gICAgb25Gb2N1cygpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy50eXBlID09PSBcInBhc3N3b3JkXCIgJiZcbiAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID09PSB0aGlzLnNlY3JldFBhdHRlcm5cbiAgICAgICkge1xuICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSBcIlwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25CbHVyKCkge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJwYXNzd29yZFwiICYmIHRoaXMudmFsdWUgPT09IFwiX19QV0RfX1wiKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IHRoaXMuc2VjcmV0UGF0dGVybjtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiY29uc3QgVFlQRURfSU5QVVRfVFlQRVMgPSBbXG4gIFwibXNnXCIsXG4gIFwiZmxvd1wiLFxuICBcImdsb2JhbFwiLFxuICBcInN0clwiLFxuICBcIm51bVwiLFxuICBcImJvb2xcIixcbiAgXCJqc29uXCIsXG4gIFwiYmluXCIsXG4gIFwicmVcIixcbiAgXCJqc29uYXRhXCIsXG4gIFwiZGF0ZVwiLFxuICBcImVudlwiLFxuICBcIm5vZGVcIixcbiAgXCJjcmVkXCIsXG5dO1xuXG5leHBvcnQgeyBUWVBFRF9JTlBVVF9UWVBFUyB9O1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCVcIj5cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIHJlZj1cInR5cGVkSW5wdXRcIlxuICAgICAgY2xhc3M9XCJub2RlLXJlZC10eXBlZC1pbnB1dFwiXG4gICAgICBzdHlsZT1cImZsZXg6IDE7IHdpZHRoOiAxMDAlXCJcbiAgICAvPlxuICAgIDxkaXYgdi1pZj1cImVycm9yXCIgY2xhc3M9XCJub2RlLXJlZC12dWUtaW5wdXQtZXJyb3ItbWVzc2FnZVwiPlxuICAgICAge3sgZXJyb3IgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgVFlQRURfSU5QVVRfVFlQRVMgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKCF0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJbV0FSTl0gSW52YWxpZCB2YWx1ZSBmb3IgJ3ZhbHVlJyBwcm9wZXJ0eS4gSXQgbXVzdCBiZSBhbiBvYmplY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1ZhbGlkID1cbiAgICAgICAgICB0eXBlb2Ygb2JqPy52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqPy50eXBlID09PSBcInN0cmluZ1wiO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIltXQVJOXSBJbnZhbGlkIHZhbHVlIGZvciAndmFsdWUnIHByb3BlcnR5LiBJdCBtdXN0IGJlIGFuIG9iamVjdCB3aXRoICd2YWx1ZScgYW5kICd0eXBlJyBwcm9wZXJ0aWVzIGJlaW5nIHN0cmluZ3MuXCIsXG4gICAgICAgICAgICBvYmpcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHR5cGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6ICgpID0+IFRZUEVEX0lOUFVUX1RZUEVTLFxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc1Byb3ZpZGVkVmFsdWVUeXBlVmFsaWQoKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy52YWx1ZS50eXBlO1xuICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLnR5cGVzO1xuXG4gICAgICByZXR1cm4gdHlwZXMuaW5jbHVkZXModHlwZSk7XG4gICAgfSxcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSB0aGlzLiRyZWZzLnR5cGVkSW5wdXQ7XG4gICAgdGhpcy4kaW5wdXQgPSAkKGlucHV0RWxlbWVudCkudHlwZWRJbnB1dCh7XG4gICAgICBkZWZhdWx0OiB0aGlzLnZhbHVlLnR5cGUgfHwgdGhpcy50eXBlc1swXSxcbiAgICAgIHR5cGVzOiB0aGlzLnR5cGVzLFxuICAgIH0pO1xuXG4gICAgdGhpcy4kaW5wdXQudHlwZWRJbnB1dChcInZhbHVlXCIsIHRoaXMudmFsdWUudmFsdWUgfHwgXCJcIik7XG4gICAgdGhpcy4kaW5wdXQudHlwZWRJbnB1dChcInR5cGVcIiwgdGhpcy52YWx1ZS50eXBlIHx8IHRoaXMudHlwZXNbMF0pO1xuXG4gICAgLy8gTk9URTogd2hlbiB0eXBlZCBpbnB1dCBpcyBqdXN0IGEgdGV4dCBpbnB1dCwgaXQgaXNuJ3QgZW1pdGluZyBjaGFuZ2Ugd2hpbGUgdHlwaW5nIGJlY2F1c2UgaXQgaXMgdXBkYXRpbmcgdGhlIHZhbHVlIGluIGEgaGlkZGVuIGlucHV0XG4gICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG9ic2VydmVyLm9ic2VydmUoaW5wdXRFbGVtZW50LCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1widmFsdWVcIl0sXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB9KTtcblxuICAgIC8vIE5PVEU6IHRoaXMgZW1pdHMgY2hhbmdlcyB0byBhbGwgdHlwZXMgdGhhdCBsb3NlIGZvY3VzIHdoZW4gY2hvb3NpbmcgYSB2YWx1ZSwgYnV0IHRleHQgaW5wdXRzXG4gICAgdGhpcy4kaW5wdXQub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH0pO1xuICB9LFxuICB3YXRjaDoge1xuICAgIGlzUHJvdmlkZWRWYWx1ZVR5cGVWYWxpZDoge1xuICAgICAgaGFuZGxlcihuZXdWYWx1ZSkge1xuICAgICAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFZhbGlkYXRpb24gZmFpbGVkOiB0aGlzLnZhbHVlLnR5cGUgKCR7dGhpcy52YWx1ZS50eXBlfSkgbXVzdCBiZSBvbmUgb2YgdGhlIHByb3ZpZGVkIHR5cGVzICgke3RoaXMudHlwZXN9KS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICB9LFxuICAgIGVycm9yKG5ld1ZhbCkge1xuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXREaXYgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIFwiLnJlZC11aS10eXBlZElucHV0LWNvbnRhaW5lclwiXG4gICAgICAgICk7XG4gICAgICAgIGlmIChuZXdWYWwpIHtcbiAgICAgICAgICB0YXJnZXREaXYuY2xhc3NMaXN0LmFkZChcImlucHV0LWVycm9yXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldERpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaW5wdXQtZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy4kaW5wdXQudHlwZWRJbnB1dChcInZhbHVlXCIpO1xuICAgICAgY29uc3QgbmV3VHlwZSA9IHRoaXMuJGlucHV0LnR5cGVkSW5wdXQoXCJ0eXBlXCIpO1xuICAgICAgaWYgKHRoaXMudmFsdWUudmFsdWUgIT09IG5ld1ZhbHVlIHx8IHRoaXMudmFsdWUudHlwZSAhPT0gbmV3VHlwZSkge1xuICAgICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIHtcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgdHlwZTogbmV3VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlXCI+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgOmlkPVwiaW5wdXRJZFwiIHN0eWxlPVwid2lkdGg6IDEwMCVcIiAvPlxuICAgIDxkaXYgdi1pZj1cImVycm9yXCIgY2xhc3M9XCJub2RlLXJlZC12dWUtaW5wdXQtZXJyb3ItbWVzc2FnZVwiPlxuICAgICAge3sgZXJyb3IgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlwiLFxuICAgIH0sXG4gIH0sXG4gIGVtaXRzOiBbXCJ1cGRhdGU6dmFsdWVcIl0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaW5wdXRQcmVmaXgoKSB7XG4gICAgICByZXR1cm4gXCJub2RlLWlucHV0LVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpO1xuICAgIH0sXG4gICAgaW5wdXRJZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0UHJlZml4ICsgXCItXCIgKyB0aGlzLnZhbHVlO1xuICAgIH0sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgUkVELmVkaXRvci5wcmVwYXJlQ29uZmlnTm9kZVNlbGVjdChcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLnZhbHVlLFxuICAgICAgdGhpcy50eXBlLFxuICAgICAgdGhpcy5pbnB1dFByZWZpeFxuICAgICk7XG5cbiAgICBjb25zdCBpbnB1dCA9ICQoXCIjXCIgKyB0aGlzLmlucHV0SWQpO1xuICAgIGlucHV0Lm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuJGVtaXQoXCJ1cGRhdGU6dmFsdWVcIiwgaW5wdXQudmFsKCkpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQudmFsKHRoaXMudmFsdWUgfHwgXCJfQUREX1wiKTtcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlXCI+XG4gICAgPGlucHV0XG4gICAgICB0eXBlPVwidGV4dFwiXG4gICAgICByZWY9XCJzZWxlY3RJbnB1dFwiXG4gICAgICBjbGFzcz1cIm5vZGUtaW5wdXQtc2VsZWN0XCJcbiAgICAgIHN0eWxlPVwid2lkdGg6IDEwMCVcIlxuICAgIC8+XG4gICAgPGRpdiB2LWlmPVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyB8IEFycmF5LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJbV0FSTl0gSW52YWxpZCB2YWx1ZSBmb3IgJ29wdGlvbnMnIHByb3BlcnR5LiBJdCBtdXN0IGJlIGFuIGFycmF5LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbHVlLmV2ZXJ5KChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNPYmplY3QgPSB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBpdGVtICE9PSBudWxsO1xuICAgICAgICAgIGlmICghaXNPYmplY3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpICYmXG4gICAgICAgICAgICBpdGVtLmhhc093blByb3BlcnR5KFwibGFiZWxcIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpdGVtLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICB0eXBlb2YgaXRlbS5sYWJlbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW1dBUk5dIEludmFsaWQgdmFsdWUgZm9yICdvcHRpb25zJyBwcm9wZXJ0eS4gRWFjaCBpdGVtIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggJ3ZhbHVlJyBhbmQgJ2xhYmVsJyBwcm9wZXJ0aWVzIGJlaW5nIHN0cmluZ3MuXCIsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuICAgIH0sXG4gICAgbXVsdGlwbGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB9LFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlwiLFxuICAgIH0sXG4gIH0sXG4gIGVtaXRzOiBbXCJ1cGRhdGU6dmFsdWVcIl0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgaW5wdXRFbGVtZW50ID0gdGhpcy4kcmVmcy5zZWxlY3RJbnB1dDtcbiAgICBjb25zdCAkc2VsZWN0SW5wdXQgPSAkKGlucHV0RWxlbWVudCk7XG4gICAgJHNlbGVjdElucHV0LnR5cGVkSW5wdXQoe1xuICAgICAgdHlwZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG11bHRpcGxlOiB0aGlzLm11bHRpcGxlLFxuICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSk7XG5cbiAgICAkc2VsZWN0SW5wdXQudHlwZWRJbnB1dChcbiAgICAgIFwidmFsdWVcIixcbiAgICAgIEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlLmpvaW4oXCIsXCIpIDogdGhpcy52YWx1ZVxuICAgICk7XG4gICAgJHNlbGVjdElucHV0Lm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5tdWx0aXBsZVxuICAgICAgICA/ICRzZWxlY3RJbnB1dC50eXBlZElucHV0KFwidmFsdWVcIik/LnNwbGl0KFwiLFwiKVxuICAgICAgICA6ICRzZWxlY3RJbnB1dC50eXBlZElucHV0KFwidmFsdWVcIik7XG4gICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIG5ld1ZhbHVlKTtcbiAgICB9KTtcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiByZWY9XCJjb250YWluZXJEaXZcIiBjbGFzcz1cIm5vZGUtdGV4dC1lZGl0b3ItY29udGFpbmVyXCI+XG4gICAgPGRpdiByZWY9XCJlZGl0b3JEaXZcIiA6aWQ9XCJlZGl0b3JJZFwiIGNsYXNzPVwibm9kZS10ZXh0LWVkaXRvclwiPjwvZGl2PlxuICAgIDxkaXYgdi1zaG93PVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBsYW5ndWFnZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJqc29uXCIsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhbGxvd2VkTGFuZ3VhZ2VzID0gW1xuICAgICAgICAgIFwiYWJhcFwiLFxuICAgICAgICAgIFwiYXBleFwiLFxuICAgICAgICAgIFwiYXpjbGlcIixcbiAgICAgICAgICBcImJhdFwiLFxuICAgICAgICAgIFwiYmljZXBcIixcbiAgICAgICAgICBcImNhbWVsaWdvXCIsXG4gICAgICAgICAgXCJjbG9qdXJlXCIsXG4gICAgICAgICAgXCJjb2ZmZWVcIixcbiAgICAgICAgICBcImNwcFwiLFxuICAgICAgICAgIFwiY3NoYXJwXCIsXG4gICAgICAgICAgXCJjc3BcIixcbiAgICAgICAgICBcImNzc1wiLFxuICAgICAgICAgIFwiY3lwaGVyXCIsXG4gICAgICAgICAgXCJkYXJ0XCIsXG4gICAgICAgICAgXCJkb2NrZXJmaWxlXCIsXG4gICAgICAgICAgXCJlY2xcIixcbiAgICAgICAgICBcImVsaXhpclwiLFxuICAgICAgICAgIFwiZmxvdzlcIixcbiAgICAgICAgICBcImZyZWVtYXJrZXIyXCIsXG4gICAgICAgICAgXCJmc2hhcnBcIixcbiAgICAgICAgICBcImdvXCIsXG4gICAgICAgICAgXCJncmFwaHFsXCIsXG4gICAgICAgICAgXCJoYW5kbGViYXJzXCIsXG4gICAgICAgICAgXCJoY2xcIixcbiAgICAgICAgICBcImh0bWxcIixcbiAgICAgICAgICBcImluaVwiLFxuICAgICAgICAgIFwiamF2YVwiLFxuICAgICAgICAgIFwiamF2YXNjcmlwdFwiLFxuICAgICAgICAgIFwianNvblwiLFxuICAgICAgICAgIFwianVsaWFcIixcbiAgICAgICAgICBcImtvdGxpblwiLFxuICAgICAgICAgIFwibGVzc1wiLFxuICAgICAgICAgIFwibGV4b25cIixcbiAgICAgICAgICBcImxpcXVpZFwiLFxuICAgICAgICAgIFwibHVhXCIsXG4gICAgICAgICAgXCJtM1wiLFxuICAgICAgICAgIFwibWFya2Rvd25cIixcbiAgICAgICAgICBcIm1keFwiLFxuICAgICAgICAgIFwibWlwc1wiLFxuICAgICAgICAgIFwibXNkYXhcIixcbiAgICAgICAgICBcIm15c3FsXCIsXG4gICAgICAgICAgXCJvYmplY3RpdmUtY1wiLFxuICAgICAgICAgIFwicGFzY2FsXCIsXG4gICAgICAgICAgXCJwYXNjYWxpZ29cIixcbiAgICAgICAgICBcInBlcmxcIixcbiAgICAgICAgICBcInBnc3FsXCIsXG4gICAgICAgICAgXCJwaHBcIixcbiAgICAgICAgICBcInBsYVwiLFxuICAgICAgICAgIFwicG9zdGlhdHNcIixcbiAgICAgICAgICBcInBvd2VycXVlcnlcIixcbiAgICAgICAgICBcInBvd2Vyc2hlbGxcIixcbiAgICAgICAgICBcInByb3RvYnVmXCIsXG4gICAgICAgICAgXCJwdWJcIixcbiAgICAgICAgICBcInB5dGhvblwiLFxuICAgICAgICAgIFwicXNoYXJwXCIsXG4gICAgICAgICAgXCJyXCIsXG4gICAgICAgICAgXCJyYXpvclwiLFxuICAgICAgICAgIFwicmVkaXNcIixcbiAgICAgICAgICBcInJlZHNoaWZ0XCIsXG4gICAgICAgICAgXCJyZXN0cnVjdHVyZWR0ZXh0XCIsXG4gICAgICAgICAgXCJydWJ5XCIsXG4gICAgICAgICAgXCJydXN0XCIsXG4gICAgICAgICAgXCJzYlwiLFxuICAgICAgICAgIFwic2NhbGFcIixcbiAgICAgICAgICBcInNjaGVtZVwiLFxuICAgICAgICAgIFwic2Nzc1wiLFxuICAgICAgICAgIFwic2hlbGxcIixcbiAgICAgICAgICBcInNvbGlkaXR5XCIsXG4gICAgICAgICAgXCJzb3BoaWFcIixcbiAgICAgICAgICBcInNwYXJxbFwiLFxuICAgICAgICAgIFwic3FsXCIsXG4gICAgICAgICAgXCJzdFwiLFxuICAgICAgICAgIFwic3dpZnRcIixcbiAgICAgICAgICBcInN5c3RlbXZlcmlsb2dcIixcbiAgICAgICAgICBcInRjbFwiLFxuICAgICAgICAgIFwidHdpZ1wiLFxuICAgICAgICAgIFwidHlwZXNjcmlwdFwiLFxuICAgICAgICAgIFwidHlwZXNwZWNcIixcbiAgICAgICAgICBcInZiXCIsXG4gICAgICAgICAgXCJ3Z3NsXCIsXG4gICAgICAgICAgXCJ4bWxcIixcbiAgICAgICAgICBcInlhbWxcIixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGFsbG93ZWRMYW5ndWFnZXMuaW5jbHVkZXModmFsdWUpO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgW1dBUk5dOiBJbnZhbGlkIHZhbHVlIGZvciAndHlwZScgcHJvcGVydHk6IFwiJHt2YWx1ZX1cIi4gYCArXG4gICAgICAgICAgICAgIGBFeHBlY3RlZCBvbmUgb2Y6ICR7YWxsb3dlZExhbmd1YWdlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgZWRpdG9yOiBudWxsLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JJZDogXCJub2RlLXJlZC1lZGl0b3ItXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSksXG4gICAgfTtcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLm1vdW50RWRpdG9yKCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtb3VudEVkaXRvcigpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyRWwgPSB0aGlzLiRyZWZzLmNvbnRhaW5lckRpdjtcbiAgICAgICAgY29uc3QgZWRpdG9yRWwgPSB0aGlzLiRyZWZzLmVkaXRvckRpdjtcblxuICAgICAgICBpZiAoY29udGFpbmVyRWwgJiYgZWRpdG9yRWwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5saW5lSGVpZ2h0ID0gY29udGFpbmVyRWwuc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgaW5saW5lV2lkdGggPSBjb250YWluZXJFbC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgIGlmIChpbmxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUuaGVpZ2h0ID0gaW5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUud2lkdGggPSBpbmxpbmVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRWRpdG9ySW5zdGFuY2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIltOb2RlUmVkRWRpdG9ySW5wdXRdIEVycm9yIHNldHRpbmcgaW5pdGlhbCBlZGl0b3Igc3R5bGU6XCIsXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUVkaXRvckluc3RhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIltOb2RlUmVkRWRpdG9ySW5wdXRdIENvbnRhaW5lciBvciBFZGl0b3IgZGl2IHJlZnMgbm90IGZvdW5kIG9uIG1vdW50LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVFZGl0b3JJbnN0YW5jZSgpIHtcbiAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UgPSBSRUQuZWRpdG9yLmNyZWF0ZUVkaXRvcih7XG4gICAgICAgIGlkOiB0aGlzLmVkaXRvcklkLFxuICAgICAgICBtb2RlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5nZXRTZXNzaW9uKCkub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmVkaXRvckluc3RhbmNlLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZVVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9ySW5zdGFuY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgZWRpdG9yIGZvciBJRCAke3RoaXMuZWRpdG9ySWR9OmAsIGVycik7XG4gICAgICB9XG4gICAgICB0aGlzLmVkaXRvckluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKTtcbn1cbmV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGdldEVzbUV4cG9ydE5hbWU7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgfHwgKGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSBVc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9ICgwLCBjb2RlXzEuXykgYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSAoMCwgY29kZV8xLl8pIGBcXG5gO1xuY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IGNvZGVfMS5uaWwgfTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGU7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICB2YWx1ZShuYW1lT3JQcmVmaXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gKF9hID0gdmFsdWUua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5yZWY7XG4gICAgICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAodnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KTtcbiAgICAgICAgICAgIGlmIChfbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aDtcbiAgICAgICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmO1xuICAgICAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleCB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHZzLmdldChrZXlPclJlZik7XG4gICAgfVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUsIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZV8xLl8pIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZSA9IFZhbHVlU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3IgPSBleHBvcnRzLmFuZCA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5vcGVyYXRvcnMgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY29uc3Qgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGNvZGVfMiA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0ckNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0ckNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuZ2V0UHJvcGVydHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdleHBDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIucmVnZXhwQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5OYW1lOyB9IH0pO1xudmFyIHNjb3BlXzIgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZU5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZU5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YXJLaW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi52YXJLaW5kczsgfSB9KTtcbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAgIEdUOiBuZXcgY29kZV8xLl9Db2RlKFwiPlwiKSxcbiAgICBHVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI+PVwiKSxcbiAgICBMVDogbmV3IGNvZGVfMS5fQ29kZShcIjxcIiksXG4gICAgTFRFOiBuZXcgY29kZV8xLl9Db2RlKFwiPD1cIiksXG4gICAgRVE6IG5ldyBjb2RlXzEuX0NvZGUoXCI9PT1cIiksXG4gICAgTkVROiBuZXcgY29kZV8xLl9Db2RlKFwiIT09XCIpLFxuICAgIE5PVDogbmV3IGNvZGVfMS5fQ29kZShcIiFcIiksXG4gICAgT1I6IG5ldyBjb2RlXzEuX0NvZGUoXCJ8fFwiKSxcbiAgICBBTkQ6IG5ldyBjb2RlXzEuX0NvZGUoXCImJlwiKSxcbiAgICBBREQ6IG5ldyBjb2RlXzEuX0NvZGUoXCIrXCIpLFxufTtcbmNsYXNzIE5vZGUge1xuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKF9uYW1lcywgX2NvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCByaHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgfVxuICAgIHJlbmRlcih7IGVzNSwgX24gfSkge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YDtcbiAgICAgICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yaHMpXG4gICAgICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5zaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RzO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB7fSA6IHsgLi4udGhpcy5saHMubmFtZXMgfTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpO1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIG9wLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cyk7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX247XG4gICAgfVxufVxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubik7XG4gICAgICAgICAgICBlbHNlIGlmIChuKVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpO1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uO1xuICAgIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbn1cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRWxzZS5raW5kID0gXCJlbHNlXCI7XG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBub2Rlcykge1xuICAgICAgICBzdXBlcihub2Rlcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7IC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgICAgIGxldCBlID0gdGhpcy5lbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IG5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbHNlID0gKF9hID0gdGhpcy5lbHNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5JZi5raW5kID0gXCJpZlwiO1xuY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkZvci5raW5kID0gXCJmb3JcIjtcbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmcm9tLCB0byB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29wLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhc3luYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFzeW5jID0gYXN5bmM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRnVuYy5raW5kID0gXCJmdW5jXCI7XG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuUmV0dXJuLmtpbmQgPSBcInJldHVyblwiO1xuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOb2RlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuQ2F0Y2gua2luZCA9IFwiY2F0Y2hcIjtcbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GaW5hbGx5LmtpbmQgPSBcImZpbmFsbHlcIjtcbmNsYXNzIENvZGVHZW4ge1xuICAgIGNvbnN0cnVjdG9yKGV4dFNjb3BlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSh7IHBhcmVudDogZXh0U2NvcGUgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cyk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gICAgc2NvcGVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpO1xuICAgICAgICB2cy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRTY29wZVZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gICAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIF9kZWYodmFyS2luZCwgbmFtZU9yUHJlZml4LCByaHMsIGNvbnN0YW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KVxuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJocztcbiAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGNvbnN0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBsZXQobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gICAgdmFyKG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnQgY29kZVxuICAgIGFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSk7XG4gICAgfVxuICAgIC8vIGArPWAgY29kZVxuICAgIGFkZChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgZXhwb3J0cy5vcGVyYXRvcnMuQURELCByaHMpKTtcbiAgICB9XG4gICAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICAgIGNvZGUoYykge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgYygpO1xuICAgICAgICBlbHNlIGlmIChjICE9PSBjb2RlXzEubmlsKVxuICAgICAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgIG9iamVjdCguLi5rZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcIntcIl07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCIsXCIpO1xuICAgICAgICAgICAgY29kZS5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiOlwiKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmFkZENvZGVBcmcpKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsICgwLCBjb2RlXzEuXykgYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsICgwLCBjb2RlXzEuXykgYCR7YXJyfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGZvckJvZHkobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAgIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgICBmb3JJbihuYW1lT3JQcmVmaXgsIG9iaiwgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsICgwLCBjb2RlXzEuXykgYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6ICgwLCBjb2RlXzEuXykgYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogKDAsIGNvZGVfMS5fKSBgJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApO1xufVxuZnVuY3Rpb24gcGFyKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8geCA6ICgwLCBjb2RlXzEuXykgYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgIGlmIChwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZTtcbmZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcykge1xuICAgIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgICAgICAgOiBpc051bWJlclxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/ICgwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcCk7XG59XG5leHBvcnRzLmdldEVycm9yUGF0aCA9IGdldEVycm9yUGF0aDtcbmZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBtb2RlID0gaXQub3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBpZiAoIW1vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWA7XG4gICAgaWYgKG1vZGUgPT09IHRydWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKTtcbn1cbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gY2hlY2tTdHJpY3RNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0cikgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJ9XWApLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtzY2hQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8ICgwLCBjb2RlZ2VuXzEuXykgYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IERhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSkoaXQsIHR5cGVzWzBdKSk7XG4gICAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGVja1R5cGVzO1xufVxuZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZTtcbmNvbnN0IENPRVJDSUJMRSA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXMsIGNvZXJjZVR5cGVzKSB7XG4gICAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgICAgIDogW107XG59XG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT4gZ2VuXG4gICAgICAgICAgICAuYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICAgICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuLmVsc2UoKTtcbiAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgIGdlbi5lbmRJZigpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6ICgwLCBjb2RlZ2VuXzEubm90KShjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5hbmQpKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/ICgwLCBjb2RlZ2VuXzEuXykgYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9ICgwLCB1dGlsXzEudG9IYXNoKShkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImA7XG4gICAgICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogKDAsIGNvZGVnZW5fMS5fKSBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLmFuZCkoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYX19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBzY2hlbWEsIFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgICAgICBzY2hlbWFDb2RlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICAgICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPSAkeygwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5mdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiAoMCwgY29kZWdlbl8xLl8pIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+ICgwLCBjb2RlZ2VuXzEuYW5kKShub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgO1xufVxuZXhwb3J0cy5pc093blByb3BlcnR5ID0gaXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kO1xufVxuZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IHByb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLm9yKShjb25kLCAoMCwgY29kZWdlbl8xLm5vdCkoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGE7XG4gICAgY29uc3QgdmFsQ3h0ID0gW1xuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmNvbnN0IG5ld1JlZ0V4cCA9ICgwLCBjb2RlZ2VuXzEuXykgYG5ldyBSZWdFeHBgO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIGNvbnN0IHsgcmVnRXhwIH0gPSBvcHRzLmNvZGU7XG4gICAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAgICAgIGtleTogcngudG9TdHJpbmcoKSxcbiAgICAgICAgcmVmOiByeCxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZWdFeHAuY29kZSA9PT0gXCJuZXcgUmVnRXhwXCIgPyBuZXdSZWdFeHAgOiAoMCwgdXRpbF8yLnVzZUZ1bmMpKGdlbiwgcmVnRXhwKX0oJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKTtcbiAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgICAgaWYgKCFtZXJnZWQpXG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfWAsICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCA6IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IG5hbWVzXzEuZGVmYXVsdC5zZWxmO1xuICAgICAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke19hd2FpdH0keygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSgoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKSwgZXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGZ1bmNLZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICAoMCwgZXJyb3JzXzEuZXh0ZW5kRXJyb3JzKShjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHJlc3VsdCkgfSk7XG59XG5mdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgICByZXR1cm4gKCFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgICAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PiBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5leHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IHZhbGlkU2NoZW1hVHlwZTtcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKHsgc2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRoIH0sIGRlZiwga2V5d29yZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IHZhbGlkYXRlS2V5d29yZFVzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5d29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFN1YnNjaGVtYShpdCwgeyBrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZiB9KSB7XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHsoMCwgdXRpbF8xLmVzY2FwZUZyYWdtZW50KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICAgICAgICBlcnJTY2hlbWFQYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJyk7XG59XG5leHBvcnRzLmdldFN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCBpdCwgeyBkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lIH0pIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZ2VuIH0gPSBpdDtcbiAgICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyb3JQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEsIGJhc2VJZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCwgdXJpUmVzb2x2ZXIgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZTtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERhdGEgPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdm9pZCAwO1xuY29uc3QgYm9vbFNjaGVtYV8xID0gcmVxdWlyZShcIi4vYm9vbFNjaGVtYVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBkYXRhVHlwZV8yID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBrZXl3b3JkXzEgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuY29uc3Qgc3Vic2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zdWJzY2hlbWFcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+ICgwLCBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEpKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApO1xuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKTtcbiAgICAgICAgICAgIGdlbi5jb2RlKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/ICgwLCBjb2RlZ2VuXzEuXykgYCwgJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9PXt9YCA6IGNvZGVnZW5fMS5uaWx9fT17fWA7XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpIHtcbiAgICBnZW4uaWYobmFtZXNfMS5kZWZhdWx0LnZhbEN4dCwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cywgZ2VuIH0gPSBpdDtcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICAgICAgY2hlY2tOb0RlZmF1bHQoaXQpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAwKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXNldEV2YWx1YXRlZChpdCk7XG4gICAgICAgIHR5cGVBbmRLZXl3b3JkcyhpdCk7XG4gICAgICAgIHJldHVyblJlc3VsdHMoaXQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0KSB7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/ICgwLCBjb2RlZ2VuXzEuXykgYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYSkoaXQsIHZhbGlkKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHsgc2NoZW1hLCBzZWxmIH0pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBnZW4sIG9wdHMgfSA9IGl0O1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgIHVwZGF0ZUNvbnRleHQoaXQpO1xuICAgIGNoZWNrQXN5bmNTY2hlbWEoaXQpO1xuICAgIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KTtcbiAgICAvLyBUT0RPIHZhclxuICAgIGdlbi52YXIodmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgICgwLCB1dGlsXzEuY2hlY2tVbmtub3duUnVsZXMpKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykoaXQuc2NoZW1hKTtcbiAgICBjb25zdCBjaGVja2VkVHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiAoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQpIHtcbiAgICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXTtcbiAgICBpZiAoc2NoSWQpXG4gICAgICAgIGl0LmJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGA7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiBzY2hlbWFFbnYucm9vdCB9KTtcbiAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtWYWxpZGF0aW9uRXJyb3J9KCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9KWApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcyk7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoISgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXApKHNjaGVtYSwgZ3JvdXApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUpKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgICgwLCBkYXRhVHlwZV8yLnJlcG9ydFR5cGVFcnJvcikoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIG9wdHM6IHsgdXNlRGVmYXVsdHMgfSwgfSA9IGl0O1xuICAgIGlmICh1c2VEZWZhdWx0cylcbiAgICAgICAgKDAsIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMpKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbmFycm93U2NoZW1hVHlwZXMoaXQsIHR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHMpIHtcbiAgICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQsIHRzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbDtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgd2l0aFR5cGVzKSB7XG4gICAgY29uc3QgdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1R5cGUod2l0aFR5cGVzLCB0KSlcbiAgICAgICAgICAgIHRzLnB1c2godCk7XG4gICAgICAgIGVsc2UgaWYgKHdpdGhUeXBlcy5pbmNsdWRlcyhcImludGVnZXJcIikgJiYgdCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRzLnB1c2goXCJpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBpdC5kYXRhVHlwZXMgPSB0cztcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcyk7XG59XG5jbGFzcyBLZXl3b3JkQ3h0IHtcbiAgICBjb25zdHJ1Y3RvcihpdCwgZGVmLCBrZXl3b3JkKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UpKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoISgwLCBrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7KDAsIGNvZGVnZW5fMS5vcikodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgKDAsIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQpKHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudCk7XG4gICAgfVxuICAgIG9rKGNvbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGNvbmQpO1xuICAgIH1cbiAgICBzZXRQYXJhbXMob2JqLCBhc3NpZ24pIHtcbiAgICAgICAgaWYgKGFzc2lnbilcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb2JqO1xuICAgIH1cbiAgICBibG9jayRkYXRhKHZhbGlkLCBjb2RlQmxvY2ssICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZCk7XG4gICAgICAgICAgICBjb2RlQmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrJGRhdGEodmFsaWQgPSBjb2RlZ2VuXzEubmlsLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYgfSA9IHRoaXM7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSh3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZXMpKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY2hlbWEoYXBwbCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0gKDAsIHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSkodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgICgwLCBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFEYXRhKShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZSkoc3Vic2NoZW1hLCBhcHBsKTtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSB7IC4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q29udGV4dDtcbiAgICB9XG4gICAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB0b05hbWUpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB2YWxpZCkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIGNvZGVnZW5fMS5OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuS2V5d29yZEN4dCA9IEtleXdvcmRDeHQ7XG5mdW5jdGlvbiBrZXl3b3JkQ29kZShpdCwga2V5d29yZCwgZGVmLCBydWxlVHlwZSkge1xuICAgIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpO1xuICAgIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICAoMCwga2V5d29yZF8xLm1hY3JvS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxufVxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgeyBkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnIgfSkge1xuICAgIGxldCBqc29uUG9pbnRlcjtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgICAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICAgIGRhdGEgPSBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBjb25zdCB1cCA9ICttYXRjaGVzWzFdO1xuICAgICAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwID4gZGF0YUxldmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpO1xuICAgICAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgaWYgKCFqc29uUG9pbnRlcilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBsZXQgZXhwciA9IGRhdGE7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBkYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoKDAsIHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKShzZWdtZW50KSl9YDtcbiAgICAgICAgICAgIGV4cHIgPSAoMCwgY29kZWdlbl8xLl8pIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc29sdmVyLCBiYXNlSWQsIHJlZiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YCk7XG4gICAgICAgIHRoaXMubWlzc2luZ1JlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICAgICAgdGhpcy5taXNzaW5nU2NoZW1hID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkocmVzb2x2ZXIsIHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZSkoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKCgwLCByZXNvbHZlXzEuaW5saW5lUmVmKShzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSAoMCwgcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKTtcbiAgICBsZXQgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVsoMCwgdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQpKHBhcnQpXTtcbiAgICAgICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gcGFydFNjaGVtYTtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEhFWCA9IHtcbiAgMDogMCxcbiAgMTogMSxcbiAgMjogMixcbiAgMzogMyxcbiAgNDogNCxcbiAgNTogNSxcbiAgNjogNixcbiAgNzogNyxcbiAgODogOCxcbiAgOTogOSxcbiAgYTogMTAsXG4gIEE6IDEwLFxuICBiOiAxMSxcbiAgQjogMTEsXG4gIGM6IDEyLFxuICBDOiAxMixcbiAgZDogMTMsXG4gIEQ6IDEzLFxuICBlOiAxNCxcbiAgRTogMTQsXG4gIGY6IDE1LFxuICBGOiAxNVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSEVYXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIRVggfSA9IHJlcXVpcmUoJy4vc2NvcGVkQ2hhcnMnKVxuXG5jb25zdCBJUFY0X1JFRyA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdVxuXG5mdW5jdGlvbiBub3JtYWxpemVJUHY0IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJy4nKSA8IDMpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY0OiBmYWxzZSB9IH1cbiAgY29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2goSVBWNF9SRUcpIHx8IFtdXG4gIGNvbnN0IFthZGRyZXNzXSA9IG1hdGNoZXNcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICByZXR1cm4geyBob3N0OiBzdHJpcExlYWRpbmdaZXJvcyhhZGRyZXNzLCAnLicpLCBpc0lQVjQ6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBaZXJvPWZhbHNlXVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQsIGtlZXBaZXJvID0gZmFsc2UpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBzdHJpcCA9IHRydWVcbiAgZm9yIChjb25zdCBjIG9mIGlucHV0KSB7XG4gICAgaWYgKEhFWFtjXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKGMgIT09ICcwJyAmJiBzdHJpcCA9PT0gdHJ1ZSkgc3RyaXAgPSBmYWxzZVxuICAgIGlmICghc3RyaXApIGFjYyArPSBjXG4gIH1cbiAgaWYgKGtlZXBaZXJvICYmIGFjYy5sZW5ndGggPT09IDApIGFjYyA9ICcwJ1xuICByZXR1cm4gYWNjXG59XG5cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBpc1pvbmUgPSBmYWxzZVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWUgKCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNab25lID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoKSkgeyBicmVhayB9XG4gICAgICB0b2tlbkNvdW50KytcbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBpZiAodG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpIC0gMSA+PSAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBpc1pvbmUgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgZXNjYXBlZEhvc3QsIGlzSVBWNjogdHJ1ZSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBMZWFkaW5nWmVyb3MgKHN0ciwgdG9rZW4pIHtcbiAgbGV0IG91dCA9ICcnXG4gIGxldCBza2lwID0gdHJ1ZVxuICBjb25zdCBsID0gc3RyLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGMgPSBzdHJbaV1cbiAgICBpZiAoYyA9PT0gJzAnICYmIHNraXApIHtcbiAgICAgIGlmICgoaSArIDEgPD0gbCAmJiBzdHJbaSArIDFdID09PSB0b2tlbikgfHwgaSArIDEgPT09IGwpIHtcbiAgICAgICAgb3V0ICs9IGNcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjID09PSB0b2tlbikge1xuICAgICAgICBza2lwID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgICBvdXQgKz0gY1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuY29uc3QgUkRTMSA9IC9eXFwuXFwuP1xcLy91XG5jb25zdCBSRFMyID0gL15cXC9cXC4oPzpcXC98JCkvdVxuY29uc3QgUkRTMyA9IC9eXFwvXFwuXFwuKD86XFwvfCQpL3VcbmNvbnN0IFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS91XG5cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChpbnB1dCkge1xuICBjb25zdCBvdXRwdXQgPSBbXVxuXG4gIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCAnJylcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgJy8nKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCAnLycpXG4gICAgICBvdXRwdXQucG9wKClcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnLicgfHwgaW5wdXQgPT09ICcuLicpIHtcbiAgICAgIGlucHV0ID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW0gPSBpbnB1dC5tYXRjaChSRFM1KVxuICAgICAgaWYgKGltKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpbVswXVxuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKVxuICAgICAgICBvdXRwdXQucHVzaChzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgKGNvbXBvbmVudHMsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudHMuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnNjaGVtZSA9IGZ1bmMoY29tcG9uZW50cy5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSBmdW5jKGNvbXBvbmVudHMudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5ob3N0ID0gZnVuYyhjb21wb25lbnRzLmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5wYXRoID0gZnVuYyhjb21wb25lbnRzLnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMucXVlcnkgPSBmdW5jKGNvbXBvbmVudHMucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBmdW5jKGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnRzKSB7XG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGhvc3QgPSB1bmVzY2FwZShjb21wb25lbnRzLmhvc3QpXG4gICAgY29uc3QgaXBWNHJlcyA9IG5vcm1hbGl6ZUlQdjQoaG9zdClcblxuICAgIGlmIChpcFY0cmVzLmlzSVBWNCkge1xuICAgICAgaG9zdCA9IGlwVjRyZXMuaG9zdFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2NihpcFY0cmVzLmhvc3QpXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50cy5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBub3JtYWxpemVJUHY0LFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBVVUlEX1JFRyA9IC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuZnVuY3Rpb24gaXNTZWN1cmUgKHdzQ29tcG9uZW50cykge1xuICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ3dzcydcbn1cblxuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnRzKSB7XG4gIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudHMpIHtcbiAgY29uc3Qgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09ICcnKSB7XG4gICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICBjb21wb25lbnRzLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIE5PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgLy8gYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gIC8vIGFuZCBub3QgdGhlIEhUVFAgc3BlYy5cblxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1BhcnNlICh3c0NvbXBvbmVudHMpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cylcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWRcbiAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnRzKSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSAnJykge1xuICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gKHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICBjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnRzLnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5XG4gICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGlmICghdXJuQ29tcG9uZW50cy5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50cy5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudHNcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJuQ29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnRzLm5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgIHVybkNvbXBvbmVudHMubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnRzLm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXVxuICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudHMubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV1cblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHNcbiAgY29uc3QgbnNzID0gdXJuQ29tcG9uZW50cy5uc3NcbiAgdXJpQ29tcG9uZW50cy5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzXG4gIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3NcbiAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhVVVJRF9SRUcudGVzdCh1dWlkQ29tcG9uZW50cy51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudHMpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzXG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuY29uc3QgaHR0cCA9IHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCBodHRwcyA9IHtcbiAgc2NoZW1lOiAnaHR0cHMnLFxuICBkb21haW5Ib3N0OiBodHRwLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCB3cyA9IHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufVxuXG5jb25zdCB3c3MgPSB7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn1cblxuY29uc3QgdXJuID0ge1xuICBzY2hlbWU6ICd1cm4nLFxuICBwYXJzZTogdXJuUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJuU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IHVybnV1aWQgPSB7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IFNDSEVNRVMgPSB7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTQ0hFTUVTXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBub3JtYWxpemVJUHY2LCBub3JtYWxpemVJUHY0LCByZW1vdmVEb3RTZWdtZW50cywgcmVjb21wb3NlQXV0aG9yaXR5LCBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyB9ID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKVxuY29uc3QgU0NIRU1FUyA9IHJlcXVpcmUoJy4vbGliL3NjaGVtZXMnKVxuXG5mdW5jdGlvbiBub3JtYWxpemUgKHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9XG4gIHJldHVybiB1cmlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZSAoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucylcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKVxuICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVkLCB7IC4uLnNjaGVtZWxlc3NPcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzIChiYXNlLCByZWxhdGl2ZSwgb3B0aW9ucywgc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgY29uc3QgdGFyZ2V0ID0ge31cbiAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcbiAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZVxuICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGhcbiAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gJy8nICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgIH1cbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydFxuICAgIH1cbiAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWVcbiAgfVxuXG4gIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG5mdW5jdGlvbiBlcXVhbCAodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaUEgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQSA9IHVuZXNjYXBlKHVyaUEpXG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlBLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlBID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiB1cmlCID09PSAnc3RyaW5nJykge1xuICAgIHVyaUIgPSB1bmVzY2FwZSh1cmlCKVxuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQiwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQiA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUIsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB1cmlBLnRvTG93ZXJDYXNlKCkgPT09IHVyaUIudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNtcHRzLCBvcHRzKSB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB7XG4gICAgaG9zdDogY21wdHMuaG9zdCxcbiAgICBzY2hlbWU6IGNtcHRzLnNjaGVtZSxcbiAgICB1c2VyaW5mbzogY21wdHMudXNlcmluZm8sXG4gICAgcG9ydDogY21wdHMucG9ydCxcbiAgICBwYXRoOiBjbXB0cy5wYXRoLFxuICAgIHF1ZXJ5OiBjbXB0cy5xdWVyeSxcbiAgICBuaWQ6IGNtcHRzLm5pZCxcbiAgICBuc3M6IGNtcHRzLm5zcyxcbiAgICB1dWlkOiBjbXB0cy51dWlkLFxuICAgIGZyYWdtZW50OiBjbXB0cy5mcmFnbWVudCxcbiAgICByZWZlcmVuY2U6IGNtcHRzLnJlZmVyZW5jZSxcbiAgICByZXNvdXJjZU5hbWU6IGNtcHRzLnJlc291cmNlTmFtZSxcbiAgICBzZWN1cmU6IGNtcHRzLnNlY3VyZSxcbiAgICBlcnJvcjogJydcbiAgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKVxuXG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghb3B0aW9ucy5za2lwRXNjYXBlKSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSBlc2NhcGUoY29tcG9uZW50cy5wYXRoKVxuXG4gICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnRzLnBhdGggPSBjb21wb25lbnRzLnBhdGguc3BsaXQoJyUzQScpLmpvaW4oJzonKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSB1bmVzY2FwZShjb21wb25lbnRzLnBhdGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lLCAnOicpXG4gIH1cblxuICBjb25zdCBhdXRob3JpdHkgPSByZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cylcbiAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4Jykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8vJylcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpXG5cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8nKVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcyA9IGNvbXBvbmVudHMucGF0aFxuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpXG4gICAgfVxuXG4gICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvL3UsICcvJTJGJykgLy8gZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChzKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCc/JywgY29tcG9uZW50cy5xdWVyeSlcbiAgfVxuXG4gIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnIycsIGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKVxufVxuXG5jb25zdCBoZXhMb29rVXAgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMjcgfSwgKF92LCBrKSA9PiAvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShrKSkpXG5cbmZ1bmN0aW9uIG5vblNpbXBsZURvbWFpbiAodmFsdWUpIHtcbiAgbGV0IGNvZGUgPSAwXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGNvZGUgPiAxMjYgfHwgaGV4TG9va1VwW2NvZGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW14jLzo/XSspOik/KD86XFwvXFwvKCg/OihbXiMvP0BdKilAKT8oXFxbW14jLz9cXF1dK1xcXXxbXiMvOj9dKikoPzo6KFxcZCopKT8pKT8oW14jP10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxbXFxuXFxyXSkqKSk/L3VcblxuZnVuY3Rpb24gcGFyc2UgKHVyaSwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHNjaGVtZTogdW5kZWZpbmVkLFxuICAgIHVzZXJpbmZvOiB1bmRlZmluZWQsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIHBhdGg6ICcnLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnQ6IHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IGdvdEVuY29kaW5nID0gdXJpLmluZGV4T2YoJyUnKSAhPT0gLTFcbiAgbGV0IGlzSVAgPSBmYWxzZVxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09ICdzdWZmaXgnKSB1cmkgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArICc6JyA6ICcnKSArICcvLycgKyB1cmlcblxuICBjb25zdCBtYXRjaGVzID0gdXJpLm1hdGNoKFVSSV9QQVJTRSlcblxuICBpZiAobWF0Y2hlcykge1xuICAgIC8vIHN0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgcGFyc2VkLnNjaGVtZSA9IG1hdGNoZXNbMV1cbiAgICBwYXJzZWQudXNlcmluZm8gPSBtYXRjaGVzWzNdXG4gICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVzWzRdXG4gICAgcGFyc2VkLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMClcbiAgICBwYXJzZWQucGF0aCA9IG1hdGNoZXNbNl0gfHwgJydcbiAgICBwYXJzZWQucXVlcnkgPSBtYXRjaGVzWzddXG4gICAgcGFyc2VkLmZyYWdtZW50ID0gbWF0Y2hlc1s4XVxuXG4gICAgLy8gZml4IHBvcnQgbnVtYmVyXG4gICAgaWYgKGlzTmFOKHBhcnNlZC5wb3J0KSkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBtYXRjaGVzWzVdXG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgY29uc3QgaXB2NHJlc3VsdCA9IG5vcm1hbGl6ZUlQdjQocGFyc2VkLmhvc3QpXG4gICAgICBpZiAoaXB2NHJlc3VsdC5pc0lQVjQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlwdjZyZXN1bHQgPSBub3JtYWxpemVJUHY2KGlwdjRyZXN1bHQuaG9zdClcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2cmVzdWx0Lmhvc3QudG9Mb3dlckNhc2UoKVxuICAgICAgICBpc0lQID0gaXB2NnJlc3VsdC5pc0lQVjZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NHJlc3VsdC5ob3N0XG4gICAgICAgIGlzSVAgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucG9ydCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkICYmICFwYXJzZWQucGF0aCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdzYW1lLWRvY3VtZW50J1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnYWJzb2x1dGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAndXJpJ1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gcGFyc2VkLnJlZmVyZW5jZSkge1xuICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgaXMgbm90IGEgJyArIG9wdGlvbnMucmVmZXJlbmNlICsgJyByZWZlcmVuY2UuJ1xuICAgIH1cblxuICAgIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAvLyBpZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICBpZiAocGFyc2VkLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSAmJiBpc0lQID09PSBmYWxzZSAmJiBub25TaW1wbGVEb21haW4ocGFyc2VkLmhvc3QpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSBVUkwuZG9tYWluVG9BU0NJSShwYXJzZWQuaG9zdC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJOiBcIiArIGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBJUkkgLT4gVVJJXG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWVIYW5kbGVyIHx8IChzY2hlbWVIYW5kbGVyICYmICFzY2hlbWVIYW5kbGVyLnNraXBOb3JtYWxpemUpKSB7XG4gICAgICBpZiAoZ290RW5jb2RpbmcgJiYgcGFyc2VkLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5zY2hlbWUgPSB1bmVzY2FwZShwYXJzZWQuc2NoZW1lKVxuICAgICAgfVxuICAgICAgaWYgKGdvdEVuY29kaW5nICYmIHBhcnNlZC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLmhvc3QgPSB1bmVzY2FwZShwYXJzZWQuaG9zdClcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IGVzY2FwZSh1bmVzY2FwZShwYXJzZWQucGF0aCkpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLmZyYWdtZW50KSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudHMsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVyaSA9IHJlcXVpcmUoXCJmYXN0LXVyaVwiKTtcbnVyaS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgdXJpXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3VyaVwiKTtcbmNvbnN0IGRlZmF1bHRSZWdFeHAgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTtcbmRlZmF1bHRSZWdFeHAuY29kZSA9IFwibmV3IFJlZ0V4cFwiO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3gsIF95LCBfeiwgXzA7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgY29uc3QgcmVnRXhwID0gKF9jID0gKF9iID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnRXhwKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVnRXhwO1xuICAgIGNvbnN0IHVyaVJlc29sdmVyID0gKF9kID0gby51cmlSZXNvbHZlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdXJpXzEuZGVmYXVsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfZiA9IChfZSA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2ggPSAoX2cgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2sgPSAoX2ogPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBzKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfbSA9IChfbCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBzKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9wID0gKF9vID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogcykgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwIH0gOiB7IG9wdGltaXplLCByZWdFeHAgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX3EgPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX3IgPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9zID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF90ID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF91ID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF92ID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF93ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF94ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3kgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3kgIT09IHZvaWQgMCA/IF95IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF96ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfeiAhPT0gdm9pZCAwID8gX3ogOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoXzAgPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF8wICE9PSB2b2lkIDAgPyBfMCA6IHRydWUsXG4gICAgICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9ICgwLCBydWxlc18xLmdldFJ1bGVzKSgpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKTtcbiAgICAgICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0cy5mb3JtYXRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3Jkcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICAgICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKTtcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHQ7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBsZXQgX2RhdGFSZWZTY2hlbWEgPSAkZGF0YVJlZlNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hID0geyAuLi4kZGF0YVJlZlNjaGVtYSB9O1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhICYmICRkYXRhKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRLZXl3b3JkKGt3ZE9yRGVmLCBkZWYgLy8gZGVwcmVjYXRlZFxuICAgICkge1xuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpO1xuICAgICAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYuc2NoZW1hVHlwZSksXG4gICAgICAgIH07XG4gICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hLCBiYXNlSWQpO1xuICAgICAgICBzY2ggPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzIH0pO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKTtcbiAgICAgICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgICAgICAgaWYgKGJhc2VJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBfY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSB7XG4gICAgICAgIGlmIChzY2gubWV0YSlcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc2NoLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlO1xuICAgIH1cbiAgICBfY29tcGlsZU1ldGFTY2hlbWEoc2NoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzO1xuICAgICAgICB9XG4gICAgfVxufVxuQWp2LlZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0O1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IHJlZl9lcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoY2hlY2tPcHRzLCBvcHRpb25zLCBtc2csIGxvZyA9IFwiZXJyb3JcIikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBrZXk7XG4gICAgICAgIGlmIChvcHQgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY2hFbnYoa2V5UmVmKSB7XG4gICAga2V5UmVmID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsICgwLCBjb2RlZ2VuXzEuXykgYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2gpIH0gOiB7IHJlZjogc2NoIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQsIHNjaCkge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgICAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwgeyByZWY6IHNjaC52YWxpZGF0ZSB9KVxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpfWApO1xuICAgICAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KTsgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KCgwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApO1xuICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgICAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxlT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKVxuICAgICAgICAgICAgICAgIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVjczJsZW5ndGg7XG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVjczJsZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHVjczJsZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIHV0aWxfMS51c2VGdW5jKShjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/ICgwLCBjb2RlZ2VuXzEuXykgYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiAoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBwcm9wZXJ0aWVzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0UHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEoY29kZWdlbl8xLm5pbCwgbG9vcEFsbFJlcXVpcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpIHtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBwcm9wIH0pO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLm5vUHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuZXF1YWwuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXTtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4oaSwgaikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdyb25nVHlwZSA9ICgwLCBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKShpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KGl0ZW0sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosICgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hIH0gPSBjeHQ7XG4gICAgICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7KDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX0gIT09ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBsZXQgZXFsO1xuICAgICAgICBjb25zdCBnZXRFcWwgPSAoKSA9PiAoZXFsICE9PSBudWxsICYmIGVxbCAhPT0gdm9pZCAwID8gZXFsIDogKGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpKSk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcygoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoY3h0LCBleHRyYUl0ZW1zLCBzY2hBcnIgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID4gJHtpfWAsICgpID0+IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSwgdmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaCkge1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGggfSA9IGl0O1xuICAgICAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+ICgwLCBpdGVtc18xLnZhbGlkYXRlVHVwbGUpKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgICgwLCBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcykoY3h0LCBwcmVmaXhJdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkID8gKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaW4sIG1heCB9KTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBsZXQgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkLCBibG9jaykge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIF92YWxpZCk7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcGVydHl9ICYmICgkeygwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkUHJvcDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlXzEuaXNPd25Qcm9wZXJ0eSkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKShkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEubm90KShkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5IH0pO1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLlN0cixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQuY29kZShuZXcgdmFsaWRhdGVfMS5LZXl3b3JkQ3h0KGl0LCBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgKDAsIHV0aWxfMS50b0hhc2gpKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID0gb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gKDAsIHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZSkoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVyblByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsICgwLCBjb2RlZ2VuXzEuXykgYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIik7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKTtcbiAgICAgICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgdmFsaWRhdGVJZigpO1xuICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2UgfSk7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gICAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQsIHJ1bGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgkZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEub3IpKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm10KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEucmVnZXhwQ29kZSkoZm10RGVmKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LnZhbGlkYXRlYF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfSgke2RhdGF9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0udGVzdCgke2RhdGF9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgZm9ybWF0ID0gW2Zvcm1hdF8xLmRlZmF1bHRdO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IERpc2NyRXJyb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lIH0pO1xuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3AgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mTWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgaWYgKChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guJHJlZikgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gc2NoLiRyZWY7XG4gICAgICAgICAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoaXQuc2VsZiwgaXQuc2NoZW1hRW52LnJvb3QsIGl0LmJhc2VJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2ggPSBzY2guc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaXNzaW5nUmVmRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMuQWp2ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2ID0gQWp2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYoZ2V0VGltZSh0cnVlKSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSh0cnVlKSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICBcImlzby10aW1lXCI6IGZtdERlZihnZXRUaW1lKCksIGNvbXBhcmVJc29UaW1lKSxcbiAgICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKCksIGNvbXBhcmVJc29EYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSQvLFxuICAgIGlwdjY6IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pLFxuICAgIHJlZ2V4LFxuICAgIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgICB1dWlkOiAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaSxcbiAgICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gICAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gICAgXCJqc29uLXBvaW50ZXJcIjogL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLyxcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gICAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAgIC8vIGJ5dGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL2lzLWJhc2U2NFxuICAgIGJ5dGUsXG4gICAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gICAgaW50MzI6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzIgfSxcbiAgICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgICBpbnQ2NDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NCB9LFxuICAgIC8vIEMtdHlwZSBmbG9hdFxuICAgIGZsb2F0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIEMtdHlwZSBkb3VibGVcbiAgICBkb3VibGU6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgLy8gdW5jaGVja2VkIHN0cmluZyBwYXlsb2FkXG4gICAgYmluYXJ5OiB0cnVlLFxufTtcbmV4cG9ydHMuZmFzdEZvcm1hdHMgPSB7XG4gICAgLi4uZXhwb3J0cy5mdWxsRm9ybWF0cyxcbiAgICBkYXRlOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLywgY29tcGFyZURhdGUpLFxuICAgIHRpbWU6IGZtdERlZigvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkdCg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlRGF0ZVRpbWUpLFxuICAgIFwiaXNvLXRpbWVcIjogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlSXNvVGltZSksXG4gICAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSwgY29tcGFyZUlzb0RhdGVUaW1lKSxcbiAgICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gICAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAgIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn07XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5mdWxsRm9ybWF0cyk7XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAgIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBtYXRjaGVzID0gREFURS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxLCBkMikge1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGQxIDwgZDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQoPzpcXC5cXGQrKT8pKHp8KFsrLV0pKFxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pPyQvaTtcbmZ1bmN0aW9uIGdldFRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGltZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFRJTUUuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhyID0gK21hdGNoZXNbMV07XG4gICAgICAgIGNvbnN0IG1pbiA9ICttYXRjaGVzWzJdO1xuICAgICAgICBjb25zdCBzZWMgPSArbWF0Y2hlc1szXTtcbiAgICAgICAgY29uc3QgdHogPSBtYXRjaGVzWzRdO1xuICAgICAgICBjb25zdCB0elNpZ24gPSBtYXRjaGVzWzVdID09PSBcIi1cIiA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgdHpIID0gKyhtYXRjaGVzWzZdIHx8IDApO1xuICAgICAgICBjb25zdCB0ek0gPSArKG1hdGNoZXNbN10gfHwgMCk7XG4gICAgICAgIGlmICh0ekggPiAyMyB8fCB0ek0gPiA1OSB8fCAoc3RyaWN0VGltZVpvbmUgJiYgIXR6KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGhyIDw9IDIzICYmIG1pbiA8PSA1OSAmJiBzZWMgPCA2MClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBsZWFwIHNlY29uZFxuICAgICAgICBjb25zdCB1dGNNaW4gPSBtaW4gLSB0ek0gKiB0elNpZ247XG4gICAgICAgIGNvbnN0IHV0Y0hyID0gaHIgLSB0ekggKiB0elNpZ24gLSAodXRjTWluIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuICh1dGNIciA9PT0gMjMgfHwgdXRjSHIgPT09IC0xKSAmJiAodXRjTWluID09PSA1OSB8fCB1dGNNaW4gPT09IC0xKSAmJiBzZWMgPCA2MTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUoczEsIHMyKSB7XG4gICAgaWYgKCEoczEgJiYgczIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHQxID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCB0MiA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMyKS52YWx1ZU9mKCk7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0MSAtIHQyO1xufVxuZnVuY3Rpb24gY29tcGFyZUlzb1RpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZ2V0RGF0ZVRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICBjb25zdCB0aW1lID0gZ2V0VGltZShzdHJpY3RUaW1lWm9uZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgICAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZDEgPSBuZXcgRGF0ZShkdDEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCBkMiA9IG5ldyBEYXRlKGR0MikudmFsdWVPZigpO1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZDEgLSBkMjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJc29EYXRlVGltZShkdDEsIGR0Mikge1xuICAgIGlmICghKGR0MSAmJiBkdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IFtkMSwgdDFdID0gZHQxLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IFtkMiwgdDJdID0gZHQyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmVEYXRlKGQxLCBkMik7XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXMgfHwgY29tcGFyZVRpbWUodDEsIHQyKTtcbn1cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuY29uc3QgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgICAvLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sICsgb3B0aW9uYWwgcHJvdG9jb2wgKyByZXF1aXJlZCBcIi5cIlxuICAgIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuY29uc3QgQllURSA9IC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kL2dtO1xuZnVuY3Rpb24gYnl0ZShzdHIpIHtcbiAgICBCWVRFLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIEJZVEUudGVzdChzdHIpO1xufVxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKTtcbmNvbnN0IE1BWF9JTlQzMiA9IDIgKiogMzEgLSAxO1xuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnQ2NCh2YWx1ZSkge1xuICAgIC8vIEpTT04gYW5kIGphdmFzY3JpcHQgbWF4IEludCBpcyAyKio1Mywgc28gYW55IGludCB0aGF0IHBhc3NlcyBpc0ludGVnZXIgaXMgdmFsaWQgZm9yIEludDY0XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovO1xuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gICAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB2b2lkIDA7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgZm9ybWF0TWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgZm9ybWF0TWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmQ3h0ID0gbmV3IGFqdl8xLktleXdvcmRDeHQoaXQsIHNlbGYuUlVMRVMuYWxsLmZvcm1hdC5kZWZpbml0aW9uLCBcImZvcm1hdFwiKTtcbiAgICAgICAgaWYgKGZDeHQuJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10c31bJHtmQ3h0LnNjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9ICE9IFwib2JqZWN0XCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdH0gaW5zdGFuY2VvZiBSZWdFeHBgLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShmb3JtYXQpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29tcGFyZUNvZGUoZm10KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUNvZGUoZm10KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgKDAsIGxpbWl0XzEuZGVmYXVsdCkoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gKDAsIGNvZGVnZW5fMS5fKSBgcmVxdWlyZShcImFqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0c1wiKS4ke2V4cG9ydE5hbWV9YCk7XG4gICAgZm9yIChjb25zdCBmIG9mIGxpc3QpXG4gICAgICAgIGFqdi5hZGRGb3JtYXQoZiwgZnNbZl0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZm9ybWF0c1BsdWdpbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdHNQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGVcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2Vycm9yc1wiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IGtleXdvcmQgPSBcImVycm9yTWVzc2FnZVwiO1xuY29uc3QgdXNlZCA9IG5ldyBhanZfMS5OYW1lKFwiZW1Vc2VkXCIpO1xuY29uc3QgS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMgPSB7XG4gICAgcmVxdWlyZWQ6IFwibWlzc2luZ1Byb3BlcnR5XCIsXG4gICAgZGVwZW5kZW5jaWVzOiBcInByb3BlcnR5XCIsXG4gICAgZGVwZW5kZW50UmVxdWlyZWQ6IFwicHJvcGVydHlcIixcbn07XG5jb25zdCBJTlRFUlBPTEFUSU9OID0gL1xcJFxce1tefV0rXFx9LztcbmNvbnN0IElOVEVSUE9MQVRJT05fUkVQTEFDRSA9IC9cXCRcXHsoW159XSspXFx9L2c7XG5jb25zdCBFTVBUWV9TVFIgPSAvXlwiXCJcXHMqXFwrXFxzKnxcXHMqXFwrXFxzKlwiXCIkL2c7XG5mdW5jdGlvbiBlcnJvck1lc3NhZ2Uob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcIm9iamVjdFwiXSxcbiAgICAgICAgcG9zdDogdHJ1ZSxcbiAgICAgICAgY29kZShjeHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VQYXRoID0gY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpO1xuICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPiAwYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2t3ZFByb3BFcnJvcnMsIGt3ZEVycm9yc10gPSBrZXl3b3JkRXJyb3JzQ29uZmlnKHNjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrd2RFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzS2V5d29yZEVycm9ycyhrd2RFcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa3dkUHJvcEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NoaWxkRXJyb3JzKGNoaWxkRXJyb3JzQ29uZmlnKHNjaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hNZXNzYWdlID0gdHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiID8gc2NoIDogc2NoLl87XG4gICAgICAgICAgICAgICAgaWYgKHNjaE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBbGxFcnJvcnMoc2NoTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVVzZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2hpbGRFcnJvcnNDb25maWcoeyBwcm9wZXJ0aWVzLCBpdGVtcyB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzW3BdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMuaXRlbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5pdGVtc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24ga2V5d29yZEVycm9yc0NvbmZpZyhlbVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wRXJyb3JzO1xuICAgICAgICAgICAgICAgIGxldCBlcnJvcnM7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGVtU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBcInByb3BlcnRpZXNcIiB8fCBrID09PSBcIml0ZW1zXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga3dkU2NoID0gZW1TY2hlbWFba107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga3dkU2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BFcnJvcnMgfHwgKHByb3BFcnJvcnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNYXAgPSAocHJvcEVycm9yc1trXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBrd2RTY2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyTWFwW3BdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgfHwgKGVycm9ycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yc1trXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcHJvcEVycm9ycywgZXJyb3JzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkRXJyb3JzKGt3ZEVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZEVycnMgPSBnZW4uY29uc3QoXCJlbUVycm9yc1wiLCBhanZfMS5zdHJpbmdpZnkoa3dkRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdldFRlbXBsYXRlc0NvZGUoa3dkRXJyb3JzLCBzY2hlbWEpKTtcbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGdlbi5pZihtYXRjaEtleXdvcmRFcnJvcihlcnIsIGt3ZEVycnMpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2t3ZEVycnN9WyR7ZXJyfS5rZXl3b3JkXS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2luZ2xlRXJyb3IgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW4ubGV0KFwibWVzc2FnZVwiLCBhanZfMS5fIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc0Vycm9ycyA9IGdlbi5sZXQoXCJwYXJhbXNFcnJvcnNcIiwgYWp2XzEuXyBgW11gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9vcEVycm9ycygoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYobWVzc2FnZSwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHttZXNzYWdlfSArPSAke3R5cGVvZiBzaW5nbGVFcnJvciA9PSBcInN0cmluZ1wiID8gc2luZ2xlRXJyb3IgOiBcIjtcIn1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uY29kZShhanZfMS5fIGAke21lc3NhZ2V9ICs9ICR7ZXJyTWVzc2FnZShrZXkpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7cGFyYW1zRXJyb3JzfS5jb25jYXQoJHtrd2RFcnJzfVske2tleX1dKWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7IG1lc3NhZ2UsIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtwYXJhbXNFcnJvcnN9fWAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb29wRXJyb3JzKChrZXkpID0+IGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2t3ZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb29wRXJyb3JzKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2t3ZEVycnN9WyR7a2V5fV0ubGVuZ3RoYCwgKCkgPT4gYm9keShrZXkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVyck1lc3NhZ2Uoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGAke2tleX0gaW4gJHt0ZW1wbGF0ZXN9ID8gJHt0ZW1wbGF0ZXN9WyR7a2V5fV0oKSA6ICR7c2NoZW1hVmFsdWV9WyR7a2V5fV1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga3dkRXJycyA9IGdlbi5jb25zdChcImVtRXJyb3JzXCIsIGFqdl8xLnN0cmluZ2lmeShrd2RQcm9wRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzQ29kZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlc0NvZGUucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGVtcGxhdGVzQ29kZShrd2RQcm9wRXJyb3JzW2tdLCBzY2hlbWFba10pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdlbi5vYmplY3QoLi4udGVtcGxhdGVzQ29kZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZFByb3BQYXJhbXMgPSBnZW4uc2NvcGVWYWx1ZShcIm9ialwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGFqdl8xLnN0cmluZ2lmeShLRVlXT1JEX1BST1BFUlRZX1BBUkFNUyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFBhcmFtID0gZ2VuLmxldChcImVtUHJvcFBhcmFtc1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNFcnJvcnMgPSBnZW4ubGV0KFwiZW1QYXJhbXNFcnJvcnNcIik7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHByb3BQYXJhbSwgYWp2XzEuXyBgJHtrd2RQcm9wUGFyYW1zfVske2Vycn0ua2V5d29yZF1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtlcnJ9LmtleXdvcmRdWyR7ZXJyfS5wYXJhbXNbJHtwcm9wUGFyYW19XV1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHBhcmFtc0Vycm9ycywgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5mb3JJbihcImtleVByb3BcIiwgYWp2XzEuXyBgJHtrd2RFcnJzfVske2tleX1dYCwgKGtleVByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtrZXl9XVske2tleVByb3B9XWApO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9Lmxlbmd0aGAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcGwgPSBnZW4uY29uc3QoXCJ0bXBsXCIsIGFqdl8xLl8gYCR7dGVtcGxhdGVzfVske2tleX1dICYmICR7dGVtcGxhdGVzfVske2tleX1dWyR7a2V5UHJvcH1dYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhanZfMS5fIGAke3RtcGx9ID8gJHt0bXBsfSgpIDogJHtzY2hlbWFWYWx1ZX1bJHtrZXl9XVske2tleVByb3B9XWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke3BhcmFtc0Vycm9yc319YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRFcnJvcnMoY2hpbGRFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gY2hpbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcyAmJiAhaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc09iaiA9IGFqdl8xLl8gYHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCJgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXJyID0gYWp2XzEuXyBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFcnJzID0gZ2VuLmxldChcImVtRXJyb3JzXCIpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEt3ZDtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRQcm9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IGdlbi5sZXQoXCJ0ZW1wbGF0ZXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzICYmIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkS3dkID0gZ2VuLmxldChcImVtQ2hpbGRLd2RcIik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc09iaik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FyciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRLd2QsIGFqdl8xLnN0ciBgaXRlbXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChwcm9wcywgc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjaGlsZEt3ZCwgYWp2XzEuc3RyIGBwcm9wZXJ0aWVzYCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3AgPSBhanZfMS5fIGBbJHtjaGlsZEt3ZH1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLml0ZW1zYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoaXNPYmosIGNvZGVnZW5fMS5ub3QoaXNBcnIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQocHJvcHMsIHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLnByb3BlcnRpZXNgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIChjaGlsZCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtjaGlsZEVycnN9WyR7Y2hpbGR9XS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBjaGlsZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2NoaWxkRXJyc31bJHtrZXl9XS5sZW5ndGhgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWp2XzEuXyBgJHtrZXl9IGluICR7dGVtcGxhdGVzfSA/ICR7dGVtcGxhdGVzfVske2tleX1dKCkgOiAke3NjaGVtYVZhbHVlfSR7Y2hpbGRQcm9wfVske2tleX1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtjaGlsZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oYWp2XzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfS0xXS5pbnN0YW5jZVBhdGhgLCBhanZfMS5fIGAke2luc3RhbmNlUGF0aH0gKyBcIi9cIiArICR7a2V5fS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWApO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0KGNoaWxkcmVuLCBtc2dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRFcnJzLCBhanZfMS5zdHJpbmdpZnkoY2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0ZW1wbGF0ZXMsIGdldFRlbXBsYXRlc0NvZGUoY2hpbGRyZW4sIG1zZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQWxsRXJyb3JzKHNjaE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hBbnlFcnJvcihlcnIpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2VycnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7ZXJyc30ubGVuZ3RoYCwgKCkgPT4gZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRlbXBsYXRlRXhwcihzY2hNZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2VycnN9fWAsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVXNlZEVycm9ycygpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYoYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtlcnJzfS5wdXNoKCR7ZXJyfSlgKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGVycnMpLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBhanZfMS5fIGAke2VycnN9Lmxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSAke2luc3RhbmNlUGF0aH1gLCBhanZfMS5fIGAke2Vycn0ua2V5d29yZCBpbiAke2t3ZEVycnN9YCwgXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXRjaCB0aGUgZW5kIG9mIHRoZSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYC9eXFxcXC9bXlxcXFwvXSokLy50ZXN0KCR7ZXJyfS5zY2hlbWFQYXRoLnNsaWNlKCR7aXQuZXJyU2NoZW1hUGF0aC5sZW5ndGh9KSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoLmluZGV4T2YoJHtpbnN0YW5jZVBhdGh9KSA9PT0gMGApLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVnZXggPSBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiAvXlxcLyhbXi9dKikoPzpcXC98JCkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYWp2XzEuXyBgbmV3IFJlZ0V4cChcIl5cXFxcXFwvKFteL10qKSg/OlxcXFxcXC98JClcIilgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGdlbi5jb25zdChcImVtTWF0Y2hlc1wiLCBhanZfMS5fIGAke2NoaWxkUmVnZXh9LmV4ZWMoJHtlcnJ9Lmluc3RhbmNlUGF0aC5zbGljZSgke2luc3RhbmNlUGF0aH0ubGVuZ3RoKSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBnZW4uY29uc3QoXCJlbUNoaWxkXCIsIGFqdl8xLl8gYCR7bWF0Y2hlc30gJiYgJHttYXRjaGVzfVsxXS5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpYCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihhanZfMS5fIGAke2NoaWxkfSAhPT0gdW5kZWZpbmVkICYmICR7Y2hpbGR9IGluICR7Y2hpbGRFcnJzfWAsICgpID0+IHRoZW5Cb2R5KGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaEFueUVycm9yKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuYW5kKGFqdl8xLl8gYCR7ZXJyfS5rZXl3b3JkICE9PSAke2tleXdvcmR9YCwgYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgY29kZWdlbl8xLm9yKGFqdl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09ICR7aW5zdGFuY2VQYXRofWAsIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aC5pbmRleE9mKCR7aW5zdGFuY2VQYXRofSkgPT09IDBgLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoWyR7aW5zdGFuY2VQYXRofS5sZW5ndGhdID09PSBcIi9cImApKSwgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoWyR7aXQuZXJyU2NoZW1hUGF0aH0ubGVuZ3RoXSA9PT0gXCIvXCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlc0NvZGUoa2V5cywgbXNncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlc0NvZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4ga2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBtc2dzW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNDb2RlLnB1c2goW2ssIHRlbXBsYXRlRnVuYyhtc2cpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLnRlbXBsYXRlc0NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVFeHByKG1zZykge1xuICAgICAgICAgICAgICAgIGlmICghSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5zdHJpbmdpZnkobXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlXzEuc2FmZVN0cmluZ2lmeShtc2cpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKElOVEVSUE9MQVRJT05fUkVQTEFDRSwgKF9zLCBwdHIpID0+IGBcIiArIEpTT04uc3RyaW5naWZ5KCR7dmFsaWRhdGVfMS5nZXREYXRhKHB0ciwgaXQpfSkgKyBcImApXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKEVNUFRZX1NUUiwgXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVGdW5jKG1zZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGBmdW5jdGlvbigpe3JldHVybiAke3RlbXBsYXRlRXhwcihtc2cpfX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXRhU2NoZW1hOiB7XG4gICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdMaXN0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdPck1hcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHsgJHJlZjogXCIjLyRkZWZzL3N0cmluZ09yTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJGRlZnM6IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5nT3JNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgYW55T2Y6IFt7IHR5cGU6IFwic3RyaW5nXCIgfSwgeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfV0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJpbmdMaXN0OiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5jb25zdCBhanZFcnJvcnMgPSAoYWp2LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIWFqdi5vcHRzLmFsbEVycm9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LWVycm9yczogQWp2IG9wdGlvbiBhbGxFcnJvcnMgbXVzdCBiZSB0cnVlXCIpO1xuICAgIGlmIChhanYub3B0cy5qc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi1lcnJvcnM6IGFqdiBvcHRpb24ganNQcm9wZXJ0eVN5bnRheCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWp2LmFkZEtleXdvcmQoZXJyb3JNZXNzYWdlKG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG5tb2R1bGUuZXhwb3J0cyA9IGFqdkVycm9ycztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgQWp2LCB7XG4gIE9wdGlvbnMsXG4gIEVycm9yT2JqZWN0LFxuICBFcnJvcnNUZXh0T3B0aW9ucyxcbiAgQW55U2NoZW1hT2JqZWN0LFxufSBmcm9tIFwiYWp2XCI7XG5pbXBvcnQgYWRkRm9ybWF0cyBmcm9tIFwiYWp2LWZvcm1hdHNcIjtcbmltcG9ydCBhZGRFcnJvcnMgZnJvbSBcImFqdi1lcnJvcnNcIjtcbmltcG9ydCB7IE1lc3NhZ2VTY2hlbWEsIFR5cGVkSW5wdXRTY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWFzXCI7XG5cbmNsYXNzIFZhbGlkYXRvclNlcnZpY2Uge1xuICBhanY6IEFqdjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogT3B0aW9ucykge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENPTlNUUlVDVE9SIE9GIFZBTElEQVRPUiBTRVJWSUNFXCIpO1xuICAgIHRoaXMuYWp2ID0gbmV3IEFqdih7XG4gICAgICBhbGxFcnJvcnM6IHRydWUsXG4gICAgICB1c2VEZWZhdWx0czogXCJlbXB0eVwiLFxuICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlRm9ybWF0czogdHJ1ZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGNvZXJjZVR5cGVzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKHRoaXMuYWp2LnNjaGVtYXMpO1xuXG4gICAgLy8gTk9URTogdGhpcyBwbHVnaW4gZW5hYmxlcyB1c2VycyB0byB1c2UgZm9ybWF0cyBrZXl3b3JkXG4gICAgYWRkRm9ybWF0cyh0aGlzLmFqdik7XG5cbiAgICAvLyBOT1RFOyB0aGlzIHBsdWdpbiBlbmFibGVzIHVzZXJzIHRvIGRlY2xhcmUgY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gICAgYWRkRXJyb3JzKHRoaXMuYWp2KTtcblxuICAgIHRoaXMuYWp2LmFkZEtleXdvcmQoXCJub2RlVHlwZVwiKTtcbiAgfVxuXG4gIGNyZWF0ZVZhbGlkYXRvcihzY2hlbWE6IEFueVNjaGVtYU9iamVjdCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENSRUFURVZBTElEQVRPUlwiKTtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmFqdi5zY2hlbWFzKTtcbiAgICByZXR1cm4gdGhpcy5hanYuY29tcGlsZShzY2hlbWEpO1xuICB9XG5cbiAgZXJyb3JzKFxuICAgIGVycm9ycz86IEVycm9yT2JqZWN0W10gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM/OiBFcnJvcnNUZXh0T3B0aW9uc1xuICApIHtcbiAgICByZXR1cm4gdGhpcy5hanYuZXJyb3JzVGV4dChlcnJvcnMsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfTtcbiIsImltcG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi4vdmFsaWRhdG9yLXNlcnZpY2VcIjtcbi8vIE5PVEU6IHNpbmdsZXRvbiB0byB1c2UgYWp2IGNhY2hpbmcgZmVhdHVyZXNcbmNvbnN0IHZhbGlkYXRvclNlcnZpY2UgPSBuZXcgVmFsaWRhdG9yU2VydmljZSgpO1xuXG5leHBvcnQgeyB2YWxpZGF0b3JTZXJ2aWNlIH07XG4iLCJpbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgeyBjcmVhdGVBcHAsIENvbXBvbmVudCwgQXBwLCBkZWZpbmVDb21wb25lbnQgfSBmcm9tIFwidnVlXCI7XG5pbXBvcnQgeyBjbG9uZURlZXAsIGlzRXF1YWwsIG1lcmdlIH0gZnJvbSBcImVzLXRvb2xraXRcIjtcbmltcG9ydCB7IEFueVNjaGVtYSwgVmFsaWRhdGVGdW5jdGlvbiB9IGZyb20gXCJhanZcIjtcbmltcG9ydCB7IGdldERlZmF1bHRzRnJvbVNjaGVtYSwgZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmltcG9ydCBOb2RlUmVkVnVlQXBwIGZyb20gXCIuL0FwcC52dWVcIjtcbmltcG9ydCBOb2RlUmVkSW5wdXQgZnJvbSBcIi4vY29tcG9uZW50cy9Ob2RlUmVkSW5wdXQudnVlXCI7XG5pbXBvcnQgTm9kZVJlZFR5cGVkSW5wdXQgZnJvbSBcIi4vY29tcG9uZW50cy9Ob2RlUmVkVHlwZWRJbnB1dC52dWVcIjtcbmltcG9ydCBOb2RlUmVkQ29uZmlnSW5wdXQgZnJvbSBcIi4vY29tcG9uZW50cy9Ob2RlUmVkQ29uZmlnSW5wdXQudnVlXCI7XG5pbXBvcnQgTm9kZVJlZFNlbGVjdElucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZFNlbGVjdElucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRFZGl0b3JJbnB1dCBmcm9tIFwiLi9jb21wb25lbnRzL05vZGVSZWRFZGl0b3JJbnB1dC52dWVcIjtcblxuaW1wb3J0IHsgdmFsaWRhdG9yU2VydmljZSB9IGZyb20gXCIuL3ZhbGlkYXRvclwiO1xuXG5mdW5jdGlvbiBjcmVhdGVOb2RlUmVkVnVlQXBwKFxuICBub2RlOiBhbnksXG4gIGZvcm06IElOb2RlRm9ybSxcbiAgdmFsaWRhdG9yOiBWYWxpZGF0ZUZ1bmN0aW9uIHwgKCgpID0+IGJvb2xlYW4pXG4pOiBBcHA8RWxlbWVudD4ge1xuICBjb25zdCBhcHAgPSBjcmVhdGVBcHAoTm9kZVJlZFZ1ZUFwcCwge1xuICAgIG5vZGUsXG4gICAgdmFsaWRhdG9yLFxuICAgIGRpc2FibGVTYXZlQnV0dG9uT25FcnJvcjogZm9ybS5kaXNhYmxlU2F2ZUJ1dHRvbk9uRXJyb3IsXG4gIH0pO1xuXG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkSW5wdXRcIiwgTm9kZVJlZElucHV0KTtcbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRUeXBlZElucHV0XCIsIE5vZGVSZWRUeXBlZElucHV0KTtcbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRDb25maWdJbnB1dFwiLCBOb2RlUmVkQ29uZmlnSW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZFNlbGVjdElucHV0XCIsIE5vZGVSZWRTZWxlY3RJbnB1dCk7XG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkRWRpdG9ySW5wdXRcIiwgTm9kZVJlZEVkaXRvcklucHV0KTtcbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWROb2RlRm9ybVwiLCBmb3JtLmNvbXBvbmVudCk7XG4gIHJldHVybiBhcHA7XG59XG5cbmZ1bmN0aW9uIG1vdW50QXBwKFxuICBub2RlOiBhbnksXG4gIGZvcm06IElOb2RlRm9ybSxcbiAgdmFsaWRhdG9yOiBWYWxpZGF0ZUZ1bmN0aW9uIHwgKCgpID0+IGJvb2xlYW4pXG4pIHtcbiAgJChcIiNhcHBcIikuZW1wdHkoKTtcbiAgbm9kZS5fbmV3U3RhdGUgPSBjbG9uZURlZXAobm9kZSk7XG4gIG5vZGUuX2FwcCA9IGNyZWF0ZU5vZGVSZWRWdWVBcHAobm9kZS5fbmV3U3RhdGUsIGZvcm0sIHZhbGlkYXRvcik7XG4gIG5vZGUuX2FwcC5tb3VudChcIiNhcHBcIik7XG59XG5cbmZ1bmN0aW9uIHVubW91bnRBcHAobm9kZTogYW55KSB7XG4gIGlmIChub2RlLl9hcHApIHtcbiAgICBub2RlLl9hcHAudW5tb3VudCgpO1xuICAgIG5vZGUuX2FwcCA9IG51bGw7XG4gIH1cbn1cblxuaW50ZXJmYWNlIElDcmVkZW50aWFscyB7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuaW50ZXJmYWNlIElOb2RlU3RhdGUge1xuICBjcmVkZW50aWFsczogSUNyZWRlbnRpYWxzO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVTdGF0ZShub2RlOiBhbnkpOiBJTm9kZVN0YXRlIHtcbiAgY29uc3Qgc3RhdGU6IElOb2RlU3RhdGUgPSB7XG4gICAgY3JlZGVudGlhbHM6IHt9LFxuICB9O1xuICBPYmplY3Qua2V5cyhub2RlLl9kZWYuZGVmYXVsdHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBzdGF0ZVtwcm9wXSA9IG5vZGVbcHJvcF07XG4gIH0pO1xuICBPYmplY3Qua2V5cyhub2RlLl9kZWYuY3JlZGVudGlhbHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBzdGF0ZS5jcmVkZW50aWFsc1twcm9wXSA9IG5vZGUuY3JlZGVudGlhbHNbcHJvcF07XG5cbiAgICBpZiAobm9kZS5fZGVmLmNyZWRlbnRpYWxzW3Byb3BdLnR5cGUgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgc3RhdGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF0gPVxuICAgICAgICBub2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdIHx8IGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VzKFxuICBvOiBSZWNvcmQ8YW55LCBhbnk+LFxuICBuOiBSZWNvcmQ8YW55LCBhbnk+XG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgY2hhbmdlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBjb25zdCBfbyA9IG9bcHJvcF07XG4gICAgY29uc3QgX24gPSBuW3Byb3BdO1xuXG4gICAgaWYgKHR5cGVvZiBfbyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgX2NoYW5nZXMgPSBnZXRDaGFuZ2VzKF9vLCBfbik7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoX2NoYW5nZXMpLmxlbmd0aCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gX2NoYW5nZXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNFcXVhbChfbywgX24pKSB7XG4gICAgICBjaGFuZ2VzW3Byb3BdID0gX287XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY2hhbmdlcztcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBidXR0b24gY29uZmlndXJhdGlvbiBmb3IgYSBOb2RlLlxuICpcbiAqIEBpbnRlcmZhY2UgSU5vZGVCdXR0b25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0b2dnbGUgLSBUZXh0IHRvIGRpc3BsYXkgd2hlbiB0b2dnbGluZyB0aGUgYnV0dG9uLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiB2b2lkfSBvbmNsaWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogYm9vbGVhbn0gW2VuYWJsZWRdIC0gRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1dHRvbiBzaG91bGQgYmVcbiAqICAgZW5hYmxlZC4gUmV0dXJucyB0cnVlIGlmIHRoZSBidXR0b24gc2hvdWxkIGJlIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogYm9vbGVhbn0gW3Zpc2libGVdIC0gRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGJ1dHRvbiBzaG91bGQgYmVcbiAqICAgdmlzaWJsZS4gUmV0dXJucyB0cnVlIGlmIHRoZSBidXR0b24gc2hvdWxkIGJlIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuaW50ZXJmYWNlIElOb2RlQnV0dG9uIHtcbiAgdG9nZ2xlOiBzdHJpbmc7XG4gIG9uY2xpY2s6ICgpID0+IHZvaWQ7XG4gIGVuYWJsZWQ/OiAoKSA9PiBib29sZWFuO1xuICB2aXNpYmxlPzogKCkgPT4gYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVwcmVzZW50aW5nIHRoZSBmb3JtIGNvbmZpZ3VyYXRpb24gZm9yIGEgTm9kZS5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlRm9ybVxuICogQHByb3BlcnR5IHtDb21wb25lbnR9IFtjb21wb25lbnRdIC0gVnVlIDMgY29tcG9uZW50LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yXSAtIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyB0cnVlLCB0aGUgU2F2ZSwgb3IgVXBkYXRlLCBidXR0b25zIGFyZSBkaXNhYmxlZCB3aGVuIHRoZSBmb3JtIGhhcyBlcnJvcnMuIEl0IGRlZmF1bHRzIHRvIGZhbHNlLlxuICovXG5pbnRlcmZhY2UgSU5vZGVGb3JtIHtcbiAgY29tcG9uZW50OiBDb21wb25lbnQ7XG4gIGRpc2FibGVTYXZlQnV0dG9uT25FcnJvcj86IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIE5vZGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBub2RlIHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSBUaGUgY2F0ZWdvcnkgdGhpcyBub2RlIGJlbG9uZ3MgdG8gaW4gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXSAtIFRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpbiBoZXggZm9ybWF0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXSAtIFRoZSBpY29uIHRvIGRpc3BsYXkgZm9yIHRoaXMgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbGFiZWxdIC0gVGhlIGxhYmVsIHRvIGRpc3BsYXkgb24gdGhlIG5vZGUuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2lucHV0c10gLSBOdW1iZXIgb2YgaW5wdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW291dHB1dHNdIC0gTnVtYmVyIG9mIG91dHB1dCBwb3J0cyB0aGUgbm9kZSBzaG91bGQgaGF2ZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbcGFsZXR0ZUxhYmVsXSAtIFRoZSBsYWJlbCB0byBzaG93IGluIHRoZSBwYWxldHRlLiBDYW4gYmUgYSBzdGF0aWMgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtsYWJlbFN0eWxlXSAtIENTUyBzdHlsZSB0byBhcHBseSB0byB0aGUgbm9kZSBsYWJlbC4gQ2FuIGJlIGEgc3RhdGljIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbaW5wdXRMYWJlbHNdIC0gTGFiZWxzIGZvciB0aGUgaW5wdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW291dHB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBvdXRwdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge1wibGVmdFwifFwicmlnaHRcIn0gW2FsaWduXSAtIEFsaWdubWVudCBvZiB0aGUgbm9kZSBjb250ZW50LlxuICogQHByb3BlcnR5IHtJTm9kZUJ1dHRvbn0gW2J1dHRvbl0gLSBDb25maWd1cmF0aW9uIGZvciBhIGJ1dHRvbiBvbiB0aGUgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZUFkZF0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcGFsZXR0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZVJlbW92ZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge0lOb2RlRm9ybX0gZm9ybSAtIFRoZSBmb3JtIGNvbXBvbmVudCB0byB1c2UgZm9yIGNvbmZpZ3VyaW5nIHRoZSBub2RlLlxuICogQHByb3BlcnR5IHtBbnlTY2hlbWF9IFtzY2hlbWFdIC0gU2NoZW1hIGRlZmluaXRpb24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmludGVyZmFjZSBJTm9kZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgY29sb3I/OiBzdHJpbmc7XG4gIGljb24/OiBzdHJpbmc7XG4gIGxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGlucHV0cz86IG51bWJlcjtcbiAgb3V0cHV0cz86IG51bWJlcjtcbiAgcGFsZXR0ZUxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGxhYmVsU3R5bGU/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgaW5wdXRMYWJlbHM/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgb3V0cHV0TGFiZWxzPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGFsaWduPzogXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG4gIGJ1dHRvbj86IElOb2RlQnV0dG9uO1xuICBvblBhbGV0dGVBZGQ/OiAoKSA9PiB2b2lkO1xuICBvblBhbGV0dGVSZW1vdmU/OiAoKSA9PiB2b2lkO1xuICBmb3JtOiBJTm9kZUZvcm07XG59XG5cbmZ1bmN0aW9uIGRlZmluZU5vZGU8VCBleHRlbmRzIE9taXQ8SU5vZGUsIFwidHlwZVwiPj4ob3B0aW9uczogVCk6IFQge1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyBhIG5vZGUgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVGhpcyBpcyBhIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZFxuICogdG8gcmVnaXN0ZXIgdGhlIG5vZGUgd2l0aCBhIHNwZWNpZmljIHR5cGUgYXQgcnVudGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZUNvbmZpZyAtIFRoZSBzdGF0aWMgY29uZmlndXJhdGlvbiBzaGFyZWQgYnkgYWxsIG5vZGVzIG9mIHRoaXMga2luZFxuICogQHBhcmFtIHtzdHJpbmd9IFtub2RlQ29uZmlnLmNhdGVnb3J5PVwidW5kZWZpbmVkXCJdIC0gVGhlIGNhdGVnb3J5IHRoaXMgbm9kZSBiZWxvbmdzIHRvIGluIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25vZGVDb25maWcuY29sb3I9XCIjRkZGRkZGXCJdIC0gVGhlIGNvbG9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGluIGhleCBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbm9kZUNvbmZpZy5pY29uXSAtIFRoZSBpY29uIHRvIGRpc3BsYXkgZm9yIHRoaXMgbm9kZVxuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLmxhYmVsXSAtIFRoZSBsYWJlbCB0byBkaXNwbGF5IG9uIHRoZSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW25vZGVDb25maWcuaW5wdXRzPTBdIC0gTnVtYmVyIG9mIGlucHV0IHBvcnRzIHRoZSBub2RlIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge251bWJlcn0gW25vZGVDb25maWcub3V0cHV0cz0wXSAtIE51bWJlciBvZiBvdXRwdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5wYWxldHRlTGFiZWxdIC0gVGhlIGxhYmVsIHRvIHNob3cgaW4gdGhlIHBhbGV0dGVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5sYWJlbFN0eWxlXSAtIENTUyBzdHlsZSB0byBhcHBseSB0byB0aGUgbm9kZSBsYWJlbFxuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLmlucHV0TGFiZWxzXSAtIExhYmVscyBmb3IgdGhlIGlucHV0IHBvcnRzXG4gKiBAcGFyYW0geyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW25vZGVDb25maWcub3V0cHV0TGFiZWxzXSAtIExhYmVscyBmb3IgdGhlIG91dHB1dCBwb3J0c1xuICogQHBhcmFtIHtcImxlZnRcInxcInJpZ2h0XCJ9IFtub2RlQ29uZmlnLmFsaWduPVwibGVmdFwiXSAtIEFsaWdubWVudCBvZiB0aGUgbm9kZSBjb250ZW50XG4gKiBAcGFyYW0ge0lOb2RlQnV0dG9ufSBbbm9kZUNvbmZpZy5idXR0b25dIC0gQ29uZmlndXJhdGlvbiBmb3IgYSBidXR0b24gb24gdGhlIG5vZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW25vZGVDb25maWcub25QYWxldHRlQWRkXSAtIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBub2RlIGlzIGFkZGVkIHRvIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtub2RlQ29uZmlnLm9uUGFsZXR0ZVJlbW92ZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhbGV0dGVcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBub2RlQ29uZmlnLmZvcm0gLSBUaGUgZm9ybSBjb21wb25lbnQgdG8gdXNlIGZvciBjb25maWd1cmluZyB0aGUgbm9kZVxuICogQHBhcmFtIHtBbnlTY2hlbWF9IFtub2RlQ29uZmlnLnNjaGVtYV0gLSBTY2hlbWEgZGVmaW5pdGlvbiBmb3IgdmFsaWRhdGlvblxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbih0eXBlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+fSAtIEEgZnVuY3Rpb24gdGhhdCByZWdpc3RlcnMgdGhlIG5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKFxuICB0eXBlOiBzdHJpbmcsXG4gIG9wdGlvbnM6IE9taXQ8SU5vZGUsIFwidHlwZVwiPlxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL25yZy9ub2Rlcy8ke3R5cGV9YCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IGdldERlZmF1bHRzRnJvbVNjaGVtYShzY2hlbWEpO1xuICAgIGlmIChkZWZhdWx0cy5jcmVkZW50aWFscykgZGVsZXRlIGRlZmF1bHRzLmNyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hKHNjaGVtYS5wcm9wZXJ0aWVzLmNyZWRlbnRpYWxzKTtcblxuICAgIGNvbnNvbGUubG9nKFwiZGVmYXVsdHNcIiwgZGVmYXVsdHMpO1xuICAgIGNvbnNvbGUubG9nKFwiY3JlZGVudGlhbHNcIiwgY3JlZGVudGlhbHMpO1xuXG4gICAgUkVELm5vZGVzLnJlZ2lzdGVyVHlwZSh0eXBlLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIHR5cGUsXG4gICAgICBsYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfSxcbiAgICAgIG9uZWRpdHByZXBhcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbmVkaXRwcmVwYXJlXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gdmFsaWRhdG9yU2VydmljZS5jcmVhdGVWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgICAgICAgbW91bnRBcHAodGhpcywgb3B0aW9ucy5mb3JtLCB2YWxpZGF0b3IpO1xuICAgICAgfSxcbiAgICAgIG9uZWRpdHNhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXM7XG4gICAgICAgIHVubW91bnRBcHAobm9kZSk7XG5cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBnZXROb2RlU3RhdGUobm9kZS5fbmV3U3RhdGUpO1xuICAgICAgICBjb25zdCBvbGRTdGF0ZSA9IGdldE5vZGVTdGF0ZShub2RlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldENoYW5nZXMob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9ICEhT2JqZWN0LmtleXMoY2hhbmdlcyk/Lmxlbmd0aDtcbiAgICAgICAgaWYgKCFjaGFuZ2VkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmtleXMobm9kZS5fZGVmLmRlZmF1bHRzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuX2RlZi5kZWZhdWx0cz8uW3Byb3BdPy50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRDb25maWdOb2RlSWQgPSBub2RlW3Byb3BdO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29uZmlnTm9kZUlkID0gbm9kZS5fbmV3U3RhdGVbcHJvcF07XG4gICAgICAgICAgICBpZiAob2xkQ29uZmlnTm9kZUlkICE9PSBuZXdDb25maWdOb2RlSWQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2xkQ29uZmlnTm9kZSA9IFJFRC5ub2Rlcy5ub2RlKG9sZENvbmZpZ05vZGVJZCk7XG4gICAgICAgICAgICAgIGlmIChvbGRDb25maWdOb2RlICYmIG9sZENvbmZpZ05vZGUuX2RlZi5jYXRlZ29yeSA9PT0gXCJjb25maWdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGVJbmRleCA9IG9sZENvbmZpZ05vZGUudXNlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICAgKF9ub2RlKSA9PiBfbm9kZS5pZCA9PT0gbm9kZS5pZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIG9sZENvbmZpZ05vZGUudXNlcnMuc3BsaWNlKHBhcmVudE5vZGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3Qua2V5cyhub2RlLl9kZWYuZGVmYXVsdHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICBpZiAobm9kZS5fZGVmLmRlZmF1bHRzPy5bcHJvcF0/LnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlQ29uZmlnTm9kZUlkID0gbm9kZS5fbmV3U3RhdGVbcHJvcF07XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZUNvbmZpZ05vZGUgPSBSRUQubm9kZXMubm9kZShuZXdTdGF0ZUNvbmZpZ05vZGVJZCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5ld1N0YXRlQ29uZmlnTm9kZSAmJlxuICAgICAgICAgICAgICBuZXdTdGF0ZUNvbmZpZ05vZGUuX2RlZi5jYXRlZ29yeSA9PT0gXCJjb25maWdcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGVJbmRleCA9IG5ld1N0YXRlQ29uZmlnTm9kZS51c2Vycy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgKF9ub2RlKSA9PiBfbm9kZS5pZCA9PT0gbm9kZS5pZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlQ29uZmlnTm9kZS51c2Vycy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZXJnZShub2RlLCBuZXdTdGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFuZ2VkLFxuICAgICAgICAgIGhpc3Rvcnk6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdDogXCJlZGl0XCIsXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgIGxpbmtzOiBbXSxcbiAgICAgICAgICAgICAgZGlydHk6IFJFRC5ub2Rlcy5kaXJ0eSgpLFxuICAgICAgICAgICAgICBjaGFuZ2VkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIG9uZWRpdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB1bm1vdW50QXBwKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIG9uZWRpdGRlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB1bm1vdW50QXBwKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIG9ucGFsZXR0ZWFkZDogb3B0aW9ucy5vblBhbGV0dGVBZGQsXG4gICAgICBvbnBhbHR0ZXJlbW92ZTogb3B0aW9ucy5vblBhbGV0dGVSZW1vdmUsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbm9kZSB0eXBlICR7dHlwZX06YCwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCB7IGRlZmluZU5vZGUsIHJlZ2lzdGVyVHlwZSwgSU5vZGUsIElOb2RlQnV0dG9uIH07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IE5hbWU8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5uYW1lXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm5hbWUnXVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwibmFtZVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBIb3N0bmFtZTwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmhvc3RcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuaG9zdCddXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCJob3N0bmFtZVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiTm9kZVJlZE5vZGVGb3JtXCIsXG4gIHByb3BzOiB7XG4gICAgbm9kZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBlcnJvcnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsIi8vIE5PVEU6IHRoaXMgZmlsZSBpcyBwcm92aWRlZCBieSB0aGUgdXNlclxuLy8gTk9URTsgdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBucmdcbmltcG9ydCB7IGRlZmluZU5vZGUgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9jbGllbnRcIjtcbmltcG9ydCBjb21wb25lbnQgZnJvbSBcIi4vRm9ybS52dWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lTm9kZSh7XG4gIGNhdGVnb3J5OiBcImNvbmZpZ1wiLFxuICBjb2xvcjogXCIjYTZiYmNmXCIsXG4gIGZvcm06IHtcbiAgICBjb21wb25lbnQsXG4gICAgZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yOiB0cnVlLFxuICB9LFxufSk7XG4iLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBV2dBQUFFT0NBSUFBQUFyS2hyRkFBQUFBWE5TUjBJQXJzNGM2UUFBQUVSbFdFbG1UVTBBS2dBQUFBZ0FBWWRwQUFRQUFBQUJBQUFBR2dBQUFBQUFBNkFCQUFNQUFBQUJBQUVBQUtBQ0FBUUFBQUFCQUFBQmFLQURBQVFBQUFBQkFBQUJEZ0FBQUFCTkw3eTRBQUFaVFVsRVFWUjRBZTFkUGE4bFJ4RjlSaHNoRWtmRUdBSnlMQkFKQVJJV2tUTkU2TXlXa0VoSUlDSWdjb0JJa0ZieVpnNFJmd0N4aUlBRVlTMDVnZGNiazNnVGkzUTV1NzF2dHUvY3VUM2RNOVhkZGJyUFM5NTg5RlJYbjZvNVUxMDFQZmV0Rnk5ZTNHWC9QWC8rZkxQdDIyKy8vYnQvL3VuSlY4ODJ6L28vK0w5SE5Kci82RmMvL3UwUGZ4NGJBdURuSXh4ZnVIdFZNOGwvK2VMZnYvLzFvMTE5bkRUNCtvZmZjcUpKcVJydmZ1TmJjSjViVnhYNXh0ZHVTU2s2amk1LytkMzNpaTVSNDJNSS9PTVBmd2ZhUmJmMHNZNWFYa1hFR2kxaE1lL0w4Q2ExSVE2TUVLNzhpMi8veEh5b2JRUnlQVU0rZVBKSkcxamE5SUpZdFUxSEpyMXd1VW84Wk55ZWhzOGJNK0xBWS9BSGI3OFRLNnJ0U2doZ1lvWFkzdEFKS3VtWkl4WnVneGdxcDZYYW5FVGdwKzk4NzZTRStISXo0b0JRQlIweHNsVzNoNG50dWFJbjZuREQxaUV0aVFOUEQ3QWFFakMyS2phVHh1VVdBd1FkR0FKUldwckxQZUs3QnJla2JiZ0I0WmJFQVhIZ0RzTUVURHg0YmE4UVFOQUJ0S2tuTE1QRVRTdlRlTnV0Y1VzYUV3Y2dneXNyNkdqak9uLzh6MS9iZEZTakYrVkVhNkI2TGRNMko3ckl0eWNPQlIwTHVMVTNrRlpFdEYrN0YzUDVlTFRBU1pRVE5RZDJVMkNsa29VOWNVQjdaVWszVFZqajRHZi8vYnlHMk5veXVXSWwzdXhHcFhBRDdsR0ZPUEE4QWM5cHdsTDc5b044dXFBRER4VkVTVVRoQmk5cjFNaUpMaTVkaFRpQzlCb3BtVVZ2YlN3SVBIejZlTmwydmhFbUtVUUtPOGN6cmQ3M3YvbWRkSU16WnlzU0I3eEVRY2NaMjJSZUc5NEh5MnpjdmRtL25uK2hFbXdESytEV3E1VGRDTXBYSkE1MG9LQ2pnWXVnQzRxNlpnZzNLRlJ0WTdXcXZTRGNBT0QxdXFoTEhGQmRDMWpxR1MrV1RGSGRWRTQwTmxtOTdaRGRRS3F4WGhjUGlxUVhjVmlRakhqcFlUMzFKZmtlQWFRYm56OTZMenpWNzQ5dC9EOWd3UTBwVzRkMkpjTWZpSEtpVzBPa09SYld6dTg2dzJvOHV4YU0yOWVOT05BVHRGSFFFU05lYjl2NXVnL242cTNzd2x0TWFYTzdWU2NPUEdlb1M3TXJmL0s4NjNuVnJKYWx0UEdjcWlYWWVBalZpUU9kSWVpb1dobUt4Mk8remZYa2NadDZkS3VZdWNQMEZkanNSbXRCSEFnNnRHcTJtVDhoUzFvMFdXMmdHRVhpZHNHQjYxR3hxSTJOWnVFRyttcEJIT2dHM0tIU2JHempldHN2czZUT1ZzMHFKMXJQM0xIa3hQZEU0MlltMjQySUkramFKbTFqZ3N0S0NOZFR5RlhWVStIR3lwY3E3VGErdVpvU1I5VlgyU3JaZzFFc252QklSbnFZc0NEMlVialJ4b1hNUDlXVFZyc3BjYWcwbXphRzRWbXNtc1ZOYXlqd21DaVZZSS9oVm5wVjQzQUQ2alVsRHJneWRXbVdhTUtDNXp4V2hmUU5PbFNDTGIzL2o3VnZtUk5kTkd4S0hPZ1ZydHlzWXJRTWNzNE5WRUQ3WmtsVmdtM2plRjNLRHEySkE2NnMwbXdiZjBJdkNEcWE5YlhxQ09IRzZvam5YYUpZY2dVandvMHVjV1ZyNHNDd3dSMWRPSEtGK0F5N3ZZSU9tRmpoUmhzSDYzVXJkU0FPQUtvc2FSdXZRaTlkU3JOZE9qME1LVys0Z1p4b2wzQURVUGNoRGp5UlZKbzk3T2hGRjdZdnpjSzRSQ1ZZWHRib2toTmRmTzh0azErclg4VEZHN3RjaUdrdzcxZmtpRDVqQmFQODdjK3ZmMjRXZDNWc28vVDJyZ1hqeTROa1hQTCs0NCtKd09FbERvUWJTQmVtRFhyQWdyRk5FOXQ5SW82Z2tMS2tDY1BZbm1xVHFvU2JxZ1JyYTdoYjBrSzRrV2FOVzllYUhPOUpIQmhBcjlTT0NYWkVRcHFsS3B0MVJBUitEVlc3djlQUW1UandqQUozMWtDMmdVeXVLTGYybWhHWXNuWVh0amJsTWw4ODl1N2hCcFRwVEJ6UW9PV1N2aGo5MmJhUnNFUmtXelRwTFlJSXdvbHlva1ZEODlZWWNYckhTVXBBb3o5eFFJLzJiOXBidVFMWFU2dHFsVlRMVXF5Y0tpMm5Zd2syVnN3RmNUUmUyQmVQLy93MkVYZlVLODF5NVVUUEc3MmpCTHpIMEQzY3dQQmRFQWYwNEEwNk92clFnYTRySlMrNXl1cEVYTDh5OGFmdmZsUnZzcm5xSzczcmhUaFVtazNieWZBc1VwaTJ6c2NWYnZDeUJuS2lNSnlIY0FQZTZJVTRBSWRLczRic2tCQmxuaVd0Rk1Va2hqRG5LVmMzaUJmaUNLN0FPMkhoZW80WlprbFZnbTNEWWs1eW9zdGdmUkdIRnJBc2hxbTZZUlYwSUU1VUNiYXFwUmJoM2dvSXZvZ0RVemdGSFl1dlZOMUE5ZlQ4Yk5rd2NxazYyQ0NjS3lxTUFYRjRVL2dpRHJpeXZpMFllMHk5YmF4RE8vbHRRYTV3ZzVjMXdudWk5VHpobUdSZnhJRXhJT2pvL2g3K01TanByanFaMVB6Wmg3K2hHektqd2o1dmgrcS9WcDlwcXJoQWlPa2NQdEw5NUt0bm1kZTZhb1luRzlHaWNsUlNFNVBuVzNNWkdBc1h1b0k5clF4N3VCRWJJcjVUMHFQRzJmakMzY1pGa3QxRkhHRjRyaXBQdTRqek5qZ1dkTUFkajEzSUMxUXZ6ZDNlQ0U2SkErVG5NQ0dVNlQxY3o3ZlNlaXBNbzV4b3BpZWNiT2JxamEvVldKd1NCN1JNaE5Dck1XajNEQUtoTkpzcEFheUJTWXBLc0psd25Xem1OdHpBdVB3U0I1UlQwSEhTOHpJdkwxcllxbVVwbWFpZWJBYm5CMDBYSlNsTzlsaDB1V3ZpUU5DQmFLMW9QSDRhRTAxWWtNM05TWGFHY0lNbzlVdGtncFhmaGhLc1c5YUF0cTZKQS9wNWp0Wld4cWJlM1UxMmhxZmZiak5xRVB3b0Q3ZjN6Qm9BeWp0eHdGOFZkTFJ4Nk4wc3FYS2liUXdSY3FKdCtqcmNpM2Zpd01EMGJjSEQxaTI2TUpFbERaTVU1VVNMOER6YzJIKzRnYUVSRUFlMFZKYjBzQmNXWFppSUtmQktYcEdvdm8xNXN4c3NyczVCSE5SWjByNjNVRkh2aUNtdXM2UjA0UVl2YTJDU2dyVmFBTHpJYWwwYWN4QUhvUEg1eG42T3piajgrRHF5UUpidSttRE93TldtRkFFNE9WakRlVm8wRElxR09LaUREaUx1V0FVZDhHTXNvaVhLYmhCQnZhS1ZFRzVRc0FZMHB5RU82S3JTN01yVkt1MHVOZGZ3OUZ0MkszVW5zUUdCRUc2d29NRkVIUEJqbHRUUnRmbTVub1JMYVRhUkxyMGVZL2NqWENESGNDSGNRRXpORW01QTh3ZTRHK01CcExlTEJsWkRNbEpIRDlNcTZxd0ZBcGliUEgvMEhpeElORW14R0hjM0dlR2RnNXhicHZzOUdEQmlpamlnTVpCVjBOSEd1eEZyTEhGSG14NVA5c0liYmpDNk5CbHhnRzcxYmNHVE4xam01WWcxRkc1a1luV3lHU1lwSnlXMHY1eU1PQUFRZ2c3ZTBteDdBMC9TbzhLTnhvYm1JdzRFSFNyTk52WVM1OTN4c2tiSWlUcUhkMU05UHVJSXcxQnBkdE9jT3NpRkFNV3lsRTFJV1lsRFdkSk5jMDU0a0RyY3lDbWorTFFwSzNFQVRjYVVrazhua0ZaZEVPQU5Od0FYTVhGQWU4WTZWdkJSM3Vka2wzdnNWcWU4TU1KMWVjTU5tSU9iT0pRbHZYVkh6WENjbHpXNGxxVnMraEkzY1dCSXlwSnUybFVIUFNQQXRTeGxFMGw2NGtDOEIvN2VISnYvZzd6UHpPN1k4a0kzUUxnQjY5TVRCOGFnb0tQN2JTd0Y4aEdBdTFKbk44SklSeUFPbUVGWjBuekhIYUFsYjdnUmNxSkZDOVY4Mm1zRTRnQ3l5cEw2ZEM5cHRVSUFLNjBHWUEwTXl1T3YxYSt3dnQ2OWhoNUJCeEpPcEQ5d2Z6MUFIVWtnd0I1dVhBL3QycCt2Mnl4SGlxWTU5U1FQRW5FQUlLMmFYWHhyNEExZTF1QmRsckxwVG9NUUI4WVdnbzdOUWVxZ0VPaU93R0FwL0hHSUEwR0hNaDNkYjQrcUNsQ0hHMFZUaktvd21nZ2ZoemdBQjdoak1GNDNzYkdFZEVkZ3ZGOGpISW80NEIvZ2RaVm11OThuTlJUZ0RUZDRIVEpoeDlHSUkyUkpFd1BXS1VZRWVGa0RhQSs1akhzMDRvQ2RGSFF3VXNPb09uLzY3a2RERG0xQTRsQ1dkREJQNVEwM1VJSWRMQ2U2dU5hQXhJR3hLVXU2R0ZnYkhSRVlPRlUvSm5IQVY4RDBXalhiOFo2eDZwbzMzQWpMVXF4dzhDWm5XT0pRME9ITjFXYlRaOGljNkdMRVlZa0RJMVNXZERFejZRWjF1RUdLZWFiYUl4TkhLTTFxd3BMcEN0NmE4YkxHWU10U05oMWpaT0lJQXg0NFFiVnBVUjNzanNBTXZ6Ukk5bXYxd1NlS1NseUlPL0FFSUYxeGo2ZnUveDQ5NjM0bnRGZUFQZHlBMStXRFZ1clBIaVNQSDNFQVpRVWQrYTZtbGljUm1NVFpwaUFPbFdaUDNneU5MK2NOTjhZdXdjWnVNQVZ4cURRYm0xemI5UkFZdXdRYjR6WUZjV0RBS3MzR1Z2ZThUUjF1ZUFiV1ZyZFppRU9sV1Z1L3FTU05selZtS01IR1JwK0ZPREJtQkIwejFNbGk2MnE3R1FLVDVFUVhQQ2NpRGdRZCtyYmdZbmlIRzlUaFJsRkoxU0g0cFNwTlJCeUFSbG5TVXY5USt4d0V4dnN5NE82bzV5S09BQWZ2cDl4NG44bTdqc2c3TkY1MzJqVktvc0YweElHUUVyL0Fra0RFK1NuZUc4dzVzSWZWbTZjRUcwTTBIWEZndGtKZG1vMk5OOHcyTHh1TyttWEFYZGVhamppQWlFcXp1MjdSc2dFdmE2QUVPMXRPZEhHTUdZa2pESDYyK3RsaWNtMVlJVEN6QzgxTEhQQWVQREdzZktpeEhONm45QW9vM29ITXN5eGxaYkt3TzhpdjFXK09MUnhNQkpPb29yMy8rT1BFdFRvbEJHNGhFRkxzbVBadU5raDQzWFg3VzBLdVcrS0lFOGxUUnh3d0EyOHRqZmRadmR3UHZFTUk0VWJSRGIrTWVveU4yWW1EK2wxU2FoZmtaUTNNY0JGdXpNd2FjTHpaaVFNUThDNWc0YjMzcUNrUERsTTBYNkFlN0MzbFJSd3ZmOXBUV2RKYi9sSHBPQy9sd1ZYZ01KT0hHL0FLRWNmTFcyUG11bG9sYWhoVkxHOThhbXNSRWNkTFBCRjVLdWl3ZGF5RU5JVWJDWEJZVG9rNFhsdHF3Z1dPTEQ3cVIwOUVwcHFrQkhPSU9ONjRwVXF6YjdDb3RzVWJia3oreHRmS0kwUWNid0JSbHZRTkZuVzJlRmxESmRpVlI0ZzRMZ0JSNnVzQ0R1M2NJNEJKaWtxdzkyQzgvQy9paU5GUWFmWUNEZHNkNm5BRHJLSHNSdXdQSW80WURYMWI4QUlON1FRRWxEaS85Z1FSeHpVbVdzQ3lnY25KUTd6aEJtL0svS1RKMHBlTE9EYndvZjYyNE1aNGVoL2laUTBnaDVSNWIvdzg5ai9GcjlYbkE3OGt3UENjZWZqMGNmNkZmbHJpTHAzekIrNXJtQ0NFR3lHN3NmaEdUa2RGQ1JGR3lZbzR0dDFBcGRsdFhNcVA4b1liS3NFbXJDM2l1QW1PRnJEY2hHYU9FMW9GbTdDemlPTW1PQWdndFlEbEpqcDVKNmpERGEyQ1RSaFp4SkVBNTA1MXVCUTZRNTlUdkprMnI0Z2pqWTlLc3p2NEpFN3poaHRoV1VwUmdqT0J3NUNuUkJ3N1psVTFiZ2VnRVUvcnk0QzdWaFZ4N0VLa29HTWZvdXNXN09IRzlZaDBKRVpBeEJHanNiMnQwdXcyTHJlUDhySUcwdUhLaWQ0MjdKc3pJbzQzV0NTMmxDcExnRFBTS1JoYXFZMGNnNG80Y2xCNitXMUIzalVMalovL2pidkxzbDllSTRRYlJTOXg1a2tkczVXSUk5ZXV5cExtSWtYYlR1Rkd2dWxFSFBsWUtVdTZqeFZ2dUJGS3NQc2pWSXRYQ0lnNENoeEJXZEkwV0x5c29XVXBhY3RlbnhWeFhHT1NPcUlzYVFvZDJuTmFsbEpxdXFsL3JmNGFySnlNT3A1T1Q3NTZkbjJ0L3lPSUNPcXR1S2NPTjBJQ0s1MFp6ZkdOeFFmU29wWm1ZWU5Sc2lLT2xSRjNkdUVRQ2pwMk1HSTdMWU1lc0ppSW93eTA4SEJRYVhhRkdtKzRvWnpveXBTWnV5S09US0F1bXVuYmdoZHdNTytveW43TWVpS09JN2hod3FLZ1l3R09PdHhZUnFHTklnUkVIRVZ3dlc2TUNRdUNEbVJKajF6czRCckRXOTFRVkdOZ1lENkZHNGN4RjNFY2hFNVowb1BBdWJsTXY5cDN4aFFpam9Qb0llZ0FkMHdlZENqY09PZzkvSmVKT0U3WlVOOFdQQVZmdjR1MUxPVWs5aUtPa3dET3U0Q0ZOOXhRQ2ZhczArdEhwODhqcUFUYmVRd2JTOUNYQWM4RHJvampQSVl6QmgzVTRZYUJ5YWNYSWVJd2NBRUVIVk5sU1hsWkEyYlN5M3NHSHErcGlnbUlFS0wxRGxaSVZwV2pWYkJXOENyaXNFRnlubmRKZWNNTjVFU1YzYkJ4OTdzNy9WcjlCWks0L3kvMmt6dXIxZEJ3eW9mSjlqclpGd0VZYUdYZmxRWFQ2cTJ1VFRjZVhySWlqclFEbEowZGZnRUxkYmhSZE9lWEdYNisxaUlPTTV2REwvRk1HemhMeXNzYU1JcXE1bWFPL2txUWlNTU16L0FTdWxaQW1BRnFKMGhHc2NQeXRTUVJoeVdrNEk1Umd3NkZHNWFPd2k5THhHRnNRMHhZOUh3enh2U2NPRlhLeitHM2ZiV0lZeHVYdzBjUmRJejNQaGgxdUtHYzZHRm5UbHdvNGtpQWMvQVV1RU5QdVlQWVdWK201Y3ZXaUw2V0orS29BaXllY3NPVVpubkREVjRUVkhGS1U2RWlEbE00NzRXRkxPbjlIdkYvWHRaUUNiYXEyNGs0YXNFN1V0QlJDNk9hY2pWYnJJbnUzWU9xMG1jV0hyS2tuLzMzYzk2ZmZlTTFIOElONVVTcm1rOFJSMFY0bFNXdENHNVN0SEtpU1hnTVRvbzRERUJNaTFDS0xvMlArVmtCYmc3cHRVQVJ4elVteGtmd0xxbXhSSWxMSXFCbEtVbDRiRTdxMStvdmNNVGs0bUkvdVpNL2k4WXo4T0hUeDBsaE9tbURRQWczTXUyWWIwRW9seWt6REdONHlZbzRiUHcxTFlYNlhkTDAwRnlkUlU0VThWM1JIZTVLZnlKbFJCeU5qS1VGTEEyQVJnbTI2RkhmUUtWUnV4QnhOTEtzZ283YVFJY1NyTUtOMmpnSCtTS09OamkvbkNIcmxhU3FXQXZlcXZDdWhJczRWb0JVM0VVVXJVcGhKWHdCckNZcGxiRGRGQ3ZpMklTbHlrRUVIU3JOVmtIMjdrNGwyRXJBM2hJcjRyaUZUSlhqQ2pwcXdLbzRyZ2FxYVpraWpqUSt4bWNSZENoTGFvdXBWc0hhNHBrcFRjU1JDWlJaTTJWSnphQjhKVWc1VVZzOE02V0pPREtCc215R0NRdWVrNVlTWjVVVlNyQ3pqcjdudUVVY0hkQlgwR0VGdWxiQldpRlpLa2ZFVVlxWVRYdGxTYy9qcUp6b2VRd1BTeEJ4SElidTFJV2hOS3NKeTJFUWxSTTlESjNKaFNJT0V4aVBDRUhRb1FVc1I0QjdkWTF5b29laE03bFF2MVovQVNOdTVvdjk1QTZpaHVUNWk1T2JrbEdhNWYyMjRNWHcydTZFU0cwVC8wMmNiMm0zS2VGV1kwbU9rVkhFRWFQUllWdFB6Z09nQTdTaTIvaEFGN29rallDSUk0MVA5Yk80QVpUa0swSTVFVzRVeVZIak13aUlPTTZnWjNNdDllOVUyMEJRSWtYaFJnbGF0ZHFLT0dvaG15OFhRWWV5cEpsd2hWV3dSYm1KVE1scVZvU0FpS01JcmxxTnRZQWxCMWxNVXZSbHdCeWdHclFSY1RRQU9hc0xCUjI3TUFFaTVVUjNVV3JUUU1UUkJ1ZjlYaFIwcERFS2IzeHBrcEpHcWRsWkVVY3pxUGM3VW1rMmdSSEFFV3NrOEdsOFNzVFJHUEJVZHlyTjNrSUg0WVltS2JmQTZYSmN4TkVGOXB1ZFlzSnk4OXpFSnhTTGVUTytpTU9iUmU3MFB0aktKQ3JCcmdEeHNDdmk4R0NGQ3gyVUpZM2hVRTQwUnNQUHRvakRqeTNlYUtMUzdJS0ZjcUlMRks0MlJCeXV6UEZhR1FVZEFRamxSRDE2NXl1ZDN2cnl5eS96bFN2S2JCY1Z6eVE1dGdMUUFIb2ZQUGtrUGpqaDlxZnZmb1JSeXpkaTB6dEJReEZIYkJSSDIvQ1B5Yk9rSVNmcXlDUlNKVUpBeEJHQjRXeHo1Z2tMSmlsYWx1TE1IeS9VRVhGY3dPRnRaOW9zcVphbGVIUEZsVDRpamhVZ3ZuYm5ERG9VYnZqeXdpMXRSQnhicUhnNk51Rkxrd28zUERuZ3RpNGlqbTFjL0J4RmxoUlBZRC82MU5ZRWcwV2NWVlNTcTYyUzVGOGpJT0s0eHNUZGthbCtyMHh2ZkxuenZ5MkZSQnhicVBnN05rbHBWaVZZZjY2M3JaR0lZeHNYYjBjbnlaS3FCT3ZOOFc3cEkrSzRoWXk3NDhPWFpoVnV1UE81MndxSk9HNWo0K3pNMkVHSGNxTE8zRzFISFJISERrQ3VUZzljbWxWTzFKV243U29qNHRpRnlGR0RVUmV3SU53b1dydmx5Q1N6cWlMaUlMTThKaXhrR21lb3EzQWpBeVJmVGQ1NjhlSkZ2a1pGcitVVVBVTWtPYlpDR28xL1BmL2k0ZFBIY1h2cWJlUkUwMnlZUm1NMWRubGRERWc5TkJSeHhEZ1RiTU1WUnZxdDJaQVRKY0JkS2w0aUlPSzR4TVA5WG5qOERsT2FIVGpkNjk2VlRpa280amdGWDYrTHh5ak5LaWZheTMvTzl5dmlPSTloSHdrRFBLc0hHRUlmMnp2b1ZjVGh3QWpsS29RSkMvVUNGcjBuV201MlIxZUlPQndabzFRVlpFbExML0hUUGwxSjhhT25OTmxFUU1TeENRdkhRVlJZU0lNT1VyVTUzS0tKbGlLT0pqRFg2UVFURnNiU3JFcXdkZHlocVZRUlIxTzR6VHREMEVHWFloeW1sbXh1VFNLQklnNGlZMjJvaXFBRDNJRm4rTVk1bDRjVWJyZzBTN0ZTSW81aXlCeGVRUFJ0UWNSSG9TVGtFRWFwbEkrQWlDTWZLOWN0S2RLTktzRzY5cUVTNVVRY0pXZzVia3RSM2RTWEFSMTdVSmxxSW80eXZEeTNEai9SN0ZaRGhSdHVUWE5Bc1FkRkUwN2s0Zkw3a09RWXF6Wm9JUFg0NUt0bmNiOU90cGVjYUhDaE5tanNqbDMrSEVOVWhJWWlqaGc2N20wWTNtMXAxcTFpM0NidnA3MklveC8yMWoySHg3akQwcXdtS2RhbTdpOVB4TkhmQm9ZYStBdzZxTmZVR0ZwbkpGRWlqcEdzZVllZ0E5emhxalNyY0dNb0Q3c2ZqSWpqSG9sUi9vTTcvQ3hnV1hLaW82Q3JjYnhHUU1ReG9Dc2c2SEN5SHNTSkdnUGF1UGVRUkJ5OUxWQ2hmd1FkSHI0dHFIQ2pnbTI5aUJSeGVMR0VyUjdnanU0VjBPNEsyRUlxYVRFQ0lvNFlqYUcyTVdIcFdKcEYxMUJnS0VBMW1BZ0JFVWNFeGxpYmZZTU9vZ1c3WTVtOTBXaEVISTJBN3RKTnI5S3NxM3B3RitTSDcxVEVNYktKdTVSbWxSTWQyYVh1eHliaXVFZGkwUC90UzdQS2lRN3FTaGZERW5GY3dESGVUdVBTckhLaTQ3blE1b2owYS9VWHNCUVZBbkJQWGx5YzNPa3UrZjNISHljVnREbVorVTJRN21pRTBYSlowSlhPaWpoc2Joai9VaG9rTExVc3hiOGJXR2tvNHJCQzBydWNCdStTNnN1QTNwM0FUajhSaHgyVzdpVlZYVG1pY01POS9TMFZGSEZZb3VsY1ZyMmdBemxSaFJ2T3JXK3Jub2pERmsvdjBpb0ZIU2pCRnVVN3ZjTWsvZllRRUhIc0lUVFcrUnBCUnlqQkZsVW94Z0oxeHRHSU9LYXp1dmtMV3VZQ3B6TUo0WUJGSElSR082RXk0Z0xNS1F4THM4cUpuckFHOGFVaURtTGpIVk1kM0dIMTlXQXRTemxtZ2dHdUVuRU1ZTVRpSVZnRkhaVlNyY1hqMFFYTkVSQnhOSWZjUVljSU9zNW5TUlZ1T0xCa054VkVITjJnNzlzeHVPTmtVdlBrNVgySHI5NVBJaURpT0FrZzhlV1lzQ0JxT0RZQTVVU1A0VGJNVlNLT1lVeFpQSkF6UVFkbU9zWDk2WUtCRU5DdjFWOFlFL2ZTeFg1eXAraGRTYmVTRVRzOGZQbzRPZEQxeVZETlhZMW9ERFRXUTQzMlYrT056bXhzRG8rR0lvNE5xMDkxNkVDV1ZNdFNwdktRemNHS09EWmhtZXRnVVpvejgxTTljeUU0MzJoRkhQUFovR3JFK1ZuU3c4blVxejUxZ0JzQkVRZTMvYXkwend3NjBLeG85bTZsbnVSNFEwREU0YzBpZmZRQkhZU1VaNkw3VUlJdHloRW1wT2tVTlFJaURtcnpXU3FQbEdkNkpxS2NxQ1hjNUxKRUhPUUd0Rk1mUVVkaTdVa0lOK3g2a3lSdUJFUWMzUGF6MWY1V2FSYVJpTUlOVzZqWnBZazQyQzFvclA5bWxoU1JpSEtpeGtDVGl4TnhrQnZRV24wUXhDclRnVjFFSXNxSldpUE5MVS9Fd1cyL0d0ci85b2MvajhVaUJoRnJ4SUJvR3dpSU9PUUdHd2dzcFZubFJEZlEwU0VSaDN4Z0U0Rmw4YXR5b3B2NDZPQURRU0FFTmhFSVFRZFNIcHFuYk9JeitjSC9BK25wRVcvR0lmQ25BQUFBQUVsRlRrU3VRbUNDXCIiLCJleHBvcnQgZGVmYXVsdCBcIl9fVklURV9QVUJMSUNfQVNTRVRfX2JmOGNjYTJlX19cIiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gVXNlcm5hbWU8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jcmVkZW50aWFscy51c2VybmFtZVwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jcmVkZW50aWFscy51c2VybmFtZSddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gUGFzc3dvcmQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jcmVkZW50aWFscy5wYXNzd29yZFwiXG4gICAgICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jcmVkZW50aWFscy5wYXNzd29yZCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gUGFzc3dvcmQgMjwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmNyZWRlbnRpYWxzLnBhc3N3b3JkMlwiXG4gICAgICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jcmVkZW50aWFscy5wYXNzd29yZDInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+VHlwZWQgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRUeXBlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLm15UHJvcGVydHlcIlxuICAgICAgICA6dHlwZXM9XCJ0eXBlc1wiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5teVByb3BlcnR5J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlR5cGVkIElucHV0IDI8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRUeXBlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLm15UHJvcGVydHkyXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm15UHJvcGVydHkyJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPkNvbmZpZyBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZENvbmZpZ0lucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLnJlbW90ZVNlcnZlclwiXG4gICAgICAgIHR5cGU9XCJyZW1vdGUtc2VydmVyXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLnJlbW90ZVNlcnZlciddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5Db25maWcgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRDb25maWdJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5hbm90aGVyUmVtb3RlU2VydmVyXCJcbiAgICAgICAgdHlwZT1cInJlbW90ZS1zZXJ2ZXJcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuYW5vdGhlclJlbW90ZVNlcnZlciddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5TZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jb3VudHJ5XCJcbiAgICAgICAgOm9wdGlvbnM9XCJjb3VudHJpZXNcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY291bnRyeSddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5NdWx0aVNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmZydWl0XCJcbiAgICAgICAgOm9wdGlvbnM9XCJmcnVpdHNcIlxuICAgICAgICBtdWx0aXBsZVxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuZnJ1aXQnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+U2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUubnVtYmVyXCJcbiAgICAgICAgOm9wdGlvbnM9XCJudW1iZXJzXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm51bWJlciddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5TZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5vYmplY3RcIlxuICAgICAgICA6b3B0aW9ucz1cIm9iamVjdHNcIlxuICAgICAgICBtdWx0aXBsZVxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUub2JqZWN0J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmFycmF5XCJcbiAgICAgICAgOm9wdGlvbnM9XCJhcnJheXNcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuYXJyYXknXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+RWRpdG9yIHdpdGggZGVmYXVsdCBoZWlnaHQgMjAwcHggYW5kIEpTT048L2xhYmVsPlxuICAgICAgPE5vZGVSZWRFZGl0b3JJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5qc29udGVzdFwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5qc29udGVzdCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5FZGl0b3Igd2l0aCBjdXN0b20gaGVpZ2h0IGFuZCBDU1M8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRFZGl0b3JJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jc3N0ZXN0XCJcbiAgICAgICAgbGFuZ3VhZ2U9XCJjc3NcIlxuICAgICAgICBzdHlsZT1cImhlaWdodDogMTAwcHhcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3NzdGVzdCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIE5PVEU6IHRoaXMgaXMgbG9hZGVkIGZyb20gdGhlIHJlc291cmNlcy97cGtnLm5hbWV9IGZvbGRlciAtLT5cbiAgICA8aW1nIHNyYz1cIi92dWUucG5nXCIgLz5cblxuICAgIDwhLS0gTk9URTogdGhpcyBpcyBhZGRlZCB0byB0aGUgYnVuZGxlZCAuanMgLS0+XG4gICAgPGltZyA6c3JjPVwibG9nb1wiIGFsdD1cIkxvZ29cIiAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgbG9nbyBmcm9tIFwiLi4vLi4vLi4vYXNzZXRzL3Z1ZS5wbmdcIjtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJOb2RlUmVkTm9kZUZvcm1cIixcbiAgcHJvcHM6IHtcbiAgICBub2RlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGVycm9yczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgICB9LFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2dvLFxuICAgICAgdHlwZXM6IFtcInN0clwiLCBcIm1zZ1wiLCBcIm5vZGVcIl0sXG4gICAgICBjb3VudHJpZXM6IFtcbiAgICAgICAgeyB2YWx1ZTogXCJ1c2FcIiwgbGFiZWw6IFwidXNhXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJhcmdlbnRpbmFcIiwgbGFiZWw6IFwiYXJnZW50aW5hXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJicmFzaWxcIiwgbGFiZWw6IFwiYnJhc2lsXCIgfSxcbiAgICAgIF0sXG4gICAgICBmcnVpdHM6IFtcbiAgICAgICAgeyB2YWx1ZTogXCJhcHBsZVwiLCBsYWJlbDogXCJhcHBsZVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwibWVsb25cIiwgbGFiZWw6IFwibWVsb25cIiB9LFxuICAgICAgICB7IHZhbHVlOiBcInJhc3BiZXJyeVwiLCBsYWJlbDogXCJyYXNwYmVycnlcIiB9LFxuICAgICAgXSxcbiAgICAgIG51bWJlcnM6IFtcbiAgICAgICAgeyB2YWx1ZTogXCIxXCIsIGxhYmVsOiBcIjFcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcIjJcIiwgbGFiZWw6IFwiMlwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwiM1wiLCBsYWJlbDogXCIzXCIgfSxcbiAgICAgIF0sXG4gICAgICBvYmplY3RzOiBbXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KHsgdGVzdDogXCJhXCIgfSksIGxhYmVsOiBcImFcIiB9LFxuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeSh7IHRlc3Q6IFwiYlwiIH0pLCBsYWJlbDogXCJiXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoeyB0ZXN0OiBcImNcIiB9KSwgbGFiZWw6IFwiY1wiIH0sXG4gICAgICBdLFxuICAgICAgYXJyYXlzOiBbXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KFtcImFcIl0pLCBsYWJlbDogXCJhXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoW1wiYlwiXSksIGxhYmVsOiBcImJcIiB9LFxuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeShbXCJjXCJdKSwgbGFiZWw6IFwiY1wiIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJNT1VOVEVEXCIpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMubG9nbyk7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCIvLyBOT1RFOiB0aGlzIGZpbGUgaXMgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbi8vIE5PVEU7IHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgbnJnXG5pbXBvcnQgeyBkZWZpbmVOb2RlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvY2xpZW50XCI7XG5pbXBvcnQgY29tcG9uZW50IGZyb20gXCIuL0Zvcm0udnVlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZU5vZGUoe1xuICBjYXRlZ29yeTogXCJmdW5jdGlvblwiLFxuICBjb2xvcjogXCIjRkZGRkZGXCIsXG4gIGlucHV0czogMSxcbiAgb3V0cHV0czogMSxcbiAgaWNvbjogXCJ2dWUucG5nXCIsXG4gIGZvcm06IHtcbiAgICBjb21wb25lbnQsXG4gICAgZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yOiB0cnVlLFxuICB9LFxuICBvblBhbGV0dGVBZGQ6ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIk5PREUgVFlQRSBSRUdJU1RFUkVEIE9OIFRIRSBQQUxFVFRFXCIpO1xuICB9LFxufSk7XG4iLCIvLyBOT1RFOiB0aGlzIG1vZHVsZSBpcyBvcHRpb25hbCBhbmQgaXQgaXMgZ2VuZXJhdGVkIGJ5IG5yZyB3aGVuIGNsaWVudC5idWlsZC5lbnRyeVBvaW50IGlzbid0IHByb3ZpZGVkLiBVc2UgdGhpcyBpZiB5b3UgbmVlZCB0byBjb250cm9sIHRoZSBvcmRlciBub2RlcyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgZWRpdG9yLlxuaW1wb3J0IHJlbW90ZVNlcnZlciBmcm9tIFwiLi9ub2Rlcy9yZW1vdGUtc2VydmVyL2NsaWVudFwiO1xuaW1wb3J0IHlvdXJOb2RlIGZyb20gXCIuL25vZGVzL3lvdXItbm9kZS9jbGllbnRcIjtcbmltcG9ydCB7IHJlZ2lzdGVyVHlwZSB9IGZyb20gXCIuL2NvcmUvY2xpZW50XCI7XG5cbi8vIFRPRE86IGlzIHRoZXJlIGEgdXNlIGNhc2UgZm9yIGNvbnRyb2xsaW5nIHRoZSBvcmRlciBub2RlcyBpbiB0aGUgZWRpdG9yIGFyZSByZWdpc3RlcmVkP1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHJlZ2lzdGVyVHlwZShcInJlbW90ZS1zZXJ2ZXJcIiwgcmVtb3RlU2VydmVyKSxcbiAgICAgIHJlZ2lzdGVyVHlwZShcInlvdXItbm9kZVwiLCB5b3VyTm9kZSksXG4gICAgXSk7XG4gICAgY29uc29sZS5sb2coXCJBbGwgbm9kZSB0eXBlcyByZWdpc3RlcmVkIGluIHBhcmFsbGVsXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWdpc3RlcmluZyBub2RlIHR5cGVzOlwiLCBlcnJvcik7XG4gIH1cbn1cbiIsIi8vIE5PVEU6IHRoaXMgbW9kdWxlIGlzIGdlbmVyYXRlZCBieSBucmdcbmltcG9ydCBpbml0IGZyb20gXCIuL2luZGV4LmNsaWVudFwiO1xuXG4oYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiUnVubmluZyBwcm92aWRlZCBpbml0XCIpO1xuICAgIGF3YWl0IGluaXQoKTtcbiAgICBjb25zb2xlLmxvZyhcIkZpbmlzaGVkIHJ1bm5pbmcgcHJvdmlkZWQgaW5pdFwiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgcnVubmluZyBwcm92aWRlZCBpbml0OlwiLCBlcnJvcik7XG4gIH1cbn0pKCk7XG4iXSwibmFtZXMiOlsibWFwIiwiaGFzT3duUHJvcGVydHkiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWYiLCJ3YXJuIiwiY29tcHV0ZWQiLCJ0eXBlIiwic2VsZiIsInJlYWRvbmx5Iiwid2F0Y2giLCJlZmZlY3QiLCJzY29wZSIsInAiLCJpZCIsImNvbXBvbmVudCIsInZlcnNpb24iLCJyZWYiLCJyZXNvbHZlIiwiaCIsImNyZWF0ZUFwcCIsInJlcXVpcmVkIiwidHlwZXMiLCJyZW1vdmUyIiwicmVtb3ZlIiwiaXNNb2RlbExpc3RlbmVyIiwiZW1pdCIsIm5hbWVzIiwiaXNCb29sZWFuIiwiY2FtZWxpemUkMSIsInN0YWNrIiwiY29tcGlsZSIsImpzb25wb2ludGVyIiwiZXJyb3JzIiwiX29wZW5CbG9jayIsIl9jcmVhdGVFbGVtZW50QmxvY2siLCJfaG9pc3RlZF8xIiwiX2NyZWF0ZVZOb2RlIiwiX3NmY19tYWluIiwiX2hvaXN0ZWRfMiIsIl9jcmVhdGVFbGVtZW50Vk5vZGUiLCJfaG9pc3RlZF8zIiwiX3RvRGlzcGxheVN0cmluZyIsIl9jcmVhdGVDb21tZW50Vk5vZGUiLCJpc09iamVjdCIsIl93aXRoRGlyZWN0aXZlcyIsImNvZGUiLCJyZXF1aXJlJCQwIiwiVXNlZFZhbHVlU3RhdGUiLCJwcmVmaXhlcyIsImRlZiIsInJlcXVpcmUkJDEiLCJub3QiLCJpdGVtcyIsInJ1bGVzIiwia2V5d29yZCIsIlR5cGUiLCJuYW1lc18xIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwiRGF0YVR5cGUiLCJkYXRhVHlwZSIsInByb3BlcnRpZXMiLCJwYXR0ZXJuIiwidmFsaWRhdGUiLCJfYSIsInN1YnNjaGVtYSIsImVxdWFsIiwidHJhdmVyc2UiLCJqc29uU2NoZW1hVHJhdmVyc2VNb2R1bGUiLCJsaW1pdCIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkMTAiLCJidWZmZXIiLCJ1cmkiLCJmYXN0VXJpIiwiZmFzdFVyaU1vZHVsZSIsInVyaV8xIiwiQWp2IiwiJHNjaGVtYSIsImRlZmluaXRpb25zIiwiZm9ybWF0IiwiY29yZV8xIiwiY29yZSIsInVjczJsZW5ndGhfMSIsInVjczJsZW5ndGgiLCJlcXVhbF8xIiwidmFsaWRhdGlvbl8xIiwidmFsaWRhdGlvbiIsInByZWZpeEl0ZW1zIiwicmVxdWlyZSQkMTEiLCJyZXF1aXJlJCQxMiIsInJlcXVpcmUkJDEzIiwicmVxdWlyZSQkMTQiLCJyZXF1aXJlJCQxNSIsImFwcGxpY2F0b3IiLCJmb3JtYXRfMiIsIkRpc2NyRXJyb3IiLCJvbmVPZiIsImFqdiIsImFkZEZvcm1hdHMiLCJmb3JtYXRzIiwiaW5pdCIsIiQiLCJkZWZhdWx0cyIsIl9jcmVhdGVUZXh0Vk5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0E7QUFBQTtBQUVBLFdBQVMsUUFBUSxLQUFLO0FBQ2QsVUFBQUEsT0FBNkIsdUJBQUEsT0FBTyxJQUFJO0FBQzlDLGVBQVcsT0FBTyxJQUFJLE1BQU0sR0FBRyxFQUFHLENBQUFBLEtBQUksR0FBRyxJQUFJO0FBQ3RDLFdBQUEsQ0FBQyxRQUFRLE9BQU9BO0FBQUEsRUFDekI7QUFFQSxRQUFNLFlBQXdELE9BQU8sT0FBTyxDQUFBLENBQUU7QUFDOUUsUUFBTSxZQUF3RCxPQUFPLE9BQU8sQ0FBQSxDQUFFO0FBQzlFLFFBQU0sT0FBTyxNQUFNO0FBQUEsRUFDbkI7QUFDQSxRQUFNLEtBQUssTUFBTTtBQUNqQixRQUFNLE9BQU8sQ0FBQyxRQUFRLElBQUksV0FBVyxDQUFDLE1BQU0sT0FBTyxJQUFJLFdBQVcsQ0FBQyxNQUFNO0FBQUEsR0FDeEUsSUFBSSxXQUFXLENBQUMsSUFBSSxPQUFPLElBQUksV0FBVyxDQUFDLElBQUk7QUFDaEQsUUFBTSxrQkFBa0IsQ0FBQyxRQUFRLElBQUksV0FBVyxXQUFXO0FBQzNELFFBQU0sU0FBUyxPQUFPO0FBQ3RCLFFBQU0sU0FBUyxDQUFDLEtBQUssT0FBTztBQUNwQixVQUFBLElBQUksSUFBSSxRQUFRLEVBQUU7QUFDeEIsUUFBSSxJQUFJLElBQUk7QUFDTixV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QUFBO0FBQzNCLFFBQUE7QUFDRixZQUFNLFFBQVEsSUFBSTtBQUFBLFFBQ2hCLGFBQWEsaUJBQWlCLFlBQVk7QUFBQSxRQUMxQyxhQUFhLGFBQWEsUUFBUTtBQUFBLE1BQUEsQ0FDbkM7QUFDRCxjQUFRLElBQUksdUNBQXVDO0FBQUEsYUFDNUMsT0FBTztBQUNOLGNBQUEsTUFBTSxpQ0FBaUMsS0FBSztBQUFBLElBQUE7QUFBQSxFQUV4RDtBQ2ZpQixHQUVoQixpQkFBa0I7QUFDYixRQUFBO0FBQ0YsY0FBUSxJQUFJLHVCQUF1QjtBQUNuQyxZQUFNLEtBQUs7QUFDWCxjQUFRLElBQUksZ0NBQWdDO0FBQUEsYUFDckMsT0FBTztBQUNOLGNBQUEsTUFBTSxzQ0FBc0MsS0FBSztBQUFBLElBQUE7QUFBQSxFQUU3RCxHQUFHOzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOSwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5N119

//# sourceURL=src/client.js
