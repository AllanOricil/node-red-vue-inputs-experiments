var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function($$1) {
  "use strict";
  /**
  * @vue/shared v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map2[key] = 1;
    return (val) => val in map2;
  }
  const EMPTY_OBJ = Object.freeze({});
  const EMPTY_ARR = Object.freeze([]);
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
  const isArray = Array.isArray;
  const isMap = (val) => toTypeString(val) === "[object Map]";
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const isRef$1 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray(val) && !isPlainObject$1(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i = "") => {
    var _a;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
    );
  };
  /**
  * @vue/reactivity v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function warn$2(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else {
        warn$2(`cannot run an inactive effect scope.`);
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        this.effects.length = 0;
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        if (activeSub !== this) {
          warn$2(
            "Active effect was not restored correctly - this is likely a Vue internal bug."
          );
        }
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed = false) {
    sub.flags |= 8;
    if (isComputed) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    const dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
      computed2.flags &= -3;
      return;
    }
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subsHead === link) {
      dep.subsHead = nextSub;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      {
        this.subsHead = void 0;
      }
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      if (activeSub.onTrack) {
        activeSub.onTrack(
          extend(
            {
              effect: activeSub
            },
            debugInfo
          )
        );
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (true) {
          for (let head = this.subsHead; head; head = head.nextSub) {
            if (head.sub.onTrigger && !(head.sub.flags & 8)) {
              head.sub.onTrigger(
                extend(
                  {
                    effect: head.sub
                  },
                  debugInfo
                )
              );
            }
          }
        }
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l = computed2.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      if (link.dep.subsHead === void 0) {
        link.dep.subsHead = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    "Object iterate"
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    "Map keys iterate"
  );
  const ARRAY_ITERATE_KEY = Symbol(
    "Array iterate"
  );
  function track(target, type2, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      {
        dep.track({
          target,
          type: type2,
          key
        });
      }
    }
  }
  function trigger(target, type2, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger({
            target,
            type: type2,
            key,
            newValue,
            oldValue,
            oldTarget
          });
        }
      }
    };
    startBatch();
    if (type2 === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type2) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn, thisArg) {
      return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  function hasOwnProperty(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      if (key === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty;
        }
      }
      const res = Reflect.get(
        target,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver
      );
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(
        target,
        key,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      {
        warn$2(
          `Set operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key) {
      {
        warn$2(
          `Delete operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type2) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        warn$2(
          `${capitalize(type2)} operation ${key}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
          return this;
        },
        delete(key) {
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get ? get.call(target, key) : void 0;
          const result = target.delete(key);
          if (hadKey) {
            trigger(target, "delete", key, void 0, oldValue);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const oldTarget = isMap(target) ? new Map(target) : new Set(target);
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0,
              oldTarget
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
      const type2 = toRawType(target);
      warn$2(
        `Reactive ${type2} contains both the raw and reactive versions of the same object${type2 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      {
        warn$2(
          `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
            target
          )}`
        );
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject(value) ? readonly(value) : value;
  function isRef(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
      activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      } else {
        warn$2("Write operation failed: computed value is readonly");
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    } else if (!failSilently) {
      warn$2(
        `onWatcherCleanup() was called when there was no active watcher to associate with.`
      );
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const warnInvalidSource = (s) => {
      (options.onWarn || warn$2)(
        `Invalid watch source: `,
        s,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction(s)) {
          return call ? call(s, 2) : s();
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope2 = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope2 && scope2.active) {
        remove(scope2.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    {
      effect2.onTrack = options.onTrack;
      effect2.onTrigger = options.onTrigger;
    }
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$1(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a) => {
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
  };
  function callWithErrorHandling(fn, instance, type2, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type2);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type2, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type2, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type2);
        });
      }
      return res;
    }
    if (isArray(fn)) {
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
      }
      return values;
    } else {
      warn$1(
        `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
      );
    }
  }
  function handleError(err, instance, type2, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = ErrorTypeStrings$1[type2];
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
    {
      const info = ErrorTypeStrings$1[type2];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  const RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id2) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    const check = (job) => checkRecursiveUpdates(seen, job);
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (check(job)) {
            continue;
          }
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs(seen);
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    const count = seen.get(fn) || 0;
    if (count > RECURSION_LIMIT) {
      const instance = fn.i;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    }
    seen.set(fn, count + 1);
    return false;
  }
  let isHmrUpdating = false;
  const hmrDirtyComponents = /* @__PURE__ */ new Map();
  {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  const map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id2 = instance.type.__hmrId;
    let record = map.get(id2);
    if (!record) {
      createRecord(id2, instance.type);
      record = map.get(id2);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id2, initialDef) {
    if (map.has(id2)) {
      return false;
    }
    map.set(id2, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component2) {
    return isClassComponent(component2) ? component2.__vccOpts : component2;
  }
  function rerender(id2, newRender) {
    const record = map.get(id2);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id2, newComp) {
    const record = map.get(id2);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (let i = 0; i < instances.length; i++) {
      const instance = instances[i];
      const oldComp = normalizeClassComponent(instance.type);
      let dirtyInstances = hmrDirtyComponents.get(oldComp);
      if (!dirtyInstances) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
      }
      dirtyInstances.add(instance);
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        dirtyInstances.add(instance);
        instance.ceReload(newComp.styles);
        dirtyInstances.delete(instance);
      } else if (instance.parent) {
        queueJob(() => {
          isHmrUpdating = true;
          instance.parent.update();
          isHmrUpdating = false;
          dirtyInstances.delete(instance);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
      if (instance.root.ce && instance !== instance.root) {
        instance.root.ce._removeChildStyle(oldComp);
      }
    }
    queuePostFlushCb(() => {
      hmrDirtyComponents.clear();
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return (id2, arg) => {
      try {
        return fn(id2, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  let devtools$1;
  let buffer = [];
  let devtoolsNotInstalled = false;
  function emit$1(event, ...args) {
    if (devtools$1) {
      devtools$1.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version2) {
    emit$1("app:init", app, version2, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:added"
    /* COMPONENT_ADDED */
  );
  const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:updated"
    /* COMPONENT_UPDATED */
  );
  const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
    /* COMPONENT_REMOVED */
  );
  const devtoolsComponentRemoved = (component2) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools$1.cleanupBuffer(component2)) {
      _devtoolsComponentRemoved(component2);
    }
  };
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function createDevtoolsComponentHook(hook) {
    return (component2) => {
      emit$1(
        hook,
        component2.appContext.app,
        component2.uid,
        component2.parent ? component2.parent.uid : void 0,
        component2
      );
    };
  }
  const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:start"
    /* PERFORMANCE_START */
  );
  const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:end"
    /* PERFORMANCE_END */
  );
  function createDevtoolsPerformanceHook(hook) {
    return (component2, type2, time) => {
      emit$1(hook, component2.appContext.app, component2.uid, component2, type2, time);
    };
  }
  function devtoolsComponentEmit(component2, event, params) {
    emit$1(
      "component:emit",
      component2.appContext.app,
      component2,
      event,
      params
    );
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type2) => type2.__isTeleport;
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
      {
        if (hasOwn(rawSetupState, key) && !isRef(rawSetupState[key])) {
          warn$1(
            `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
          );
        }
        if (knownTemplateRefs.has(rawSetupState[key])) {
          return false;
        }
      }
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray(existing) && remove(existing, refValue);
            } else {
              if (!isArray(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else {
            warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else {
        warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
      }
    }
  }
  getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type2, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type2, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type2, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
    const injected = injectHook(
      type2,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type2], injected);
    }, target);
  }
  function injectHook(type2, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type2] || (target[type2] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type2, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type2].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve$1(instance[type2] || Component[type2], name) || // global registration
        resolve$1(instance.appContext[type2], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (warnMissing && !res) {
        const extra = `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.`;
        warn$1(`Failed to resolve ${type2.slice(0, -1)}: ${name}${extra}`);
      }
      return res;
    } else {
      warn$1(
        `resolve${capitalize(type2.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve$1(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => shallowReadonly(i.props),
      $attrs: (i) => shallowReadonly(i.attrs),
      $slots: (i) => shallowReadonly(i.slots),
      $refs: (i) => shallowReadonly(i.refs),
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $host: (i) => i.ce,
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => {
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    })
  );
  const isReservedPrefix = (key) => key === "_" || key === "$";
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
          markAttrsAccessed();
        } else if (key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
      // to infinite warning loop
      key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
              key
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type2, key) => {
      if (cache[key]) {
        warn$1(`${type2} property "${key}" is already defined in ${cache[key]}.`);
      } else {
        cache[key] = type2;
      }
    };
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          {
            Object.defineProperty(ctx, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          }
          {
            checkDuplicateProperties("Methods", key);
          }
        } else {
          warn$1(
            `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (!isReservedPrefix(key[0])) {
              Object.defineProperty(ctx, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get === NOOP) {
          warn$1(`Computed property "${key}" has no getter.`);
        }
        const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
          warn$1(
            `Write operation failed: computed property "${key}" is readonly.`
          );
        };
        const c = computed({
          get,
          set
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
      {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type2) {
    callWithAsyncErrorHandling(
      isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type2
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction(handler)) {
        {
          watch(getter, handler);
        }
      } else {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        } else {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else {
      warn$1(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction(to) ? to.call(this, this) : to,
        isFunction(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray(to) && isArray(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          }
          return app;
        },
        component(name, component2) {
          {
            validateComponentName(name, context.config);
          }
          if (!component2) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn$1(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component2;
          return app;
        },
        directive(name, directive) {
          {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn$1(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              context.reload = () => {
                render(
                  cloneVNode(vnode),
                  rootContainer,
                  namespace
                );
              };
            }
            {
              render(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getComponentPublicInstance(vnode.component);
          } else {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        onUnmount(cleanupFn) {
          if (typeof cleanupFn !== "function") {
            warn$1(
              `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
            );
          }
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render(null, app._container);
            {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            warn$1(
              `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
            );
          }
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) {
      {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else {
        warn$1(`injection "${String(key)}" not found.`);
      }
    } else {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId) return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys) needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn$1(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type2 = propType[index];
              const typeName = isFunction(type2) && type2.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    } else {
      warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
    for (const key in options) {
      let opt = options[key];
      if (opt == null) continue;
      validateProp(
        key,
        resolvedValues[key],
        opt,
        shallowReadonly(resolvedValues),
        !camelizePropsKey.includes(key)
      );
    }
  }
  function validateProp(name, value, prop, props, isAbsent) {
    const { type: type2, required: required2, validator, skipCheck } = prop;
    if (required2 && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required2) {
      return;
    }
    if (type2 != null && type2 !== true && !skipCheck) {
      let isValid = false;
      const types2 = isArray(type2) ? type2 : [type2];
      const expectedTypes = [];
      for (let i = 0; i < types2.length && !isValid; i++) {
        const { valid, expectedType } = assertType(value, types2[i]);
        expectedTypes.push(expectedType || "");
        isValid = valid;
      }
      if (!isValid) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  const isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type2) {
    let valid;
    const expectedType = getType(type2);
    if (expectedType === "null") {
      valid = value === null;
    } else if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type2;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else {
      valid = value instanceof type2;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type2) {
    if (type2 === "String") {
      return `"${value}"`;
    } else if (type2 === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type2) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type2.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1(
          `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        {
          warn$1(
            `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type2, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        if (isHmrUpdating) {
          assignSlots(slots, children, optimized);
          trigger(instance, "set", "$slots");
        } else if (optimized && type2 === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  let supported;
  let perf;
  function startMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type2}-${instance.uid}`);
    }
    {
      devtoolsPerfStart(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type2}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(
        `<${formatComponentName(instance, instance.type)}> ${type2}`,
        startTag,
        endTag
      );
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    {
      devtoolsPerfEnd(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type2, ref: ref3, shapeFlag } = n2;
      switch (type2) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else {
            warn$1("Invalid VNode type:", type2, `(${typeof type2})`);
          }
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      {
        def(el, "__vnode", vnode, true);
        def(el, "__vueParentComponent", parentComponent, true);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      {
        el.__vnode = n2;
      }
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (
        // #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048
      ) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        {
          startMeasure(instance, `init`);
        }
        setupComponent(instance, false, optimized);
        {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        if (isHmrUpdating) initialVNode.el = null;
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent, root, type: type2 } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root.ce) {
              root.ce._injectChildStyle(type2);
            }
            {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
          {
            devtoolsComponentUpdated(instance);
          }
          {
            popWarningContext();
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type2, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type2.move(vnode, container, anchor, internals);
        return;
      }
      if (type2 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type2 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type: type2,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type: type2, el, anchor, transition } = vnode;
      if (type2 === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type2 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope: scope2, job, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope2.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    return {
      render,
      hydrate,
      createApp: createAppAPI(render)
    };
  }
  function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
    return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watch(source, cb, options) {
    if (!isFunction(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const baseWatchOptions = extend({}, options);
    baseWatchOptions.onWarn = warn$1;
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance, type2, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
            warn$1(
              `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event))}" prop.`
            );
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction(validator)) {
            const isValid = validator(...rawArgs);
            if (!isValid) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    {
      devtoolsComponentEmit(instance, event, args);
    }
    {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event
          )}" instead of "${event}".`
        );
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  let accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render.call(
            thisProxy,
            proxyToUse,
            renderCache,
            true ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render2.length > 1 ? render2(
            true ? shallowReadonly(props) : props,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render2(
            true ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      setTransitionHooks(root, vnode.transition);
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  const isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component: component2 } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component2.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type2) => type2.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type2, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && n1.component) {
      const dirtyInstances = hmrDirtyComponents.get(n2.type);
      if (dirtyInstances && dirtyInstances.has(n1.component)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
      }
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...args
    );
  };
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type2,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type2.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = createVNodeWithArgsTransform;
  function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
      if (!type2) {
        warn$1(`Invalid vnode type when creating vnode: ${type2}.`);
      }
      type2 = Comment;
    }
    if (isVNode(type2)) {
      const cloned = cloneVNode(
        type2,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type2)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type2)) {
      type2 = type2.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction(type2) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type2)) {
      type2 = toRaw(type2);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type2
      );
    }
    return createBaseVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type2 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type2 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type2 = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type2 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type2 = 16;
        children = [createTextVNode(children)];
      } else {
        type2 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type2;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type2 = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type: type2,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type2, appContext),
      emitsOptions: normalizeEmitsOptions(type2, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type2.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = createDevRenderContext(instance);
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key])) setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set) => set(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names2 = Object.keys(Component.components);
        for (let i = 0; i < names2.length; i++) {
          validateComponentName(names2[i], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names2 = Object.keys(Component.directives);
        for (let i = 0; i < names2.length; i++) {
          validateDirectiveName(names2[i]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          shallowReadonly(instance.props),
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name = (_a = Component.name) != null ? _a : "Anonymous";
            warn$1(
              `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  const isRuntimeOnly = () => true;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!Component.render && instance.render === NOOP && !isSSR) {
      if (Component.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function: `, Component);
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      markAttrsAccessed();
      track(target, "get", "");
      return target[key];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  };
  function getSlotsProxy(instance) {
    return new Proxy(instance.slots, {
      get(target, key) {
        track(instance, "get", "$slots");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray(exposed)) {
              exposedType = "array";
            } else if (isRef(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    {
      let attrsProxy;
      let slotsProxy;
      return Object.freeze({
        get attrs() {
          return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
        },
        get slots() {
          return slotsProxy || (slotsProxy = getSlotsProxy(instance));
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    {
      const i = getCurrentInstance();
      if (i && i.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      __vue_custom_formatter: true,
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            // avoid debugger accessing value affecting behavior
            formatValue("_value" in obj ? obj._value : obj),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed2 = extractKeys(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type2, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type2
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type2) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type2)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type2) {
      const opts = Comp[type2];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type2)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type2))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  const version = "3.5.13";
  const warn = warn$1;
  /**
  * @vue/runtime-dom v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
      warn(`Error creating trusted types policy: ${e}`);
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id2) {
      el.setAttribute(id2, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const vtcKey = Symbol("_vtc");
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const semicolonRE = /[^\\];\s*$/;
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null) val = "";
      {
        if (semicolonRE.test(val)) {
          warn(
            `Unexpected semicolon at the end of '${name}' style value: '${val}'`
          );
        }
      }
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type2 = typeof el[key];
      if (type2 === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type2 === "string") {
        value = "";
        needRemove = true;
      } else if (type2 === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (!needRemove) {
        warn(
          `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e
        );
      }
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = sanitizeEventValue(nextValue, rawName);
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          sanitizeEventValue(nextValue, rawName),
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function sanitizeEventValue(value, propName) {
    if (isFunction(value) || isArray(value)) {
      return value;
    }
    warn(
      `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
    );
    return NOOP;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
    ) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component2 = app._component;
      if (!isFunction(component2) && !component2.render && !component2.template) {
        component2.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn(msg);
          return compilerOptions;
        },
        set() {
          warn(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }
  /**
  * vue v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  {
    initDev();
  }
  function noop() {
  }
  function isPrimitive(value) {
    return value == null || typeof value !== "object" && typeof value !== "function";
  }
  function isTypedArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }
  function getSymbols(object) {
    return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
  }
  function getTag(value) {
    if (value == null) {
      return value === void 0 ? "[object Undefined]" : "[object Null]";
    }
    return Object.prototype.toString.call(value);
  }
  const regexpTag = "[object RegExp]";
  const stringTag = "[object String]";
  const numberTag = "[object Number]";
  const booleanTag = "[object Boolean]";
  const argumentsTag = "[object Arguments]";
  const symbolTag = "[object Symbol]";
  const dateTag = "[object Date]";
  const mapTag = "[object Map]";
  const setTag = "[object Set]";
  const arrayTag = "[object Array]";
  const functionTag = "[object Function]";
  const arrayBufferTag = "[object ArrayBuffer]";
  const objectTag = "[object Object]";
  const errorTag = "[object Error]";
  const dataViewTag = "[object DataView]";
  const uint8ArrayTag = "[object Uint8Array]";
  const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
  const uint16ArrayTag = "[object Uint16Array]";
  const uint32ArrayTag = "[object Uint32Array]";
  const bigUint64ArrayTag = "[object BigUint64Array]";
  const int8ArrayTag = "[object Int8Array]";
  const int16ArrayTag = "[object Int16Array]";
  const int32ArrayTag = "[object Int32Array]";
  const bigInt64ArrayTag = "[object BigInt64Array]";
  const float32ArrayTag = "[object Float32Array]";
  const float64ArrayTag = "[object Float64Array]";
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack2 = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack2);
    if (cloned != null) {
      return cloned;
    }
    if (isPrimitive(valueToClone)) {
      return valueToClone;
    }
    if (stack2.has(valueToClone)) {
      return stack2.get(valueToClone);
    }
    if (Array.isArray(valueToClone)) {
      const result = new Array(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
      }
      if (Object.hasOwn(valueToClone, "index")) {
        result.index = valueToClone.index;
      }
      if (Object.hasOwn(valueToClone, "input")) {
        result.input = valueToClone.input;
      }
      return result;
    }
    if (valueToClone instanceof Date) {
      return new Date(valueToClone.getTime());
    }
    if (valueToClone instanceof RegExp) {
      const result = new RegExp(valueToClone.source, valueToClone.flags);
      result.lastIndex = valueToClone.lastIndex;
      return result;
    }
    if (valueToClone instanceof Map) {
      const result = /* @__PURE__ */ new Map();
      stack2.set(valueToClone, result);
      for (const [key, value] of valueToClone) {
        result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (valueToClone instanceof Set) {
      const result = /* @__PURE__ */ new Set();
      stack2.set(valueToClone, result);
      for (const value of valueToClone) {
        result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
      return valueToClone.subarray();
    }
    if (isTypedArray(valueToClone)) {
      const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
      }
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
      return valueToClone.slice(0);
    }
    if (valueToClone instanceof DataView) {
      const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof File !== "undefined" && valueToClone instanceof File) {
      const result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Blob) {
      const result = new Blob([valueToClone], { type: valueToClone.type });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Error) {
      const result = new valueToClone.constructor();
      stack2.set(valueToClone, result);
      result.message = valueToClone.message;
      result.name = valueToClone.name;
      result.stack = valueToClone.stack;
      result.cause = valueToClone.cause;
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
      const result = Object.create(Object.getPrototypeOf(valueToClone));
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack2, cloneValue) {
    const keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor == null || descriptor.writable) {
        target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack2, cloneValue);
      }
    }
  }
  function isCloneableObject(object) {
    switch (getTag(object)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  function isPlainObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
    if (!hasObjectPrototype) {
      return false;
    }
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function merge(target, source) {
    const sourceKeys = Object.keys(source);
    for (let i = 0; i < sourceKeys.length; i++) {
      const key = sourceKeys[i];
      const sourceValue = source[key];
      const targetValue = target[key];
      if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge([], sourceValue);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge({}, sourceValue);
        }
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function isEqualWith(a, b, areValuesEqual) {
    return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  function isEqualWithImpl(a, b, property, aParent, bParent, stack2, areValuesEqual) {
    const result = areValuesEqual(a, b, property, aParent, bParent, stack2);
    if (result !== void 0) {
      return result;
    }
    if (typeof a === typeof b) {
      switch (typeof a) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined": {
          return a === b;
        }
        case "number": {
          return a === b || Object.is(a, b);
        }
        case "function": {
          return a === b;
        }
        case "object": {
          return areObjectsEqual(a, b, stack2, areValuesEqual);
        }
      }
    }
    return areObjectsEqual(a, b, stack2, areValuesEqual);
  }
  function areObjectsEqual(a, b, stack2, areValuesEqual) {
    if (Object.is(a, b)) {
      return true;
    }
    let aTag = getTag(a);
    let bTag = getTag(b);
    if (aTag === argumentsTag) {
      aTag = objectTag;
    }
    if (bTag === argumentsTag) {
      bTag = objectTag;
    }
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case stringTag:
        return a.toString() === b.toString();
      case numberTag: {
        const x = a.valueOf();
        const y = b.valueOf();
        return eq(x, y);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a.valueOf(), b.valueOf());
      case regexpTag: {
        return a.source === b.source && a.flags === b.flags;
      }
      case functionTag: {
        return a === b;
      }
    }
    stack2 = stack2 ?? /* @__PURE__ */ new Map();
    const aStack = stack2.get(a);
    const bStack = stack2.get(b);
    if (aStack != null && bStack != null) {
      return aStack === b;
    }
    stack2.set(a, b);
    stack2.set(b, a);
    try {
      switch (aTag) {
        case mapTag: {
          if (a.size !== b.size) {
            return false;
          }
          for (const [key, value] of a.entries()) {
            if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case setTag: {
          if (a.size !== b.size) {
            return false;
          }
          const aValues = Array.from(a.values());
          const bValues = Array.from(b.values());
          for (let i = 0; i < aValues.length; i++) {
            const aValue = aValues[i];
            const index = bValues.findIndex((bValue) => {
              return isEqualWithImpl(aValue, bValue, void 0, a, b, stack2, areValuesEqual);
            });
            if (index === -1) {
              return false;
            }
            bValues.splice(index, 1);
          }
          return true;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer !== "undefined" && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0; i < a.length; i++) {
            if (!isEqualWithImpl(a[i], b[i], i, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case arrayBufferTag: {
          if (a.byteLength !== b.byteLength) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
        }
        case dataViewTag: {
          if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
        }
        case errorTag: {
          return a.name === b.name && a.message === b.message;
        }
        case objectTag: {
          const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack2, areValuesEqual) || isPlainObject(a) && isPlainObject(b);
          if (!areEqualInstances) {
            return false;
          }
          const aKeys = [...Object.keys(a), ...getSymbols(a)];
          const bKeys = [...Object.keys(b), ...getSymbols(b)];
          if (aKeys.length !== bKeys.length) {
            return false;
          }
          for (let i = 0; i < aKeys.length; i++) {
            const propKey = aKeys[i];
            const aProp = a[propKey];
            if (!Object.hasOwn(b, propKey)) {
              return false;
            }
            const bProp = b[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        default: {
          return false;
        }
      }
    } finally {
      stack2.delete(a);
      stack2.delete(b);
    }
  }
  function isEqual(a, b) {
    return isEqualWith(a, b, noop);
  }
  function getDefaultsFromSchema(schema) {
    const result = {};
    console.log("getDefaultsFromSchema");
    for (const [key, value] of Object.entries(schema.properties)) {
      if (["x", "y", "z", "g", "wires", "type", "id"].includes(key)) continue;
      const property = value;
      console.log(key);
      console.log(property);
      result[key] = {
        required: false,
        value: property.default ?? void 0,
        // NOTE: I'm using a custom json schema keyword to determine the node type
        type: property.nodeType
      };
    }
    return result;
  }
  function getCredentialsFromSchema(schema) {
    const result = {};
    for (const [key, value] of Object.entries(schema.properties)) {
      const property = value;
      console.log(property);
      const isPassword = property.format === "password";
      result[key] = {
        required: false,
        type: isPassword ? "password" : "text",
        value: property.default ?? void 0
      };
    }
    return result;
  }
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var jsonpointer$1 = {};
  var hasRequiredJsonpointer;
  function requireJsonpointer() {
    if (hasRequiredJsonpointer) return jsonpointer$1;
    hasRequiredJsonpointer = 1;
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p2 = 1, len = pointer.length; p2 < len; ) {
        if (pointer[p2] === "constructor" || pointer[p2] === "prototype" || pointer[p2] === "__proto__") return obj;
        part = untilde(pointer[p2++]);
        hasNextPart = len > p2;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p2] !== "" && pointer[p2] < Infinity || pointer[p2] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p2 = 1; p2 < len; ) {
        obj = obj[untilde(pointer[p2++])];
        if (len === p2) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile2(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    jsonpointer$1.get = get;
    jsonpointer$1.set = set;
    jsonpointer$1.compile = compile2;
    return jsonpointer$1;
  }
  var jsonpointerExports = requireJsonpointer();
  const jsonpointer = /* @__PURE__ */ getDefaultExportFromCjs(jsonpointerExports);
  const _sfc_main$7 = {
    name: "NodeRedVueApp",
    props: {
      node: {
        type: Object,
        required: true
      },
      validator: {
        type: Function,
        required: true
      },
      disableSaveButtonOnError: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    data() {
      return {
        localNode: this.node,
        errors: {}
      };
    },
    beforeMount() {
      this.validator(this.localNode);
      Object.keys(this.localNode._def.defaults).forEach((prop) => {
        this.$watch(
          () => this.localNode[prop],
          (newVal) => {
            this.validate();
          },
          { deep: true }
        );
      });
      Object.keys(this.localNode._def.credentials).forEach((prop) => {
        if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`]) {
          this.localNode.credentials[prop] = "__PWD__";
        }
        this.$watch(
          () => this.localNode.credentials[prop],
          (newVal, oldVal) => {
            this.validate();
            if (this.localNode._def.credentials[prop].type === "password" && newVal !== oldVal) {
              this.localNode.credentials[`has_${prop}`] = !!newVal;
            }
          },
          { deep: true }
        );
      });
    },
    beforeUnmount() {
      var _a, _b;
      if (this.disableSaveButtonOnError) {
        (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", false).removeClass("disabled");
        (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", false).removeClass("disabled");
        $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
      }
      Object.keys(this.localNode._def.credentials).forEach((prop) => {
        if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`] && this.localNode.credentials[prop] === "__PWD__") {
          this.localNode.credentials[prop] = void 0;
        }
      });
    },
    methods: {
      validate() {
        var _a, _b;
        const valid = this.validator(this.localNode);
        if (!valid) {
          const errors2 = this.validator.errors;
          this.errors = errors2.reduce((acc, error) => {
            const errorValue = jsonpointer.get(
              this.localNode,
              error.instancePath
            );
            if (error.parentSchema.format === "password" && errorValue === "__PWD__") {
              console.log(
                "password fields with value equal to __PWD__ should not be an error"
              );
              return acc;
            } else {
              const key = `node${error.instancePath.replaceAll("/", ".")}`;
              acc[key] = error.message;
              return acc;
            }
          }, {});
        } else {
          this.errors = {};
        }
        if (this.disableSaveButtonOnError) {
          if (Object.keys(this.errors).length) {
            (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", true).addClass("disabled");
            (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", true).addClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "none", "important");
          } else {
            $("#node-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#node-config-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
          }
        }
      }
    }
  };
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _hoisted_1$7 = { style: { "width": "100%" } };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedNodeForm = resolveComponent("NodeRedNodeForm");
    return openBlock(), createElementBlock("div", _hoisted_1$7, [
      createVNode(_component_NodeRedNodeForm, {
        node: $data.localNode,
        errors: $data.errors,
        style: { "width": "100%" }
      }, null, 8, ["node", "errors"])
    ]);
  }
  const NodeRedVueApp = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
  const _sfc_main$6 = {
    props: {
      value: String,
      type: {
        type: String,
        default: "text"
      },
      placeholder: String,
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value", "input"],
    data() {
      return {
        internalValue: "",
        secretPattern: "*************"
      };
    },
    beforeMount() {
      this.internalValue = this.value;
      this.onBlur();
    },
    methods: {
      onInput(event) {
        this.internalValue = event.target.value;
        this.$emit("update:value", this.internalValue);
        this.$emit("input", this.internalValue);
      },
      onFocus() {
        if (this.type === "password" && this.internalValue === this.secretPattern) {
          this.internalValue = "";
        }
      },
      onBlur() {
        if (this.type === "password" && this.value === "__PWD__") {
          this.internalValue = this.secretPattern;
        }
      }
    }
  };
  const _hoisted_1$6 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$6 = ["type", "value", "placeholder"];
  const _hoisted_3$4 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$6, [
      createBaseVNode("input", {
        ref: "inputField",
        type: $props.type,
        value: $data.internalValue,
        placeholder: $props.placeholder,
        onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
        onFocus: _cache[1] || (_cache[1] = (...args) => $options.onFocus && $options.onFocus(...args)),
        onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
        style: { "flex": "1", "width": "100%" }
      }, null, 40, _hoisted_2$6),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$4, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedInput = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
  const TYPED_INPUT_TYPES = [
    "msg",
    "flow",
    "global",
    "str",
    "num",
    "bool",
    "json",
    "bin",
    "re",
    "jsonata",
    "date",
    "env",
    "node",
    "cred"
  ];
  const _sfc_main$5 = {
    props: {
      value: {
        type: Object,
        required: true,
        validator: function(obj) {
          if (false) {
            console.warn(
              "[WARN] Invalid value for 'value' property. It must be an object."
            );
            return false;
          }
          const isValid = typeof (obj == null ? void 0 : obj.value) === "string" && typeof (obj == null ? void 0 : obj.type) === "string";
          if (!isValid) {
            console.warn(
              "[WARN] Invalid value for 'value' property. It must be an object with 'value' and 'type' properties being strings.",
              obj
            );
          }
          return isValid;
        }
      },
      types: {
        type: Array,
        default: () => TYPED_INPUT_TYPES
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    computed: {
      isProvidedValueTypeValid() {
        const type2 = this.value.type;
        const types2 = this.types;
        return types2.includes(type2);
      }
    },
    mounted() {
      const inputElement = this.$refs.typedInput;
      this.$input = $(inputElement).typedInput({
        default: this.value.type || this.types[0],
        types: this.types
      });
      this.$input.typedInput("value", this.value.value || "");
      this.$input.typedInput("type", this.value.type || this.types[0]);
      this.$nextTick(() => {
        const observer = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            if (mutation.attributeName === "value") {
              this.onChange();
            }
          }
        });
        observer.observe(inputElement, {
          attributes: true,
          attributeFilter: ["value"]
        });
        this._observer = observer;
      });
      this.$input.on("change", () => {
        this.onChange();
      });
    },
    watch: {
      isProvidedValueTypeValid: {
        handler(newValue) {
          if (!newValue) {
            console.warn(
              `Validation failed: this.value.type (${this.value.type}) must be one of the provided types (${this.types}).`
            );
          }
        },
        immediate: true
      },
      error(newVal) {
        this.$nextTick(() => {
          const targetDiv = this.$el.querySelector(
            ".red-ui-typedInput-container"
          );
          if (newVal) {
            targetDiv.classList.add("input-error");
          } else {
            targetDiv.classList.remove("input-error");
          }
        });
      }
    },
    methods: {
      onChange() {
        const newValue = this.$input.typedInput("value");
        const newType = this.$input.typedInput("type");
        if (this.value.value !== newValue || this.value.type !== newType) {
          this.$emit("update:value", {
            value: newValue,
            type: newType
          });
        }
      }
    }
  };
  const _hoisted_1$5 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$5 = {
    type: "text",
    ref: "typedInput",
    class: "node-red-typed-input",
    style: { "flex": "1", "width": "100%" }
  };
  const _hoisted_3$3 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$5, [
      createBaseVNode("input", _hoisted_2$5, null, 512),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$3, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedTypedInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
  const _sfc_main$4 = {
    props: {
      value: String,
      type: String,
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    computed: {
      inputPrefix() {
        return "node-input-" + Math.random().toString(36).substring(2, 9);
      },
      inputId() {
        return this.inputPrefix + "-" + this.value;
      }
    },
    mounted() {
      RED.editor.prepareConfigNodeSelect(
        this,
        this.value,
        this.type,
        this.inputPrefix
      );
      const input = $("#" + this.inputId);
      input.on("change", () => {
        this.$emit("update:value", input.val());
      });
      input.val(this.value || "_ADD_");
    }
  };
  const _hoisted_1$4 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$4 = ["id"];
  const _hoisted_3$2 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$4, [
      createBaseVNode("input", {
        type: "text",
        id: $options.inputId,
        style: { "width": "100%" }
      }, null, 8, _hoisted_2$4),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$2, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedConfigInput = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
  const _sfc_main$3 = {
    props: {
      value: String | Array,
      options: {
        type: Array,
        required: true,
        validator: function(value) {
          if (!Array.isArray(value)) {
            console.warn(
              "[WARN] Invalid value for 'options' property. It must be an array."
            );
            return false;
          }
          const isValid = value.every((item) => {
            const isObject2 = typeof item === "object" && item !== null;
            if (!isObject2) return false;
            return item.hasOwnProperty("value") && item.hasOwnProperty("label") && typeof item.value === "string" && typeof item.label === "string";
          });
          if (!isValid) {
            console.warn(
              "[WARN] Invalid value for 'options' property. Each item must be an object with 'value' and 'label' properties being strings.",
              value
            );
          }
          return isValid;
        }
      },
      multiple: {
        type: Boolean,
        default: false
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    mounted() {
      const inputElement = this.$refs.selectInput;
      const $selectInput = $(inputElement);
      $selectInput.typedInput({
        types: [
          {
            multiple: this.multiple,
            options: this.options
          }
        ]
      });
      $selectInput.typedInput(
        "value",
        Array.isArray(this.value) ? this.value.join(",") : this.value
      );
      $selectInput.on("change", () => {
        var _a;
        const newValue = this.multiple ? (_a = $selectInput.typedInput("value")) == null ? void 0 : _a.split(",") : $selectInput.typedInput("value");
        this.$emit("update:value", newValue);
      });
    }
  };
  const _hoisted_1$3 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$3 = {
    type: "text",
    ref: "selectInput",
    class: "node-input-select",
    style: { "width": "100%" }
  };
  const _hoisted_3$1 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$3, [
      createBaseVNode("input", _hoisted_2$3, null, 512),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$1, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
  const _sfc_main$2 = {
    props: {
      value: String,
      language: {
        type: String,
        default: "json",
        validator: function(value) {
          const allowedLanguages = [
            "abap",
            "apex",
            "azcli",
            "bat",
            "bicep",
            "cameligo",
            "clojure",
            "coffee",
            "cpp",
            "csharp",
            "csp",
            "css",
            "cypher",
            "dart",
            "dockerfile",
            "ecl",
            "elixir",
            "flow9",
            "freemarker2",
            "fsharp",
            "go",
            "graphql",
            "handlebars",
            "hcl",
            "html",
            "ini",
            "java",
            "javascript",
            "json",
            "julia",
            "kotlin",
            "less",
            "lexon",
            "liquid",
            "lua",
            "m3",
            "markdown",
            "mdx",
            "mips",
            "msdax",
            "mysql",
            "objective-c",
            "pascal",
            "pascaligo",
            "perl",
            "pgsql",
            "php",
            "pla",
            "postiats",
            "powerquery",
            "powershell",
            "protobuf",
            "pub",
            "python",
            "qsharp",
            "r",
            "razor",
            "redis",
            "redshift",
            "restructuredtext",
            "ruby",
            "rust",
            "sb",
            "scala",
            "scheme",
            "scss",
            "shell",
            "solidity",
            "sophia",
            "sparql",
            "sql",
            "st",
            "swift",
            "systemverilog",
            "tcl",
            "twig",
            "typescript",
            "typespec",
            "vb",
            "wgsl",
            "xml",
            "yaml"
          ];
          const isValid = allowedLanguages.includes(value);
          if (!isValid) {
            console.warn(
              `[WARN]: Invalid value for 'type' property: "${value}". Expected one of: ${allowedLanguages.join(", ")}`
            );
          }
          return isValid;
        }
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    editor: null,
    data() {
      return {
        editorId: "node-red-editor-" + Math.random().toString(36).substring(2, 9)
      };
    },
    mounted() {
      this.mountEditor();
    },
    methods: {
      mountEditor() {
        this.$nextTick(() => {
          const containerEl = this.$refs.containerDiv;
          const editorEl = this.$refs.editorDiv;
          if (containerEl && editorEl) {
            try {
              const inlineHeight = containerEl.style.height;
              const inlineWidth = containerEl.style.width;
              if (inlineHeight) {
                editorEl.style.height = inlineHeight;
              } else {
                editorEl.style.height = "200px";
              }
              if (inlineWidth) {
                editorEl.style.width = inlineWidth;
              } else {
                editorEl.style.width = "100%";
              }
              this.createEditorInstance();
            } catch (e) {
              console.error(
                "[NodeRedEditorInput] Error setting initial editor style:",
                e
              );
              this.createEditorInstance();
            }
          } else {
            console.error(
              "[NodeRedEditorInput] Container or Editor div refs not found on mount."
            );
          }
        });
      },
      createEditorInstance() {
        this.editorInstance = RED.editor.createEditor({
          id: this.editorId,
          mode: this.language,
          value: this.value
        });
        this.editorInstance.getSession().on("change", () => {
          const currentValue = this.editorInstance.getValue();
          if (currentValue !== this.value) {
            this.$emit("update:value", currentValue);
          }
        });
      }
    },
    beforeUnmount() {
      if (this.editorInstance) {
        try {
          this.editorInstance.destroy();
        } catch (err) {
          console.error(`Error destroying editor for ID ${this.editorId}:`, err);
        }
        this.editorInstance = null;
      }
    }
  };
  const _hoisted_1$2 = {
    ref: "containerDiv",
    class: "node-text-editor-container"
  };
  const _hoisted_2$2 = ["id"];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$2, [
      createBaseVNode("div", {
        ref: "editorDiv",
        id: $data.editorId,
        class: "node-text-editor"
      }, null, 8, _hoisted_2$2),
      withDirectives(createBaseVNode("div", { class: "node-red-vue-input-error-message" }, toDisplayString($props.error), 513), [
        [vShow, $props.error]
      ])
    ], 512);
  }
  const NodeRedEditorInput = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  var ajv = { exports: {} };
  var core$1 = {};
  var validate = {};
  var boolSchema = {};
  var errors = {};
  var codegen = {};
  var code$1 = {};
  var hasRequiredCode$1;
  function requireCode$1() {
    if (hasRequiredCode$1) return code$1;
    hasRequiredCode$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
      class _CodeOrName {
      }
      exports._CodeOrName = _CodeOrName;
      exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class Name extends _CodeOrName {
        constructor(s) {
          super();
          if (!exports.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      exports.Name = Name;
      class _Code extends _CodeOrName {
        constructor(code2) {
          super();
          this._items = typeof code2 === "string" ? [code2] : code2;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a;
          return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
        }
        get names() {
          var _a;
          return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
            if (c instanceof Name)
              names2[c.str] = (names2[c.str] || 0) + 1;
            return names2;
          }, {});
        }
      }
      exports._Code = _Code;
      exports.nil = new _Code("");
      function _(strs, ...args) {
        const code2 = [strs[0]];
        let i = 0;
        while (i < args.length) {
          addCodeArg(code2, args[i]);
          code2.push(strs[++i]);
        }
        return new _Code(code2);
      }
      exports._ = _;
      const plus = new _Code("+");
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i = 0;
        while (i < args.length) {
          expr.push(plus);
          addCodeArg(expr, args[i]);
          expr.push(plus, safeStringify(strs[++i]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports.str = str;
      function addCodeArg(code2, arg) {
        if (arg instanceof _Code)
          code2.push(...arg._items);
        else if (arg instanceof Name)
          code2.push(arg);
        else
          code2.push(interpolate(arg));
      }
      exports.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i = 1;
        while (i < expr.length - 1) {
          if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
            if (res !== void 0) {
              expr.splice(i - 1, 3, res);
              continue;
            }
            expr[i++] = "+";
          }
          i++;
        }
      }
      function mergeExprItems(a, b) {
        if (b === '""')
          return a;
        if (a === '""')
          return b;
        if (typeof a == "string") {
          if (b instanceof Name || a[a.length - 1] !== '"')
            return;
          if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
          if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
          return;
        }
        if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
          return `"${a}${b.slice(1)}`;
        return;
      }
      function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
      }
      exports.strConcat = strConcat;
      function interpolate(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
      }
      function stringify(x) {
        return new _Code(safeStringify(x));
      }
      exports.stringify = stringify;
      function safeStringify(x) {
        return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
      }
      exports.getProperty = getProperty;
      function getEsmExportName(key) {
        if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
          return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
      }
      exports.getEsmExportName = getEsmExportName;
      function regexpCode(rx) {
        return new _Code(rx.toString());
      }
      exports.regexpCode = regexpCode;
    })(code$1);
    return code$1;
  }
  var scope = {};
  var hasRequiredScope;
  function requireScope() {
    if (hasRequiredScope) return scope;
    hasRequiredScope = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
      const code_1 = requireCode$1();
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`);
          this.value = name.value;
        }
      }
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
      exports.varKinds = {
        const: new code_1.Name("const"),
        let: new code_1.Name("let"),
        var: new code_1.Name("var")
      };
      class Scope {
        constructor({ prefixes: prefixes2, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes2;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_1.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a, _b;
          if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      }
      exports.Scope = Scope;
      class ValueScopeName extends code_1.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
        }
      }
      exports.ValueScopeName = ValueScopeName;
      const line = (0, code_1._)`\n`;
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name = this.toName(nameOrPrefix);
          const { prefix } = name;
          const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
          let vs = this._values[prefix];
          if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs.set(valueKey, name);
          const s = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s.length;
          s[itemIndex] = value.ref;
          name.setValue(value, { property: prefix, itemIndex });
          return name;
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix];
          if (!vs)
            return;
          return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_1._)`${scopeName}${name.scopePath}`;
          });
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(values, (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code2 = code_1.nil;
          for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs.forEach((name) => {
              if (nameSet.has(name))
                return;
              nameSet.set(name, UsedValueState.Started);
              let c = valueCode(name);
              if (c) {
                const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                code2 = (0, code_1._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
              } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
              } else {
                throw new ValueError(name);
              }
              nameSet.set(name, UsedValueState.Completed);
            });
          }
          return code2;
        }
      }
      exports.ValueScope = ValueScope;
    })(scope);
    return scope;
  }
  var hasRequiredCodegen;
  function requireCodegen() {
    if (hasRequiredCodegen) return codegen;
    hasRequiredCodegen = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
      const code_1 = requireCode$1();
      const scope_1 = requireScope();
      var code_2 = requireCode$1();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = requireScope();
      Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports.operators = {
        GT: new code_1._Code(">"),
        GTE: new code_1._Code(">="),
        LT: new code_1._Code("<"),
        LTE: new code_1._Code("<="),
        EQ: new code_1._Code("==="),
        NEQ: new code_1._Code("!=="),
        NOT: new code_1._Code("!"),
        OR: new code_1._Code("||"),
        AND: new code_1._Code("&&"),
        ADD: new code_1._Code("+")
      };
      class Node {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      }
      class Def extends Node {
        constructor(varKind, name, rhs) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.rhs = rhs;
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (!names2[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
        }
      }
      class Assign extends Node {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
          return addExprNames(names2, this.rhs);
        }
      }
      class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
      }
      class Label extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          return `${this.label}:` + _n;
        }
      }
      class Break extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n;
        }
      }
      class Throw extends Node {
        constructor(error) {
          super();
          this.error = error;
        }
        render({ _n }) {
          return `throw ${this.error};` + _n;
        }
        get names() {
          return this.error.names;
        }
      }
      class AnyCode extends Node {
        constructor(code2) {
          super();
          this.code = code2;
        }
        render({ _n }) {
          return `${this.code};` + _n;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names2, constants) {
          this.code = optimizeExpr(this.code, names2, constants);
          return this;
        }
        get names() {
          return this.code instanceof code_1._CodeOrName ? this.code.names : {};
        }
      }
      class ParentNode extends Node {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i = nodes.length;
          while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
              nodes.splice(i, 1, ...n);
            else if (n)
              nodes[i] = n;
            else
              nodes.splice(i, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names2, constants) {
          const { nodes } = this;
          let i = nodes.length;
          while (i--) {
            const n = nodes[i];
            if (n.optimizeNames(names2, constants))
              continue;
            subtractNames(names2, n.names);
            nodes.splice(i, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      }
      class Root extends ParentNode {
      }
      class Else extends BlockNode {
      }
      Else.kind = "else";
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code2 = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code2 += "else " + this.else.render(opts);
          return code2;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e = this.else;
          if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
          }
          if (e) {
            if (cond === false)
              return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
              return this;
            return new If(not2(cond), e instanceof If ? [e] : e.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names2, constants) {
          var _a;
          this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
          if (!(super.optimizeNames(names2, constants) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          addExprNames(names2, this.condition);
          if (this.else)
            addNames(names2, this.else.names);
          return names2;
        }
      }
      If.kind = "if";
      class For extends BlockNode {
      }
      For.kind = "for";
      class ForLoop extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iteration = optimizeExpr(this.iteration, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from, to) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.from = from;
          this.to = to;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name, from, to } = this;
          return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
          const names2 = addExprNames(super.names, this.from);
          return addExprNames(names2, this.to);
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iterable = optimizeExpr(this.iterable, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super();
          this.name = name;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      }
      Func.kind = "func";
      class Return extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      }
      Return.kind = "return";
      class Try extends BlockNode {
        render(opts) {
          let code2 = "try" + super.render(opts);
          if (this.catch)
            code2 += this.catch.render(opts);
          if (this.finally)
            code2 += this.finally.render(opts);
          return code2;
        }
        optimizeNodes() {
          var _a, _b;
          super.optimizeNodes();
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names2, constants) {
          var _a, _b;
          super.optimizeNames(names2, constants);
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          if (this.catch)
            addNames(names2, this.catch.names);
          if (this.finally)
            addNames(names2, this.finally.names);
          return names2;
        }
      }
      class Catch extends BlockNode {
        constructor(error) {
          super();
          this.error = error;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      }
      Catch.kind = "catch";
      class Finally extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      }
      Finally.kind = "finally";
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value);
          const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
          vs.add(name);
          return name;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name.str] = rhs;
          this._leafNode(new Def(varKind, name, rhs));
          return name;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
          if (typeof c == "function")
            c();
          else if (c !== code_1.nil)
            this._leafNode(new AnyCode(c));
          return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
          const code2 = ["{"];
          for (const [key, value] of keyValues) {
            if (code2.length > 1)
              code2.push(",");
            code2.push(key);
            if (key !== value || this.opts.es5) {
              code2.push(":");
              (0, code_1.addCodeArg)(code2, value);
            }
          }
          code2.push("}");
          return new code_1._Code(code2);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
              this.var(name, (0, code_1._)`${arr}[${i}]`);
              forBody(name);
            });
          }
          return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
          }
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label(label));
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error) {
          return this._leafNode(new Throw(error));
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_1.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n = 1) {
          while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N1, N2) {
          const n = this._currNode;
          if (n instanceof N1 || N2 && n instanceof N2) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
          const n = this._currNode;
          if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns = this._nodes;
          return ns[ns.length - 1];
        }
        set _currNode(node) {
          const ns = this._nodes;
          ns[ns.length - 1] = node;
        }
      }
      exports.CodeGen = CodeGen;
      function addNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) + (from[n] || 0);
        return names2;
      }
      function addExprNames(names2, from) {
        return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
      }
      function optimizeExpr(expr, names2, constants) {
        if (expr instanceof code_1.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_1._Code(expr._items.reduce((items2, c) => {
          if (c instanceof code_1.Name)
            c = replaceName(c);
          if (c instanceof code_1._Code)
            items2.push(...c._items);
          else
            items2.push(c);
          return items2;
        }, []));
        function replaceName(n) {
          const c = constants[n.str];
          if (c === void 0 || names2[n.str] !== 1)
            return n;
          delete names2[n.str];
          return c;
        }
        function canOptimize(e) {
          return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
        }
      }
      function subtractNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) - (from[n] || 0);
      }
      function not2(x) {
        return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
      }
      exports.not = not2;
      const andCode = mappend(exports.operators.AND);
      function and(...args) {
        return args.reduce(andCode);
      }
      exports.and = and;
      const orCode = mappend(exports.operators.OR);
      function or(...args) {
        return args.reduce(orCode);
      }
      exports.or = or;
      function mappend(op) {
        return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
      }
      function par(x) {
        return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
      }
    })(codegen);
    return codegen;
  }
  var util = {};
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil) return util;
    hasRequiredUtil = 1;
    Object.defineProperty(util, "__esModule", { value: true });
    util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
    const codegen_1 = requireCodegen();
    const code_1 = requireCode$1();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    util.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    util.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules2 = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules2[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    util.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules2) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules2[key])
          return true;
      return false;
    }
    util.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    util.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
    }
    util.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    util.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    util.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    util.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    util.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    util.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    util.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items2) => gen.var("items", items2)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    util.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
    }
    util.setEvaluated = setEvaluated;
    const snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    util.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (util.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    util.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    util.checkStrictMode = checkStrictMode;
    return util;
  }
  var names = {};
  var hasRequiredNames;
  function requireNames() {
    if (hasRequiredNames) return names;
    hasRequiredNames = 1;
    Object.defineProperty(names, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const names$1 = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    names.default = names$1;
    return names;
  }
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const names_1 = requireNames();
      exports.keywordError = {
        message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
      };
      exports.keyword$DataError = {
        message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
      };
      function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen, errObj);
        } else {
          returnErrors(it, (0, codegen_1._)`[${errObj}]`);
        }
      }
      exports.reportError = reportError;
      function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it, names_1.default.vErrors);
        }
      }
      exports.reportExtraError = reportExtraError;
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
      }
      exports.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, (i) => {
          gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
          gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
          gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
          if (it.opts.verbose) {
            gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
            gen.assign((0, codegen_1._)`${err}.data`, data);
          }
        });
      }
      exports.extendErrors = extendErrors;
      function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
        gen.code((0, codegen_1._)`${names_1.default.errors}++`);
      }
      function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it;
        if (schemaEnv.$async) {
          gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
          gen.return(false);
        }
      }
      const E = {
        keyword: new codegen_1.Name("keyword"),
        schemaPath: new codegen_1.Name("schemaPath"),
        // also used in JTD errors
        params: new codegen_1.Name("params"),
        propertyName: new codegen_1.Name("propertyName"),
        message: new codegen_1.Name("message"),
        schema: new codegen_1.Name("schema"),
        parentSchema: new codegen_1.Name("parentSchema")
      };
      function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return (0, codegen_1._)`{}`;
        return errorObject(cxt, error, errorPaths);
      }
      function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt;
        const keyValues = [
          errorInstancePath(it, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error, keyValues);
        return gen.object(...keyValues);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
        return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
        if (schemaPath) {
          schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
        }
        return [E.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword: keyword2, data, schemaValue, it } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it;
        keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
        if (opts.messages) {
          keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
        }
        if (propertyName)
          keyValues.push([E.propertyName, propertyName]);
      }
    })(errors);
    return errors;
  }
  var hasRequiredBoolSchema;
  function requireBoolSchema() {
    if (hasRequiredBoolSchema) return boolSchema;
    hasRequiredBoolSchema = 1;
    Object.defineProperty(boolSchema, "__esModule", { value: true });
    boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
    const errors_1 = requireErrors();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    boolSchema.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
    return boolSchema;
  }
  var dataType = {};
  var rules = {};
  var hasRequiredRules;
  function requireRules() {
    if (hasRequiredRules) return rules;
    hasRequiredRules = 1;
    Object.defineProperty(rules, "__esModule", { value: true });
    rules.getRules = rules.isJSONType = void 0;
    const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    const jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    rules.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    rules.getRules = getRules;
    return rules;
  }
  var applicability = {};
  var hasRequiredApplicability;
  function requireApplicability() {
    if (hasRequiredApplicability) return applicability;
    hasRequiredApplicability = 1;
    Object.defineProperty(applicability, "__esModule", { value: true });
    applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type2) {
      const group = self2.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    applicability.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    applicability.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    applicability.shouldUseRule = shouldUseRule;
    return applicability;
  }
  var hasRequiredDataType;
  function requireDataType() {
    if (hasRequiredDataType) return dataType;
    hasRequiredDataType = 1;
    Object.defineProperty(dataType, "__esModule", { value: true });
    dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
    const rules_1 = requireRules();
    const applicability_1 = requireApplicability();
    const errors_1 = requireErrors();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (dataType.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    dataType.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    dataType.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types2) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types2, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    dataType.coerceAndCheckDataType = coerceAndCheckDataType;
    const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types2, coerceTo) {
      const { gen, data, opts } = it;
      const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType2) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType2}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    dataType.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t in types2)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    dataType.checkDataTypes = checkDataTypes;
    const typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    dataType.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
    return dataType;
  }
  var defaults = {};
  var hasRequiredDefaults;
  function requireDefaults() {
    if (hasRequiredDefaults) return defaults;
    hasRequiredDefaults = 1;
    Object.defineProperty(defaults, "__esModule", { value: true });
    defaults.assignDefaults = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    function assignDefaults(it, ty) {
      const { properties: properties2, items: items2 } = it.schema;
      if (ty === "object" && properties2) {
        for (const key in properties2) {
          assignDefault(it, key, properties2[key].default);
        }
      } else if (ty === "array" && Array.isArray(items2)) {
        items2.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    defaults.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
    return defaults;
  }
  var keyword = {};
  var code = {};
  var hasRequiredCode;
  function requireCode() {
    if (hasRequiredCode) return code;
    hasRequiredCode = 1;
    Object.defineProperty(code, "__esModule", { value: true });
    code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const names_1 = requireNames();
    const util_2 = requireUtil();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    code.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
      return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    code.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    code.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    code.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    code.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    code.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    code.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    code.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p2]));
    }
    code.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    code.callValidateCode = callValidateCode;
    const newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern2) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern2, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
      });
    }
    code.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    code.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword: keyword2, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    code.validateUnion = validateUnion;
    return code;
  }
  var hasRequiredKeyword;
  function requireKeyword() {
    if (hasRequiredKeyword) return keyword;
    hasRequiredKeyword = 1;
    Object.defineProperty(keyword, "__esModule", { value: true });
    keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const code_1 = requireCode();
    const errors_1 = requireErrors();
    function macroKeywordCode(cxt, def2) {
      const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
      const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    keyword.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def2) {
      var _a;
      const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def2);
      const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
      const validateRef = useKeyword(gen, keyword2, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def2.errors === false) {
          assignValid();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def2.async ? validateAsync() : validateSync();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def2.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def2 && !$data || def2.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
      }
      function reportErrs(errors2) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
      }
    }
    keyword.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def2) {
      if (def2.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    keyword.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
      if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def2.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def2.validateSchema) {
        const valid = def2.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    keyword.validateKeywordUsage = validateKeywordUsage;
    return keyword;
  }
  var subschema = {};
  var hasRequiredSubschema;
  function requireSubschema() {
    if (hasRequiredSubschema) return subschema;
    hasRequiredSubschema = 1;
    Object.defineProperty(subschema, "__esModule", { value: true });
    subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    subschema.getSubschema = getSubschema;
    function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema2.propertyName = propertyName;
      }
      if (dataTypes)
        subschema2.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema2.data = _nextData;
        subschema2.dataLevel = it.dataLevel + 1;
        subschema2.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema2.parentData = it.data;
        subschema2.dataNames = [...it.dataNames, _nextData];
      }
    }
    subschema.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema2.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema2.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema2.allErrors = allErrors;
      subschema2.jtdDiscriminator = jtdDiscriminator;
      subschema2.jtdMetadata = jtdMetadata;
    }
    subschema.extendSubschemaMode = extendSubschemaMode;
    return subschema;
  }
  var resolve = {};
  var fastDeepEqual;
  var hasRequiredFastDeepEqual;
  function requireFastDeepEqual() {
    if (hasRequiredFastDeepEqual) return fastDeepEqual;
    hasRequiredFastDeepEqual = 1;
    fastDeepEqual = function equal2(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
    return fastDeepEqual;
  }
  var jsonSchemaTraverse = { exports: {} };
  var hasRequiredJsonSchemaTraverse;
  function requireJsonSchemaTraverse() {
    if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
    hasRequiredJsonSchemaTraverse = 1;
    var traverse2 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse2.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse2.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse2.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse2.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse2.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse2.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse2.keywords || opts.allKeys && !(key in traverse2.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    return jsonSchemaTraverse.exports;
  }
  var hasRequiredResolve;
  function requireResolve() {
    if (hasRequiredResolve) return resolve;
    hasRequiredResolve = 1;
    Object.defineProperty(resolve, "__esModule", { value: true });
    resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
    const util_1 = requireUtil();
    const equal2 = requireFastDeepEqual();
    const traverse2 = requireJsonSchemaTraverse();
    const SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit2 = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit2 === true)
        return !hasRef(schema);
      if (!limit2)
        return false;
      return countKeys(schema) <= limit2;
    }
    resolve.inlineRef = inlineRef;
    const REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize) {
      if (normalize !== false)
        id2 = normalizeId(id2);
      const p2 = resolver.parse(id2);
      return _getFullPath(resolver, p2);
    }
    resolve.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    resolve._getFullPath = _getFullPath;
    const TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    resolve.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    resolve.resolveUrl = resolveUrl;
    const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref2) {
          const _resolve = this.opts.uriResolver.resolve;
          ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
          if (schemaRefs.has(ref2))
            throw ambiguos(ref2);
          schemaRefs.add(ref2);
          let schOrRef = this.refs[ref2];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref2);
          } else if (ref2 !== normalizeId(fullPath)) {
            if (ref2[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref2], ref2);
              localRefs[ref2] = sch;
            } else {
              this.refs[ref2] = fullPath;
            }
          }
          return ref2;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref2) {
        if (sch2 !== void 0 && !equal2(sch1, sch2))
          throw ambiguos(ref2);
      }
      function ambiguos(ref2) {
        return new Error(`reference "${ref2}" resolves to more than one schema`);
      }
    }
    resolve.getSchemaRefs = getSchemaRefs;
    return resolve;
  }
  var hasRequiredValidate;
  function requireValidate() {
    if (hasRequiredValidate) return validate;
    hasRequiredValidate = 1;
    Object.defineProperty(validate, "__esModule", { value: true });
    validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
    const boolSchema_1 = requireBoolSchema();
    const dataType_1 = requireDataType();
    const applicability_1 = requireApplicability();
    const dataType_2 = requireDataType();
    const defaults_1 = requireDefaults();
    const keyword_1 = requireKeyword();
    const subschema_1 = requireSubschema();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const resolve_1 = requireResolve();
    const util_1 = requireUtil();
    const errors_1 = requireErrors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    validate.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
      schemaKeywords(it, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items: items2 }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items2 instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
    }
    function schemaKeywords(it, types2, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types2);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types2) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types2);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types2);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types2) {
      if (!types2.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types2;
        return;
      }
      types2.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types2);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules2 = it.self.RULES.all;
      for (const keyword2 in rules2) {
        const rule = rules2[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    class KeywordCxt {
      constructor(it, def2, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword2;
        this.data = it.data;
        this.schema = it.schema[keyword2];
        this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
        this.schemaType = def2.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def2;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
          }
        }
        if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def: def2 } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def2.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def: def2, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def2.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema2, appl);
        const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    }
    validate.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword2, def2, ruleType) {
      const cxt = new KeywordCxt(it, def2, keyword2);
      if ("code" in def2) {
        def2.code(cxt, ruleType);
      } else if (cxt.$data && def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      } else if ("macro" in def2) {
        (0, keyword_1.macroKeywordCode)(cxt, def2);
      } else if (def2.compile || def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    validate.getData = getData;
    return validate;
  }
  var validation_error = {};
  var hasRequiredValidation_error;
  function requireValidation_error() {
    if (hasRequiredValidation_error) return validation_error;
    hasRequiredValidation_error = 1;
    Object.defineProperty(validation_error, "__esModule", { value: true });
    class ValidationError extends Error {
      constructor(errors2) {
        super("validation failed");
        this.errors = errors2;
        this.ajv = this.validation = true;
      }
    }
    validation_error.default = ValidationError;
    return validation_error;
  }
  var ref_error = {};
  var hasRequiredRef_error;
  function requireRef_error() {
    if (hasRequiredRef_error) return ref_error;
    hasRequiredRef_error = 1;
    Object.defineProperty(ref_error, "__esModule", { value: true });
    const resolve_1 = requireResolve();
    class MissingRefError extends Error {
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    }
    ref_error.default = MissingRefError;
    return ref_error;
  }
  var compile = {};
  var hasRequiredCompile;
  function requireCompile() {
    if (hasRequiredCompile) return compile;
    hasRequiredCompile = 1;
    Object.defineProperty(compile, "__esModule", { value: true });
    compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
    const codegen_1 = requireCodegen();
    const validation_error_1 = requireValidation_error();
    const names_1 = requireNames();
    const resolve_1 = requireResolve();
    const util_1 = requireUtil();
    const validate_1 = requireValidate();
    class SchemaEnv {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    }
    compile.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items: items2 } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items2 instanceof codegen_1.Name ? void 0 : items2,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items2 instanceof codegen_1.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    compile.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref2) {
      var _a;
      ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
      const schOrFunc = root.refs[ref2];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve2.call(this, root, ref2);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    compile.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    compile.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve2(root, ref2) {
      let sch;
      while (typeof (sch = this.refs[ref2]) == "string")
        ref2 = sch;
      return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    function resolveSchema(root, ref2) {
      const p2 = this.opts.uriResolver.parse(ref2);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref2)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    compile.resolveSchema = resolveSchema;
    const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
    return compile;
  }
  const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
  const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
  const type$1 = "object";
  const required$1 = ["$data"];
  const properties$2 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
  const additionalProperties$1 = false;
  const require$$9 = {
    $id: $id$1,
    description,
    type: type$1,
    required: required$1,
    properties: properties$2,
    additionalProperties: additionalProperties$1
  };
  var uri = {};
  var fastUri = { exports: {} };
  var scopedChars;
  var hasRequiredScopedChars;
  function requireScopedChars() {
    if (hasRequiredScopedChars) return scopedChars;
    hasRequiredScopedChars = 1;
    const HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    scopedChars = {
      HEX
    };
    return scopedChars;
  }
  var utils;
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils;
    hasRequiredUtils = 1;
    const { HEX } = requireScopedChars();
    const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(IPV4_REG) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer2 = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer2.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer2);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer2.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer2.push(cursor);
          continue;
        }
      }
      if (buffer2.length) {
        if (isZone) {
          output.zone = buffer2.join("");
        } else if (endIpv6) {
          address.push(buffer2.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer2));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    const RDS1 = /^\.\.?\//u;
    const RDS2 = /^\/\.(?:\/|$)/u;
    const RDS3 = /^\/\.\.(?:\/|$)/u;
    const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    utils = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
    return utils;
  }
  var schemes;
  var hasRequiredSchemes;
  function requireSchemes() {
    if (hasRequiredSchemes) return schemes;
    hasRequiredSchemes = 1;
    const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    const http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    const https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    const ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    const wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    const urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    const urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    const SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    schemes = SCHEMES;
    return schemes;
  }
  var hasRequiredFastUri;
  function requireFastUri() {
    if (hasRequiredFastUri) return fastUri.exports;
    hasRequiredFastUri = 1;
    const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils();
    const SCHEMES = requireSchemes();
    function normalize(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse(uri2, options), options);
      } else if (typeof uri2 === "object") {
        uri2 = parse(serialize(uri2, options), options);
      }
      return uri2;
    }
    function resolve2(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal2(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code2 = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code2 = value.charCodeAt(i);
        if (code2 > 126 || hexLookUp[code2]) {
          return true;
        }
      }
      return false;
    }
    const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri2, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri2.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
      const matches = uri2.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    const fastUri$1 = {
      SCHEMES,
      normalize,
      resolve: resolve2,
      resolveComponents,
      equal: equal2,
      serialize,
      parse
    };
    fastUri.exports = fastUri$1;
    fastUri.exports.default = fastUri$1;
    fastUri.exports.fastUri = fastUri$1;
    return fastUri.exports;
  }
  var hasRequiredUri;
  function requireUri() {
    if (hasRequiredUri) return uri;
    hasRequiredUri = 1;
    Object.defineProperty(uri, "__esModule", { value: true });
    const uri$1 = requireFastUri();
    uri$1.code = 'require("ajv/dist/runtime/uri").default';
    uri.default = uri$1;
    return uri;
  }
  var hasRequiredCore$1;
  function requireCore$1() {
    if (hasRequiredCore$1) return core$1;
    hasRequiredCore$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
      var validate_1 = requireValidate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = requireCodegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      const validation_error_1 = requireValidation_error();
      const ref_error_1 = requireRef_error();
      const rules_1 = requireRules();
      const compile_1 = requireCompile();
      const codegen_2 = requireCodegen();
      const resolve_1 = requireResolve();
      const dataType_1 = requireDataType();
      const util_1 = requireUtil();
      const $dataRefSchema = require$$9;
      const uri_1 = requireUri();
      const defaultRegExp = (str, flags) => new RegExp(str, flags);
      defaultRegExp.code = "new RegExp";
      const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
      const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]);
      const removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      };
      const deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      };
      const MAX_EXPRESSION = 200;
      function requiredOptions(o) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        const s = o.strict;
        const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
        const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
        return {
          strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
          strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
          strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
          strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
          strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
          code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
          loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
          loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
          addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver
        };
      }
      class Ajv2 {
        constructor(opts = {}) {
          this.schemas = {};
          this.refs = {};
          this.formats = {};
          this._compilations = /* @__PURE__ */ new Set();
          this._loading = {};
          this._cache = /* @__PURE__ */ new Map();
          opts = this.opts = { ...opts, ...requiredOptions(opts) };
          const { es5, lines } = this.opts.code;
          this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
          this.logger = getLogger(opts.logger);
          const formatOpt = opts.validateFormats;
          opts.validateFormats = false;
          this.RULES = (0, rules_1.getRules)();
          checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
          checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
          this._metaOpts = getMetaSchemaOptions.call(this);
          if (opts.formats)
            addInitialFormats.call(this);
          this._addVocabularies();
          this._addDefaultMetaSchema();
          if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
          if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
          addInitialSchemas.call(this);
          opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts;
          let _dataRefSchema = $dataRefSchema;
          if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts;
          return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
        }
        validate(schemaKeyRef, data) {
          let v;
          if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
          } else {
            v = this.compile(schemaKeyRef);
          }
          const valid = v(data);
          if (!("$async" in v))
            this.errors = v.errors;
          return valid;
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta);
          return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
          }
          const { loadSchema } = this.opts;
          return runCompileAsync.call(this, schema, meta);
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true);
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_1.default))
                throw e;
              checkLoaded.call(this, e);
              await loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          }
          function checkLoaded({ missingSchema: ref2, missingRef }) {
            if (this.refs[ref2]) {
              throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
            }
          }
          async function loadMissingSchema(ref2) {
            const _schema = await _loadSchema.call(this, ref2);
            if (!this.refs[ref2])
              await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref2])
              this.addSchema(_schema, ref2, meta);
          }
          async function _loadSchema(ref2) {
            const p2 = this._loading[ref2];
            if (p2)
              return p2;
            try {
              return await (this._loading[ref2] = loadSchema(ref2));
            } finally {
              delete this._loading[ref2];
            }
          }
        }
        // Adds schema to the instance
        addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, void 0, _meta, _validateSchema);
            return this;
          }
          let id2;
          if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id2 = schema[schemaId];
            if (id2 !== void 0 && typeof id2 != "string") {
              throw new Error(`schema ${schemaId} must be string`);
            }
          }
          key = (0, resolve_1.normalizeId)(key || id2);
          this._checkUnique(key);
          this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
          return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
          this.addSchema(schema, key, true, _validateSchema);
          return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == "boolean")
            return true;
          let $schema2;
          $schema2 = schema.$schema;
          if ($schema2 !== void 0 && typeof $schema2 != "string") {
            throw new Error("$schema must be a string");
          }
          $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
          if (!$schema2) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
          }
          const valid = this.validate($schema2, schema);
          if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(message);
            else
              throw new Error(message);
          }
          return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch;
          while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
          if (sch === void 0) {
            const { schemaId } = this.opts;
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
              return;
            this.refs[keyRef] = sch;
          }
          return sch.validate || this._compileSchemaEnv(sch);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
          }
          switch (typeof schemaKeyRef) {
            case "undefined":
              this._removeAllSchemas(this.schemas);
              this._removeAllSchemas(this.refs);
              this._cache.clear();
              return this;
            case "string": {
              const sch = getSchEnv.call(this, schemaKeyRef);
              if (typeof sch == "object")
                this._cache.delete(sch.schema);
              delete this.schemas[schemaKeyRef];
              delete this.refs[schemaKeyRef];
              return this;
            }
            case "object": {
              const cacheKey = schemaKeyRef;
              this._cache.delete(cacheKey);
              let id2 = schemaKeyRef[this.opts.schemaId];
              if (id2) {
                id2 = (0, resolve_1.normalizeId)(id2);
                delete this.schemas[id2];
                delete this.refs[id2];
              }
              return this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions2) {
          for (const def2 of definitions2)
            this.addKeyword(def2);
          return this;
        }
        addKeyword(kwdOrDef, def2) {
          let keyword2;
          if (typeof kwdOrDef == "string") {
            keyword2 = kwdOrDef;
            if (typeof def2 == "object") {
              this.logger.warn("these parameters are deprecated, see docs for addKeyword");
              def2.keyword = keyword2;
            }
          } else if (typeof kwdOrDef == "object" && def2 === void 0) {
            def2 = kwdOrDef;
            keyword2 = def2.keyword;
            if (Array.isArray(keyword2) && !keyword2.length) {
              throw new Error("addKeywords: keyword must be string or non-empty array");
            }
          } else {
            throw new Error("invalid addKeywords parameters");
          }
          checkKeyword.call(this, keyword2, def2);
          if (!def2) {
            (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
            return this;
          }
          keywordMetaschema.call(this, def2);
          const definition = {
            ...def2,
            type: (0, dataType_1.getJSONTypes)(def2.type),
            schemaType: (0, dataType_1.getJSONTypes)(def2.schemaType)
          };
          (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
          return this;
        }
        getKeyword(keyword2) {
          const rule = this.RULES.all[keyword2];
          return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword2) {
          const { RULES } = this;
          delete RULES.keywords[keyword2];
          delete RULES.all[keyword2];
          for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
            if (i >= 0)
              group.rules.splice(i, 1);
          }
          return this;
        }
        // Add format
        addFormat(name, format2) {
          if (typeof format2 == "string")
            format2 = new RegExp(format2);
          this.formats[name] = format2;
          return this;
        }
        errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
          if (!errors2 || errors2.length === 0)
            return "No errors";
          return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
          const rules2 = this.RULES.all;
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1);
            let keywords = metaSchema;
            for (const seg of segments)
              keywords = keywords[seg];
            for (const key in rules2) {
              const rule = rules2[key];
              if (typeof rule != "object")
                continue;
              const { $data } = rule.definition;
              const schema = keywords[key];
              if ($data && schema)
                keywords[key] = schemaOrData(schema);
            }
          }
          return metaSchema;
        }
        _removeAllSchemas(schemas, regex) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
              if (typeof sch == "string") {
                delete schemas[keyRef];
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema);
                delete schemas[keyRef];
              }
            }
          }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
          let id2;
          const { schemaId } = this.opts;
          if (typeof schema == "object") {
            id2 = schema[schemaId];
          } else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            else if (typeof schema != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let sch = this._cache.get(schema);
          if (sch !== void 0)
            return sch;
          baseId = (0, resolve_1.normalizeId)(id2 || baseId);
          const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
          sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
          this._cache.set(sch.schema, sch);
          if (addSchema && !baseId.startsWith("#")) {
            if (baseId)
              this._checkUnique(baseId);
            this.refs[baseId] = sch;
          }
          if (validateSchema)
            this.validateSchema(schema, true);
          return sch;
        }
        _checkUnique(id2) {
          if (this.schemas[id2] || this.refs[id2]) {
            throw new Error(`schema with key or id "${id2}" already exists`);
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta)
            this._compileMetaSchema(sch);
          else
            compile_1.compileSchema.call(this, sch);
          if (!sch.validate)
            throw new Error("ajv implementation error");
          return sch.validate;
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts;
          this.opts = this._metaOpts;
          try {
            compile_1.compileSchema.call(this, sch);
          } finally {
            this.opts = currentOpts;
          }
        }
      }
      Ajv2.ValidationError = validation_error_1.default;
      Ajv2.MissingRefError = ref_error_1.default;
      exports.default = Ajv2;
      function checkOptions(checkOpts, options, msg, log = "error") {
        for (const key in checkOpts) {
          const opt = key;
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_1.normalizeId)(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
          return;
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format2 = this.opts.formats[name];
          if (format2)
            this.addFormat(name, format2);
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword2 in defs) {
          const def2 = defs[keyword2];
          if (!def2.keyword)
            def2.keyword = keyword2;
          this.addKeyword(def2);
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts };
        for (const opt of META_IGNORE_OPTIONS)
          delete metaOpts[opt];
        return metaOpts;
      }
      const noLogs = { log() {
      }, warn() {
      }, error() {
      } };
      function getLogger(logger) {
        if (logger === false)
          return noLogs;
        if (logger === void 0)
          return console;
        if (logger.log && logger.warn && logger.error)
          return logger;
        throw new Error("logger must implement log, warn and error methods");
      }
      const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
      function checkKeyword(keyword2, def2) {
        const { RULES } = this;
        (0, util_1.eachItem)(keyword2, (kwd) => {
          if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def2)
          return;
        if (def2.$data && !("code" in def2 || "validate" in def2)) {
          throw new Error('$data keyword must have "code" or "validate" function');
        }
      }
      function addRule(keyword2, definition, dataType2) {
        var _a;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType2 && post)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES } = this;
        let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.rules.push(ruleGroup);
        }
        RULES.keywords[keyword2] = true;
        if (!definition)
          return;
        const rule = {
          keyword: keyword2,
          definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
          }
        };
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
          ruleGroup.rules.push(rule);
        RULES.all[keyword2] = rule;
        (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i >= 0) {
          ruleGroup.rules.splice(i, 0, rule);
        } else {
          ruleGroup.rules.push(rule);
          this.logger.warn(`rule ${before} is not defined`);
        }
      }
      function keywordMetaschema(def2) {
        let { metaSchema } = def2;
        if (metaSchema === void 0)
          return;
        if (def2.$data && this.opts.$data)
          metaSchema = schemaOrData(metaSchema);
        def2.validateSchema = this.compile(metaSchema, true);
      }
      const $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
      }
    })(core$1);
    return core$1;
  }
  var draft7 = {};
  var core = {};
  var id = {};
  var hasRequiredId;
  function requireId() {
    if (hasRequiredId) return id;
    hasRequiredId = 1;
    Object.defineProperty(id, "__esModule", { value: true });
    const def2 = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    id.default = def2;
    return id;
  }
  var ref = {};
  var hasRequiredRef;
  function requireRef() {
    if (hasRequiredRef) return ref;
    hasRequiredRef = 1;
    Object.defineProperty(ref, "__esModule", { value: true });
    ref.callRef = ref.getValidate = void 0;
    const ref_error_1 = requireRef_error();
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const compile_1 = requireCompile();
    const util_1 = requireUtil();
    const def2 = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    ref.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items2, it.items, codegen_1.Name);
          }
        }
      }
    }
    ref.callRef = callRef;
    ref.default = def2;
    return ref;
  }
  var hasRequiredCore;
  function requireCore() {
    if (hasRequiredCore) return core;
    hasRequiredCore = 1;
    Object.defineProperty(core, "__esModule", { value: true });
    const id_1 = requireId();
    const ref_1 = requireRef();
    const core$12 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    core.default = core$12;
    return core;
  }
  var validation = {};
  var limitNumber = {};
  var hasRequiredLimitNumber;
  function requireLimitNumber() {
    if (hasRequiredLimitNumber) return limitNumber;
    hasRequiredLimitNumber = 1;
    Object.defineProperty(limitNumber, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const ops = codegen_1.operators;
    const KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    const error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    limitNumber.default = def2;
    return limitNumber;
  }
  var multipleOf = {};
  var hasRequiredMultipleOf;
  function requireMultipleOf() {
    if (hasRequiredMultipleOf) return multipleOf;
    hasRequiredMultipleOf = 1;
    Object.defineProperty(multipleOf, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    const def2 = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    multipleOf.default = def2;
    return multipleOf;
  }
  var limitLength = {};
  var ucs2length = {};
  var hasRequiredUcs2length;
  function requireUcs2length() {
    if (hasRequiredUcs2length) return ucs2length;
    hasRequiredUcs2length = 1;
    Object.defineProperty(ucs2length, "__esModule", { value: true });
    function ucs2length$1(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    ucs2length.default = ucs2length$1;
    ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
    return ucs2length;
  }
  var hasRequiredLimitLength;
  function requireLimitLength() {
    if (hasRequiredLimitLength) return limitLength;
    hasRequiredLimitLength = 1;
    Object.defineProperty(limitLength, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const ucs2length_1 = requireUcs2length();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it } = cxt;
        const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    limitLength.default = def2;
    return limitLength;
  }
  var pattern = {};
  var hasRequiredPattern;
  function requirePattern() {
    if (hasRequiredPattern) return pattern;
    hasRequiredPattern = 1;
    Object.defineProperty(pattern, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    const def2 = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    pattern.default = def2;
    return pattern;
  }
  var limitProperties = {};
  var hasRequiredLimitProperties;
  function requireLimitProperties() {
    if (hasRequiredLimitProperties) return limitProperties;
    hasRequiredLimitProperties = 1;
    Object.defineProperty(limitProperties, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    limitProperties.default = def2;
    return limitProperties;
  }
  var required = {};
  var hasRequiredRequired;
  function requireRequired() {
    if (hasRequiredRequired) return required;
    hasRequiredRequired = 1;
    Object.defineProperty(required, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    const def2 = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    required.default = def2;
    return required;
  }
  var limitItems = {};
  var hasRequiredLimitItems;
  function requireLimitItems() {
    if (hasRequiredLimitItems) return limitItems;
    hasRequiredLimitItems = 1;
    Object.defineProperty(limitItems, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    limitItems.default = def2;
    return limitItems;
  }
  var uniqueItems = {};
  var equal = {};
  var hasRequiredEqual;
  function requireEqual() {
    if (hasRequiredEqual) return equal;
    hasRequiredEqual = 1;
    Object.defineProperty(equal, "__esModule", { value: true });
    const equal$1 = requireFastDeepEqual();
    equal$1.code = 'require("ajv/dist/runtime/equal").default';
    equal.default = equal$1;
    return equal;
  }
  var hasRequiredUniqueItems;
  function requireUniqueItems() {
    if (hasRequiredUniqueItems) return uniqueItems;
    hasRequiredUniqueItems = 1;
    Object.defineProperty(uniqueItems, "__esModule", { value: true });
    const dataType_1 = requireDataType();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    const def2 = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    uniqueItems.default = def2;
    return uniqueItems;
  }
  var _const = {};
  var hasRequired_const;
  function require_const() {
    if (hasRequired_const) return _const;
    hasRequired_const = 1;
    Object.defineProperty(_const, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    const def2 = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    _const.default = def2;
    return _const;
  }
  var _enum = {};
  var hasRequired_enum;
  function require_enum() {
    if (hasRequired_enum) return _enum;
    hasRequired_enum = 1;
    Object.defineProperty(_enum, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    const def2 = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    _enum.default = def2;
    return _enum;
  }
  var hasRequiredValidation;
  function requireValidation() {
    if (hasRequiredValidation) return validation;
    hasRequiredValidation = 1;
    Object.defineProperty(validation, "__esModule", { value: true });
    const limitNumber_1 = requireLimitNumber();
    const multipleOf_1 = requireMultipleOf();
    const limitLength_1 = requireLimitLength();
    const pattern_1 = requirePattern();
    const limitProperties_1 = requireLimitProperties();
    const required_1 = requireRequired();
    const limitItems_1 = requireLimitItems();
    const uniqueItems_1 = requireUniqueItems();
    const const_1 = require_const();
    const enum_1 = require_enum();
    const validation$1 = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    validation.default = validation$1;
    return validation;
  }
  var applicator = {};
  var additionalItems = {};
  var hasRequiredAdditionalItems;
  function requireAdditionalItems() {
    if (hasRequiredAdditionalItems) return additionalItems;
    hasRequiredAdditionalItems = 1;
    Object.defineProperty(additionalItems, "__esModule", { value: true });
    additionalItems.validateAdditionalItems = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    const def2 = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items: items2 } = parentSchema;
        if (!Array.isArray(items2)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items2);
      }
    };
    function validateAdditionalItems(cxt, items2) {
      const { gen, schema, data, keyword: keyword2, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items2.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items2.length, len, (i) => {
          cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    additionalItems.validateAdditionalItems = validateAdditionalItems;
    additionalItems.default = def2;
    return additionalItems;
  }
  var prefixItems = {};
  var items = {};
  var hasRequiredItems;
  function requireItems() {
    if (hasRequiredItems) return items;
    hasRequiredItems = 1;
    Object.defineProperty(items, "__esModule", { value: true });
    items.validateTuple = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const code_1 = requireCode();
    const def2 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    items.validateTuple = validateTuple;
    items.default = def2;
    return items;
  }
  var hasRequiredPrefixItems;
  function requirePrefixItems() {
    if (hasRequiredPrefixItems) return prefixItems;
    hasRequiredPrefixItems = 1;
    Object.defineProperty(prefixItems, "__esModule", { value: true });
    const items_1 = requireItems();
    const def2 = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    prefixItems.default = def2;
    return prefixItems;
  }
  var items2020 = {};
  var hasRequiredItems2020;
  function requireItems2020() {
    if (hasRequiredItems2020) return items2020;
    hasRequiredItems2020 = 1;
    Object.defineProperty(items2020, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const code_1 = requireCode();
    const additionalItems_1 = requireAdditionalItems();
    const error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    const def2 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems: prefixItems2 } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems2)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    items2020.default = def2;
    return items2020;
  }
  var contains = {};
  var hasRequiredContains;
  function requireContains() {
    if (hasRequiredContains) return contains;
    hasRequiredContains = 1;
    Object.defineProperty(contains, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    const def2 = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    contains.default = def2;
    return contains;
  }
  var dependencies = {};
  var hasRequiredDependencies;
  function requireDependencies() {
    if (hasRequiredDependencies) return dependencies;
    hasRequiredDependencies = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const code_1 = requireCode();
      exports.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? "property" : "properties";
          return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        // TODO change to reference
      };
      const def2 = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt);
          validatePropertyDeps(cxt, propDeps);
          validateSchemaDeps(cxt, schDeps);
        }
      };
      function splitDependencies({ schema }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema) {
          if (key === "__proto__")
            continue;
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
          deps[key] = schema[key];
        }
        return [propertyDeps, schemaDeps];
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt;
        if (Object.keys(propertyDeps).length === 0)
          return;
        const missing = gen.let("missing");
        for (const prop in propertyDeps) {
          const deps = propertyDeps[prop];
          if (deps.length === 0)
            continue;
          const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
          cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", ")
          });
          if (it.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                (0, code_1.checkReportMissingProp)(cxt, depProp);
              }
            });
          } else {
            gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
      }
      exports.validatePropertyDeps = validatePropertyDeps;
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword: keyword2, it } = cxt;
        const valid = gen.name("valid");
        for (const prop in schemaDeps) {
          if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
            continue;
          gen.if(
            (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
              cxt.mergeValidEvaluated(schCxt, valid);
            },
            () => gen.var(valid, true)
            // TODO var
          );
          cxt.ok(valid);
        }
      }
      exports.validateSchemaDeps = validateSchemaDeps;
      exports.default = def2;
    })(dependencies);
    return dependencies;
  }
  var propertyNames = {};
  var hasRequiredPropertyNames;
  function requirePropertyNames() {
    if (hasRequiredPropertyNames) return propertyNames;
    hasRequiredPropertyNames = 1;
    Object.defineProperty(propertyNames, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    const def2 = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    propertyNames.default = def2;
    return propertyNames;
  }
  var additionalProperties = {};
  var hasRequiredAdditionalProperties;
  function requireAdditionalProperties() {
    if (hasRequiredAdditionalProperties) return additionalProperties;
    hasRequiredAdditionalProperties = 1;
    Object.defineProperty(additionalProperties, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const util_1 = requireUtil();
    const error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    const def2 = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors2) {
          const subschema2 = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors2 === false) {
            Object.assign(subschema2, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema2, valid);
        }
      }
    };
    additionalProperties.default = def2;
    return additionalProperties;
  }
  var properties$1 = {};
  var hasRequiredProperties;
  function requireProperties() {
    if (hasRequiredProperties) return properties$1;
    hasRequiredProperties = 1;
    Object.defineProperty(properties$1, "__esModule", { value: true });
    const validate_1 = requireValidate();
    const code_1 = requireCode();
    const util_1 = requireUtil();
    const additionalProperties_1 = requireAdditionalProperties();
    const def2 = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties2 = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (properties2.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties2) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    properties$1.default = def2;
    return properties$1;
  }
  var patternProperties = {};
  var hasRequiredPatternProperties;
  function requirePatternProperties() {
    if (hasRequiredPatternProperties) return patternProperties;
    hasRequiredPatternProperties = 1;
    Object.defineProperty(patternProperties, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const util_2 = requireUtil();
    const def2 = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    patternProperties.default = def2;
    return patternProperties;
  }
  var not = {};
  var hasRequiredNot;
  function requireNot() {
    if (hasRequiredNot) return not;
    hasRequiredNot = 1;
    Object.defineProperty(not, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    not.default = def2;
    return not;
  }
  var anyOf = {};
  var hasRequiredAnyOf;
  function requireAnyOf() {
    if (hasRequiredAnyOf) return anyOf;
    hasRequiredAnyOf = 1;
    Object.defineProperty(anyOf, "__esModule", { value: true });
    const code_1 = requireCode();
    const def2 = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    anyOf.default = def2;
    return anyOf;
  }
  var oneOf = {};
  var hasRequiredOneOf;
  function requireOneOf() {
    if (hasRequiredOneOf) return oneOf;
    hasRequiredOneOf = 1;
    Object.defineProperty(oneOf, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    const def2 = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    oneOf.default = def2;
    return oneOf;
  }
  var allOf = {};
  var hasRequiredAllOf;
  function requireAllOf() {
    if (hasRequiredAllOf) return allOf;
    hasRequiredAllOf = 1;
    Object.defineProperty(allOf, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    allOf.default = def2;
    return allOf;
  }
  var _if = {};
  var hasRequired_if;
  function require_if() {
    if (hasRequired_if) return _if;
    hasRequired_if = 1;
    Object.defineProperty(_if, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    const def2 = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it, keyword2) {
      const schema = it.schema[keyword2];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    _if.default = def2;
    return _if;
  }
  var thenElse = {};
  var hasRequiredThenElse;
  function requireThenElse() {
    if (hasRequiredThenElse) return thenElse;
    hasRequiredThenElse = 1;
    Object.defineProperty(thenElse, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
      }
    };
    thenElse.default = def2;
    return thenElse;
  }
  var hasRequiredApplicator;
  function requireApplicator() {
    if (hasRequiredApplicator) return applicator;
    hasRequiredApplicator = 1;
    Object.defineProperty(applicator, "__esModule", { value: true });
    const additionalItems_1 = requireAdditionalItems();
    const prefixItems_1 = requirePrefixItems();
    const items_1 = requireItems();
    const items2020_1 = requireItems2020();
    const contains_1 = requireContains();
    const dependencies_1 = requireDependencies();
    const propertyNames_1 = requirePropertyNames();
    const additionalProperties_1 = requireAdditionalProperties();
    const properties_1 = requireProperties();
    const patternProperties_1 = requirePatternProperties();
    const not_1 = requireNot();
    const anyOf_1 = requireAnyOf();
    const oneOf_1 = requireOneOf();
    const allOf_1 = requireAllOf();
    const if_1 = require_if();
    const thenElse_1 = requireThenElse();
    function getApplicator(draft2020 = false) {
      const applicator2 = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator2.push(prefixItems_1.default, items2020_1.default);
      else
        applicator2.push(additionalItems_1.default, items_1.default);
      applicator2.push(contains_1.default);
      return applicator2;
    }
    applicator.default = getApplicator;
    return applicator;
  }
  var format$1 = {};
  var format = {};
  var hasRequiredFormat$1;
  function requireFormat$1() {
    if (hasRequiredFormat$1) return format;
    hasRequiredFormat$1 = 1;
    Object.defineProperty(format, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    const def2 = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    format.default = def2;
    return format;
  }
  var hasRequiredFormat;
  function requireFormat() {
    if (hasRequiredFormat) return format$1;
    hasRequiredFormat = 1;
    Object.defineProperty(format$1, "__esModule", { value: true });
    const format_1 = requireFormat$1();
    const format2 = [format_1.default];
    format$1.default = format2;
    return format$1;
  }
  var metadata = {};
  var hasRequiredMetadata;
  function requireMetadata() {
    if (hasRequiredMetadata) return metadata;
    hasRequiredMetadata = 1;
    Object.defineProperty(metadata, "__esModule", { value: true });
    metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
    metadata.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    metadata.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
    return metadata;
  }
  var hasRequiredDraft7;
  function requireDraft7() {
    if (hasRequiredDraft7) return draft7;
    hasRequiredDraft7 = 1;
    Object.defineProperty(draft7, "__esModule", { value: true });
    const core_1 = requireCore();
    const validation_1 = requireValidation();
    const applicator_1 = requireApplicator();
    const format_1 = requireFormat();
    const metadata_1 = requireMetadata();
    const draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    draft7.default = draft7Vocabularies;
    return draft7;
  }
  var discriminator = {};
  var types = {};
  var hasRequiredTypes;
  function requireTypes() {
    if (hasRequiredTypes) return types;
    hasRequiredTypes = 1;
    Object.defineProperty(types, "__esModule", { value: true });
    types.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (types.DiscrError = DiscrError = {}));
    return types;
  }
  var hasRequiredDiscriminator;
  function requireDiscriminator() {
    if (hasRequiredDiscriminator) return discriminator;
    hasRequiredDiscriminator = 1;
    Object.defineProperty(discriminator, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const types_1 = requireTypes();
    const compile_1 = requireCompile();
    const ref_error_1 = requireRef_error();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    const def2 = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf: oneOf2 } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf2)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf2.length; i++) {
            let sch = oneOf2[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref2 = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    discriminator.default = def2;
    return discriminator;
  }
  const $schema = "http://json-schema.org/draft-07/schema#";
  const $id = "http://json-schema.org/draft-07/schema#";
  const title = "Core schema meta-schema";
  const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
  const type = ["object", "boolean"];
  const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
  const require$$3 = {
    $schema,
    $id,
    title,
    definitions,
    type,
    properties,
    "default": true
  };
  var hasRequiredAjv;
  function requireAjv() {
    if (hasRequiredAjv) return ajv.exports;
    hasRequiredAjv = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
      const core_1 = requireCore$1();
      const draft7_1 = requireDraft7();
      const discriminator_1 = requireDiscriminator();
      const draft7MetaSchema = require$$3;
      const META_SUPPORT_DATA = ["/properties"];
      const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      class Ajv2 extends core_1.default {
        _addVocabularies() {
          super._addVocabularies();
          draft7_1.default.forEach((v) => this.addVocabulary(v));
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          if (!this.opts.meta)
            return;
          const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
          this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      }
      exports.Ajv = Ajv2;
      module.exports = exports = Ajv2;
      module.exports.Ajv = Ajv2;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = Ajv2;
      var validate_1 = requireValidate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = requireCodegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      var validation_error_1 = requireValidation_error();
      Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
        return validation_error_1.default;
      } });
      var ref_error_1 = requireRef_error();
      Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_1.default;
      } });
    })(ajv, ajv.exports);
    return ajv.exports;
  }
  var ajvExports = requireAjv();
  const Ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
  var dist$1 = { exports: {} };
  var formats = {};
  var hasRequiredFormats;
  function requireFormats() {
    if (hasRequiredFormats) return formats;
    hasRequiredFormats = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
      function fmtDef(validate2, compare) {
        return { validate: validate2, compare };
      }
      exports.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(getTime(true), compareTime),
        "date-time": fmtDef(getDateTime(true), compareDateTime),
        "iso-time": fmtDef(getTime(), compareIsoTime),
        "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: uri2,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports.fastFormats = {
        ...exports.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
        "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      };
      exports.formatNames = Object.keys(exports.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date(str) {
        const matches = DATE.exec(str);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d2) {
        if (!(d1 && d2))
          return void 0;
        if (d1 > d2)
          return 1;
        if (d1 < d2)
          return -1;
        return 0;
      }
      const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
      function getTime(strictTimeZone) {
        return function time(str) {
          const matches = TIME.exec(str);
          if (!matches)
            return false;
          const hr = +matches[1];
          const min = +matches[2];
          const sec = +matches[3];
          const tz = matches[4];
          const tzSign = matches[5] === "-" ? -1 : 1;
          const tzH = +(matches[6] || 0);
          const tzM = +(matches[7] || 0);
          if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
            return false;
          if (hr <= 23 && min <= 59 && sec < 60)
            return true;
          const utcMin = min - tzM * tzSign;
          const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
          return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
        };
      }
      function compareTime(s1, s2) {
        if (!(s1 && s2))
          return void 0;
        const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
        const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
        if (!(t1 && t2))
          return void 0;
        return t1 - t2;
      }
      function compareIsoTime(t1, t2) {
        if (!(t1 && t2))
          return void 0;
        const a1 = TIME.exec(t1);
        const a2 = TIME.exec(t2);
        if (!(a1 && a2))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3];
        t2 = a2[1] + a2[2] + a2[3];
        if (t1 > t2)
          return 1;
        if (t1 < t2)
          return -1;
        return 0;
      }
      const DATE_TIME_SEPARATOR = /t|\s/i;
      function getDateTime(strictTimeZone) {
        const time = getTime(strictTimeZone);
        return function date_time(str) {
          const dateTime = str.split(DATE_TIME_SEPARATOR);
          return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
        };
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const d1 = new Date(dt1).valueOf();
        const d2 = new Date(dt2).valueOf();
        if (!(d1 && d2))
          return void 0;
        return d1 - d2;
      }
      function compareIsoDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d2);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t2);
      }
      const NOT_URI_FRAGMENT = /\/|:/;
      const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri2(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function byte(str) {
        BYTE.lastIndex = 0;
        return BYTE.test(str);
      }
      const MIN_INT32 = -2147483648;
      const MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      const Z_ANCHOR = /[^\\]\\Z/;
      function regex(str) {
        if (Z_ANCHOR.test(str))
          return false;
        try {
          new RegExp(str);
          return true;
        } catch (e) {
          return false;
        }
      }
    })(formats);
    return formats;
  }
  var limit = {};
  var hasRequiredLimit;
  function requireLimit() {
    if (hasRequiredLimit) return limit;
    hasRequiredLimit = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatLimitDefinition = void 0;
      const ajv_1 = requireAjv();
      const codegen_1 = requireCodegen();
      const ops = codegen_1.operators;
      const KWDs = {
        formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      const error = {
        message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
      };
      exports.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
          const { opts, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format2 = fCxt.schema;
            const fmtDef = self2.formats[format2];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format2,
              ref: fmtDef,
              code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const formatLimitPlugin = (ajv2) => {
        ajv2.addKeyword(exports.formatLimitDefinition);
        return ajv2;
      };
      exports.default = formatLimitPlugin;
    })(limit);
    return limit;
  }
  var hasRequiredDist$1;
  function requireDist$1() {
    if (hasRequiredDist$1) return dist$1.exports;
    hasRequiredDist$1 = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      const formats_1 = requireFormats();
      const limit_1 = requireLimit();
      const codegen_1 = requireCodegen();
      const fullName = new codegen_1.Name("fullFormats");
      const fastName = new codegen_1.Name("fastFormats");
      const formatsPlugin = (ajv2, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats2(ajv2, opts, formats_1.fullFormats, fullName);
          return ajv2;
        }
        const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list = opts.formats || formats_1.formatNames;
        addFormats2(ajv2, list, formats2, exportName);
        if (opts.keywords)
          (0, limit_1.default)(ajv2);
        return ajv2;
      };
      formatsPlugin.get = (name, mode = "full") => {
        const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f = formats2[name];
        if (!f)
          throw new Error(`Unknown format "${name}"`);
        return f;
      };
      function addFormats2(ajv2, list, fs, exportName) {
        var _a;
        var _b;
        (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
        for (const f of list)
          ajv2.addFormat(f, fs[f]);
      }
      module.exports = exports = formatsPlugin;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = formatsPlugin;
    })(dist$1, dist$1.exports);
    return dist$1.exports;
  }
  var distExports$1 = requireDist$1();
  const addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports$1);
  var dist = { exports: {} };
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist.exports;
    hasRequiredDist = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      const ajv_1 = requireAjv();
      const codegen_1 = requireCodegen();
      const code_1 = requireCode$1();
      const validate_1 = requireValidate();
      const errors_1 = requireErrors();
      const names_1 = requireNames();
      const keyword2 = "errorMessage";
      const used = new ajv_1.Name("emUsed");
      const KEYWORD_PROPERTY_PARAMS = {
        required: "missingProperty",
        dependencies: "property",
        dependentRequired: "property"
      };
      const INTERPOLATION = /\$\{[^}]+\}/;
      const INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
      const EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
      function errorMessage(options) {
        return {
          keyword: keyword2,
          schemaType: ["string", "object"],
          post: true,
          code(cxt) {
            const { gen, data, schema, schemaValue, it } = cxt;
            if (it.createErrors === false)
              return;
            const sch = schema;
            const instancePath = codegen_1.strConcat(names_1.default.instancePath, it.errorPath);
            gen.if(ajv_1._`${names_1.default.errors} > 0`, () => {
              if (typeof sch == "object") {
                const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
                if (kwdErrors)
                  processKeywordErrors(kwdErrors);
                if (kwdPropErrors)
                  processKeywordPropErrors(kwdPropErrors);
                processChildErrors(childErrorsConfig(sch));
              }
              const schMessage = typeof sch == "string" ? sch : sch._;
              if (schMessage)
                processAllErrors(schMessage);
              if (!options.keepErrors)
                removeUsedErrors();
            });
            function childErrorsConfig({ properties: properties2, items: items2 }) {
              const errors2 = {};
              if (properties2) {
                errors2.props = {};
                for (const p2 in properties2)
                  errors2.props[p2] = [];
              }
              if (items2) {
                errors2.items = {};
                for (let i = 0; i < items2.length; i++)
                  errors2.items[i] = [];
              }
              return errors2;
            }
            function keywordErrorsConfig(emSchema) {
              let propErrors;
              let errors2;
              for (const k in emSchema) {
                if (k === "properties" || k === "items")
                  continue;
                const kwdSch = emSchema[k];
                if (typeof kwdSch == "object") {
                  propErrors || (propErrors = {});
                  const errMap = propErrors[k] = {};
                  for (const p2 in kwdSch)
                    errMap[p2] = [];
                } else {
                  errors2 || (errors2 = {});
                  errors2[k] = [];
                }
              }
              return [propErrors, errors2];
            }
            function processKeywordErrors(kwdErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
              const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              const { singleError } = options;
              if (singleError) {
                const message = gen.let("message", ajv_1._`""`);
                const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
                loopErrors((key) => {
                  gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                  gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                  gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
                });
                errors_1.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
              } else {
                loopErrors((key) => errors_1.reportError(cxt, {
                  message: errMessage(key),
                  params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
                }));
              }
              function loopErrors(body) {
                gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
              }
              function errMessage(key) {
                return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
              }
            }
            function processKeywordPropErrors(kwdPropErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
              const templatesCode = [];
              for (const k in kwdPropErrors) {
                templatesCode.push([
                  k,
                  getTemplatesCode(kwdPropErrors[k], schema[k])
                ]);
              }
              const templates = gen.const("templates", gen.object(...templatesCode));
              const kwdPropParams = gen.scopeValue("obj", {
                ref: KEYWORD_PROPERTY_PARAMS,
                code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
              });
              const propParam = gen.let("emPropParams");
              const paramsErrors = gen.let("emParamsErrors");
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
                gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
                gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
              }));
              gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
                gen.if(ajv_1._`${paramsErrors}.length`, () => {
                  const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                  errors_1.reportError(cxt, {
                    message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                    params: ajv_1._`{errors: ${paramsErrors}}`
                  });
                });
              }));
            }
            function processChildErrors(childErrors) {
              const { props, items: items2 } = childErrors;
              if (!props && !items2)
                return;
              const isObj = ajv_1._`typeof ${data} == "object"`;
              const isArr = ajv_1._`Array.isArray(${data})`;
              const childErrs = gen.let("emErrors");
              let childKwd;
              let childProp;
              const templates = gen.let("templates");
              if (props && items2) {
                childKwd = gen.let("emChildKwd");
                gen.if(isObj);
                gen.if(isArr, () => {
                  init2(items2, schema.items);
                  gen.assign(childKwd, ajv_1.str`items`);
                }, () => {
                  init2(props, schema.properties);
                  gen.assign(childKwd, ajv_1.str`properties`);
                });
                childProp = ajv_1._`[${childKwd}]`;
              } else if (items2) {
                gen.if(isArr);
                init2(items2, schema.items);
                childProp = ajv_1._`.items`;
              } else if (props) {
                gen.if(codegen_1.and(isObj, codegen_1.not(isArr)));
                init2(props, schema.properties);
                childProp = ajv_1._`.properties`;
              }
              gen.forOf("err", names_1.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
                errors_1.reportError(cxt, {
                  message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                  params: ajv_1._`{errors: ${childErrs}[${key}]}`
                });
                gen.assign(ajv_1._`${names_1.default.vErrors}[${names_1.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
              }));
              gen.endIf();
              function init2(children, msgs) {
                gen.assign(childErrs, ajv_1.stringify(children));
                gen.assign(templates, getTemplatesCode(children, msgs));
              }
            }
            function processAllErrors(schMessage) {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.if(ajv_1._`${errs}.length`, () => errors_1.reportError(cxt, {
                message: templateExpr(schMessage),
                params: ajv_1._`{errors: ${errs}}`
              }));
            }
            function removeUsedErrors() {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
              gen.assign(names_1.default.vErrors, errs).assign(names_1.default.errors, ajv_1._`${errs}.length`);
            }
            function matchKeywordError(err, kwdErrs) {
              return codegen_1.and(
                ajv_1._`${err}.keyword !== ${keyword2}`,
                ajv_1._`!${err}.${used}`,
                ajv_1._`${err}.instancePath === ${instancePath}`,
                ajv_1._`${err}.keyword in ${kwdErrs}`,
                // TODO match the end of the string?
                ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,
                ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`
              );
            }
            function ifMatchesChildError(err, childErrs, thenBody) {
              gen.if(codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
                const childRegex = gen.scopeValue("pattern", {
                  ref: /^\/([^/]*)(?:\/|$)/,
                  code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
                });
                const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
                const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
                gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
              });
            }
            function matchAnyError(err) {
              return codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, codegen_1.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_1.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it.errSchemaPath}.length] === "/"`);
            }
            function getTemplatesCode(keys, msgs) {
              const templatesCode = [];
              for (const k in keys) {
                const msg = msgs[k];
                if (INTERPOLATION.test(msg))
                  templatesCode.push([k, templateFunc(msg)]);
              }
              return gen.object(...templatesCode);
            }
            function templateExpr(msg) {
              if (!INTERPOLATION.test(msg))
                return ajv_1.stringify(msg);
              return new code_1._Code(code_1.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_1.getData(ptr, it)}) + "`).replace(EMPTY_STR, ""));
            }
            function templateFunc(msg) {
              return ajv_1._`function(){return ${templateExpr(msg)}}`;
            }
          },
          metaSchema: {
            anyOf: [
              { type: "string" },
              {
                type: "object",
                properties: {
                  properties: { $ref: "#/$defs/stringMap" },
                  items: { $ref: "#/$defs/stringList" },
                  required: { $ref: "#/$defs/stringOrMap" },
                  dependencies: { $ref: "#/$defs/stringOrMap" }
                },
                additionalProperties: { type: "string" }
              }
            ],
            $defs: {
              stringMap: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              stringOrMap: {
                anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
              },
              stringList: { type: "array", items: { type: "string" } }
            }
          }
        };
      }
      const ajvErrors = (ajv2, options = {}) => {
        if (!ajv2.opts.allErrors)
          throw new Error("ajv-errors: Ajv option allErrors must be true");
        if (ajv2.opts.jsPropertySyntax) {
          throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
        }
        return ajv2.addKeyword(errorMessage(options));
      };
      exports.default = ajvErrors;
      module.exports = ajvErrors;
      module.exports.default = ajvErrors;
    })(dist, dist.exports);
    return dist.exports;
  }
  var distExports = requireDist();
  const addErrors = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
  class ValidatorService {
    constructor(options) {
      __publicField(this, "ajv");
      this.ajv = new Ajv({
        allErrors: true,
        useDefaults: "empty",
        verbose: true,
        validateFormats: true,
        strict: true,
        coerceTypes: true,
        ...options
      });
      console.log(this.ajv.schemas);
      addFormats(this.ajv);
      addErrors(this.ajv);
      this.ajv.addKeyword("nodeType");
    }
    createValidator(schema) {
      return this.ajv.compile(schema);
    }
    errors(errors2, options) {
      return this.ajv.errorsText(errors2, options);
    }
  }
  const validatorService = new ValidatorService();
  function createNodeRedVueApp(node, form, validator) {
    const app = createApp(NodeRedVueApp, {
      node,
      validator,
      disableSaveButtonOnError: form.disableSaveButtonOnError
    });
    app.component("NodeRedInput", NodeRedInput);
    app.component("NodeRedTypedInput", NodeRedTypedInput);
    app.component("NodeRedConfigInput", NodeRedConfigInput);
    app.component("NodeRedSelectInput", NodeRedSelectInput);
    app.component("NodeRedEditorInput", NodeRedEditorInput);
    app.component("NodeRedNodeForm", form.component);
    return app;
  }
  function mountApp(node, form, validator) {
    $$1("#app").empty();
    node._newState = cloneDeep(node);
    node._app = createNodeRedVueApp(node._newState, form, validator);
    node._app.mount("#app");
  }
  function unmountApp(node) {
    if (node._app) {
      node._app.unmount();
      node._app = null;
    }
  }
  function getNodeState(node) {
    const state = {
      credentials: {}
    };
    Object.keys(node._def.defaults).forEach((prop) => {
      state[prop] = node[prop];
    });
    Object.keys(node._def.credentials).forEach((prop) => {
      state.credentials[prop] = node.credentials[prop];
      if (node._def.credentials[prop].type === "password") {
        state.credentials[`has_${prop}`] = node.credentials[`has_${prop}`] || false;
      }
    });
    return state;
  }
  function getChanges(o, n) {
    const changes = {};
    Object.keys(o).forEach((prop) => {
      const _o = o[prop];
      const _n = n[prop];
      if (typeof _o === "object") {
        const _changes = getChanges(_o, _n);
        if (Object.keys(_changes).length) {
          changes[prop] = _changes;
        }
      } else if (!isEqual(_o, _n)) {
        changes[prop] = _o;
      }
    });
    return changes;
  }
  function defineNode(options) {
    return options;
  }
  async function registerType(type2, options) {
    try {
      const response = await fetch(`/nrg/nodes/${type2}`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const { schema } = await response.json();
      const defaults2 = getDefaultsFromSchema(schema);
      if (defaults2.credentials) delete defaults2.credentials;
      const credentials = getCredentialsFromSchema(schema.properties.credentials);
      console.log("defaults", defaults2);
      console.log("credentials", credentials);
      RED.nodes.registerType(type2, {
        ...options,
        defaults: defaults2,
        credentials,
        type: type2,
        label: function() {
          return this.name;
        },
        oneditprepare: function() {
          console.log("oneditprepare");
          console.log(this);
          const validator = validatorService.createValidator(schema);
          mountApp(this, options.form, validator);
        },
        oneditsave: function() {
          var _a;
          const node = this;
          unmountApp(node);
          const newState = getNodeState(node._newState);
          const oldState = getNodeState(node);
          const changes = getChanges(oldState, newState);
          const changed = !!((_a = Object.keys(changes)) == null ? void 0 : _a.length);
          if (!changed) return false;
          Object.keys(node._def.defaults).forEach((prop) => {
            var _a2, _b;
            if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
              const oldConfigNodeId = node[prop];
              const newConfigNodeId = node._newState[prop];
              if (oldConfigNodeId !== newConfigNodeId) {
                const oldConfigNode = RED.nodes.node(oldConfigNodeId);
                if (oldConfigNode && oldConfigNode._def.category === "config") {
                  const parentNodeIndex = oldConfigNode.users.findIndex(
                    (_node) => _node.id === node.id
                  );
                  if (parentNodeIndex !== -1) {
                    oldConfigNode.users.splice(parentNodeIndex, 1);
                  }
                }
              }
            }
          });
          Object.keys(node._def.defaults).forEach((prop) => {
            var _a2, _b;
            if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
              const newStateConfigNodeId = node._newState[prop];
              const newStateConfigNode = RED.nodes.node(newStateConfigNodeId);
              if (newStateConfigNode && newStateConfigNode._def.category === "config") {
                const parentNodeIndex = newStateConfigNode.users.findIndex(
                  (_node) => _node.id === node.id
                );
                if (parentNodeIndex === -1) {
                  newStateConfigNode.users.push(node);
                }
              }
            }
          });
          merge(node, newState);
          return {
            changed,
            history: [
              {
                t: "edit",
                node,
                changes,
                links: [],
                dirty: RED.nodes.dirty(),
                changed
              }
            ]
          };
        },
        oneditcancel: function() {
          unmountApp(this);
        },
        oneditdelete: function() {
          unmountApp(this);
        },
        onpaletteadd: options.onPaletteAdd,
        onpaltteremove: options.onPaletteRemove
      });
    } catch (error) {
      console.error(`Error fetching node type ${type2}:`, error);
      throw error;
    }
  }
  const _sfc_main$1 = {
    name: "NodeRedNodeForm",
    props: {
      node: {
        type: Object,
        required: true
      },
      errors: {
        type: Object,
        default: () => ({})
      }
    }
  };
  const _hoisted_1$1 = { class: "form-row" };
  const _hoisted_2$1 = { class: "form-row" };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedInput = resolveComponent("NodeRedInput");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1$1, [
        _cache[2] || (_cache[2] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Name")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.name,
          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.name = $event),
          error: $props.errors["node.name"],
          placeholder: "name"
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_2$1, [
        _cache[3] || (_cache[3] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Hostname")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.host,
          "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.host = $event),
          error: $props.errors["node.host"],
          placeholder: "hostname"
        }, null, 8, ["value", "error"])
      ])
    ]);
  }
  const component$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
  const remoteServer = defineNode({
    category: "config",
    color: "#a6bbcf",
    form: {
      component: component$1,
      disableSaveButtonOnError: true
    }
  });
  const logo = "data:image/png;base64,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";
  const _imports_0 = "/resources/red-vue-test/vue.png";
  const _sfc_main = {
    name: "NodeRedNodeForm",
    props: {
      node: {
        type: Object,
        required: true
      },
      errors: {
        type: Object,
        default: () => ({})
      }
    },
    data() {
      return {
        logo,
        types: ["str", "msg", "node"],
        countries: [
          { value: "usa", label: "usa" },
          { value: "argentina", label: "argentina" },
          { value: "brasil", label: "brasil" }
        ],
        fruits: [
          { value: "apple", label: "apple" },
          { value: "melon", label: "melon" },
          { value: "raspberry", label: "raspberry" }
        ],
        numbers: [
          { value: "1", label: "1" },
          { value: "2", label: "2" },
          { value: "3", label: "3" }
        ],
        objects: [
          { value: JSON.stringify({ test: "a" }), label: "a" },
          { value: JSON.stringify({ test: "b" }), label: "b" },
          { value: JSON.stringify({ test: "c" }), label: "c" }
        ],
        arrays: [
          { value: JSON.stringify(["a"]), label: "a" },
          { value: JSON.stringify(["b"]), label: "b" },
          { value: JSON.stringify(["c"]), label: "c" }
        ]
      };
    },
    mounted() {
      console.log("MOUNTED");
      console.log(this.logo);
    }
  };
  const _hoisted_1 = { class: "form-row" };
  const _hoisted_2 = { class: "form-row" };
  const _hoisted_3 = { class: "form-row" };
  const _hoisted_4 = { class: "form-row" };
  const _hoisted_5 = { class: "form-row" };
  const _hoisted_6 = { class: "form-row" };
  const _hoisted_7 = { class: "form-row" };
  const _hoisted_8 = { class: "form-row" };
  const _hoisted_9 = { class: "form-row" };
  const _hoisted_10 = { class: "form-row" };
  const _hoisted_11 = { class: "form-row" };
  const _hoisted_12 = { class: "form-row" };
  const _hoisted_13 = { class: "form-row" };
  const _hoisted_14 = { class: "form-row" };
  const _hoisted_15 = ["src"];
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedInput = resolveComponent("NodeRedInput");
    const _component_NodeRedTypedInput = resolveComponent("NodeRedTypedInput");
    const _component_NodeRedConfigInput = resolveComponent("NodeRedConfigInput");
    const _component_NodeRedSelectInput = resolveComponent("NodeRedSelectInput");
    const _component_NodeRedEditorInput = resolveComponent("NodeRedEditorInput");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1, [
        _cache[14] || (_cache[14] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Username")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.username,
          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.credentials.username = $event),
          error: $props.errors["node.credentials.username"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_2, [
        _cache[15] || (_cache[15] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Password")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.password,
          "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.credentials.password = $event),
          type: "password",
          error: $props.errors["node.credentials.password"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_3, [
        _cache[16] || (_cache[16] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Password 2")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.password2,
          "onUpdate:value": _cache[2] || (_cache[2] = ($event) => $props.node.credentials.password2 = $event),
          type: "password",
          error: $props.errors["node.credentials.password2"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_4, [
        _cache[17] || (_cache[17] = createBaseVNode("label", null, "Typed Input", -1)),
        createVNode(_component_NodeRedTypedInput, {
          value: $props.node.myProperty,
          "onUpdate:value": _cache[3] || (_cache[3] = ($event) => $props.node.myProperty = $event),
          types: $data.types,
          error: $props.errors["node.myProperty"]
        }, null, 8, ["value", "types", "error"])
      ]),
      createBaseVNode("div", _hoisted_5, [
        _cache[18] || (_cache[18] = createBaseVNode("label", null, "Typed Input 2", -1)),
        createVNode(_component_NodeRedTypedInput, {
          value: $props.node.myProperty2,
          "onUpdate:value": _cache[4] || (_cache[4] = ($event) => $props.node.myProperty2 = $event),
          error: $props.errors["node.myProperty2"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_6, [
        _cache[19] || (_cache[19] = createBaseVNode("label", null, "Config Input", -1)),
        createVNode(_component_NodeRedConfigInput, {
          value: $props.node.remoteServer,
          "onUpdate:value": _cache[5] || (_cache[5] = ($event) => $props.node.remoteServer = $event),
          type: "remote-server",
          error: $props.errors["node.remoteServer"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_7, [
        _cache[20] || (_cache[20] = createBaseVNode("label", null, "Config Input", -1)),
        createVNode(_component_NodeRedConfigInput, {
          value: $props.node.anotherRemoteServer,
          "onUpdate:value": _cache[6] || (_cache[6] = ($event) => $props.node.anotherRemoteServer = $event),
          type: "remote-server",
          error: $props.errors["node.anotherRemoteServer"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_8, [
        _cache[21] || (_cache[21] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.country,
          "onUpdate:value": _cache[7] || (_cache[7] = ($event) => $props.node.country = $event),
          options: $data.countries,
          error: $props.errors["node.country"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_9, [
        _cache[22] || (_cache[22] = createBaseVNode("label", null, "MultiSelect Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.fruit,
          "onUpdate:value": _cache[8] || (_cache[8] = ($event) => $props.node.fruit = $event),
          options: $data.fruits,
          multiple: "",
          error: $props.errors["node.fruit"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_10, [
        _cache[23] || (_cache[23] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.number,
          "onUpdate:value": _cache[9] || (_cache[9] = ($event) => $props.node.number = $event),
          options: $data.numbers,
          error: $props.errors["node.number"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_11, [
        _cache[24] || (_cache[24] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.object,
          "onUpdate:value": _cache[10] || (_cache[10] = ($event) => $props.node.object = $event),
          options: $data.objects,
          multiple: "",
          error: $props.errors["node.object"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_12, [
        _cache[25] || (_cache[25] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.array,
          "onUpdate:value": _cache[11] || (_cache[11] = ($event) => $props.node.array = $event),
          options: $data.arrays,
          error: $props.errors["node.array"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_13, [
        _cache[26] || (_cache[26] = createBaseVNode("label", null, "Editor with default height 200px and JSON", -1)),
        createVNode(_component_NodeRedEditorInput, {
          value: $props.node.jsontest,
          "onUpdate:value": _cache[12] || (_cache[12] = ($event) => $props.node.jsontest = $event),
          error: $props.errors["node.jsontest"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_14, [
        _cache[27] || (_cache[27] = createBaseVNode("label", null, "Editor with custom height and CSS", -1)),
        createVNode(_component_NodeRedEditorInput, {
          value: $props.node.csstest,
          "onUpdate:value": _cache[13] || (_cache[13] = ($event) => $props.node.csstest = $event),
          language: "css",
          style: { "height": "100px" },
          error: $props.errors["node.csstest"]
        }, null, 8, ["value", "error"])
      ]),
      _cache[28] || (_cache[28] = createBaseVNode("img", { src: _imports_0 }, null, -1)),
      createBaseVNode("img", {
        src: $data.logo,
        alt: "Logo"
      }, null, 8, _hoisted_15)
    ]);
  }
  const component = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
  const yourNode = defineNode({
    category: "function",
    color: "#FFFFFF",
    inputs: 1,
    outputs: 1,
    icon: "vue.png",
    form: {
      component,
      disableSaveButtonOnError: true
    },
    onPaletteAdd: () => {
      console.log("NODE TYPE REGISTERED ON THE PALETTE");
    }
  });
  async function init() {
    try {
      await Promise.all([
        registerType("remote-server", remoteServer),
        registerType("your-node", yourNode)
      ]);
      console.log("All node types registered in parallel");
    } catch (error) {
      console.error("Error registering node types:", error);
    }
  }
  (async function() {
    try {
      console.log("Running provided init");
      await init();
      console.log("Finished running provided init");
    } catch (error) {
      console.error("Error while running provided init:", error);
    }
  })();
})($);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNEQ3Q3dSUGQuanMiLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5lc20tYnVuZGxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvZnVuY3Rpb24vbm9vcC5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc1ByaW1pdGl2ZS5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc1R5cGVkQXJyYXkubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvX2ludGVybmFsL2dldFN5bWJvbHMubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvX2ludGVybmFsL2dldFRhZy5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC9faW50ZXJuYWwvdGFncy5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9jbG9uZURlZXBXaXRoLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L2Nsb25lRGVlcC5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc1BsYWluT2JqZWN0Lm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L21lcmdlLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L3V0aWwvZXEubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNFcXVhbFdpdGgubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNFcXVhbC5tanMiLCIuLi8uLi9zcmMvY29yZS91dGlscy50cyIsIi4uLy4uL25vZGVfbW9kdWxlcy9qc29ucG9pbnRlci9qc29ucG9pbnRlci5qcyIsIi4uLy4uL3NyYy9jb3JlL0FwcC52dWUiLCIuLi8uLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRJbnB1dC52dWUiLCIuLi8uLi9zcmMvY29yZS9jb25zdGFudHMudHMiLCIuLi8uLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRUeXBlZElucHV0LnZ1ZSIsIi4uLy4uL3NyYy9jb3JlL2NvbXBvbmVudHMvTm9kZVJlZENvbmZpZ0lucHV0LnZ1ZSIsIi4uLy4uL3NyYy9jb3JlL2NvbXBvbmVudHMvTm9kZVJlZFNlbGVjdElucHV0LnZ1ZSIsIi4uLy4uL3NyYy9jb3JlL2NvbXBvbmVudHMvTm9kZVJlZEVkaXRvcklucHV0LnZ1ZSIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vY29kZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vc2NvcGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL25hbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvZXJyb3JzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYm9vbFNjaGVtYS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3J1bGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYXBwbGljYWJpbGl0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9rZXl3b3JkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3Jlc29sdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZWZfZXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NvcGVkQ2hhcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY2hlbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdXJpLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9hanYtZXJyb3JzL2Rpc3QvaW5kZXguanMiLCIuLi8uLi9zcmMvY29yZS92YWxpZGF0b3Itc2VydmljZS50cyIsIi4uLy4uL3NyYy9jb3JlL3ZhbGlkYXRvci50cyIsIi4uLy4uL3NyYy9jb3JlL2luZGV4LnRzIiwiLi4vLi4vc3JjL25vZGVzL3JlbW90ZS1zZXJ2ZXIvRm9ybS52dWUiLCIuLi8uLi9zcmMvbm9kZXMvcmVtb3RlLXNlcnZlci9pbmRleC50cyIsIi4uLy4uL3NyYy9hc3NldHMvdnVlLnBuZyIsIi4uLy4uLy4uLy4uLy4uL3Z1ZS5wbmciLCIuLi8uLi9zcmMvbm9kZXMveW91ci1ub2RlL0Zvcm0udnVlIiwiLi4vLi4vc3JjL25vZGVzL3lvdXItbm9kZS9pbmRleC50cyIsIi4uLy4uL3NyYy9pbmRleC5jbGllbnQudHMiLCIuLi8uLi9zcmMvY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWtlTWFwKHN0cikge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygc3RyLnNwbGl0KFwiLFwiKSkgbWFwW2tleV0gPSAxO1xuICByZXR1cm4gKHZhbCkgPT4gdmFsIGluIG1hcDtcbn1cblxuY29uc3QgRU1QVFlfT0JKID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7XG59O1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gdXBwZXJjYXNlIGxldHRlclxuKGtleS5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IGtleS5jaGFyQ29kZUF0KDIpIDwgOTcpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblVwZGF0ZTpcIik7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIChpc09iamVjdCh2YWwpIHx8IGlzRnVuY3Rpb24odmFsKSkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiYga2V5ICE9PSBcIk5hTlwiICYmIGtleVswXSAhPT0gXCItXCIgJiYgXCJcIiArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcImJpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW9cIlxuKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChzdHIpID0+IHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgfTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH1cbik7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKVxuKTtcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIGNvbnN0IHMgPSBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGA7XG4gICAgcmV0dXJuIHM7XG4gIH1cbik7XG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCAuLi5hcmcpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBmbnNbaV0oLi4uYXJnKTtcbiAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSkgPyBgX19wcm9wcy4ke25hbWV9YCA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5mdW5jdGlvbiBnZW5DYWNoZUtleShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNvdXJjZSArIEpTT04uc3RyaW5naWZ5KFxuICAgIG9wdGlvbnMsXG4gICAgKF8sIHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsLnRvU3RyaW5nKCkgOiB2YWxcbiAgKTtcbn1cblxuY29uc3QgUGF0Y2hGbGFncyA9IHtcbiAgXCJURVhUXCI6IDEsXG4gIFwiMVwiOiBcIlRFWFRcIixcbiAgXCJDTEFTU1wiOiAyLFxuICBcIjJcIjogXCJDTEFTU1wiLFxuICBcIlNUWUxFXCI6IDQsXG4gIFwiNFwiOiBcIlNUWUxFXCIsXG4gIFwiUFJPUFNcIjogOCxcbiAgXCI4XCI6IFwiUFJPUFNcIixcbiAgXCJGVUxMX1BST1BTXCI6IDE2LFxuICBcIjE2XCI6IFwiRlVMTF9QUk9QU1wiLFxuICBcIk5FRURfSFlEUkFUSU9OXCI6IDMyLFxuICBcIjMyXCI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgXCJTVEFCTEVfRlJBR01FTlRcIjogNjQsXG4gIFwiNjRcIjogXCJTVEFCTEVfRlJBR01FTlRcIixcbiAgXCJLRVlFRF9GUkFHTUVOVFwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiS0VZRURfRlJBR01FTlRcIixcbiAgXCJVTktFWUVEX0ZSQUdNRU5UXCI6IDI1NixcbiAgXCIyNTZcIjogXCJVTktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiTkVFRF9QQVRDSFwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiTkVFRF9QQVRDSFwiLFxuICBcIkRZTkFNSUNfU0xPVFNcIjogMTAyNCxcbiAgXCIxMDI0XCI6IFwiRFlOQU1JQ19TTE9UU1wiLFxuICBcIkRFVl9ST09UX0ZSQUdNRU5UXCI6IDIwNDgsXG4gIFwiMjA0OFwiOiBcIkRFVl9ST09UX0ZSQUdNRU5UXCIsXG4gIFwiQ0FDSEVEXCI6IC0xLFxuICBcIi0xXCI6IFwiQ0FDSEVEXCIsXG4gIFwiQkFJTFwiOiAtMixcbiAgXCItMlwiOiBcIkJBSUxcIlxufTtcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICBbMV06IGBURVhUYCxcbiAgWzJdOiBgQ0xBU1NgLFxuICBbNF06IGBTVFlMRWAsXG4gIFs4XTogYFBST1BTYCxcbiAgWzE2XTogYEZVTExfUFJPUFNgLFxuICBbMzJdOiBgTkVFRF9IWURSQVRJT05gLFxuICBbNjRdOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gIFs1MTJdOiBgTkVFRF9QQVRDSGAsXG4gIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gIFstMV06IGBIT0lTVEVEYCxcbiAgWy0yXTogYEJBSUxgXG59O1xuXG5jb25zdCBTaGFwZUZsYWdzID0ge1xuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCI6IDIsXG4gIFwiMlwiOiBcIkZVTkNUSU9OQUxfQ09NUE9ORU5UXCIsXG4gIFwiU1RBVEVGVUxfQ09NUE9ORU5UXCI6IDQsXG4gIFwiNFwiOiBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiLFxuICBcIlRFWFRfQ0hJTERSRU5cIjogOCxcbiAgXCI4XCI6IFwiVEVYVF9DSElMRFJFTlwiLFxuICBcIkFSUkFZX0NISUxEUkVOXCI6IDE2LFxuICBcIjE2XCI6IFwiQVJSQVlfQ0hJTERSRU5cIixcbiAgXCJTTE9UU19DSElMRFJFTlwiOiAzMixcbiAgXCIzMlwiOiBcIlNMT1RTX0NISUxEUkVOXCIsXG4gIFwiVEVMRVBPUlRcIjogNjQsXG4gIFwiNjRcIjogXCJURUxFUE9SVFwiLFxuICBcIlNVU1BFTlNFXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJTVVNQRU5TRVwiLFxuICBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIjogNTEyLFxuICBcIjUxMlwiOiBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCIsXG4gIFwiQ09NUE9ORU5UXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVFwiXG59O1xuXG5jb25zdCBTbG90RmxhZ3MgPSB7XG4gIFwiU1RBQkxFXCI6IDEsXG4gIFwiMVwiOiBcIlNUQUJMRVwiLFxuICBcIkRZTkFNSUNcIjogMixcbiAgXCIyXCI6IFwiRFlOQU1JQ1wiLFxuICBcIkZPUldBUkRFRFwiOiAzLFxuICBcIjNcIjogXCJGT1JXQVJERURcIlxufTtcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gIFsxXTogXCJTVEFCTEVcIixcbiAgWzJdOiBcIkRZTkFNSUNcIixcbiAgWzNdOiBcIkZPUldBUkRFRFwiXG59O1xuXG5jb25zdCBHTE9CQUxTX0FMTE9XRUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yLFN5bWJvbFwiO1xuY29uc3QgaXNHbG9iYWxseUFsbG93ZWQgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChHTE9CQUxTX0FMTE9XRUQpO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseUFsbG93ZWQ7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBzb3VyY2UubGVuZ3RoKSk7XG4gIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFwiXCI7XG4gIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoIHx8IDApO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBpZiAoIXN0eWxlcykgcmV0dXJuIFwiXCI7XG4gIGlmIChpc1N0cmluZyhzdHlsZXMpKSByZXR1cm4gc3R5bGVzO1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmVzID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgcmVzICs9IG5hbWUgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBNQVRIX1RBR1MgPSBcImFubm90YXRpb24sYW5ub3RhdGlvbi14bWwsbWFjdGlvbixtYWxpZ25ncm91cCxtYWxpZ25tYXJrLG1hdGgsbWVuY2xvc2UsbWVycm9yLG1mZW5jZWQsbWZyYWMsbWZyYWN0aW9uLG1nbHlwaCxtaSxtbGFiZWxlZHRyLG1sb25nZGl2LG1tdWx0aXNjcmlwdHMsbW4sbW8sbW92ZXIsbXBhZGRlZCxtcGhhbnRvbSxtcHJlc2NyaXB0cyxtcm9vdCxtcm93LG1zLG1zY2Fycmllcyxtc2NhcnJ5LG1zZ3JvdXAsbXNsaW5lLG1zcGFjZSxtc3FydCxtc3Jvdyxtc3RhY2ssbXN0eWxlLG1zdWIsbXN1YnN1cCxtc3VwLG10YWJsZSxtdGQsbXRleHQsbXRyLG11bmRlcixtdW5kZXJvdmVyLG5vbmUsc2VtYW50aWNzXCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc01hdGhNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKE1BVEhfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWxuczp4bGluayx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5jb25zdCBpc0tub3duTWF0aE1MQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZW50LGFjY2VudHVuZGVyLGFjdGlvbnR5cGUsYWxpZ24sYWxpZ25tZW50c2NvcGUsYWx0aW1nLGFsdGltZy1oZWlnaHQsYWx0aW1nLXZhbGlnbixhbHRpbWctd2lkdGgsYWx0dGV4dCxiZXZlbGxlZCxjbG9zZSxjb2x1bW5zYWxpZ24sY29sdW1ubGluZXMsY29sdW1uc3BhbixkZW5vbWFsaWduLGRlcHRoLGRpcixkaXNwbGF5LGRpc3BsYXlzdHlsZSxlbmNvZGluZyxlcXVhbGNvbHVtbnMsZXF1YWxyb3dzLGZlbmNlLGZvbnRzdHlsZSxmb250d2VpZ2h0LGZvcm0sZnJhbWUsZnJhbWVzcGFjaW5nLGdyb3VwYWxpZ24saGVpZ2h0LGhyZWYsaWQsaW5kZW50YWxpZ24saW5kZW50YWxpZ25maXJzdCxpbmRlbnRhbGlnbmxhc3QsaW5kZW50c2hpZnQsaW5kZW50c2hpZnRmaXJzdCxpbmRlbnRzaGlmdGxhc3QsaW5kZXh0eXBlLGp1c3RpZnksbGFyZ2V0b3AsbGFyZ2VvcCxscXVvdGUsbHNwYWNlLG1hdGhiYWNrZ3JvdW5kLG1hdGhjb2xvcixtYXRoc2l6ZSxtYXRodmFyaWFudCxtYXhzaXplLG1pbmxhYmVsc3BhY2luZyxtb2RlLG90aGVyLG92ZXJmbG93LHBvc2l0aW9uLHJvd2FsaWduLHJvd2xpbmVzLHJvd3NwYW4scnF1b3RlLHJzcGFjZSxzY3JpcHRsZXZlbCxzY3JpcHRtaW5zaXplLHNjcmlwdHNpemVtdWx0aXBsaWVyLHNlbGVjdGlvbixzZXBhcmF0b3Isc2VwYXJhdG9ycyxzaGlmdCxzaWRlLHNyYyxzdGFja2FsaWduLHN0cmV0Y2h5LHN1YnNjcmlwdHNoaWZ0LHN1cGVyc2NyaXB0c2hpZnQsc3ltbWV0cmljLHZvZmZzZXQsd2lkdGgsd2lkdGhzLHhsaW5rOmhyZWYseGxpbms6c2hvdyx4bGluazp0eXBlLHhtbG5zYFxuKTtcbmZ1bmN0aW9uIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiO1xufVxuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBsZXQgZXNjYXBlZDtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xufVxuY29uc3QgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSA9IC9bICFcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXV5ge3x9fl0vZztcbmZ1bmN0aW9uIGdldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZG91YmxlRXNjYXBlKSB7XG4gIHJldHVybiBrZXkucmVwbGFjZShcbiAgICBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFLFxuICAgIChzKSA9PiBkb3VibGVFc2NhcGUgPyBzID09PSAnXCInID8gJ1xcXFxcXFxcXFxcXFwiJyA6IGBcXFxcXFxcXCR7c31gIDogYFxcXFwke3N9YFxuICApO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGxldCBlcXVhbCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgfVxuICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IGlzUmVmID0gKHZhbCkgPT4ge1xuICByZXR1cm4gISEodmFsICYmIHZhbFtcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSk7XG59O1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGlzQXJyYXkodmFsKSB8fCBpc09iamVjdCh2YWwpICYmICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpID8gaXNSZWYodmFsKSA/IHRvRGlzcGxheVN0cmluZyh2YWwudmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKFxuICAgICAgICAoZW50cmllcywgW2tleSwgdmFsMl0sIGkpID0+IHtcbiAgICAgICAgICBlbnRyaWVzW3N0cmluZ2lmeVN5bWJvbChrZXksIGkpICsgXCIgPT5cIl0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV0ubWFwKCh2KSA9PiBzdHJpbmdpZnlTeW1ib2wodikpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1N5bWJvbCh2YWwpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN5bWJvbCh2YWwpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuY29uc3Qgc3RyaW5naWZ5U3ltYm9sID0gKHYsIGkgPSBcIlwiKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChcbiAgICAvLyBTeW1ib2wuZGVzY3JpcHRpb24gaW4gZXMyMDE5KyBzbyB3ZSBuZWVkIHRvIGNhc3QgaGVyZSB0byBwYXNzXG4gICAgLy8gdGhlIGxpYjogZXMyMDE2IGNoZWNrXG4gICAgaXNTeW1ib2wodikgPyBgU3ltYm9sKCR7KF9hID0gdi5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hIDogaX0pYCA6IHZcbiAgKTtcbn07XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIFBhdGNoRmxhZ3MsIFNoYXBlRmxhZ3MsIFNsb3RGbGFncywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuQ2FjaGVLZXksIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseUFsbG93ZWQsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93bk1hdGhNTEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNYXRoTUxUYWcsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIi8qKlxuKiBAdnVlL3JlYWN0aXZpdHkgdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgaGFzQ2hhbmdlZCwgZXh0ZW5kLCBpc0FycmF5LCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBpc01hcCwgaGFzT3duLCBpc09iamVjdCwgbWFrZU1hcCwgdG9SYXdUeXBlLCBjYXBpdGFsaXplLCBkZWYsIGlzRnVuY3Rpb24sIEVNUFRZX09CSiwgaXNTZXQsIGlzUGxhaW5PYmplY3QsIE5PT1AsIHJlbW92ZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnfWAsIC4uLmFyZ3MpO1xufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XG5jbGFzcyBFZmZlY3RTY29wZSB7XG4gIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgIHRoaXMuaW5kZXggPSAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICAgIHRoaXNcbiAgICAgICkgLSAxO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyB0aGUgZWZmZWN0IHNjb3BlLCBpbmNsdWRpbmcgYWxsIGNoaWxkIHNjb3BlcyBhbmQgZWZmZWN0cy5cbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGksIGw7XG4gICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBydW4oZm4pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xuICB9XG4gIHN0b3AoZnJvbVBhcmVudCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhbnVwcy5sZW5ndGggPSAwO1xuICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NvcGVzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSkge1xuICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbn1cblxubGV0IGFjdGl2ZVN1YjtcbmNvbnN0IEVmZmVjdEZsYWdzID0ge1xuICBcIkFDVElWRVwiOiAxLFxuICBcIjFcIjogXCJBQ1RJVkVcIixcbiAgXCJSVU5OSU5HXCI6IDIsXG4gIFwiMlwiOiBcIlJVTk5JTkdcIixcbiAgXCJUUkFDS0lOR1wiOiA0LFxuICBcIjRcIjogXCJUUkFDS0lOR1wiLFxuICBcIk5PVElGSUVEXCI6IDgsXG4gIFwiOFwiOiBcIk5PVElGSUVEXCIsXG4gIFwiRElSVFlcIjogMTYsXG4gIFwiMTZcIjogXCJESVJUWVwiLFxuICBcIkFMTE9XX1JFQ1VSU0VcIjogMzIsXG4gIFwiMzJcIjogXCJBTExPV19SRUNVUlNFXCIsXG4gIFwiUEFVU0VEXCI6IDY0LFxuICBcIjY0XCI6IFwiUEFVU0VEXCJcbn07XG5jb25zdCBwYXVzZWRRdWV1ZUVmZmVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgY29uc3RydWN0b3IoZm4pIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDEgfCA0O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXAgPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSB2b2lkIDA7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlICYmIGFjdGl2ZUVmZmVjdFNjb3BlLmFjdGl2ZSkge1xuICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmZsYWdzIHw9IDY0O1xuICB9XG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICB0aGlzLmZsYWdzICY9IH42NDtcbiAgICAgIGlmIChwYXVzZWRRdWV1ZUVmZmVjdHMuaGFzKHRoaXMpKSB7XG4gICAgICAgIHBhdXNlZFF1ZXVlRWZmZWN0cy5kZWxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAyICYmICEodGhpcy5mbGFncyAmIDMyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0aGlzLmZsYWdzICYgOCkpIHtcbiAgICAgIGJhdGNoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBydW4oKSB7XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH1cbiAgICB0aGlzLmZsYWdzIHw9IDI7XG4gICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICBwcmVwYXJlRGVwcyh0aGlzKTtcbiAgICBjb25zdCBwcmV2RWZmZWN0ID0gYWN0aXZlU3ViO1xuICAgIGNvbnN0IHByZXZTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xuICAgIGFjdGl2ZVN1YiA9IHRoaXM7XG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVTdWIgIT09IHRoaXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkFjdGl2ZSBlZmZlY3Qgd2FzIG5vdCByZXN0b3JlZCBjb3JyZWN0bHkgLSB0aGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbCBidWcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNsZWFudXBEZXBzKHRoaXMpO1xuICAgICAgYWN0aXZlU3ViID0gcHJldkVmZmVjdDtcbiAgICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgICAgdGhpcy5mbGFncyAmPSB+MjtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDEpIHtcbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICAgICAgcmVtb3ZlU3ViKGxpbmspO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXBzID0gdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcbiAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICB0aGlzLm9uU3RvcCAmJiB0aGlzLm9uU3RvcCgpO1xuICAgICAgdGhpcy5mbGFncyAmPSB+MTtcbiAgICB9XG4gIH1cbiAgdHJpZ2dlcigpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuYWRkKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVuSWZEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBydW5JZkRpcnR5KCkge1xuICAgIGlmIChpc0RpcnR5KHRoaXMpKSB7XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH1cbiAgfVxuICBnZXQgZGlydHkoKSB7XG4gICAgcmV0dXJuIGlzRGlydHkodGhpcyk7XG4gIH1cbn1cbmxldCBiYXRjaERlcHRoID0gMDtcbmxldCBiYXRjaGVkU3ViO1xubGV0IGJhdGNoZWRDb21wdXRlZDtcbmZ1bmN0aW9uIGJhdGNoKHN1YiwgaXNDb21wdXRlZCA9IGZhbHNlKSB7XG4gIHN1Yi5mbGFncyB8PSA4O1xuICBpZiAoaXNDb21wdXRlZCkge1xuICAgIHN1Yi5uZXh0ID0gYmF0Y2hlZENvbXB1dGVkO1xuICAgIGJhdGNoZWRDb21wdXRlZCA9IHN1YjtcbiAgICByZXR1cm47XG4gIH1cbiAgc3ViLm5leHQgPSBiYXRjaGVkU3ViO1xuICBiYXRjaGVkU3ViID0gc3ViO1xufVxuZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgYmF0Y2hEZXB0aCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gIGlmICgtLWJhdGNoRGVwdGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChiYXRjaGVkQ29tcHV0ZWQpIHtcbiAgICBsZXQgZSA9IGJhdGNoZWRDb21wdXRlZDtcbiAgICBiYXRjaGVkQ29tcHV0ZWQgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XG4gICAgICBlLm5leHQgPSB2b2lkIDA7XG4gICAgICBlLmZsYWdzICY9IH44O1xuICAgICAgZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIGxldCBlcnJvcjtcbiAgd2hpbGUgKGJhdGNoZWRTdWIpIHtcbiAgICBsZXQgZSA9IGJhdGNoZWRTdWI7XG4gICAgYmF0Y2hlZFN1YiA9IHZvaWQgMDtcbiAgICB3aGlsZSAoZSkge1xuICAgICAgY29uc3QgbmV4dCA9IGUubmV4dDtcbiAgICAgIGUubmV4dCA9IHZvaWQgMDtcbiAgICAgIGUuZmxhZ3MgJj0gfjg7XG4gICAgICBpZiAoZS5mbGFncyAmIDEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZS50cmlnZ2VyKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVEZXBzKHN1Yikge1xuICBmb3IgKGxldCBsaW5rID0gc3ViLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICBsaW5rLnZlcnNpb24gPSAtMTtcbiAgICBsaW5rLnByZXZBY3RpdmVMaW5rID0gbGluay5kZXAuYWN0aXZlTGluaztcbiAgICBsaW5rLmRlcC5hY3RpdmVMaW5rID0gbGluaztcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW51cERlcHMoc3ViKSB7XG4gIGxldCBoZWFkO1xuICBsZXQgdGFpbCA9IHN1Yi5kZXBzVGFpbDtcbiAgbGV0IGxpbmsgPSB0YWlsO1xuICB3aGlsZSAobGluaykge1xuICAgIGNvbnN0IHByZXYgPSBsaW5rLnByZXZEZXA7XG4gICAgaWYgKGxpbmsudmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgIGlmIChsaW5rID09PSB0YWlsKSB0YWlsID0gcHJldjtcbiAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIHJlbW92ZURlcChsaW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGxpbms7XG4gICAgfVxuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rLnByZXZBY3RpdmVMaW5rO1xuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gICAgbGluayA9IHByZXY7XG4gIH1cbiAgc3ViLmRlcHMgPSBoZWFkO1xuICBzdWIuZGVwc1RhaWwgPSB0YWlsO1xufVxuZnVuY3Rpb24gaXNEaXJ0eShzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgaWYgKGxpbmsuZGVwLnZlcnNpb24gIT09IGxpbmsudmVyc2lvbiB8fCBsaW5rLmRlcC5jb21wdXRlZCAmJiAocmVmcmVzaENvbXB1dGVkKGxpbmsuZGVwLmNvbXB1dGVkKSB8fCBsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHN1Yi5fZGlydHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWZyZXNoQ29tcHV0ZWQoY29tcHV0ZWQpIHtcbiAgaWYgKGNvbXB1dGVkLmZsYWdzICYgNCAmJiAhKGNvbXB1dGVkLmZsYWdzICYgMTYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmZsYWdzICY9IH4xNjtcbiAgaWYgKGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPT09IGdsb2JhbFZlcnNpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb247XG4gIGNvbnN0IGRlcCA9IGNvbXB1dGVkLmRlcDtcbiAgY29tcHV0ZWQuZmxhZ3MgfD0gMjtcbiAgaWYgKGRlcC52ZXJzaW9uID4gMCAmJiAhY29tcHV0ZWQuaXNTU1IgJiYgY29tcHV0ZWQuZGVwcyAmJiAhaXNEaXJ0eShjb21wdXRlZCkpIHtcbiAgICBjb21wdXRlZC5mbGFncyAmPSB+MjtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJldlN1YiA9IGFjdGl2ZVN1YjtcbiAgY29uc3QgcHJldlNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gIGFjdGl2ZVN1YiA9IGNvbXB1dGVkO1xuICBzaG91bGRUcmFjayA9IHRydWU7XG4gIHRyeSB7XG4gICAgcHJlcGFyZURlcHMoY29tcHV0ZWQpO1xuICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWQuZm4oY29tcHV0ZWQuX3ZhbHVlKTtcbiAgICBpZiAoZGVwLnZlcnNpb24gPT09IDAgfHwgaGFzQ2hhbmdlZCh2YWx1ZSwgY29tcHV0ZWQuX3ZhbHVlKSkge1xuICAgICAgY29tcHV0ZWQuX3ZhbHVlID0gdmFsdWU7XG4gICAgICBkZXAudmVyc2lvbisrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVwLnZlcnNpb24rKztcbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZlU3ViID0gcHJldlN1YjtcbiAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcbiAgICBjbGVhbnVwRGVwcyhjb21wdXRlZCk7XG4gICAgY29tcHV0ZWQuZmxhZ3MgJj0gfjI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVN1YihsaW5rLCBzb2Z0ID0gZmFsc2UpIHtcbiAgY29uc3QgeyBkZXAsIHByZXZTdWIsIG5leHRTdWIgfSA9IGxpbms7XG4gIGlmIChwcmV2U3ViKSB7XG4gICAgcHJldlN1Yi5uZXh0U3ViID0gbmV4dFN1YjtcbiAgICBsaW5rLnByZXZTdWIgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHRTdWIpIHtcbiAgICBuZXh0U3ViLnByZXZTdWIgPSBwcmV2U3ViO1xuICAgIGxpbmsubmV4dFN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZXAuc3Vic0hlYWQgPT09IGxpbmspIHtcbiAgICBkZXAuc3Vic0hlYWQgPSBuZXh0U3ViO1xuICB9XG4gIGlmIChkZXAuc3VicyA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzID0gcHJldlN1YjtcbiAgICBpZiAoIXByZXZTdWIgJiYgZGVwLmNvbXB1dGVkKSB7XG4gICAgICBkZXAuY29tcHV0ZWQuZmxhZ3MgJj0gfjQ7XG4gICAgICBmb3IgKGxldCBsID0gZGVwLmNvbXB1dGVkLmRlcHM7IGw7IGwgPSBsLm5leHREZXApIHtcbiAgICAgICAgcmVtb3ZlU3ViKGwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXNvZnQgJiYgIS0tZGVwLnNjICYmIGRlcC5tYXApIHtcbiAgICBkZXAubWFwLmRlbGV0ZShkZXAua2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRGVwKGxpbmspIHtcbiAgY29uc3QgeyBwcmV2RGVwLCBuZXh0RGVwIH0gPSBsaW5rO1xuICBpZiAocHJldkRlcCkge1xuICAgIHByZXZEZXAubmV4dERlcCA9IG5leHREZXA7XG4gICAgbGluay5wcmV2RGVwID0gdm9pZCAwO1xuICB9XG4gIGlmIChuZXh0RGVwKSB7XG4gICAgbmV4dERlcC5wcmV2RGVwID0gcHJldkRlcDtcbiAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xuICBpZiAoZm4uZWZmZWN0IGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcbiAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgfVxuICBjb25zdCBlID0gbmV3IFJlYWN0aXZlRWZmZWN0KGZuKTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQoZSwgb3B0aW9ucyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBlLnJ1bigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlLnN0b3AoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY29uc3QgcnVubmVyID0gZS5ydW4uYmluZChlKTtcbiAgcnVubmVyLmVmZmVjdCA9IGU7XG4gIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBzaG91bGRUcmFjayA9IHRydWU7XG5jb25zdCB0cmFja1N0YWNrID0gW107XG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XG4gIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xufVxuZnVuY3Rpb24gb25FZmZlY3RDbGVhbnVwKGZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSkge1xuICBpZiAoYWN0aXZlU3ViIGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcbiAgICBhY3RpdmVTdWIuY2xlYW51cCA9IGZuO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25FZmZlY3RDbGVhbnVwKCkgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBhY3RpdmUgZWZmZWN0IHRvIGFzc29jaWF0ZSB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGUpIHtcbiAgY29uc3QgeyBjbGVhbnVwIH0gPSBlO1xuICBlLmNsZWFudXAgPSB2b2lkIDA7XG4gIGlmIChjbGVhbnVwKSB7XG4gICAgY29uc3QgcHJldlN1YiA9IGFjdGl2ZVN1YjtcbiAgICBhY3RpdmVTdWIgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWN0aXZlU3ViID0gcHJldlN1YjtcbiAgICB9XG4gIH1cbn1cblxubGV0IGdsb2JhbFZlcnNpb24gPSAwO1xuY2xhc3MgTGluayB7XG4gIGNvbnN0cnVjdG9yKHN1YiwgZGVwKSB7XG4gICAgdGhpcy5zdWIgPSBzdWI7XG4gICAgdGhpcy5kZXAgPSBkZXA7XG4gICAgdGhpcy52ZXJzaW9uID0gZGVwLnZlcnNpb247XG4gICAgdGhpcy5uZXh0RGVwID0gdGhpcy5wcmV2RGVwID0gdGhpcy5uZXh0U3ViID0gdGhpcy5wcmV2U3ViID0gdGhpcy5wcmV2QWN0aXZlTGluayA9IHZvaWQgMDtcbiAgfVxufVxuY2xhc3MgRGVwIHtcbiAgY29uc3RydWN0b3IoY29tcHV0ZWQpIHtcbiAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBMaW5rIGJldHdlZW4gdGhpcyBkZXAgYW5kIHRoZSBjdXJyZW50IGFjdGl2ZSBlZmZlY3RcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogRG91Ymx5IGxpbmtlZCBsaXN0IHJlcHJlc2VudGluZyB0aGUgc3Vic2NyaWJpbmcgZWZmZWN0cyAodGFpbClcbiAgICAgKi9cbiAgICB0aGlzLnN1YnMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogRm9yIG9iamVjdCBwcm9wZXJ0eSBkZXBzIGNsZWFudXBcbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVyIGNvdW50ZXJcbiAgICAgKi9cbiAgICB0aGlzLnNjID0gMDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5zdWJzSGVhZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgdHJhY2soZGVidWdJbmZvKSB7XG4gICAgaWYgKCFhY3RpdmVTdWIgfHwgIXNob3VsZFRyYWNrIHx8IGFjdGl2ZVN1YiA9PT0gdGhpcy5jb21wdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbGluayA9IHRoaXMuYWN0aXZlTGluaztcbiAgICBpZiAobGluayA9PT0gdm9pZCAwIHx8IGxpbmsuc3ViICE9PSBhY3RpdmVTdWIpIHtcbiAgICAgIGxpbmsgPSB0aGlzLmFjdGl2ZUxpbmsgPSBuZXcgTGluayhhY3RpdmVTdWIsIHRoaXMpO1xuICAgICAgaWYgKCFhY3RpdmVTdWIuZGVwcykge1xuICAgICAgICBhY3RpdmVTdWIuZGVwcyA9IGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5rLnByZXZEZXAgPSBhY3RpdmVTdWIuZGVwc1RhaWw7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH1cbiAgICAgIGFkZFN1YihsaW5rKTtcbiAgICB9IGVsc2UgaWYgKGxpbmsudmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGlmIChsaW5rLm5leHREZXApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxpbmsubmV4dERlcDtcbiAgICAgICAgbmV4dC5wcmV2RGVwID0gbGluay5wcmV2RGVwO1xuICAgICAgICBpZiAobGluay5wcmV2RGVwKSB7XG4gICAgICAgICAgbGluay5wcmV2RGVwLm5leHREZXAgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgbGluay5uZXh0RGVwID0gdm9pZCAwO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwubmV4dERlcCA9IGxpbms7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICAgIGlmIChhY3RpdmVTdWIuZGVwcyA9PT0gbGluaykge1xuICAgICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVTdWIub25UcmFjaykge1xuICAgICAgYWN0aXZlU3ViLm9uVHJhY2soXG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZVN1YlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVidWdJbmZvXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBsaW5rO1xuICB9XG4gIHRyaWdnZXIoZGVidWdJbmZvKSB7XG4gICAgdGhpcy52ZXJzaW9uKys7XG4gICAgZ2xvYmFsVmVyc2lvbisrO1xuICAgIHRoaXMubm90aWZ5KGRlYnVnSW5mbyk7XG4gIH1cbiAgbm90aWZ5KGRlYnVnSW5mbykge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB0cnkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZm9yIChsZXQgaGVhZCA9IHRoaXMuc3Vic0hlYWQ7IGhlYWQ7IGhlYWQgPSBoZWFkLm5leHRTdWIpIHtcbiAgICAgICAgICBpZiAoaGVhZC5zdWIub25UcmlnZ2VyICYmICEoaGVhZC5zdWIuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgaGVhZC5zdWIub25UcmlnZ2VyKFxuICAgICAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWZmZWN0OiBoZWFkLnN1YlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5zdWJzOyBsaW5rOyBsaW5rID0gbGluay5wcmV2U3ViKSB7XG4gICAgICAgIGlmIChsaW5rLnN1Yi5ub3RpZnkoKSkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBsaW5rLnN1Yi5kZXAubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFN1YihsaW5rKSB7XG4gIGxpbmsuZGVwLnNjKys7XG4gIGlmIChsaW5rLnN1Yi5mbGFncyAmIDQpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IGxpbmsuZGVwLmNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCAmJiAhbGluay5kZXAuc3Vicykge1xuICAgICAgY29tcHV0ZWQuZmxhZ3MgfD0gNCB8IDE2O1xuICAgICAgZm9yIChsZXQgbCA9IGNvbXB1dGVkLmRlcHM7IGw7IGwgPSBsLm5leHREZXApIHtcbiAgICAgICAgYWRkU3ViKGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGFpbCA9IGxpbmsuZGVwLnN1YnM7XG4gICAgaWYgKGN1cnJlbnRUYWlsICE9PSBsaW5rKSB7XG4gICAgICBsaW5rLnByZXZTdWIgPSBjdXJyZW50VGFpbDtcbiAgICAgIGlmIChjdXJyZW50VGFpbCkgY3VycmVudFRhaWwubmV4dFN1YiA9IGxpbms7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGxpbmsuZGVwLnN1YnNIZWFkID09PSB2b2lkIDApIHtcbiAgICAgIGxpbmsuZGVwLnN1YnNIZWFkID0gbGluaztcbiAgICB9XG4gICAgbGluay5kZXAuc3VicyA9IGxpbms7XG4gIH1cbn1cbmNvbnN0IHRhcmdldE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk9iamVjdCBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiTWFwIGtleXMgaXRlcmF0ZVwiIDogXCJcIlxuKTtcbmNvbnN0IEFSUkFZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJBcnJheSBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZVN1Yikge1xuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gbmV3IERlcCgpKTtcbiAgICAgIGRlcC5tYXAgPSBkZXBzTWFwO1xuICAgICAgZGVwLmtleSA9IGtleTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGRlcC50cmFjayh7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVwLnRyYWNrKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xuICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJ1biA9IChkZXApID0+IHtcbiAgICBpZiAoZGVwKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBkZXAudHJpZ2dlcih7XG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgIG9sZFRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcC50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGFydEJhdGNoKCk7XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzTWFwLmZvckVhY2gocnVuKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGNvbnN0IGlzQXJyYXlJbmRleCA9IHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSk7XG4gICAgaWYgKHRhcmdldElzQXJyYXkgJiYga2V5ID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleTIpID0+IHtcbiAgICAgICAgaWYgKGtleTIgPT09IFwibGVuZ3RoXCIgfHwga2V5MiA9PT0gQVJSQVlfSVRFUkFURV9LRVkgfHwgIWlzU3ltYm9sKGtleTIpICYmIGtleTIgPj0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgcnVuKGRlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5ICE9PSB2b2lkIDAgfHwgZGVwc01hcC5oYXModm9pZCAwKSkge1xuICAgICAgICBydW4oZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgIHJ1bihkZXBzTWFwLmdldChBUlJBWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlJbmRleCkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbmRCYXRjaCgpO1xufVxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XG4gIGNvbnN0IGRlcE1hcCA9IHRhcmdldE1hcC5nZXQob2JqZWN0KTtcbiAgcmV0dXJuIGRlcE1hcCAmJiBkZXBNYXAuZ2V0KGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0aXZlUmVhZEFycmF5KGFycmF5KSB7XG4gIGNvbnN0IHJhdyA9IHRvUmF3KGFycmF5KTtcbiAgaWYgKHJhdyA9PT0gYXJyYXkpIHJldHVybiByYXc7XG4gIHRyYWNrKHJhdywgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGlzU2hhbGxvdyhhcnJheSkgPyByYXcgOiByYXcubWFwKHRvUmVhY3RpdmUpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRBcnJheShhcnIpIHtcbiAgdHJhY2soYXJyID0gdG9SYXcoYXJyKSwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgU3ltYm9sLml0ZXJhdG9yLCB0b1JlYWN0aXZlKTtcbiAgfSxcbiAgY29uY2F0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuY29uY2F0KFxuICAgICAgLi4uYXJncy5tYXAoKHgpID0+IGlzQXJyYXkoeCkgPyByZWFjdGl2ZVJlYWRBcnJheSh4KSA6IHgpXG4gICAgKTtcbiAgfSxcbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgXCJlbnRyaWVzXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgdmFsdWVbMV0gPSB0b1JlYWN0aXZlKHZhbHVlWzFdKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSxcbiAgZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJldmVyeVwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaWx0ZXIoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaWx0ZXJcIiwgZm4sIHRoaXNBcmcsICh2KSA9PiB2Lm1hcCh0b1JlYWN0aXZlKSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRcIiwgZm4sIHRoaXNBcmcsIHRvUmVhY3RpdmUsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRJbmRleChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRJbmRleFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kTGFzdChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRMYXN0XCIsIGZuLCB0aGlzQXJnLCB0b1JlYWN0aXZlLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kTGFzdEluZGV4KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZExhc3RJbmRleFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICAvLyBmbGF0LCBmbGF0TWFwIGNvdWxkIGJlbmVmaXQgZnJvbSBBUlJBWV9JVEVSQVRFIGJ1dCBhcmUgbm90IHN0cmFpZ2h0LWZvcndhcmQgdG8gaW1wbGVtZW50XG4gIGZvckVhY2goZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmb3JFYWNoXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGluY2x1ZGVzKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmNsdWRlc1wiLCBhcmdzKTtcbiAgfSxcbiAgaW5kZXhPZiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwiaW5kZXhPZlwiLCBhcmdzKTtcbiAgfSxcbiAgam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuam9pbihzZXBhcmF0b3IpO1xuICB9LFxuICAvLyBrZXlzKCkgaXRlcmF0b3Igb25seSByZWFkcyBgbGVuZ3RoYCwgbm8gb3B0aW1pc2F0aW9uIHJlcXVpcmVkXG4gIGxhc3RJbmRleE9mKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJsYXN0SW5kZXhPZlwiLCBhcmdzKTtcbiAgfSxcbiAgbWFwKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwibWFwXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIHBvcCgpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInBvcFwiKTtcbiAgfSxcbiAgcHVzaCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJwdXNoXCIsIGFyZ3MpO1xuICB9LFxuICByZWR1Y2UoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIFwicmVkdWNlXCIsIGZuLCBhcmdzKTtcbiAgfSxcbiAgcmVkdWNlUmlnaHQoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIFwicmVkdWNlUmlnaHRcIiwgZm4sIGFyZ3MpO1xuICB9LFxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInNoaWZ0XCIpO1xuICB9LFxuICAvLyBzbGljZSBjb3VsZCB1c2UgQVJSQVlfSVRFUkFURSBidXQgYWxzbyBzZWVtcyB0byBiZWcgZm9yIHJhbmdlIHRyYWNraW5nXG4gIHNvbWUoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJzb21lXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIHNwbGljZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJzcGxpY2VcIiwgYXJncyk7XG4gIH0sXG4gIHRvUmV2ZXJzZWQoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvUmV2ZXJzZWQoKTtcbiAgfSxcbiAgdG9Tb3J0ZWQoY29tcGFyZXIpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9Tb3J0ZWQoY29tcGFyZXIpO1xuICB9LFxuICB0b1NwbGljZWQoLi4uYXJncykge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1NwbGljZWQoLi4uYXJncyk7XG4gIH0sXG4gIHVuc2hpZnQoLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwidW5zaGlmdFwiLCBhcmdzKTtcbiAgfSxcbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcInZhbHVlc1wiLCB0b1JlYWN0aXZlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGl0ZXJhdG9yKHNlbGYsIG1ldGhvZCwgd3JhcFZhbHVlKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGNvbnN0IGl0ZXIgPSBhcnJbbWV0aG9kXSgpO1xuICBpZiAoYXJyICE9PSBzZWxmICYmICFpc1NoYWxsb3coc2VsZikpIHtcbiAgICBpdGVyLl9uZXh0ID0gaXRlci5uZXh0O1xuICAgIGl0ZXIubmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXIuX25leHQoKTtcbiAgICAgIGlmIChyZXN1bHQudmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gd3JhcFZhbHVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGl0ZXI7XG59XG5jb25zdCBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuZnVuY3Rpb24gYXBwbHkoc2VsZiwgbWV0aG9kLCBmbiwgdGhpc0FyZywgd3JhcHBlZFJldEZuLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGNvbnN0IG5lZWRzV3JhcCA9IGFyciAhPT0gc2VsZiAmJiAhaXNTaGFsbG93KHNlbGYpO1xuICBjb25zdCBtZXRob2RGbiA9IGFyclttZXRob2RdO1xuICBpZiAobWV0aG9kRm4gIT09IGFycmF5UHJvdG9bbWV0aG9kXSkge1xuICAgIGNvbnN0IHJlc3VsdDIgPSBtZXRob2RGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICByZXR1cm4gbmVlZHNXcmFwID8gdG9SZWFjdGl2ZShyZXN1bHQyKSA6IHJlc3VsdDI7XG4gIH1cbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKG5lZWRzV3JhcCkge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZuLmxlbmd0aCA+IDIpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG1ldGhvZEZuLmNhbGwoYXJyLCB3cmFwcGVkRm4sIHRoaXNBcmcpO1xuICByZXR1cm4gbmVlZHNXcmFwICYmIHdyYXBwZWRSZXRGbiA/IHdyYXBwZWRSZXRGbihyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVkdWNlKHNlbGYsIG1ldGhvZCwgZm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKCFpc1NoYWxsb3coc2VsZikpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYWNjLCB0b1JlYWN0aXZlKGl0ZW0pLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm4ubGVuZ3RoID4gMykge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJbbWV0aG9kXSh3cmFwcGVkRm4sIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc2VhcmNoUHJveHkoc2VsZiwgbWV0aG9kLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHRvUmF3KHNlbGYpO1xuICB0cmFjayhhcnIsIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIGNvbnN0IHJlcyA9IGFyclttZXRob2RdKC4uLmFyZ3MpO1xuICBpZiAoKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkgJiYgaXNQcm94eShhcmdzWzBdKSkge1xuICAgIGFyZ3NbMF0gPSB0b1JhdyhhcmdzWzBdKTtcbiAgICByZXR1cm4gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5vVHJhY2tpbmcoc2VsZiwgbWV0aG9kLCBhcmdzID0gW10pIHtcbiAgcGF1c2VUcmFja2luZygpO1xuICBzdGFydEJhdGNoKCk7XG4gIGNvbnN0IHJlcyA9IHRvUmF3KHNlbGYpW21ldGhvZF0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVuZEJhdGNoKCk7XG4gIHJlc2V0VHJhY2tpbmcoKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcImFyZ3VtZW50c1wiICYmIGtleSAhPT0gXCJjYWxsZXJcIikubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpXG4pO1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gIGlmICghaXNTeW1ib2woa2V5KSkga2V5ID0gU3RyaW5nKGtleSk7XG4gIGNvbnN0IG9iaiA9IHRvUmF3KHRoaXMpO1xuICB0cmFjayhvYmosIFwiaGFzXCIsIGtleSk7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn1cbmNsYXNzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihfaXNSZWFkb25seSA9IGZhbHNlLCBfaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9pc1JlYWRvbmx5ID0gX2lzUmVhZG9ubHk7XG4gICAgdGhpcy5faXNTaGFsbG93ID0gX2lzU2hhbGxvdztcbiAgfVxuICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiKSByZXR1cm4gdGFyZ2V0W1wiX192X3NraXBcIl07XG4gICAgY29uc3QgaXNSZWFkb25seTIgPSB0aGlzLl9pc1JlYWRvbmx5LCBpc1NoYWxsb3cyID0gdGhpcy5faXNTaGFsbG93O1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiKSB7XG4gICAgICByZXR1cm4gaXNTaGFsbG93MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIpIHtcbiAgICAgIGlmIChyZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkyID8gaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFkb25seU1hcCA6IHJlYWRvbmx5TWFwIDogaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFjdGl2ZU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSB8fCAvLyByZWNlaXZlciBpcyBub3QgdGhlIHJlYWN0aXZlIHByb3h5LCBidXQgaGFzIHRoZSBzYW1lIHByb3RvdHlwZVxuICAgICAgLy8gdGhpcyBtZWFucyB0aGUgcmVjZWl2ZXIgaXMgYSB1c2VyIHByb3h5IG9mIHRoZSByZWFjdGl2ZSBwcm94eVxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihyZWNlaXZlcikpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICBsZXQgZm47XG4gICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiAoZm4gPSBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgcHJveHkgd3JhcHBpbmcgYSByZWYsIHJldHVybiBtZXRob2RzIHVzaW5nIHRoZSByYXcgcmVmXG4gICAgICAvLyBhcyByZWNlaXZlciBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2FsbCBgdG9SYXdgIG9uIHRoZSByZWYgaW4gYWxsXG4gICAgICAvLyBpdHMgY2xhc3MgbWV0aG9kc1xuICAgICAgaXNSZWYodGFyZ2V0KSA/IHRhcmdldCA6IHJlY2VpdmVyXG4gICAgKTtcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICB9XG4gICAgaWYgKGlzU2hhbGxvdzIpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5jbGFzcyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKGZhbHNlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmICghdGhpcy5faXNTaGFsbG93KSB7XG4gICAgICBjb25zdCBpc09sZFZhbHVlUmVhZG9ubHkgPSBpc1JlYWRvbmx5KG9sZFZhbHVlKTtcbiAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzT2xkVmFsdWVSZWFkb25seSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGlzUmVmKHRhcmdldCkgPyB0YXJnZXQgOiByZWNlaXZlclxuICAgICk7XG4gICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG93bktleXModGFyZ2V0KSB7XG4gICAgdHJhY2soXG4gICAgICB0YXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9XG59XG5jbGFzcyBSZWFkb25seVJlYWN0aXZlSGFuZGxlciBleHRlbmRzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihpc1NoYWxsb3cyID0gZmFsc2UpIHtcbiAgICBzdXBlcih0cnVlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCByZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcigpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5MiwgaXNTaGFsbG93Mikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xuICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gXCJlbnRyaWVzXCIgfHwgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSBcImtleXNcIiAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdzIgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5MiA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhcbiAgICAgIHJhd1RhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgdmFsdWUsIGRvbmUgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdG9SYXcodGhpcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0eXBlID09PSBcImNsZWFyXCIgPyB2b2lkIDAgOiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucyhyZWFkb25seSwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgICBpZiAoIXJlYWRvbmx5KSB7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xuICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgICAgIGNvbnN0IHdyYXAgPSBzaGFsbG93ID8gdG9TaGFsbG93IDogcmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgIGlmICghcmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwgcmF3S2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG4gICAgfSxcbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3Qgd3JhcCA9IHNoYWxsb3cgPyB0b1NoYWxsb3cgOiByZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgIXJlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGV4dGVuZChcbiAgICBpbnN0cnVtZW50YXRpb25zLFxuICAgIHJlYWRvbmx5ID8ge1xuICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiksXG4gICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIilcbiAgICB9IDoge1xuICAgICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgICAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgICAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmIChoYWRLZXkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgICAgICAgY29uc3Qgb2xkVGFyZ2V0ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGlzTWFwKHRhcmdldCkgPyBuZXcgTWFwKHRhcmdldCkgOiBuZXcgU2V0KHRhcmdldCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xuICAgICAgICBpZiAoaGFkSXRlbXMpIHtcbiAgICAgICAgICB0cmlnZ2VyKFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgXCJjbGVhclwiLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gW1xuICAgIFwia2V5c1wiLFxuICAgIFwidmFsdWVzXCIsXG4gICAgXCJlbnRyaWVzXCIsXG4gICAgU3ltYm9sLml0ZXJhdG9yXG4gIF07XG4gIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBpbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHJlYWRvbmx5LCBzaGFsbG93KTtcbiAgfSk7XG4gIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHkyLCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBjcmVhdGVJbnN0cnVtZW50YXRpb25zKGlzUmVhZG9ubHkyLCBzaGFsbG93KTtcbiAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KFxuICAgICAgaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldCA/IGluc3RydW1lbnRhdGlvbnMgOiB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICByZWNlaXZlclxuICAgICk7XG4gIH07XG59XG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xuICAgIHdhcm4oXG4gICAgICBgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gIHN3aXRjaCAocmF3VHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIl0gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpID8gMCAvKiBJTlZBTElEICovIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIG11dGFibGVIYW5kbGVycyxcbiAgICBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsXG4gICAgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgcmVhZG9ubHlIYW5kbGVycyxcbiAgICByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5MiwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgdmFsdWUgY2Fubm90IGJlIG1hZGUgJHtpc1JlYWRvbmx5MiA/IFwicmVhZG9ubHlcIiA6IFwicmVhY3RpdmVcIn06ICR7U3RyaW5nKFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIl0gJiYgIShpc1JlYWRvbmx5MiAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiXSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgfVxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShcbiAgICB0YXJnZXQsXG4gICAgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzXG4gICk7XG4gIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIl0pO1xuICB9XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCJdKTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIl0pO1xufVxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIl0pO1xufVxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyAhIXZhbHVlW1wiX192X3Jhd1wiXSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICBpZiAoIWhhc093bih2YWx1ZSwgXCJfX3Zfc2tpcFwiKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuXG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gIHJldHVybiByID8gcltcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xufVxuY2xhc3MgUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBpc1NoYWxsb3cyKSB7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBmYWxzZTtcbiAgICB0aGlzLl9yYXdWYWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICAgIHRoaXNbXCJfX3ZfaXNTaGFsbG93XCJdID0gaXNTaGFsbG93MjtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICB0eXBlOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3Jhd1ZhbHVlO1xuICAgIGNvbnN0IHVzZURpcmVjdFZhbHVlID0gdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gfHwgaXNTaGFsbG93KG5ld1ZhbHVlKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbHVlKTtcbiAgICBuZXdWYWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsdWUgOiB0b1JhdyhuZXdWYWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmVhY3RpdmUobmV3VmFsdWUpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdGhpcy5kZXAudHJpZ2dlcih7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZjIpIHtcbiAgaWYgKHJlZjIuZGVwKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoe1xuICAgICAgICB0YXJnZXQ6IHJlZjIsXG4gICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgICAgICBuZXdWYWx1ZTogcmVmMi5fdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYyLmRlcC50cmlnZ2VyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1bnJlZihyZWYyKSB7XG4gIHJldHVybiBpc1JlZihyZWYyKSA/IHJlZjIudmFsdWUgOiByZWYyO1xufVxuZnVuY3Rpb24gdG9WYWx1ZShzb3VyY2UpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlKSA/IHNvdXJjZSgpIDogdW5yZWYoc291cmNlKTtcbn1cbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcbiAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiBrZXkgPT09IFwiX192X3Jhd1wiID8gdGFyZ2V0IDogdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICBjb25zdCBkZXAgPSB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KGRlcC50cmFjay5iaW5kKGRlcCksIGRlcC50cmlnZ2VyLmJpbmQoZGVwKSk7XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICAgIHRoaXMuX3NldCA9IHNldDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0KCk7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICB9XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICB3YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgfVxuICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmV0W2tleV0gPSBwcm9wZXJ0eVRvUmVmKG9iamVjdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXksIF9kZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gX2RlZmF1bHRWYWx1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdmFsID09PSB2b2lkIDAgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICB9XG4gIGdldCBkZXAoKSB7XG4gICAgcmV0dXJuIGdldERlcEZyb21SZWFjdGl2ZSh0b1Jhdyh0aGlzLl9vYmplY3QpLCB0aGlzLl9rZXkpO1xuICB9XG59XG5jbGFzcyBHZXR0ZXJSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xuICAgIHRoaXMuX2dldHRlciA9IF9nZXR0ZXI7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgR2V0dGVyUmVmSW1wbChzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgcmV0dXJuIGlzUmVmKHZhbCkgPyB2YWwgOiBuZXcgT2JqZWN0UmVmSW1wbChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZm4sIHNldHRlciwgaXNTU1IpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAvLyBUT0RPIGlzb2xhdGVkRGVjbGFyYXRpb25zIFwiX192X2lzUmVhZG9ubHlcIlxuICAgIC8vIEEgY29tcHV0ZWQgaXMgYWxzbyBhIHN1YnNjcmliZXIgdGhhdCB0cmFja3Mgb3RoZXIgZGVwc1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxNjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uIC0gMTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICB0aGlzLmVmZmVjdCA9IHRoaXM7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gIXNldHRlcjtcbiAgICB0aGlzLmlzU1NSID0gaXNTU1I7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5KCkge1xuICAgIHRoaXMuZmxhZ3MgfD0gMTY7XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpICYmIC8vIGF2b2lkIGluZmluaXRlIHNlbGYgcmVjdXJzaW9uXG4gICAgYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICBiYXRjaCh0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBsaW5rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwidmFsdWVcIlxuICAgIH0pIDogdGhpcy5kZXAudHJhY2soKTtcbiAgICByZWZyZXNoQ29tcHV0ZWQodGhpcyk7XG4gICAgaWYgKGxpbmspIHtcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMuZGVwLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBpZiAodGhpcy5zZXR0ZXIpIHtcbiAgICAgIHRoaXMuc2V0dGVyKG5ld1ZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXCJXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBzZXR0ZXI7XG4gIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICB9XG4gIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc1NTUik7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICBjUmVmLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICBjUmVmLm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgcmV0dXJuIGNSZWY7XG59XG5cbmNvbnN0IFRyYWNrT3BUeXBlcyA9IHtcbiAgXCJHRVRcIjogXCJnZXRcIixcbiAgXCJIQVNcIjogXCJoYXNcIixcbiAgXCJJVEVSQVRFXCI6IFwiaXRlcmF0ZVwiXG59O1xuY29uc3QgVHJpZ2dlck9wVHlwZXMgPSB7XG4gIFwiU0VUXCI6IFwic2V0XCIsXG4gIFwiQUREXCI6IFwiYWRkXCIsXG4gIFwiREVMRVRFXCI6IFwiZGVsZXRlXCIsXG4gIFwiQ0xFQVJcIjogXCJjbGVhclwiXG59O1xuY29uc3QgUmVhY3RpdmVGbGFncyA9IHtcbiAgXCJTS0lQXCI6IFwiX192X3NraXBcIixcbiAgXCJJU19SRUFDVElWRVwiOiBcIl9fdl9pc1JlYWN0aXZlXCIsXG4gIFwiSVNfUkVBRE9OTFlcIjogXCJfX3ZfaXNSZWFkb25seVwiLFxuICBcIklTX1NIQUxMT1dcIjogXCJfX3ZfaXNTaGFsbG93XCIsXG4gIFwiUkFXXCI6IFwiX192X3Jhd1wiLFxuICBcIklTX1JFRlwiOiBcIl9fdl9pc1JlZlwiXG59O1xuXG5jb25zdCBXYXRjaEVycm9yQ29kZXMgPSB7XG4gIFwiV0FUQ0hfR0VUVEVSXCI6IDIsXG4gIFwiMlwiOiBcIldBVENIX0dFVFRFUlwiLFxuICBcIldBVENIX0NBTExCQUNLXCI6IDMsXG4gIFwiM1wiOiBcIldBVENIX0NBTExCQUNLXCIsXG4gIFwiV0FUQ0hfQ0xFQU5VUFwiOiA0LFxuICBcIjRcIjogXCJXQVRDSF9DTEVBTlVQXCJcbn07XG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbmNvbnN0IGNsZWFudXBNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmxldCBhY3RpdmVXYXRjaGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFdhdGNoZXIoKSB7XG4gIHJldHVybiBhY3RpdmVXYXRjaGVyO1xufVxuZnVuY3Rpb24gb25XYXRjaGVyQ2xlYW51cChjbGVhbnVwRm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlLCBvd25lciA9IGFjdGl2ZVdhdGNoZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgbGV0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQob3duZXIpO1xuICAgIGlmICghY2xlYW51cHMpIGNsZWFudXBNYXAuc2V0KG93bmVyLCBjbGVhbnVwcyA9IFtdKTtcbiAgICBjbGVhbnVwcy5wdXNoKGNsZWFudXBGbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbldhdGNoZXJDbGVhbnVwKCkgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBhY3RpdmUgd2F0Y2hlciB0byBhc3NvY2lhdGUgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCB7IGltbWVkaWF0ZSwgZGVlcCwgb25jZSwgc2NoZWR1bGVyLCBhdWdtZW50Sm9iLCBjYWxsIH0gPSBvcHRpb25zO1xuICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgKG9wdGlvbnMub25XYXJuIHx8IHdhcm4pKFxuICAgICAgYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLFxuICAgICAgcyxcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHJlYWN0aXZlR2V0dGVyID0gKHNvdXJjZTIpID0+IHtcbiAgICBpZiAoZGVlcCkgcmV0dXJuIHNvdXJjZTI7XG4gICAgaWYgKGlzU2hhbGxvdyhzb3VyY2UyKSB8fCBkZWVwID09PSBmYWxzZSB8fCBkZWVwID09PSAwKVxuICAgICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIsIDEpO1xuICAgIHJldHVybiB0cmF2ZXJzZShzb3VyY2UyKTtcbiAgfTtcbiAgbGV0IGVmZmVjdDtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IGNsZWFudXA7XG4gIGxldCBib3VuZENsZWFudXA7XG4gIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gcmVhY3RpdmVHZXR0ZXIoc291cmNlKTtcbiAgICBmb3JjZVRyaWdnZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKChzKSA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyhzKSk7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcCgocykgPT4ge1xuICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgIHJldHVybiByZWFjdGl2ZUdldHRlcihzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgICAgICByZXR1cm4gY2FsbCA/IGNhbGwocywgMikgOiBzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIGlmIChjYikge1xuICAgICAgZ2V0dGVyID0gY2FsbCA/ICgpID0+IGNhbGwoc291cmNlLCAyKSA6IHNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3QgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzb3VyY2UsIDMsIFtib3VuZENsZWFudXBdKSA6IHNvdXJjZShib3VuZENsZWFudXApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBjdXJyZW50RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBOT09QO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICBpZiAoY2IgJiYgZGVlcCkge1xuICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgY29uc3QgZGVwdGggPSBkZWVwID09PSB0cnVlID8gSW5maW5pdHkgOiBkZWVwO1xuICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSwgZGVwdGgpO1xuICB9XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IHdhdGNoSGFuZGxlID0gKCkgPT4ge1xuICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgICAgcmVtb3ZlKHNjb3BlLmVmZmVjdHMsIGVmZmVjdCk7XG4gICAgfVxuICB9O1xuICBpZiAob25jZSAmJiBjYikge1xuICAgIGNvbnN0IF9jYiA9IGNiO1xuICAgIGNiID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIF9jYiguLi5hcmdzKTtcbiAgICAgIHdhdGNoSGFuZGxlKCk7XG4gICAgfTtcbiAgfVxuICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpLmZpbGwoSU5JVElBTF9XQVRDSEVSX1ZBTFVFKSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcbiAgY29uc3Qgam9iID0gKGltbWVkaWF0ZUZpcnN0UnVuKSA9PiB7XG4gICAgaWYgKCEoZWZmZWN0LmZsYWdzICYgMSkgfHwgIWVmZmVjdC5kaXJ0eSAmJiAhaW1tZWRpYXRlRmlyc3RSdW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNiKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCAoaXNNdWx0aVNvdXJjZSA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKSA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFdhdGNoZXIgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdm9pZCAwIDogaXNNdWx0aVNvdXJjZSAmJiBvbGRWYWx1ZVswXSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gW10gOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIGJvdW5kQ2xlYW51cFxuICAgICAgICAgIF07XG4gICAgICAgICAgY2FsbCA/IGNhbGwoY2IsIDMsIGFyZ3MpIDogKFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY2IoLi4uYXJncylcbiAgICAgICAgICApO1xuICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRXYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH07XG4gIGlmIChhdWdtZW50Sm9iKSB7XG4gICAgYXVnbWVudEpvYihqb2IpO1xuICB9XG4gIGVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIpO1xuICBlZmZlY3Quc2NoZWR1bGVyID0gc2NoZWR1bGVyID8gKCkgPT4gc2NoZWR1bGVyKGpvYiwgZmFsc2UpIDogam9iO1xuICBib3VuZENsZWFudXAgPSAoZm4pID0+IG9uV2F0Y2hlckNsZWFudXAoZm4sIGZhbHNlLCBlZmZlY3QpO1xuICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwcyA9IGNsZWFudXBNYXAuZ2V0KGVmZmVjdCk7XG4gICAgaWYgKGNsZWFudXBzKSB7XG4gICAgICBpZiAoY2FsbCkge1xuICAgICAgICBjYWxsKGNsZWFudXBzLCA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgY2xlYW51cDIgb2YgY2xlYW51cHMpIGNsZWFudXAyKCk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwTWFwLmRlbGV0ZShlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBlZmZlY3Qub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcbiAgICBlZmZlY3Qub25UcmlnZ2VyID0gb3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgam9iKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2NoZWR1bGVyKSB7XG4gICAgc2NoZWR1bGVyKGpvYi5iaW5kKG51bGwsIHRydWUpLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QucnVuKCk7XG4gIH1cbiAgd2F0Y2hIYW5kbGUucGF1c2UgPSBlZmZlY3QucGF1c2UuYmluZChlZmZlY3QpO1xuICB3YXRjaEhhbmRsZS5yZXN1bWUgPSBlZmZlY3QucmVzdW1lLmJpbmQoZWZmZWN0KTtcbiAgd2F0Y2hIYW5kbGUuc3RvcCA9IHdhdGNoSGFuZGxlO1xuICByZXR1cm4gd2F0Y2hIYW5kbGU7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgZGVwdGggPSBJbmZpbml0eSwgc2Vlbikge1xuICBpZiAoZGVwdGggPD0gMCB8fCAhaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIl0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuLmFkZCh2YWx1ZSk7XG4gIGRlcHRoLS07XG4gIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgZGVwdGgsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgIHRyYXZlcnNlKHYsIGRlcHRoLCBzZWVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyBBUlJBWV9JVEVSQVRFX0tFWSwgRWZmZWN0RmxhZ3MsIEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgTUFQX0tFWV9JVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIFJlYWN0aXZlRmxhZ3MsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIFdhdGNoRXJyb3JDb2RlcywgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uRWZmZWN0Q2xlYW51cCwgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWN0aXZlUmVhZEFycmF5LCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkQXJyYXksIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVhY3RpdmUsIHRvUmVhZG9ubHksIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmF2ZXJzZSwgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYsIHdhdGNoIH07XG4iLCIvKipcbiogQHZ1ZS9ydW50aW1lLWNvcmUgdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCB0cmF2ZXJzZSwgc2hhbGxvd1JlZiwgcmVhZG9ubHksIGlzUmVhY3RpdmUsIHJlZiwgaXNTaGFsbG93LCBzaGFsbG93UmVhZEFycmF5LCB0b1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBSZWFjdGl2ZUVmZmVjdCwgd2F0Y2ggYXMgd2F0Y2gkMSwgY3VzdG9tUmVmLCBpc1Byb3h5LCBwcm94eVJlZnMsIG1hcmtSYXcsIEVmZmVjdFNjb3BlLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgVHJhY2tPcFR5cGVzLCBUcmlnZ2VyT3BUeXBlcywgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGdldEN1cnJlbnRXYXRjaGVyLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgb25XYXRjaGVyQ2xlYW51cCwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBFTVBUWV9PQkosIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgaXNCdWlsdEluRGlyZWN0aXZlLCBoYXNPd24sIHJlbW92ZSwgZGVmLCBpc09uLCBpc1Jlc2VydmVkUHJvcCwgbm9ybWFsaXplQ2xhc3MsIHN0cmluZ2lmeVN0eWxlLCBub3JtYWxpemVTdHlsZSwgaXNLbm93blN2Z0F0dHIsIGlzQm9vbGVhbkF0dHIsIGlzS25vd25IdG1sQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc1JlbmRlcmFibGVBdHRyVmFsdWUsIGdldEVzY2FwZWRDc3NWYXJOYW1lLCBpc09iamVjdCwgaXNSZWdFeHAsIGludm9rZUFycmF5Rm5zLCB0b0hhbmRsZXJLZXksIGNhcGl0YWxpemUsIGNhbWVsaXplLCBpc1N5bWJvbCwgaXNHbG9iYWxseUFsbG93ZWQsIE5PLCBoeXBoZW5hdGUsIEVNUFRZX0FSUiwgdG9SYXdUeXBlLCBtYWtlTWFwLCBoYXNDaGFuZ2VkLCBsb29zZVRvTnVtYmVyLCBpc01vZGVsTGlzdGVuZXIsIHRvTnVtYmVyIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gIHN0YWNrLnB1c2godm5vZGUpO1xufVxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XG4gIHN0YWNrLnBvcCgpO1xufVxubGV0IGlzV2FybmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybiQxKG1zZywgLi4uYXJncykge1xuICBpZiAoaXNXYXJuaW5nKSByZXR1cm47XG4gIGlzV2FybmluZyA9IHRydWU7XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xuICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XG4gIGlmIChhcHBXYXJuSGFuZGxlcikge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIGFwcFdhcm5IYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAxMSxcbiAgICAgIFtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIG1zZyArIGFyZ3MubWFwKChhKSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gYS50b1N0cmluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoYSkpICE9IG51bGwgPyBfYiA6IEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcbiAgICAgICAgdHJhY2UubWFwKFxuICAgICAgICAgICh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YFxuICAgICAgICApLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHRyYWNlXG4gICAgICBdXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XG4gICAgaWYgKHRyYWNlLmxlbmd0aCAmJiAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xuICAgIHRydWUpIHtcbiAgICAgIHdhcm5BcmdzLnB1c2goYFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcbiAgfVxuICByZXNldFRyYWNraW5nKCk7XG4gIGlzV2FybmluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XG4gIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XG4gIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcbiAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xuICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xuICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xuICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxuICAgICAgICByZWN1cnNlQ291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XG4gICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XG4gIGNvbnN0IGxvZ3MgPSBbXTtcbiAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICBsb2dzLnB1c2goLi4uaSA9PT0gMCA/IFtdIDogW2BcbmBdLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XG4gIH0pO1xuICByZXR1cm4gbG9ncztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcbiAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcbiAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XG4gIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgdm5vZGUuY29tcG9uZW50LFxuICAgIHZub2RlLnR5cGUsXG4gICAgaXNSb290XG4gICl9YDtcbiAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xuICByZXR1cm4gdm5vZGUucHJvcHMgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV0gOiBbb3BlbiArIGNsb3NlXTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XG4gIH0pO1xuICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XG4gICAgcmVzLnB1c2goYCAuLi5gKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gIH0gZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHZhbCwgdHlwZSkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHJldHVybjtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICB3YXJuJDEoYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4kMShgJHt0eXBlfSBpcyBOYU4gLSB0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuYCk7XG4gIH1cbn1cblxuY29uc3QgRXJyb3JDb2RlcyA9IHtcbiAgXCJTRVRVUF9GVU5DVElPTlwiOiAwLFxuICBcIjBcIjogXCJTRVRVUF9GVU5DVElPTlwiLFxuICBcIlJFTkRFUl9GVU5DVElPTlwiOiAxLFxuICBcIjFcIjogXCJSRU5ERVJfRlVOQ1RJT05cIixcbiAgXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiOiA1LFxuICBcIjVcIjogXCJOQVRJVkVfRVZFTlRfSEFORExFUlwiLFxuICBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCI6IDYsXG4gIFwiNlwiOiBcIkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSXCIsXG4gIFwiVk5PREVfSE9PS1wiOiA3LFxuICBcIjdcIjogXCJWTk9ERV9IT09LXCIsXG4gIFwiRElSRUNUSVZFX0hPT0tcIjogOCxcbiAgXCI4XCI6IFwiRElSRUNUSVZFX0hPT0tcIixcbiAgXCJUUkFOU0lUSU9OX0hPT0tcIjogOSxcbiAgXCI5XCI6IFwiVFJBTlNJVElPTl9IT09LXCIsXG4gIFwiQVBQX0VSUk9SX0hBTkRMRVJcIjogMTAsXG4gIFwiMTBcIjogXCJBUFBfRVJST1JfSEFORExFUlwiLFxuICBcIkFQUF9XQVJOX0hBTkRMRVJcIjogMTEsXG4gIFwiMTFcIjogXCJBUFBfV0FSTl9IQU5ETEVSXCIsXG4gIFwiRlVOQ1RJT05fUkVGXCI6IDEyLFxuICBcIjEyXCI6IFwiRlVOQ1RJT05fUkVGXCIsXG4gIFwiQVNZTkNfQ09NUE9ORU5UX0xPQURFUlwiOiAxMyxcbiAgXCIxM1wiOiBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIixcbiAgXCJTQ0hFRFVMRVJcIjogMTQsXG4gIFwiMTRcIjogXCJTQ0hFRFVMRVJcIixcbiAgXCJDT01QT05FTlRfVVBEQVRFXCI6IDE1LFxuICBcIjE1XCI6IFwiQ09NUE9ORU5UX1VQREFURVwiLFxuICBcIkFQUF9VTk1PVU5UX0NMRUFOVVBcIjogMTYsXG4gIFwiMTZcIjogXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCJcbn07XG5jb25zdCBFcnJvclR5cGVTdHJpbmdzJDEgPSB7XG4gIFtcInNwXCJdOiBcInNlcnZlclByZWZldGNoIGhvb2tcIixcbiAgW1wiYmNcIl06IFwiYmVmb3JlQ3JlYXRlIGhvb2tcIixcbiAgW1wiY1wiXTogXCJjcmVhdGVkIGhvb2tcIixcbiAgW1wiYm1cIl06IFwiYmVmb3JlTW91bnQgaG9va1wiLFxuICBbXCJtXCJdOiBcIm1vdW50ZWQgaG9va1wiLFxuICBbXCJidVwiXTogXCJiZWZvcmVVcGRhdGUgaG9va1wiLFxuICBbXCJ1XCJdOiBcInVwZGF0ZWRcIixcbiAgW1wiYnVtXCJdOiBcImJlZm9yZVVubW91bnQgaG9va1wiLFxuICBbXCJ1bVwiXTogXCJ1bm1vdW50ZWQgaG9va1wiLFxuICBbXCJhXCJdOiBcImFjdGl2YXRlZCBob29rXCIsXG4gIFtcImRhXCJdOiBcImRlYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZWNcIl06IFwiZXJyb3JDYXB0dXJlZCBob29rXCIsXG4gIFtcInJ0Y1wiXTogXCJyZW5kZXJUcmFja2VkIGhvb2tcIixcbiAgW1wicnRnXCJdOiBcInJlbmRlclRyaWdnZXJlZCBob29rXCIsXG4gIFswXTogXCJzZXR1cCBmdW5jdGlvblwiLFxuICBbMV06IFwicmVuZGVyIGZ1bmN0aW9uXCIsXG4gIFsyXTogXCJ3YXRjaGVyIGdldHRlclwiLFxuICBbM106IFwid2F0Y2hlciBjYWxsYmFja1wiLFxuICBbNF06IFwid2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uXCIsXG4gIFs1XTogXCJuYXRpdmUgZXZlbnQgaGFuZGxlclwiLFxuICBbNl06IFwiY29tcG9uZW50IGV2ZW50IGhhbmRsZXJcIixcbiAgWzddOiBcInZub2RlIGhvb2tcIixcbiAgWzhdOiBcImRpcmVjdGl2ZSBob29rXCIsXG4gIFs5XTogXCJ0cmFuc2l0aW9uIGhvb2tcIixcbiAgWzEwXTogXCJhcHAgZXJyb3JIYW5kbGVyXCIsXG4gIFsxMV06IFwiYXBwIHdhcm5IYW5kbGVyXCIsXG4gIFsxMl06IFwicmVmIGZ1bmN0aW9uXCIsXG4gIFsxM106IFwiYXN5bmMgY29tcG9uZW50IGxvYWRlclwiLFxuICBbMTRdOiBcInNjaGVkdWxlciBmbHVzaFwiLFxuICBbMTVdOiBcImNvbXBvbmVudCB1cGRhdGVcIixcbiAgWzE2XTogXCJhcHAgdW5tb3VudCBjbGVhbnVwIGZ1bmN0aW9uXCJcbn07XG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gICAgaWYgKHJlcyAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoaXNBcnJheShmbikpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYEludmFsaWQgdmFsdWUgdHlwZSBwYXNzZWQgdG8gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoKTogJHt0eXBlb2YgZm59YFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xuICBjb25zdCB7IGVycm9ySGFuZGxlciwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbiB9ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcgfHwgRU1QVFlfT0JKO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGVycm9ySW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0gOiBgaHR0cHM6Ly92dWVqcy5vcmcvZXJyb3ItcmVmZXJlbmNlLyNydW50aW1lLSR7dHlwZX1gO1xuICAgIHdoaWxlIChjdXIpIHtcbiAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcbiAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKGVycm9ySGFuZGxlcikge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGVycm9ySGFuZGxlciwgbnVsbCwgMTAsIFtcbiAgICAgICAgZXJyLFxuICAgICAgICBleHBvc2VkSW5zdGFuY2UsXG4gICAgICAgIGVycm9ySW5mb1xuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2LCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSwgdGhyb3dJblByb2QgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV07XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XG4gICAgfVxuICAgIHdhcm4kMShgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKHRocm93SW5EZXYpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aHJvd0luUHJvZCkge1xuICAgIHRocm93IGVycjtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuY29uc3QgcXVldWUgPSBbXTtcbmxldCBmbHVzaEluZGV4ID0gLTE7XG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XG4gIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XG59XG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcbiAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XG4gIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+PiAxO1xuICAgIGNvbnN0IG1pZGRsZUpvYiA9IHF1ZXVlW21pZGRsZV07XG4gICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChtaWRkbGVKb2IpO1xuICAgIGlmIChtaWRkbGVKb2JJZCA8IGlkIHx8IG1pZGRsZUpvYklkID09PSBpZCAmJiBtaWRkbGVKb2IuZmxhZ3MgJiAyKSB7XG4gICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IG1pZGRsZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gIGlmICghKGpvYi5mbGFncyAmIDEpKSB7XG4gICAgY29uc3Qgam9iSWQgPSBnZXRJZChqb2IpO1xuICAgIGNvbnN0IGxhc3RKb2IgPSBxdWV1ZVtxdWV1ZS5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWxhc3RKb2IgfHwgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIGpvYiBpZCBpcyBsYXJnZXIgdGhhbiB0aGUgdGFpbFxuICAgICEoam9iLmZsYWdzICYgMikgJiYgam9iSWQgPj0gZ2V0SWQobGFzdEpvYikpIHtcbiAgICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWUuc3BsaWNlKGZpbmRJbnNlcnRpb25JbmRleChqb2JJZCksIDAsIGpvYik7XG4gICAgfVxuICAgIGpvYi5mbGFncyB8PSAxO1xuICAgIHF1ZXVlRmx1c2goKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFjdXJyZW50Rmx1c2hQcm9taXNlKSB7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcbiAgaWYgKCFpc0FycmF5KGNiKSkge1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMgJiYgY2IuaWQgPT09IC0xKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc3BsaWNlKHBvc3RGbHVzaEluZGV4ICsgMSwgMCwgY2IpO1xuICAgIH0gZWxzZSBpZiAoIShjYi5mbGFncyAmIDEpKSB7XG4gICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goY2IpO1xuICAgICAgY2IuZmxhZ3MgfD0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgfVxuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBmbHVzaFByZUZsdXNoQ2JzKGluc3RhbmNlLCBzZWVuLCBpID0gZmx1c2hJbmRleCArIDEpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjYiA9IHF1ZXVlW2ldO1xuICAgIGlmIChjYiAmJiBjYi5mbGFncyAmIDIpIHtcbiAgICAgIGlmIChpbnN0YW5jZSAmJiBjYi5pZCAhPT0gaW5zdGFuY2UudWlkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICAgIGlmIChjYi5mbGFncyAmIDQpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgICBjYigpO1xuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA0KSkge1xuICAgICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcbiAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYilcbiAgICApO1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XG4gICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gZGVkdXBlZDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3QgY2IgPSBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5mbGFncyAmIDQpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgICBpZiAoIShjYi5mbGFncyAmIDgpKSBjYigpO1xuICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG4gICAgcG9zdEZsdXNoSW5kZXggPSAwO1xuICB9XG59XG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gam9iLmZsYWdzICYgMiA/IC0xIDogSW5maW5pdHkgOiBqb2IuaWQ7XG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY29uc3QgY2hlY2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYikgOiBOT09QO1xuICB0cnkge1xuICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iICYmICEoam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2soam9iKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICBqb2IsXG4gICAgICAgICAgam9iLmksXG4gICAgICAgICAgam9iLmkgPyAxNSA6IDE0XG4gICAgICAgICk7XG4gICAgICAgIGlmICghKGpvYi5mbGFncyAmIDQpKSB7XG4gICAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGZvciAoOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgaWYgKGpvYikge1xuICAgICAgICBqb2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoSW5kZXggPSAtMTtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggfHwgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICAgIGZsdXNoSm9icyhzZWVuKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xuICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKSB8fCAwO1xuICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGZuLmk7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XG4gICAgaGFuZGxlRXJyb3IoXG4gICAgICBgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3Igd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCxcbiAgICAgIG51bGwsXG4gICAgICAxMFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbmNvbnN0IGhtckRpcnR5Q29tcG9uZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcbiAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcbiAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXG4gICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcbiAgfTtcbn1cbmNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcbiAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XG4gICAgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIH1cbiAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGluaXRpYWxEZWYpIHtcbiAgaWYgKG1hcC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1hcC5zZXQoaWQsIHtcbiAgICBpbml0aWFsRGVmOiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbml0aWFsRGVmKSxcbiAgICBpbnN0YW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50O1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xuICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAobmV3UmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XG4gICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHJldHVybjtcbiAgbmV3Q29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KG5ld0NvbXApO1xuICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xuICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xuICAgIGxldCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQob2xkQ29tcCk7XG4gICAgaWYgKCFkaXJ0eUluc3RhbmNlcykge1xuICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcbiAgICAgIH1cbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5zZXQob2xkQ29tcCwgZGlydHlJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnByb3BzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQuZW1pdHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xuICAgICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIHF1ZXVlSm9iKCgpID0+IHtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICBkaXJ0eUluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xuICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5yb290LmNlICYmIGluc3RhbmNlICE9PSBpbnN0YW5jZS5yb290KSB7XG4gICAgICBpbnN0YW5jZS5yb290LmNlLl9yZW1vdmVDaGlsZFN0eWxlKG9sZENvbXApO1xuICAgIH1cbiAgfVxuICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcbiAgICBobXJEaXJ0eUNvbXBvbmVudHMuY2xlYXIoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xuICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9sZENvbXApIHtcbiAgICBpZiAoa2V5ICE9PSBcIl9fZmlsZVwiICYmICEoa2V5IGluIG5ld0NvbXApKSB7XG4gICAgICBkZWxldGUgb2xkQ29tcFtrZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gKGlkLCBhcmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGRldnRvb2xzJDE7XG5sZXQgYnVmZmVyID0gW107XG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVtaXQkMShldmVudCwgLi4uYXJncykge1xuICBpZiAoZGV2dG9vbHMkMSkge1xuICAgIGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoIWRldnRvb2xzTm90SW5zdGFsbGVkKSB7XG4gICAgYnVmZmVyLnB1c2goeyBldmVudCwgYXJncyB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rJDEoaG9vaywgdGFyZ2V0KSB7XG4gIHZhciBfYSwgX2I7XG4gIGRldnRvb2xzJDEgPSBob29rO1xuICBpZiAoZGV2dG9vbHMkMSkge1xuICAgIGRldnRvb2xzJDEuZW5hYmxlZCA9IHRydWU7XG4gICAgYnVmZmVyLmZvckVhY2goKHsgZXZlbnQsIGFyZ3MgfSkgPT4gZGV2dG9vbHMkMS5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG4gICAgYnVmZmVyID0gW107XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIHNvbWUgZW52cyBtb2NrIHdpbmRvdyBidXQgbm90IGZ1bGx5XG4gICAgd2luZG93LkhUTUxFbGVtZW50ICYmIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwianNkb21cIikpXG4gICkge1xuICAgIGNvbnN0IHJlcGxheSA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW107XG4gICAgcmVwbGF5LnB1c2goKG5ld0hvb2spID0+IHtcbiAgICAgIHNldERldnRvb2xzSG9vayQxKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWRldnRvb2xzJDEpIHtcbiAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgfVxuICAgIH0sIDNlMyk7XG4gIH0gZWxzZSB7XG4gICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9XG59XG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XG4gIGVtaXQkMShcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xuICAgIEZyYWdtZW50LFxuICAgIFRleHQsXG4gICAgQ29tbWVudCxcbiAgICBTdGF0aWNcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XG4gIGVtaXQkMShcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGFwcCk7XG59XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XG5jb25zdCBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcbiAgXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovXG4pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkID0gKGNvbXBvbmVudCkgPT4ge1xuICBpZiAoZGV2dG9vbHMkMSAmJiB0eXBlb2YgZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gcmVtb3ZlIHRoZSBjb21wb25lbnQgaWYgaXQgd2Fzbid0IGJ1ZmZlcmVkXG4gICFkZXZ0b29scyQxLmNsZWFudXBCdWZmZXIoY29tcG9uZW50KSkge1xuICAgIF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoY29tcG9uZW50KTtcbiAgfVxufTtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50KSA9PiB7XG4gICAgZW1pdCQxKFxuICAgICAgaG9vayxcbiAgICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICAgIGNvbXBvbmVudC51aWQsXG4gICAgICBjb21wb25lbnQucGFyZW50ID8gY29tcG9uZW50LnBhcmVudC51aWQgOiB2b2lkIDAsXG4gICAgICBjb21wb25lbnRcbiAgICApO1xuICB9O1xufVxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xuICAgIGVtaXQkMShob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudCwgdHlwZSwgdGltZSk7XG4gIH07XG59XG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XG4gIGVtaXQkMShcbiAgICBcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sXG4gICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgIGNvbXBvbmVudCxcbiAgICBldmVudCxcbiAgICBwYXJhbXNcbiAgKTtcbn1cblxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xuICBjdXJyZW50U2NvcGVJZCA9IGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkIHx8IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBpZDtcbn1cbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbn1cbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90KSB7XG4gIGlmICghY3R4KSByZXR1cm4gZm47XG4gIGlmIChmbi5fbikge1xuICAgIHJldHVybiBmbjtcbiAgfVxuICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGZuKC4uLmFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcbiAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGN0eCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9jID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XG4gIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xuICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XG4gICAgd2FybiQxKFwiRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6IFwiICsgbmFtZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBkaXJlY3RpdmVzKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpO1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcbiAgICBpZiAoZGlyKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XG4gICAgICAgIGRpciA9IHtcbiAgICAgICAgICBtb3VudGVkOiBkaXIsXG4gICAgICAgICAgdXBkYXRlZDogZGlyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZGlyLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgYmluZGluZ3MucHVzaCh7XG4gICAgICAgIGRpcixcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxuICAgICAgICBhcmcsXG4gICAgICAgIG1vZGlmaWVyc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xuICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICBpZiAob2xkQmluZGluZ3MpIHtcbiAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcbiAgICB9XG4gICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcbiAgICBpZiAoaG9vaykge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDgsIFtcbiAgICAgICAgdm5vZGUuZWwsXG4gICAgICAgIGJpbmRpbmcsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBwcmV2Vk5vZGVcbiAgICAgIF0pO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBUZWxlcG9ydEVuZEtleSA9IFN5bWJvbChcIl92dGVcIik7XG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09IFwiXCIpO1xuY29uc3QgaXNUZWxlcG9ydERlZmVycmVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGVmZXIgfHwgcHJvcHMuZGVmZXIgPT09IFwiXCIpO1xuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuY29uc3QgaXNUYXJnZXRNYXRoTUwgPSAodGFyZ2V0KSA9PiB0eXBlb2YgTWF0aE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIHRhcmdldCBpbnN0YW5jZW9mIE1hdGhNTEVsZW1lbnQ7XG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcbiAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcbiAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xuICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0YXJnZXQgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgVGVsZXBvcnQgdGFyZ2V0OiAke3RhcmdldFNlbGVjdG9yfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U2VsZWN0b3I7XG4gIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gIG5hbWU6IFwiVGVsZXBvcnRcIixcbiAgX19pc1RlbGVwb3J0OiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscykge1xuICAgIGNvbnN0IHtcbiAgICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICAgIG86IHsgaW5zZXJ0LCBxdWVyeVNlbGVjdG9yLCBjcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50IH1cbiAgICB9ID0gaW50ZXJuYWxzO1xuICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICBsZXQgeyBzaGFwZUZsYWcsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4gfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gbjIuZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IHN0YXJ0XCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlQ29tbWVudChcInRlbGVwb3J0IGVuZFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBpbnNlcnQocGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGluc2VydChtYWluQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIyLCBhbmNob3IyKSA9PiB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LmlzQ0UpIHtcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jZS5fdGVsZXBvcnRUYXJnZXQgPSBjb250YWluZXIyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vdW50VG9UYXJnZXQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBwcmVwYXJlQW5jaG9yKHRhcmdldCwgbjIsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlICE9PSBcInN2Z1wiICYmIGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgIT09IFwibWF0aG1sXCIgJiYgaXNUYXJnZXRNYXRoTUwodGFyZ2V0KSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6XCIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcbiAgICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZWxlcG9ydERlZmVycmVkKG4yLnByb3BzKSkge1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIG1vdW50VG9UYXJnZXQoKTtcbiAgICAgICAgICBuMi5lbC5fX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50VG9UYXJnZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGVsZXBvcnREZWZlcnJlZChuMi5wcm9wcykgJiYgIW4xLmVsLl9faXNNb3VudGVkKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgVGVsZXBvcnRJbXBsLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRlbGV0ZSBuMS5lbC5fX2lzTW91bnRlZDtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIudGFyZ2V0U3RhcnQgPSBuMS50YXJnZXRTdGFydDtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSBuMS50YXJnZXQ7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3I7XG4gICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJzdmdcIiB8fCBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiB8fCBpc1RhcmdldE1hdGhNTCh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICB9XG4gICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50QW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbWFpbkFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuMi5wcm9wcyAmJiBuMS5wcm9wcyAmJiBuMi5wcm9wcy50byAhPT0gbjEucHJvcHMudG8pIHtcbiAgICAgICAgICAgIG4yLnByb3BzLnRvID0gbjEucHJvcHMudG87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgICAgICAgICAgbjIucHJvcHMsXG4gICAgICAgICAgICBxdWVyeVNlbGVjdG9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV4dFRhcmdldCkge1xuICAgICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgbmV4dFRhcmdldCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTpcIixcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVDc3NWYXJzKG4yLCBkaXNhYmxlZCk7XG4gICAgfVxuICB9LFxuICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHsgdW06IHVubW91bnQsIG86IHsgcmVtb3ZlOiBob3N0UmVtb3ZlIH0gfSwgZG9SZW1vdmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGFuY2hvcixcbiAgICAgIHRhcmdldFN0YXJ0LFxuICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJvcHNcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRTdGFydCk7XG4gICAgICBob3N0UmVtb3ZlKHRhcmdldEFuY2hvcik7XG4gICAgfVxuICAgIGRvUmVtb3ZlICYmIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGNvbnN0IHNob3VsZFJlbW92ZSA9IGRvUmVtb3ZlIHx8ICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzaG91bGRSZW1vdmUsXG4gICAgICAgICAgISFjaGlsZC5keW5hbWljQ2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdmU6IG1vdmVUZWxlcG9ydCxcbiAgaHlkcmF0ZTogaHlkcmF0ZVRlbGVwb3J0XG59O1xuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMikge1xuICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICBpbnNlcnQodm5vZGUudGFyZ2V0QW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzUmVvcmRlciA9IG1vdmVUeXBlID09PSAyO1xuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbiAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKFxuICAgICAgICAgIGNoaWxkcmVuW2ldLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRBbmNob3IsXG4gICAgICAgICAgMlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaXNSZW9yZGVyKSB7XG4gICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7XG4gIG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IsIGluc2VydCwgY3JlYXRlVGV4dCB9XG59LCBoeWRyYXRlQ2hpbGRyZW4pIHtcbiAgY29uc3QgdGFyZ2V0ID0gdm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICB2bm9kZS5wcm9wcyxcbiAgICBxdWVyeVNlbGVjdG9yXG4gICk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcyk7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNikge1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHZub2RlLnRhcmdldFN0YXJ0ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiYgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPSB2bm9kZS50YXJnZXRBbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUudGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldEFuY2hvciA9IG5leHRTaWJsaW5nKHRhcmdldEFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2bm9kZS50YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIHRhcmdldE5vZGUgJiYgbmV4dFNpYmxpbmcodGFyZ2V0Tm9kZSksXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNzc1ZhcnModm5vZGUsIGRpc2FibGVkKTtcbiAgfVxuICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XG59XG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcbmZ1bmN0aW9uIHVwZGF0ZUNzc1ZhcnModm5vZGUsIGlzRGlzYWJsZWQpIHtcbiAgY29uc3QgY3R4ID0gdm5vZGUuY3R4O1xuICBpZiAoY3R4ICYmIGN0eC51dCkge1xuICAgIGxldCBub2RlLCBhbmNob3I7XG4gICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgIG5vZGUgPSB2bm9kZS5lbDtcbiAgICAgIGFuY2hvciA9IHZub2RlLmFuY2hvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHZub2RlLnRhcmdldFN0YXJ0O1xuICAgICAgYW5jaG9yID0gdm5vZGUudGFyZ2V0QW5jaG9yO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBhbmNob3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdi1vd25lclwiLCBjdHgudWlkKTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBjdHgudXQoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUFuY2hvcih0YXJnZXQsIHZub2RlLCBjcmVhdGVUZXh0LCBpbnNlcnQpIHtcbiAgY29uc3QgdGFyZ2V0U3RhcnQgPSB2bm9kZS50YXJnZXRTdGFydCA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIGNvbnN0IHRhcmdldEFuY2hvciA9IHZub2RlLnRhcmdldEFuY2hvciA9IGNyZWF0ZVRleHQoXCJcIik7XG4gIHRhcmdldFN0YXJ0W1RlbGVwb3J0RW5kS2V5XSA9IHRhcmdldEFuY2hvcjtcbiAgaWYgKHRhcmdldCkge1xuICAgIGluc2VydCh0YXJnZXRTdGFydCwgdGFyZ2V0KTtcbiAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xuICB9XG4gIHJldHVybiB0YXJnZXRBbmNob3I7XG59XG5cbmNvbnN0IGxlYXZlQ2JLZXkgPSBTeW1ib2woXCJfbGVhdmVDYlwiKTtcbmNvbnN0IGVudGVyQ2JLZXkgPSBTeW1ib2woXCJfZW50ZXJDYlwiKTtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc0xlYXZpbmc6IGZhbHNlLFxuICAgIGlzVW5tb3VudGluZzogZmFsc2UsXG4gICAgbGVhdmluZ1ZOb2RlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gIH0pO1xuICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xuY29uc3QgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG1vZGU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXG4gIC8vIGVudGVyXG4gIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGxlYXZlXG4gIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIC8vIGFwcGVhclxuICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxufTtcbmNvbnN0IHJlY3Vyc2l2ZUdldFN1YnRyZWUgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIHJldHVybiBzdWJUcmVlLmNvbXBvbmVudCA/IHJlY3Vyc2l2ZUdldFN1YnRyZWUoc3ViVHJlZS5jb21wb25lbnQpIDogc3ViVHJlZTtcbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XG4gIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXG4gIHByb3BzOiBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xuICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gZmluZE5vbkNvbW1lbnRDaGlsZChjaGlsZHJlbik7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtb2RlICYmIG1vZGUgIT09IFwiaW4tb3V0XCIgJiYgbW9kZSAhPT0gXCJvdXQtaW5cIiAmJiBtb2RlICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICB3YXJuJDEoYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldElubmVyQ2hpbGQkMShjaGlsZCk7XG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgbGV0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICBpbm5lckNoaWxkLFxuICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICAvLyAjMTEwNjEsIGVuc3VyZSBlbnRlckhvb2tzIGlzIGZyZXNoIGFmdGVyIGNsb25lXG4gICAgICAgIChob29rcykgPT4gZW50ZXJIb29rcyA9IGhvb2tzXG4gICAgICApO1xuICAgICAgaWYgKGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XG4gICAgICB9XG4gICAgICBsZXQgb2xkSW5uZXJDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWUgJiYgZ2V0SW5uZXJDaGlsZCQxKGluc3RhbmNlLnN1YlRyZWUpO1xuICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiYgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50ICYmICFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgJiYgcmVjdXJzaXZlR2V0U3VidHJlZShpbnN0YW5jZSkudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBsZXQgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICBvbGRJbm5lckNoaWxkLFxuICAgICAgICAgIHJhd1Byb3BzLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJvdXQtaW5cIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZS5qb2IuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZTtcbiAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJpbi1vdXRcIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRJbm5lckNoaWxkKSB7XG4gICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pIHtcbiAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoYy50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGhhc0ZvdW5kKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgXCI8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlIDx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xuICAgICAgICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XG4gIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlLCBwb3N0Q2xvbmUpIHtcbiAgY29uc3Qge1xuICAgIGFwcGVhcixcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCA9IGZhbHNlLFxuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkFmdGVyRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUxlYXZlLFxuICAgIG9uTGVhdmUsXG4gICAgb25BZnRlckxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIsXG4gICAgb25BcHBlYXIsXG4gICAgb25BZnRlckFwcGVhcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XG4gIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBob29rICYmIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaG9vayxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgOSxcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9O1xuICBjb25zdCBjYWxsQXN5bmNIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkb25lID0gYXJnc1sxXTtcbiAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaWYgKGhvb2suZXZlcnkoKGhvb2syKSA9PiBob29rMi5sZW5ndGggPD0gMSkpIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhvb2tzID0ge1xuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkLFxuICAgIGJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgZWxbbGVhdmVDYktleV0oXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XG4gICAgICBpZiAobGVhdmluZ1ZOb2RlICYmIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJiBsZWF2aW5nVk5vZGUuZWxbbGVhdmVDYktleV0pIHtcbiAgICAgICAgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICB9LFxuICAgIGVudGVyKGVsKSB7XG4gICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XG4gICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xuICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xuICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2VudGVyQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtlbnRlckNiS2V5XSA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgY29uc3Qga2V5MiA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICAgICAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgICAgIGVsW2VudGVyQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWxbbGVhdmVDYktleV0gPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldID0gdm9pZCAwO1xuICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID09PSB2bm9kZSkge1xuICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPSB2bm9kZTtcbiAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZSh2bm9kZTIpIHtcbiAgICAgIGNvbnN0IGhvb2tzMiA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIHZub2RlMixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgcG9zdENsb25lXG4gICAgICApO1xuICAgICAgaWYgKHBvc3RDbG9uZSkgcG9zdENsb25lKGhvb2tzMik7XG4gICAgICByZXR1cm4gaG9va3MyO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xuICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkJDEodm5vZGUpIHtcbiAgaWYgKCFpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICBpZiAoaXNUZWxlcG9ydCh2bm9kZS50eXBlKSAmJiB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGZpbmROb25Db21tZW50Q2hpbGQodm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMzIgJiYgaXNGdW5jdGlvbihjaGlsZHJlbi5kZWZhdWx0KSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuLmRlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xuICB9IGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcbiAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSwgcGFyZW50S2V5KSB7XG4gIGxldCByZXQgPSBbXTtcbiAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbCA/IGNoaWxkLmtleSA6IFN0cmluZyhwYXJlbnRLZXkpICsgU3RyaW5nKGNoaWxkLmtleSAhPSBudWxsID8gY2hpbGQua2V5IDogaSk7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4KSBrZXllZEZyYWdtZW50Q291bnQrKztcbiAgICAgIHJldCA9IHJldC5jb25jYXQoXG4gICAgICAgIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChrZWVwQ29tbWVudCB8fCBjaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICByZXQucHVzaChrZXkgIT0gbnVsbCA/IGNsb25lVk5vZGUoY2hpbGQsIHsga2V5IH0pIDogY2hpbGQpO1xuICAgIH1cbiAgfVxuICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyAoXG4gICAgLy8gIzgyMzY6IGV4dGVuZCBjYWxsIGFuZCBvcHRpb25zLm5hbWUgYWNjZXNzIGFyZSBjb25zaWRlcmVkIHNpZGUtZWZmZWN0c1xuICAgIC8vIGJ5IFJvbGx1cCwgc28gd2UgaGF2ZSB0byB3cmFwIGl0IGluIGEgcHVyZS1hbm5vdGF0ZWQgSUlGRS5cbiAgICAvKiBAX19QVVJFX18gKi8gKCgpID0+IGV4dGVuZCh7IG5hbWU6IG9wdGlvbnMubmFtZSB9LCBleHRyYU9wdGlvbnMsIHsgc2V0dXA6IG9wdGlvbnMgfSkpKClcbiAgKSA6IG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpKSB7XG4gICAgcmV0dXJuIChpLmFwcENvbnRleHQuY29uZmlnLmlkUHJlZml4IHx8IFwidlwiKSArIFwiLVwiICsgaS5pZHNbMF0gKyBpLmlkc1sxXSsrO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlSWQoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLmlkcyA9IFtpbnN0YW5jZS5pZHNbMF0gKyBpbnN0YW5jZS5pZHNbMl0rKyArIFwiLVwiLCAwLCAwXTtcbn1cblxuY29uc3Qga25vd25UZW1wbGF0ZVJlZnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIHVzZVRlbXBsYXRlUmVmKGtleSkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IHIgPSBzaGFsbG93UmVmKG51bGwpO1xuICBpZiAoaSkge1xuICAgIGNvbnN0IHJlZnMgPSBpLnJlZnMgPT09IEVNUFRZX09CSiA/IGkucmVmcyA9IHt9IDogaS5yZWZzO1xuICAgIGxldCBkZXNjO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWZzLCBrZXkpKSAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgIHdhcm4kMShgdXNlVGVtcGxhdGVSZWYoJyR7a2V5fScpIGFscmVhZHkgZXhpc3RzLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVmcywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gci52YWx1ZSxcbiAgICAgICAgc2V0OiAodmFsKSA9PiByLnZhbHVlID0gdmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGB1c2VUZW1wbGF0ZVJlZigpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHJldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyByZWFkb25seShyKSA6IHI7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAga25vd25UZW1wbGF0ZVJlZnMuYWRkKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSB7XG4gIGlmIChpc0FycmF5KHJhd1JlZikpIHtcbiAgICByYXdSZWYuZm9yRWFjaChcbiAgICAgIChyLCBpKSA9PiBzZXRSZWYoXG4gICAgICAgIHIsXG4gICAgICAgIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBpc1VubW91bnRcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNTEyICYmIHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkICYmIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLmNvbXBvbmVudCkge1xuICAgICAgc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0ID8gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2Uodm5vZGUuY29tcG9uZW50KSA6IHZub2RlLmVsO1xuICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFvd25lcikge1xuICAgIHdhcm4kMShcbiAgICAgIGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyBvd25lci5yZWZzID0ge30gOiBvd25lci5yZWZzO1xuICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgY29uc3QgcmF3U2V0dXBTdGF0ZSA9IHRvUmF3KHNldHVwU3RhdGUpO1xuICBjb25zdCBjYW5TZXRTZXR1cFJlZiA9IHNldHVwU3RhdGUgPT09IEVNUFRZX09CSiA/ICgpID0+IGZhbHNlIDogKGtleSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaGFzT3duKHJhd1NldHVwU3RhdGUsIGtleSkgJiYgIWlzUmVmKHJhd1NldHVwU3RhdGVba2V5XSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBUZW1wbGF0ZSByZWYgXCIke2tleX1cIiB1c2VkIG9uIGEgbm9uLXJlZiB2YWx1ZS4gSXQgd2lsbCBub3Qgd29yayBpbiB0aGUgcHJvZHVjdGlvbiBidWlsZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoa25vd25UZW1wbGF0ZVJlZnMuaGFzKHJhd1NldHVwU3RhdGVba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzT3duKHJhd1NldHVwU3RhdGUsIGtleSk7XG4gIH07XG4gIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xuICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XG4gICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xuICAgICAgaWYgKGNhblNldFNldHVwUmVmKG9sZFJlZikpIHtcbiAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcbiAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIsIFt2YWx1ZSwgcmVmc10pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XG4gICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChyYXdSZWYuZikge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gY2FuU2V0U2V0dXBSZWYocmVmKSA/IHNldHVwU3RhdGVbcmVmXSA6IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcbiAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XG4gICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUoZXhpc3RpbmcsIHJlZlZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuU2V0U2V0dXBSZWYocmVmKSkge1xuICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaykgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcbiAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNSZWYpIHtcbiAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAocmF3UmVmLmspIHJlZnNbcmF3UmVmLmtdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvU2V0LmlkID0gLTE7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9TZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvciA9IGZhbHNlO1xuY29uc3QgbG9nTWlzbWF0Y2hFcnJvciA9ICgpID0+IHtcbiAgaWYgKGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5lcnJvcihcIkh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuXCIpO1xuICBoYXNMb2dnZWRNaXNtYXRjaEVycm9yID0gdHJ1ZTtcbn07XG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJzdmdcIikgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuY29uc3QgaXNNYXRoTUxDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiBjb250YWluZXIubmFtZXNwYWNlVVJJLmluY2x1ZGVzKFwiTWF0aE1MXCIpO1xuY29uc3QgZ2V0Q29udGFpbmVyVHlwZSA9IChjb250YWluZXIpID0+IHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lcikpIHJldHVybiBcInN2Z1wiO1xuICBpZiAoaXNNYXRoTUxDb250YWluZXIoY29udGFpbmVyKSkgcmV0dXJuIFwibWF0aG1sXCI7XG4gIHJldHVybiB2b2lkIDA7XG59O1xuY29uc3QgaXNDb21tZW50ID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDg7XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgY29uc3Qge1xuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7XG4gICAgICBwYXRjaFByb3AsXG4gICAgICBjcmVhdGVUZXh0LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICBwYXJlbnROb2RlLFxuICAgICAgcmVtb3ZlLFxuICAgICAgaW5zZXJ0LFxuICAgICAgY3JlYXRlQ29tbWVudFxuICAgIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gXG4gICAgICApO1xuICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIjtcbiAgICBjb25zdCBvbk1pc21hdGNoID0gKCkgPT4gaGFuZGxlTWlzbWF0Y2goXG4gICAgICBub2RlLFxuICAgICAgdm5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIGlzRnJhZ21lbnRTdGFydFxuICAgICk7XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZywgcGF0Y2hGbGFnIH0gPSB2bm9kZTtcbiAgICBsZXQgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgdm5vZGUuZWwgPSBub2RlO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGVmKG5vZGUsIFwiX192bm9kZVwiLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICBkZWYobm9kZSwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCBwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMykge1xuICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgcGFyZW50Tm9kZShub2RlKSwgbm9kZSk7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBtaXNtYXRjaCBpbmAsXG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgYFxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBub2RlLmRhdGFcbiAgICAgICAgICAgICAgKX1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICByZXBsYWNlTm9kZShcbiAgICAgICAgICAgIHZub2RlLmVsID0gbm9kZS5jb250ZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb21UeXBlICE9PSA4IHx8IGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tVHlwZSA9PT0gMSB8fCBkb21UeXBlID09PSAzKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxuICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPSBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMSA/IG5leHROb2RlLm91dGVySFRNTCA6IG5leHROb2RlLmRhdGE7XG4gICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0ZyYWdtZW50U3RhcnQgPyBuZXh0U2libGluZyhuZXh0Tm9kZSkgOiBuZXh0Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk1pc21hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBpZiAoIWlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEpIHtcbiAgICAgICAgICBpZiAoKGRvbVR5cGUgIT09IDEgfHwgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgIWlzVGVtcGxhdGVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBzdGFydFwiKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSwgbm9kZS5kYXRhLCBcInRlbGVwb3J0IGVuZFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nIDogY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKFwiXCIpIDogY3JlYXRlVk5vZGUoXCJkaXZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgICBoeWRyYXRlQ2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUeXBlKHBhcmVudE5vZGUobm9kZSkpLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICBoeWRyYXRlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHROb2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBjb25zdCBmb3JjZVBhdGNoID0gdHlwZSA9PT0gXCJpbnB1dFwiIHx8IHR5cGUgPT09IFwib3B0aW9uXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZm9yY2VQYXRjaCB8fCBwYXRjaEZsYWcgIT09IC0xKSB7XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IGZhbHNlO1xuICAgICAgaWYgKGlzVGVtcGxhdGVOb2RlKGVsKSkge1xuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IG5lZWRUcmFuc2l0aW9uKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gbm8gbmVlZCBjaGVjayBwYXJlbnRTdXNwZW5zZSBpbiBoeWRyYXRpb25cbiAgICAgICAgICB0cmFuc2l0aW9uXG4gICAgICAgICkgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcyAmJiBwYXJlbnRDb21wb25lbnQudm5vZGUucHJvcHMuYXBwZWFyO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZWwuY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VOb2RlKGNvbnRlbnQsIGVsLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB2bm9kZS5lbCA9IGVsID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAmJiAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAhKHByb3BzICYmIChwcm9wcy5pbm5lckhUTUwgfHwgcHJvcHMudGV4dENvbnRlbnQpKSkge1xuICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBlbC5maXJzdENoaWxkLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgYFxuU2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcbiAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICByZW1vdmUoY3VyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgIGxldCBjbGllbnRUZXh0ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChjbGllbnRUZXh0WzBdID09PSBcIlxcblwiICYmIChlbC50YWdOYW1lID09PSBcIlBSRVwiIHx8IGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikpIHtcbiAgICAgICAgICBjbGllbnRUZXh0ID0gY2xpZW50VGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IGNsaWVudFRleHQpIHtcbiAgICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCAwIC8qIFRFWFQgKi8pKSB7XG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgYFxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtlbC50ZXh0Q29udGVudH1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7dm5vZGUuY2hpbGRyZW59YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyB8fCBmb3JjZVBhdGNoIHx8ICFvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnICYgKDE2IHwgMzIpKSB7XG4gICAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gZWwudGFnTmFtZS5pbmNsdWRlcyhcIi1cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIC8vICMxMTE4OSBza2lwIGlmIHRoaXMgbm9kZSBoYXMgZGlyZWN0aXZlcyB0aGF0IGhhdmUgY3JlYXRlZCBob29rc1xuICAgICAgICAgICAgLy8gYXMgaXQgY291bGQgaGF2ZSBtdXRhdGVkIHRoZSBET00gaW4gYW55IHBvc3NpYmxlIHdheVxuICAgICAgICAgICAgIShkaXJzICYmIGRpcnMuc29tZSgoZCkgPT4gZC5kaXIuY3JlYXRlZCkpICYmIHByb3BIYXNNaXNtYXRjaChlbCwga2V5LCBwcm9wc1trZXldLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50KSkge1xuICAgICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9yY2VQYXRjaCAmJiAoa2V5LmVuZHNXaXRoKFwidmFsdWVcIikgfHwga2V5ID09PSBcImluZGV0ZXJtaW5hdGVcIikgfHwgaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpIHx8IC8vIGZvcmNlIGh5ZHJhdGUgdi1iaW5kIHdpdGggLnByb3AgbW9kaWZpZXJzXG4gICAgICAgICAgICBrZXlbMF0gPT09IFwiLlwiIHx8IGlzQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgdm9pZCAwLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgICAgcGF0Y2hQcm9wKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBcIm9uQ2xpY2tcIixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wcy5vbkNsaWNrLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA0ICYmIGlzUmVhY3RpdmUocHJvcHMuc3R5bGUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMuc3R5bGUpIHByb3BzLnN0eWxlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZUhvb2tzO1xuICAgICAgaWYgKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMgfHwgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xuICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xuICB9O1xuICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWQgPyBjaGlsZHJlbltpXSA6IGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgY29uc3QgaXNUZXh0ID0gdm5vZGUudHlwZSA9PT0gVGV4dDtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChpc1RleHQgJiYgIW9wdGltaXplZCkge1xuICAgICAgICAgIGlmIChpICsgMSA8IGwgJiYgbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baSArIDFdKS50eXBlID09PSBUZXh0KSB7XG4gICAgICAgICAgICBpbnNlcnQoXG4gICAgICAgICAgICAgIGNyZWF0ZVRleHQoXG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLnNsaWNlKHZub2RlLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBuZXh0U2libGluZyhub2RlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpc1RleHQgJiYgIXZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGluc2VydCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoXCJcIiksIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKGNvbnRhaW5lciwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIGBcblNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgeyBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSB2bm9kZTtcbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgdm5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgIHJldHVybiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IgPSBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgaW5zZXJ0KHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSwgY29udGFpbmVyLCBuZXh0KTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xuICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQobm9kZS5wYXJlbnRFbGVtZW50LCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgIGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcbi0gcmVuZGVyZWQgb24gc2VydmVyOmAsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBgKHRleHQpYCA6IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiID8gYChzdGFydCBvZiBmcmFnbWVudClgIDogYGAsXG4gICAgICAgIGBcbi0gZXhwZWN0ZWQgb24gY2xpZW50OmAsXG4gICAgICAgIHZub2RlLnR5cGVcbiAgICAgICk7XG4gICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgfVxuICAgIHZub2RlLmVsID0gbnVsbDtcbiAgICBpZiAoaXNGcmFnbWVudCkge1xuICAgICAgY29uc3QgZW5kID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5leHQyID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIGlmIChuZXh0MiAmJiBuZXh0MiAhPT0gZW5kKSB7XG4gICAgICAgICAgcmVtb3ZlKG5leHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICByZW1vdmUobm9kZSk7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBuZXh0LFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IHZub2RlLmVsO1xuICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgdm5vZGUuZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbiAgfTtcbiAgY29uc3QgbG9jYXRlQ2xvc2luZ0FuY2hvciA9IChub2RlLCBvcGVuID0gXCJbXCIsIGNsb3NlID0gXCJdXCIpID0+IHtcbiAgICBsZXQgbWF0Y2ggPSAwO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gb3BlbikgbWF0Y2grKztcbiAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gY2xvc2UpIHtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2gtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIGNvbnN0IHJlcGxhY2VOb2RlID0gKG5ld05vZGUsIG9sZE5vZGUsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudE5vZGUyID0gb2xkTm9kZS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlMikge1xuICAgICAgcGFyZW50Tm9kZTIucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gcGFyZW50Q29tcG9uZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQudm5vZGUuZWwgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgcGFyZW50LnZub2RlLmVsID0gcGFyZW50LnN1YlRyZWUuZWwgPSBuZXdOb2RlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGlzVGVtcGxhdGVOb2RlID0gKG5vZGUpID0+IHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLnRhZ05hbWUgPT09IFwiVEVNUExBVEVcIjtcbiAgfTtcbiAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XG59XG5mdW5jdGlvbiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgY2xpZW50VmFsdWUsIHZub2RlLCBpbnN0YW5jZSkge1xuICBsZXQgbWlzbWF0Y2hUeXBlO1xuICBsZXQgbWlzbWF0Y2hLZXk7XG4gIGxldCBhY3R1YWw7XG4gIGxldCBleHBlY3RlZDtcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgZXhwZWN0ZWQgPSBub3JtYWxpemVDbGFzcyhjbGllbnRWYWx1ZSk7XG4gICAgaWYgKCFpc1NldEVxdWFsKHRvQ2xhc3NTZXQoYWN0dWFsIHx8IFwiXCIpLCB0b0NsYXNzU2V0KGV4cGVjdGVkKSkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDIgLyogQ0xBU1MgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGBjbGFzc2A7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgfHwgXCJcIjtcbiAgICBleHBlY3RlZCA9IGlzU3RyaW5nKGNsaWVudFZhbHVlKSA/IGNsaWVudFZhbHVlIDogc3RyaW5naWZ5U3R5bGUobm9ybWFsaXplU3R5bGUoY2xpZW50VmFsdWUpKTtcbiAgICBjb25zdCBhY3R1YWxNYXAgPSB0b1N0eWxlTWFwKGFjdHVhbCk7XG4gICAgY29uc3QgZXhwZWN0ZWRNYXAgPSB0b1N0eWxlTWFwKGV4cGVjdGVkKTtcbiAgICBpZiAodm5vZGUuZGlycykge1xuICAgICAgZm9yIChjb25zdCB7IGRpciwgdmFsdWUgfSBvZiB2bm9kZS5kaXJzKSB7XG4gICAgICAgIGlmIChkaXIubmFtZSA9PT0gXCJzaG93XCIgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgZXhwZWN0ZWRNYXAuc2V0KFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZSwgdm5vZGUsIGV4cGVjdGVkTWFwKTtcbiAgICB9XG4gICAgaWYgKCFpc01hcEVxdWFsKGFjdHVhbE1hcCwgZXhwZWN0ZWRNYXApKSB7XG4gICAgICBtaXNtYXRjaFR5cGUgPSAzIC8qIFNUWUxFICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBcInN0eWxlXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBpc0tub3duU3ZnQXR0cihrZXkpIHx8IGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKGlzQm9vbGVhbkF0dHIoa2V5KSB8fCBpc0tub3duSHRtbEF0dHIoa2V5KSkpIHtcbiAgICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgICBhY3R1YWwgPSBlbC5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGV4cGVjdGVkID0gaW5jbHVkZUJvb2xlYW5BdHRyKGNsaWVudFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudFZhbHVlID09IG51bGwpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgYWN0dWFsID0gZWwudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV4cGVjdGVkID0gaXNSZW5kZXJhYmxlQXR0clZhbHVlKGNsaWVudFZhbHVlKSA/IFN0cmluZyhjbGllbnRWYWx1ZSkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDQgLyogQVRUUklCVVRFICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBrZXk7XG4gICAgfVxuICB9XG4gIGlmIChtaXNtYXRjaFR5cGUgIT0gbnVsbCAmJiAhaXNNaXNtYXRjaEFsbG93ZWQoZWwsIG1pc21hdGNoVHlwZSkpIHtcbiAgICBjb25zdCBmb3JtYXQgPSAodikgPT4gdiA9PT0gZmFsc2UgPyBgKG5vdCByZW5kZXJlZClgIDogYCR7bWlzbWF0Y2hLZXl9PVwiJHt2fVwiYDtcbiAgICBjb25zdCBwcmVTZWdtZW50ID0gYEh5ZHJhdGlvbiAke01pc21hdGNoVHlwZVN0cmluZ1ttaXNtYXRjaFR5cGVdfSBtaXNtYXRjaCBvbmA7XG4gICAgY29uc3QgcG9zdFNlZ21lbnQgPSBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2Zvcm1hdChhY3R1YWwpfVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtmb3JtYXQoZXhwZWN0ZWQpfVxuICBOb3RlOiB0aGlzIG1pc21hdGNoIGlzIGNoZWNrLW9ubHkuIFRoZSBET00gd2lsbCBub3QgYmUgcmVjdGlmaWVkIGluIHByb2R1Y3Rpb24gZHVlIHRvIHBlcmZvcm1hbmNlIG92ZXJoZWFkLlxuICBZb3Ugc2hvdWxkIGZpeCB0aGUgc291cmNlIG9mIHRoZSBtaXNtYXRjaC5gO1xuICAgIHtcbiAgICAgIHdhcm4kMShwcmVTZWdtZW50LCBlbCwgcG9zdFNlZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0b0NsYXNzU2V0KHN0cikge1xuICByZXR1cm4gbmV3IFNldChzdHIudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xufVxuZnVuY3Rpb24gaXNTZXRFcXVhbChhLCBiKSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IHMgb2YgYSkge1xuICAgIGlmICghYi5oYXMocykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0b1N0eWxlTWFwKHN0cikge1xuICBjb25zdCBzdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBzdHIuc3BsaXQoXCI7XCIpKSB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IGl0ZW0uc3BsaXQoXCI6XCIpO1xuICAgIGtleSA9IGtleS50cmltKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS50cmltKCk7XG4gICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgc3R5bGVNYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVNYXA7XG59XG5mdW5jdGlvbiBpc01hcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGEpIHtcbiAgICBpZiAodmFsdWUgIT09IGIuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZSwgdm5vZGUsIGV4cGVjdGVkTWFwKSB7XG4gIGNvbnN0IHJvb3QgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICBpZiAoaW5zdGFuY2UuZ2V0Q3NzVmFycyAmJiAodm5vZGUgPT09IHJvb3QgfHwgcm9vdCAmJiByb290LnR5cGUgPT09IEZyYWdtZW50ICYmIHJvb3QuY2hpbGRyZW4uaW5jbHVkZXModm5vZGUpKSkge1xuICAgIGNvbnN0IGNzc1ZhcnMgPSBpbnN0YW5jZS5nZXRDc3NWYXJzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY3NzVmFycykge1xuICAgICAgZXhwZWN0ZWRNYXAuc2V0KFxuICAgICAgICBgLS0ke2dldEVzY2FwZWRDc3NWYXJOYW1lKGtleSwgZmFsc2UpfWAsXG4gICAgICAgIFN0cmluZyhjc3NWYXJzW2tleV0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodm5vZGUgPT09IHJvb3QgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UucGFyZW50LCBpbnN0YW5jZS52bm9kZSwgZXhwZWN0ZWRNYXApO1xuICB9XG59XG5jb25zdCBhbGxvd01pc21hdGNoQXR0ciA9IFwiZGF0YS1hbGxvdy1taXNtYXRjaFwiO1xuY29uc3QgTWlzbWF0Y2hUeXBlU3RyaW5nID0ge1xuICBbMCAvKiBURVhUICovXTogXCJ0ZXh0XCIsXG4gIFsxIC8qIENISUxEUkVOICovXTogXCJjaGlsZHJlblwiLFxuICBbMiAvKiBDTEFTUyAqL106IFwiY2xhc3NcIixcbiAgWzMgLyogU1RZTEUgKi9dOiBcInN0eWxlXCIsXG4gIFs0IC8qIEFUVFJJQlVURSAqL106IFwiYXR0cmlidXRlXCJcbn07XG5mdW5jdGlvbiBpc01pc21hdGNoQWxsb3dlZChlbCwgYWxsb3dlZFR5cGUpIHtcbiAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gfHwgYWxsb3dlZFR5cGUgPT09IDEgLyogQ0hJTERSRU4gKi8pIHtcbiAgICB3aGlsZSAoZWwgJiYgIWVsLmhhc0F0dHJpYnV0ZShhbGxvd01pc21hdGNoQXR0cikpIHtcbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYWxsb3dlZEF0dHIgPSBlbCAmJiBlbC5nZXRBdHRyaWJ1dGUoYWxsb3dNaXNtYXRjaEF0dHIpO1xuICBpZiAoYWxsb3dlZEF0dHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChhbGxvd2VkQXR0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxpc3QgPSBhbGxvd2VkQXR0ci5zcGxpdChcIixcIik7XG4gICAgaWYgKGFsbG93ZWRUeXBlID09PSAwIC8qIFRFWFQgKi8gJiYgbGlzdC5pbmNsdWRlcyhcImNoaWxkcmVuXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhNaXNtYXRjaFR5cGVTdHJpbmdbYWxsb3dlZFR5cGVdKTtcbiAgfVxufVxuXG5jb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID0gZ2V0R2xvYmFsVGhpcygpLnJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgKChjYikgPT4gc2V0VGltZW91dChjYiwgMSkpO1xuY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID0gZ2V0R2xvYmFsVGhpcygpLmNhbmNlbElkbGVDYWxsYmFjayB8fCAoKGlkKSA9PiBjbGVhclRpbWVvdXQoaWQpKTtcbmNvbnN0IGh5ZHJhdGVPbklkbGUgPSAodGltZW91dCA9IDFlNCkgPT4gKGh5ZHJhdGUpID0+IHtcbiAgY29uc3QgaWQgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGh5ZHJhdGUsIHsgdGltZW91dCB9KTtcbiAgcmV0dXJuICgpID0+IGNhbmNlbElkbGVDYWxsYmFjayhpZCk7XG59O1xuZnVuY3Rpb24gZWxlbWVudElzVmlzaWJsZUluVmlld3BvcnQoZWwpIHtcbiAgY29uc3QgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7IGlubmVySGVpZ2h0LCBpbm5lcldpZHRoIH0gPSB3aW5kb3c7XG4gIHJldHVybiAodG9wID4gMCAmJiB0b3AgPCBpbm5lckhlaWdodCB8fCBib3R0b20gPiAwICYmIGJvdHRvbSA8IGlubmVySGVpZ2h0KSAmJiAobGVmdCA+IDAgJiYgbGVmdCA8IGlubmVyV2lkdGggfHwgcmlnaHQgPiAwICYmIHJpZ2h0IDwgaW5uZXJXaWR0aCk7XG59XG5jb25zdCBoeWRyYXRlT25WaXNpYmxlID0gKG9wdHMpID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGNvbnN0IG9iID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgIGlmICghZS5pc0ludGVyc2VjdGluZykgY29udGludWU7XG4gICAgICBvYi5kaXNjb25uZWN0KCk7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0sIG9wdHMpO1xuICBmb3JFYWNoKChlbCkgPT4ge1xuICAgIGlmICghKGVsIGluc3RhbmNlb2YgRWxlbWVudCkpIHJldHVybjtcbiAgICBpZiAoZWxlbWVudElzVmlzaWJsZUluVmlld3BvcnQoZWwpKSB7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBvYi5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iLm9ic2VydmUoZWwpO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IG9iLmRpc2Nvbm5lY3QoKTtcbn07XG5jb25zdCBoeWRyYXRlT25NZWRpYVF1ZXJ5ID0gKHF1ZXJ5KSA9PiAoaHlkcmF0ZSkgPT4ge1xuICBpZiAocXVlcnkpIHtcbiAgICBjb25zdCBtcWwgPSBtYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICBpZiAobXFsLm1hdGNoZXMpIHtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXFsLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaHlkcmF0ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuICgpID0+IG1xbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGh5ZHJhdGVPbkludGVyYWN0aW9uID0gKGludGVyYWN0aW9ucyA9IFtdKSA9PiAoaHlkcmF0ZSwgZm9yRWFjaCkgPT4ge1xuICBpZiAoaXNTdHJpbmcoaW50ZXJhY3Rpb25zKSkgaW50ZXJhY3Rpb25zID0gW2ludGVyYWN0aW9uc107XG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xuICBjb25zdCBkb0h5ZHJhdGUgPSAoZSkgPT4ge1xuICAgIGlmICghaGFzSHlkcmF0ZWQpIHtcbiAgICAgIGhhc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgIHRlYXJkb3duKCk7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGVhcmRvd24gPSAoKSA9PiB7XG4gICAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBpbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3JFYWNoKChlbCkgPT4ge1xuICAgIGZvciAoY29uc3QgaSBvZiBpbnRlcmFjdGlvbnMpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoaSwgZG9IeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRlYXJkb3duO1xufTtcbmZ1bmN0aW9uIGZvckVhY2hFbGVtZW50KG5vZGUsIGNiKSB7XG4gIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIikge1xuICAgIGxldCBkZXB0aCA9IDE7XG4gICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjYihuZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobmV4dCkpIHtcbiAgICAgICAgaWYgKG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICBpZiAoLS1kZXB0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dC5kYXRhID09PSBcIltcIikge1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYihub2RlKTtcbiAgfVxufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gIH1cbiAgY29uc3Qge1xuICAgIGxvYWRlcixcbiAgICBsb2FkaW5nQ29tcG9uZW50LFxuICAgIGVycm9yQ29tcG9uZW50LFxuICAgIGRlbGF5ID0gMjAwLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdHJhdGVneSxcbiAgICB0aW1lb3V0LFxuICAgIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSxcbiAgICBvbkVycm9yOiB1c2VyT25FcnJvclxuICB9ID0gc291cmNlO1xuICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICBsZXQgcmVzb2x2ZWRDb21wO1xuICBsZXQgcmV0cmllcyA9IDA7XG4gIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgIHJldHJpZXMrKztcbiAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgcmV0dXJuIGxvYWQoKTtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBsZXQgdGhpc1JlcXVlc3Q7XG4gICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0IHx8ICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcbiAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xuICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KS50aGVuKChjb21wKSA9PiB7XG4gICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjb21wKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wICYmIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIk1vZHVsZVwiKSkge1xuICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29tcCAmJiAhaXNPYmplY3QoY29tcCkgJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH0pKTtcbiAgfTtcbiAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XG4gICAgbmFtZTogXCJBc3luY0NvbXBvbmVudFdyYXBwZXJcIixcbiAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxuICAgIF9fYXN5bmNIeWRyYXRlKGVsLCBpbnN0YW5jZSwgaHlkcmF0ZSkge1xuICAgICAgY29uc3QgZG9IeWRyYXRlID0gaHlkcmF0ZVN0cmF0ZWd5ID8gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZWFyZG93biA9IGh5ZHJhdGVTdHJhdGVneShcbiAgICAgICAgICBoeWRyYXRlLFxuICAgICAgICAgIChjYikgPT4gZm9yRWFjaEVsZW1lbnQoZWwsIGNiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGVhcmRvd24pIHtcbiAgICAgICAgICAoaW5zdGFuY2UuYnVtIHx8IChpbnN0YW5jZS5idW0gPSBbXSkpLnB1c2godGVhcmRvd24pO1xuICAgICAgICB9XG4gICAgICB9IDogaHlkcmF0ZTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgZG9IeWRyYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkKCkudGhlbigoKSA9PiAhaW5zdGFuY2UuaXNVbm1vdW50ZWQgJiYgZG9IeWRyYXRlKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XG4gICAgfSxcbiAgICBzZXR1cCgpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICBoYW5kbGVFcnJvcihcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgMTMsXG4gICAgICAgICAgIWVycm9yQ29tcG9uZW50XG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgaWYgKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlIHx8IGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICByZXR1cm4gbG9hZCgpLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnQgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgICBsb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgIGluc3RhbmNlLnBhcmVudC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobG9hZGVkLnZhbHVlICYmIHJlc29sdmVkQ29tcCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUobG9hZGluZ0NvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCBwYXJlbnQpIHtcbiAgY29uc3QgeyByZWY6IHJlZjIsIHByb3BzLCBjaGlsZHJlbiwgY2UgfSA9IHBhcmVudC52bm9kZTtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xuICB2bm9kZS5yZWYgPSByZWYyO1xuICB2bm9kZS5jZSA9IGNlO1xuICBkZWxldGUgcGFyZW50LnZub2RlLmNlO1xuICByZXR1cm4gdm5vZGU7XG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xuICBuYW1lOiBgS2VlcEFsaXZlYCxcbiAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcbiAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxuICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xuICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgcDogcGF0Y2gsXG4gICAgICAgIG06IG1vdmUsXG4gICAgICAgIHVtOiBfdW5tb3VudCxcbiAgICAgICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgICAgIH1cbiAgICB9ID0gc2hhcmVkQ29udGV4dDtcbiAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgaW5zdGFuY2UyLnZub2RlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGluc3RhbmNlMixcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIubSk7XG4gICAgICBpbnZhbGlkYXRlTW91bnQoaW5zdGFuY2UyLmEpO1xuICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5kYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5kYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IHRydWU7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xuICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XG4gICAgICBjYWNoZS5mb3JFYWNoKCh2bm9kZSwga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xuICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoa2V5KSB7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmIChjYWNoZWQgJiYgKCFjdXJyZW50IHx8ICFpc1NhbWVWTm9kZVR5cGUoY2FjaGVkLCBjdXJyZW50KSkpIHtcbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICB3YXRjaChcbiAgICAgICgpID0+IFtwcm9wcy5pbmNsdWRlLCBwcm9wcy5leGNsdWRlXSxcbiAgICAgIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcbiAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKChuYW1lKSA9PiBtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKTtcbiAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKChuYW1lKSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XG4gICAgICB9LFxuICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgIHsgZmx1c2g6IFwicG9zdFwiLCBkZWVwOiB0cnVlIH1cbiAgICApO1xuICAgIGxldCBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcbiAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNTdXNwZW5zZShpbnN0YW5jZS5zdWJUcmVlLnR5cGUpKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgICAgIH0sIGluc3RhbmNlLnN1YlRyZWUuc3VzcGVuc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcbiAgICBvblVwZGF0ZWQoY2FjaGVTdWJ0cmVlKTtcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgY2FjaGUuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCB2bm9kZSA9IGdldElubmVyQ2hpbGQoc3ViVHJlZSk7XG4gICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSAmJiBjYWNoZWQua2V5ID09PSB2bm9kZS5rZXkpIHtcbiAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICAgICAgY29uc3QgZGEgPSB2bm9kZS5jb21wb25lbnQuZGE7XG4gICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xuICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fCAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDQpICYmICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSkge1xuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XG4gICAgICBpZiAodm5vZGUudHlwZSA9PT0gQ29tbWVudCkge1xuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgaXNBc3luY1dyYXBwZXIodm5vZGUpID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge30gOiBjb21wXG4gICAgICApO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xuICAgICAgaWYgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSB8fCBleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkge1xuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XG4gICAgICBjb25zdCBjYWNoZWRWTm9kZSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKHZub2RlLmVsKSB7XG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xuICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XG4gICAgICAgIHZub2RlLmVsID0gY2FjaGVkVk5vZGUuZWw7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTI7XG4gICAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NjtcbiAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgIHJldHVybiBpc1N1c3BlbnNlKHJhd1ZOb2RlLnR5cGUpID8gcmF3Vk5vZGUgOiB2bm9kZTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcbmZ1bmN0aW9uIG1hdGNoZXMocGF0dGVybiwgbmFtZSkge1xuICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoXCIsXCIpLmluY2x1ZGVzKG5hbWUpO1xuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImRhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fCAoaG9vay5fX3dkYyA9ICgpID0+IHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBob29rKCk7XG4gIH0pO1xuICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQucGFyZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQucGFyZW50KSB7XG4gICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgIGluamVjdFRvS2VlcEFsaXZlUm9vdCh3cmFwcGVkSG9vaywgdHlwZSwgdGFyZ2V0LCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdFRvS2VlcEFsaXZlUm9vdChob29rLCB0eXBlLCB0YXJnZXQsIGtlZXBBbGl2ZVJvb3QpIHtcbiAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKFxuICAgIHR5cGUsXG4gICAgaG9vayxcbiAgICBrZWVwQWxpdmVSb290LFxuICAgIHRydWVcbiAgICAvKiBwcmVwZW5kICovXG4gICk7XG4gIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xuICB9LCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTY7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+NTEyO1xufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4ID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2VoIHx8IChob29rLl9fd2VoID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XG4gICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgaWYgKHByZXBlbmQpIHtcbiAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCBcIlwiKSk7XG4gICAgd2FybiQxKFxuICAgICAgYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguIExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICsgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmAgKVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gIGlmICghaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiKSB7XG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsICguLi5hcmdzKSA9PiBob29rKC4uLmFyZ3MpLCB0YXJnZXQpO1xuICB9XG59O1xuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIpO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFxuICBcImJ1XCJcbik7XG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXG4gIFwiYnVtXCJcbik7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiKTtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFxuICBcInNwXCJcbik7XG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIik7XG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIpO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBpbmplY3RIb29rKFwiZWNcIiwgaG9vaywgdGFyZ2V0KTtcbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9IFwiY29tcG9uZW50c1wiO1xuY29uc3QgRElSRUNUSVZFUyA9IFwiZGlyZWN0aXZlc1wiO1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sLmZvcihcInYtbmRjXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xuICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaWYgKHNlbGZOYW1lICYmIChzZWxmTmFtZSA9PT0gbmFtZSB8fCBzZWxmTmFtZSA9PT0gY2FtZWxpemUobmFtZSkgfHwgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSAoXG4gICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxuICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8IC8vIGdsb2JhbCByZWdpc3RyYXRpb25cbiAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSlcbiAgICApO1xuICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgICAgY29uc3QgZXh0cmEgPSB0eXBlID09PSBDT01QT05FTlRTID8gYFxuSWYgdGhpcyBpcyBhIG5hdGl2ZSBjdXN0b20gZWxlbWVudCwgbWFrZSBzdXJlIHRvIGV4Y2x1ZGUgaXQgZnJvbSBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gIDogYGA7XG4gICAgICB3YXJuJDEoYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcbiAgcmV0dXJuIHJlZ2lzdHJ5ICYmIChyZWdpc3RyeVtuYW1lXSB8fCByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHwgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xuICBsZXQgcmV0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVtpbmRleF07XG4gIGNvbnN0IHNvdXJjZUlzQXJyYXkgPSBpc0FycmF5KHNvdXJjZSk7XG4gIGlmIChzb3VyY2VJc0FycmF5IHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICBjb25zdCBzb3VyY2VJc1JlYWN0aXZlQXJyYXkgPSBzb3VyY2VJc0FycmF5ICYmIGlzUmVhY3RpdmUoc291cmNlKTtcbiAgICBsZXQgbmVlZHNXcmFwID0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZUlzUmVhY3RpdmVBcnJheSkge1xuICAgICAgbmVlZHNXcmFwID0gIWlzU2hhbGxvdyhzb3VyY2UpO1xuICAgICAgc291cmNlID0gc2hhbGxvd1JlYWRBcnJheShzb3VyY2UpO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKFxuICAgICAgICBuZWVkc1dyYXAgPyB0b1JlYWN0aXZlKHNvdXJjZVtpXSkgOiBzb3VyY2VbaV0sXG4gICAgICAgIGksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgY2FjaGVkICYmIGNhY2hlZFtpXVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcbiAgICAgIHdhcm4kMShgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXkgPyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBzbG90LmZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzKSByZXMua2V5ID0gc2xvdC5rZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IDogc2xvdC5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBmYWxsYmFjaywgbm9TbG90dGVkKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmNlKSB7XG4gICAgaWYgKG5hbWUgIT09IFwiZGVmYXVsdFwiKSBwcm9wcy5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gb3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgW2NyZWF0ZVZOb2RlKFwic2xvdFwiLCBwcm9wcywgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSldLFxuICAgICAgNjRcbiAgICApO1xuICB9XG4gIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XG4gICAgd2FybiQxKFxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxuICAgICk7XG4gICAgc2xvdCA9ICgpID0+IFtdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gZmFsc2U7XG4gIH1cbiAgb3BlbkJsb2NrKCk7XG4gIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICBjb25zdCBzbG90S2V5ID0gcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgdmFsaWRTbG90Q29udGVudCAmJiB2YWxpZFNsb3RDb250ZW50LmtleTtcbiAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhcbiAgICBGcmFnbWVudCxcbiAgICB7XG4gICAgICBrZXk6IChzbG90S2V5ICYmICFpc1N5bWJvbChzbG90S2V5KSA/IHNsb3RLZXkgOiBgXyR7bmFtZX1gKSArIC8vICM3MjU2IGZvcmNlIGRpZmZlcmVudGlhdGUgZmFsbGJhY2sgY29udGVudCBmcm9tIGFjdHVhbCBjb250ZW50XG4gICAgICAoIXZhbGlkU2xvdENvbnRlbnQgJiYgZmFsbGJhY2sgPyBcIl9mYlwiIDogXCJcIilcbiAgICB9LFxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcbiAgICB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgPyA2NCA6IC0yXG4gICk7XG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArIFwiLXNcIl07XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJiAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pID8gdm5vZGVzIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgIHdhcm4kMShgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmV0W3ByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5ICYmIC9bQS1aXS8udGVzdChrZXkpID8gYG9uOiR7a2V5fWAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gIGlmICghaSkgcmV0dXJuIG51bGw7XG4gIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKSByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaSk7XG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XG59O1xuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogKGkpID0+IGksXG4gICAgJGVsOiAoaSkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogKGkpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcbiAgICAkYXR0cnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyxcbiAgICAkc2xvdHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyxcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcbiAgICAkcGFyZW50OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcbiAgICAkaG9zdDogKGkpID0+IGkuY2UsXG4gICAgJGVtaXQ6IChpKSA9PiBpLmVtaXQsXG4gICAgJG9wdGlvbnM6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUsXG4gICAgJGZvcmNlVXBkYXRlOiAoaSkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiB7XG4gICAgICBxdWV1ZUpvYihpLnVwZGF0ZSk7XG4gICAgfSksXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcbiAgICAkd2F0Y2g6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUFxuICB9KVxuKTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkXCI7XG5jb25zdCBoYXNTZXR1cEJpbmRpbmcgPSAoc3RhdGUsIGtleSkgPT4gc3RhdGUgIT09IEVNUFRZX09CSiAmJiAhc3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgaWYgKGtleVswXSAhPT0gXCIkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgIGNhc2UgMiAvKiBEQVRBICovOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcbiAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpXG4gICAgICApIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogT1RIRVIgKi87XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcbiAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xuICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiJGF0dHJzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UuYXR0cnMsIFwiZ2V0XCIsIFwiXCIpO1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIiRzbG90c1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXG4gICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSlcbiAgICApIHtcbiAgICAgIHJldHVybiBjc3NNb2R1bGU7XG4gICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpXG4gICAgKSB7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJiAoIWlzU3RyaW5nKGtleSkgfHwgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcbiAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcbiAgICBrZXkuaW5kZXhPZihcIl9fdlwiKSAhPT0gMCkpIHtcbiAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYnV0IGlzIG5vdCBkZWZpbmVkIG9uIGluc3RhbmNlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNldCh7IF86IGluc3RhbmNlIH0sIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICBzZXR1cFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgd2FybiQxKGBDYW5ub3QgbXV0YXRlIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmcgXCIke2tleX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gPT09IFwiJFwiICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBoYXMoe1xuICAgIF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH1cbiAgfSwga2V5KSB7XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICByZXR1cm4gISFhY2Nlc3NDYWNoZVtrZXldIHx8IGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSB8fCBoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSB8fCAobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpIHx8IGhhc093bihjdHgsIGtleSkgfHwgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHwgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSk7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcbiAgICAgIHRhcmdldC5fLmFjY2Vzc0NhY2hlW2tleV0gPSAwO1xuICAgIH0gZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsIFwidmFsdWVcIikpIHtcbiAgICAgIHRoaXMuc2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLnZhbHVlLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICB9XG59O1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcbiAgICB3YXJuJDEoXG4gICAgICBgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBrZXlzIHdpbGwgYmUgZW1wdHkgaW4gcHJvZHVjdGlvbiBtb2RlIHRvIGF2b2lkIHBlcmZvcm1hbmNlIG92ZXJoZWFkLmBcbiAgICApO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgfTtcbn1cbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XG4gIH0sXG4gIGhhcyhfLCBrZXkpIHtcbiAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09IFwiX1wiICYmICFpc0dsb2JhbGx5QWxsb3dlZChrZXkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIGtleVxuICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaGFzO1xuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6ICgpID0+IGluc3RhbmNlXG4gIH0pO1xuICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxuICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcbiAgICAgIHNldDogTk9PUFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBjdHgsXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICB9ID0gaW5zdGFuY2U7XG4gIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXApIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBzZXR1cCgpIHJldHVybiBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxuICAgICAgICBzZXQ6IE5PT1BcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuJDEoXG4gIGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gXG4pO1xuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUV4cG9zZWApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVPcHRpb25zYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZVNsb3RzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVNsb3RzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVNb2RlbCgpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKFwiZGVmaW5lTW9kZWxcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybiQxKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICB9XG4gIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPckVtaXRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FycmF5KHByb3BzKSA/IHByb3BzLnJlZHVjZShcbiAgICAobm9ybWFsaXplZCwgcCkgPT4gKG5vcm1hbGl6ZWRbcF0gPSBudWxsLCBub3JtYWxpemVkKSxcbiAgICB7fVxuICApIDogcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgY29uc3QgcHJvcHMgPSBub3JtYWxpemVQcm9wc09yRW1pdHMocmF3KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX3NraXBcIikpIGNvbnRpbnVlO1xuICAgIGxldCBvcHQgPSBwcm9wc1trZXldO1xuICAgIGlmIChvcHQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICBvcHQgPSBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgfVxuICAgIGlmIChvcHQgJiYgZGVmYXVsdHNbYF9fc2tpcF8ke2tleX1gXSkge1xuICAgICAgb3B0LnNraXBGYWN0b3J5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VNb2RlbHMoYSwgYikge1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBhIHx8IGI7XG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpIHJldHVybiBhLmNvbmNhdChiKTtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGEpLCBub3JtYWxpemVQcm9wc09yRW1pdHMoYikpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvcHNSZXN0UHJveHkocHJvcHMsIGV4Y2x1ZGVkS2V5cykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBwcm9wc1trZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY3R4KSB7XG4gICAgd2FybiQxKFxuICAgICAgYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIFRoaXMgaXMgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICB9XG4gIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XG4gICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKChlKSA9PiB7XG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgd2FybiQxKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xuICAgIH1cbiAgfTtcbn1cbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcbiAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xuICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XG4gIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xuICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgLy8gc3RhdGVcbiAgICBkYXRhOiBkYXRhT3B0aW9ucyxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLFxuICAgIG1ldGhvZHMsXG4gICAgd2F0Y2g6IHdhdGNoT3B0aW9ucyxcbiAgICBwcm92aWRlOiBwcm92aWRlT3B0aW9ucyxcbiAgICBpbmplY3Q6IGluamVjdE9wdGlvbnMsXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgY3JlYXRlZCxcbiAgICBiZWZvcmVNb3VudCxcbiAgICBtb3VudGVkLFxuICAgIGJlZm9yZVVwZGF0ZSxcbiAgICB1cGRhdGVkLFxuICAgIGFjdGl2YXRlZCxcbiAgICBkZWFjdGl2YXRlZCxcbiAgICBiZWZvcmVEZXN0cm95LFxuICAgIGJlZm9yZVVubW91bnQsXG4gICAgZGVzdHJveWVkLFxuICAgIHVubW91bnRlZCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyVHJhY2tlZCxcbiAgICByZW5kZXJUcmlnZ2VyZWQsXG4gICAgZXJyb3JDYXB0dXJlZCxcbiAgICBzZXJ2ZXJQcmVmZXRjaCxcbiAgICAvLyBwdWJsaWMgQVBJXG4gICAgZXhwb3NlLFxuICAgIGluaGVyaXRBdHRycyxcbiAgICAvLyBhc3NldHNcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZXMsXG4gICAgZmlsdGVyc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbmplY3RPcHRpb25zKSB7XG4gICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xuICB9XG4gIGlmIChtZXRob2RzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkYXRhT3B0aW9ucykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxuICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG4gIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xuICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogTk9PUDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGdldCA9PT0gTk9PUCkge1xuICAgICAgICB3YXJuJDEoYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uKG9wdCkgJiYgaXNGdW5jdGlvbihvcHQuc2V0KSA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKSA6ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoKSA9PiB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gXG4gICAgICAgICk7XG4gICAgICB9IDogTk9PUDtcbiAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gYy52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHdhdGNoT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKSA6IHByb3ZpZGVPcHRpb25zO1xuICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNyZWF0ZWQpIHtcbiAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBob29rLmZvckVhY2goKF9ob29rKSA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XG4gICAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcbiAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xuICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcbiAgICAgIGV4cG9zZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxuICAgICAgICAgIHNldDogKHZhbCkgPT4gcHVibGljVGhpc1trZXldID0gdmFsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xuICAgIH1cbiAgfVxuICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xuICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcbiAgfVxuICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcbiAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMpIGluc3RhbmNlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICBpZiAoZGlyZWN0aXZlcykgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gIGlmIChzZXJ2ZXJQcmVmZXRjaCkge1xuICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QKSB7XG4gIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XG4gICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3RPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gaW5qZWN0T3B0aW9uc1trZXldO1xuICAgIGxldCBpbmplY3RlZDtcbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIG9wdCkge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChcbiAgICAgICAgICBvcHQuZnJvbSB8fCBrZXksXG4gICAgICAgICAgb3B0LmRlZmF1bHQsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0LmZyb20gfHwga2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0KTtcbiAgICB9XG4gICAgaWYgKGlzUmVmKGluamVjdGVkKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gaW5qZWN0ZWQudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4W2tleV0gPSBpbmplY3RlZDtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgIGlzQXJyYXkoaG9vaykgPyBob29rLm1hcCgoaCkgPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSkgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLFxuICAgIGluc3RhbmNlLFxuICAgIHR5cGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xuICBsZXQgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KSA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgaWYgKGlzU3RyaW5nKHJhdykpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XG4gICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgIHtcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcbiAgICB7XG4gICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xuICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgIHJhdy5mb3JFYWNoKChyKSA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKSA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcykgOiBjdHhbcmF3LmhhbmRsZXJdO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcbiAgY29uc3Qge1xuICAgIG1peGluczogZ2xvYmFsTWl4aW5zLFxuICAgIG9wdGlvbnNDYWNoZTogY2FjaGUsXG4gICAgY29uZmlnOiB7IG9wdGlvbk1lcmdlU3RyYXRlZ2llcyB9XG4gIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XG4gIGxldCByZXNvbHZlZDtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJlc29sdmVkID0gY2FjaGVkO1xuICB9IGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XG4gICAge1xuICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZCA9IHt9O1xuICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XG4gICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChcbiAgICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKVxuICAgICAgKTtcbiAgICB9XG4gICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xuICB9XG4gIGlmIChpc09iamVjdChiYXNlKSkge1xuICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XG4gIGlmIChleHRlbmRzT3B0aW9ucykge1xuICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XG4gIH1cbiAgaWYgKG1peGlucykge1xuICAgIG1peGlucy5mb3JFYWNoKFxuICAgICAgKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKVxuICAgICk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIGlmIChhc01peGluICYmIGtleSA9PT0gXCJleHBvc2VcIikge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyYXQgPSBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV0gfHwgc3RyYXRzICYmIHN0cmF0c1trZXldO1xuICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcbiAgZGF0YTogbWVyZ2VEYXRhRm4sXG4gIHByb3BzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIGVtaXRzOiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnMsXG4gIC8vIG9iamVjdHNcbiAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyBsaWZlY3ljbGVcbiAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXG4gIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlTW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcbiAgdXBkYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgZGVzdHJveWVkOiBtZXJnZUFzQXJyYXksXG4gIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZGVhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxuICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxuICAvLyBhc3NldHNcbiAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxuICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIHdhdGNoXG4gIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcbiAgLy8gcHJvdmlkZSAvIGluamVjdFxuICBwcm92aWRlOiBtZXJnZURhdGFGbixcbiAgaW5qZWN0OiBtZXJnZUluamVjdFxufTtcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkge1xuICAgIHJldHVybiB0bztcbiAgfVxuICBpZiAoIXRvKSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICByZXR1cm4gKGV4dGVuZCkoXG4gICAgICBpc0Z1bmN0aW9uKHRvKSA/IHRvLmNhbGwodGhpcywgdGhpcykgOiB0byxcbiAgICAgIGlzRnVuY3Rpb24oZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XG4gIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChyYXcpIHtcbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gcmF3O1xufVxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0bywgZnJvbSkgOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICh0bykge1xuICAgIGlmIChpc0FycmF5KHRvKSAmJiBpc0FycmF5KGZyb20pKSB7XG4gICAgICByZXR1cm4gWy4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi50bywgLi4uZnJvbV0pXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZChcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKHRvKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhmcm9tICE9IG51bGwgPyBmcm9tIDoge30pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKCF0bykgcmV0dXJuIGZyb207XG4gIGlmICghZnJvbSkgcmV0dXJuIHRvO1xuICBjb25zdCBtZXJnZWQgPSBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhcHA6IG51bGwsXG4gICAgY29uZmlnOiB7XG4gICAgICBpc05hdGl2ZVRhZzogTk8sXG4gICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcbiAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXG4gICAgICBlcnJvckhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHdhcm5IYW5kbGVyOiB2b2lkIDAsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHt9XG4gICAgfSxcbiAgICBtaXhpbnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgIHByb3ZpZGVzOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBvcHRpb25zQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIHByb3BzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIGVtaXRzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gIH07XG59XG5sZXQgdWlkJDEgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcbiAgICAgIHJvb3RDb21wb25lbnQgPSBleHRlbmQoe30sIHJvb3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHBsdWdpbkNsZWFudXBGbnMgPSBbXTtcbiAgICBsZXQgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgY29uc3QgYXBwID0gY29udGV4dC5hcHAgPSB7XG4gICAgICBfdWlkOiB1aWQkMSsrLFxuICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcbiAgICAgIF9wcm9wczogcm9vdFByb3BzLFxuICAgICAgX2NvbnRhaW5lcjogbnVsbCxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2luc3RhbmNlOiBudWxsLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcbiAgICAgIH0sXG4gICAgICBzZXQgY29uZmlnKHYpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBmdW5jdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1peGluKG1peGluKSB7XG4gICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XG4gICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcbiAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBcIk1peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwXCIgKyAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMShgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlyZWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuJDEoYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cbiBJZiB5b3Ugd2FudCB0byBtb3VudCBhbm90aGVyIGFwcCBvbiB0aGUgc2FtZSBob3N0IGNvbnRhaW5lciwgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2bm9kZSA9IGFwcC5fY2VWTm9kZSB8fCBjcmVhdGVWTm9kZShyb290Q29tcG9uZW50LCByb290UHJvcHMpO1xuICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmVuZGVyKFxuICAgICAgICAgICAgICAgIGNsb25lVk5vZGUodm5vZGUpLFxuICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcbiAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xuICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSh2bm9kZS5jb21wb25lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cbklmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Vbm1vdW50KGNsZWFudXBGbikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0eXBlb2YgY2xlYW51cEZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnQgdG8gYXBwLm9uVW5tb3VudCgpLCBidXQgZ290ICR7dHlwZW9mIGNsZWFudXBGbn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwbHVnaW5DbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuKTtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICAgICAgICBwbHVnaW5DbGVhbnVwRm5zLFxuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSxcbiAgICAgICAgICAgIDE2XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICBkZXZ0b29sc1VubW91bnRBcHAoYXBwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIGFwcC5fY29udGFpbmVyLl9fdnVlX2FwcF9fO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgcnVuV2l0aENvbnRleHQoZm4pIHtcbiAgICAgICAgY29uc3QgbGFzdEFwcCA9IGN1cnJlbnRBcHA7XG4gICAgICAgIGN1cnJlbnRBcHAgPSBhcHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudEFwcCA9IGxhc3RBcHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhcHA7XG4gIH07XG59XG5sZXQgY3VycmVudEFwcCA9IG51bGw7XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICB9XG4gICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlIHx8IGN1cnJlbnRBcHApIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGN1cnJlbnRBcHAgPyBjdXJyZW50QXBwLl9jb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UgPyBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbCA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlcyA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcyA6IHZvaWQgMDtcbiAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XG4gICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5KSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xuICB9XG59XG5mdW5jdGlvbiBoYXNJbmplY3Rpb25Db250ZXh0KCkge1xuICByZXR1cm4gISEoY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50QXBwKTtcbn1cblxuY29uc3QgaW50ZXJuYWxPYmplY3RQcm90byA9IHt9O1xuY29uc3QgY3JlYXRlSW50ZXJuYWxPYmplY3QgPSAoKSA9PiBPYmplY3QuY3JlYXRlKGludGVybmFsT2JqZWN0UHJvdG8pO1xuY29uc3QgaXNJbnRlcm5hbE9iamVjdCA9IChvYmopID0+IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBpbnRlcm5hbE9iamVjdFByb3RvO1xuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGNvbnN0IHByb3BzID0ge307XG4gIGNvbnN0IGF0dHJzID0gY3JlYXRlSW50ZXJuYWxPYmplY3QoKTtcbiAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcbiAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICBwcm9wc1trZXldID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGlzU3RhdGVmdWwpIHtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYXR0cnMgPSBhdHRycztcbn1cbmZ1bmN0aW9uIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIHdoaWxlIChpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS50eXBlLl9faG1ySWQpIHJldHVybiB0cnVlO1xuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50O1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHJhd1ByZXZQcm9wcywgb3B0aW1pemVkKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9wcyxcbiAgICBhdHRycyxcbiAgICB2bm9kZTogeyBwYXRjaEZsYWcgfVxuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3QgW29wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxuICAgIC8vIC0gIzE5NDIgaWYgaG1yIGlzIGVuYWJsZWQgd2l0aCBzZmMgY29tcG9uZW50XG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcbiAgICAhKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpKSAmJiAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmICEocGF0Y2hGbGFnICYgMTYpXG4gICkge1xuICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xuICAgICAgICBpZiAoaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBjYW1lbGl6ZWRLZXksXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcbiAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGxldCBrZWJhYktleTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgIGlmICghcmF3UHJvcHMgfHwgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAvLyBpdCdzIHBvc3NpYmxlIHRoZSBvcmlnaW5hbCBwcm9wcyB3YXMgcGFzc2VkIGluIGFzIGtlYmFiLWNhc2VcbiAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxuICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmIC8vIGZvciBjYW1lbENhc2VcbiAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHZvaWQgMCB8fCAvLyBmb3Iga2ViYWItY2FzZVxuICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHZvaWQgMCkpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJzICE9PSByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmICghcmF3UHJvcHMgfHwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XG4gICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XG4gICAgdHJpZ2dlcihpbnN0YW5jZS5hdHRycywgXCJzZXRcIiwgXCJcIik7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcbiAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgbGV0IHJhd0Nhc3RWYWx1ZXM7XG4gIGlmIChyYXdQcm9wcykge1xuICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICBsZXQgY2FtZWxLZXk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkge1xuICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xuICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChyYXdDYXN0VmFsdWVzIHx8IChyYXdDYXN0VmFsdWVzID0ge30pKVtjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmVlZENhc3RLZXlzKSB7XG4gICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICAgIGNvbnN0IGNhc3RWYWx1ZXMgPSByYXdDYXN0VmFsdWVzIHx8IEVNUFRZX09CSjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAga2V5LFxuICAgICAgICBjYXN0VmFsdWVzW2tleV0sXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICAhaGFzT3duKGNhc3RWYWx1ZXMsIGtleSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNBdHRyc0NoYW5nZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSwgaXNBYnNlbnQpIHtcbiAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xuICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdCwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xuICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiAhb3B0LnNraXBGYWN0b3J5ICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoa2V5IGluIHByb3BzRGVmYXVsdHMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdGFuY2UuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuY2UuX3NldFByb3Aoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xuICAgICAgaWYgKGlzQWJzZW50ICYmICFoYXNEZWZhdWx0KSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IG1peGluUHJvcHNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IF9fVlVFX09QVElPTlNfQVBJX18gJiYgYXNNaXhpbiA/IG1peGluUHJvcHNDYWNoZSA6IGFwcENvbnRleHQucHJvcHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdzIpID0+IHtcbiAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XG4gICAgICBpZiAoa2V5cykgbmVlZENhc3RLZXlzLnB1c2goLi4ua2V5cyk7XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBFTVBUWV9BUlIpO1xuICAgIH1cbiAgICByZXR1cm4gRU1QVFlfQVJSO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzU3RyaW5nKHJhd1tpXSkpIHtcbiAgICAgICAgd2FybiQxKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShyYXdbaV0pO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmF3KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KHJhdykpIHtcbiAgICAgIHdhcm4kMShgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xuICAgICAgICBjb25zdCBwcm9wID0gbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogZXh0ZW5kKHt9LCBvcHQpO1xuICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHByb3AudHlwZTtcbiAgICAgICAgbGV0IHNob3VsZENhc3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNob3VsZENhc3RUcnVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzQXJyYXkocHJvcFR5cGUpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb3BUeXBlLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHByb3BUeXBlW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID0gaXNGdW5jdGlvbih0eXBlKSAmJiB0eXBlLm5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZU5hbWUgPT09IFwiQm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgIHNob3VsZENhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgc2hvdWxkQ2FzdFRydWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvdWxkQ2FzdCA9IGlzRnVuY3Rpb24ocHJvcFR5cGUpICYmIHByb3BUeXBlLm5hbWUgPT09IFwiQm9vbGVhblwiO1xuICAgICAgICB9XG4gICAgICAgIHByb3BbMCAvKiBzaG91bGRDYXN0ICovXSA9IHNob3VsZENhc3Q7XG4gICAgICAgIHByb3BbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gPSBzaG91bGRDYXN0VHJ1ZTtcbiAgICAgICAgaWYgKHNob3VsZENhc3QgfHwgaGFzT3duKHByb3AsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdO1xuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wTmFtZShrZXkpIHtcbiAgaWYgKGtleVswXSAhPT0gXCIkXCIgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xuICBpZiAoY3RvciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAodHlwZW9mIGN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjdG9yLm5hbWUgfHwgXCJcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY3RvciA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IG5hbWUgPSBjdG9yLmNvbnN0cnVjdG9yICYmIGN0b3IuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gbmFtZSB8fCBcIlwiO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xuICBjb25zdCBjYW1lbGl6ZVByb3BzS2V5ID0gT2JqZWN0LmtleXMocmF3UHJvcHMpLm1hcCgoa2V5KSA9PiBjYW1lbGl6ZShrZXkpKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XG4gICAgaWYgKG9wdCA9PSBudWxsKSBjb250aW51ZTtcbiAgICB2YWxpZGF0ZVByb3AoXG4gICAgICBrZXksXG4gICAgICByZXNvbHZlZFZhbHVlc1trZXldLFxuICAgICAgb3B0LFxuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShyZXNvbHZlZFZhbHVlcykgOiByZXNvbHZlZFZhbHVlcyxcbiAgICAgICFjYW1lbGl6ZVByb3BzS2V5LmluY2x1ZGVzKGtleSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIHByb3BzLCBpc0Fic2VudCkge1xuICBjb25zdCB7IHR5cGUsIHJlcXVpcmVkLCB2YWxpZGF0b3IsIHNraXBDaGVjayB9ID0gcHJvcDtcbiAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XG4gICAgd2FybiQxKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXJlcXVpcmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZSAhPT0gdHJ1ZSAmJiAhc2tpcENoZWNrKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChleHBlY3RlZFR5cGUgfHwgXCJcIik7XG4gICAgICBpc1ZhbGlkID0gdmFsaWQ7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgd2FybiQxKGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUsIHByb3BzKSkge1xuICAgIHdhcm4kMSgnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xuICB9XG59XG5jb25zdCBpc1NpbXBsZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgXCJTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludFwiXG4pO1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICBsZXQgdmFsaWQ7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgdmFsaWQgPSB2YWx1ZSA9PT0gbnVsbDtcbiAgfSBlbHNlIGlmIChpc1NpbXBsZVR5cGUoZXhwZWN0ZWRUeXBlKSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwiT2JqZWN0XCIpIHtcbiAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IFwiQXJyYXlcIikge1xuICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYFByb3AgdHlwZSBbXSBmb3IgcHJvcCBcIiR7bmFtZX1cIiB3b24ndCBtYXRjaCBhbnl0aGluZy4gRGlkIHlvdSBtZWFuIHRvIHVzZSB0eXBlIEFycmF5IGluc3RlYWQ/YDtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLiBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oXCIgfCBcIil9YDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiYgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiYgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgfVxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBcIlN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiTnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICB9XG59XG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xuICBjb25zdCBleHBsaWNpdFR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZSgoZWxlbSkgPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnNvbWUoKGVsZW0pID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gXCJib29sZWFuXCIpO1xufVxuXG5jb25zdCBpc0ludGVybmFsS2V5ID0gKGtleSkgPT4ga2V5WzBdID09PSBcIl9cIiB8fCBrZXkgPT09IFwiJHN0YWJsZVwiO1xuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSkgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcbiAgaWYgKHJhd1Nsb3QuX24pIHtcbiAgICByZXR1cm4gcmF3U2xvdDtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgoLi4uYXJncykgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRJbnN0YW5jZSAmJiAoIWN0eCB8fCBjdHgucm9vdCA9PT0gY3VycmVudEluc3RhbmNlLnJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdCguLi5hcmdzKSk7XG4gIH0sIGN0eCk7XG4gIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xuICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHZhbHVlID0gcmF3U2xvdHNba2V5XTtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHNsb3RzW2tleV0gPSBub3JtYWxpemVTbG90KGtleSwgdmFsdWUsIGN0eCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBzbG90IFwiJHtrZXl9XCIuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xuICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSAmJiB0cnVlKSB7XG4gICAgd2FybiQxKFxuICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcbiAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XG59O1xuY29uc3QgYXNzaWduU2xvdHMgPSAoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRyZW4pIHtcbiAgICBpZiAob3B0aW1pemVkIHx8IGtleSAhPT0gXCJfXCIpIHtcbiAgICAgIHNsb3RzW2tleV0gPSBjaGlsZHJlbltrZXldO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGluaXRTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBjb25zdCBzbG90cyA9IGluc3RhbmNlLnNsb3RzID0gY3JlYXRlSW50ZXJuYWxPYmplY3QoKTtcbiAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgIGlmIChvcHRpbWl6ZWQpIHtcbiAgICAgICAgZGVmKHNsb3RzLCBcIl9cIiwgdHlwZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICB9XG59O1xuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xuICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xuICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIsIFwiJHNsb3RzXCIpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSkge1xuICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICB9XG4gICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XG4gIH1cbiAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldFtrZXldID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5sZXQgc3VwcG9ydGVkO1xubGV0IHBlcmY7XG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBwZXJmLm1hcmsoYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWApO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YDtcbiAgICBjb25zdCBlbmRUYWcgPSBzdGFydFRhZyArIGA6ZW5kYDtcbiAgICBwZXJmLm1hcmsoZW5kVGFnKTtcbiAgICBwZXJmLm1lYXN1cmUoXG4gICAgICBgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCxcbiAgICAgIHN0YXJ0VGFnLFxuICAgICAgZW5kVGFnXG4gICAgKTtcbiAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzUGVyZkVuZChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XG4gIGNvbnN0IG5lZWRXYXJuID0gW107XG4gIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX09QVElPTlNfQVBJX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0RFVlRPT0xTX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX19gKTtcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fID0gZmFsc2U7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XG4gICAgY29uc3QgbXVsdGkgPSBuZWVkV2Fybi5sZW5ndGggPiAxO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbihcIiwgXCIpfSAke211bHRpID8gYGFyZWAgOiBgaXNgfSBub3QgZXhwbGljaXRseSBkZWZpbmVkLiBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZSwgd2hpY2ggZXhwZWN0cyB0aGVzZSBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyB0byBiZSBnbG9iYWxseSBpbmplY3RlZCB2aWEgdGhlIGJ1bmRsZXIgY29uZmlnIGluIG9yZGVyIHRvIGdldCBiZXR0ZXIgdHJlZS1zaGFraW5nIGluIHRoZSBwcm9kdWN0aW9uIGJ1bmRsZS5cblxuRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QgPSBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSA7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XG4gIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcbn1cbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAge1xuICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIHRhcmdldC5fX1ZVRV9fID0gdHJ1ZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgc2V0RGV2dG9vbHNIb29rJDEodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sIHRhcmdldCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGluc2VydDogaG9zdEluc2VydCxcbiAgICByZW1vdmU6IGhvc3RSZW1vdmUsXG4gICAgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LFxuICAgIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LFxuICAgIHNldFRleHQ6IGhvc3RTZXRUZXh0LFxuICAgIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsXG4gICAgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZyxcbiAgICBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIG5hbWVzcGFjZSA9IHZvaWQgMCwgc2xvdFNjb3BlSWRzID0gbnVsbCwgb3B0aW1pemVkID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xuICAgIGlmIChuMSA9PT0gbjIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4xICYmICFpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcbiAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgbjEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEpIHtcbiAgICAgICAgICBwcm9jZXNzRWxlbWVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xuICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgICBob3N0U2V0VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCBcIlwiKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpID0+IHtcbiAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbjIuZWwsXG4gICAgICBuMi5hbmNob3JcbiAgICApO1xuICB9O1xuICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XG4gICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICB9O1xuICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgaWYgKG4yLnR5cGUgPT09IFwic3ZnXCIpIHtcbiAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgfSBlbHNlIGlmIChuMi50eXBlID09PSBcIm1hdGhcIikge1xuICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50RWxlbWVudChcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaEVsZW1lbnQoXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgZWw7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBjb25zdCB7IHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIGRpcnMgfSA9IHZub2RlO1xuICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudChcbiAgICAgIHZub2RlLnR5cGUsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBwcm9wcyAmJiBwcm9wcy5pcyxcbiAgICAgIHByb3BzXG4gICAgKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCB2bm9kZS5jaGlsZHJlbik7XG4gICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2Uodm5vZGUsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgfVxuICAgIHNldFNjb3BlSWQoZWwsIHZub2RlLCB2bm9kZS5zY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCk7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoa2V5ICE9PSBcInZhbHVlXCIgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBwcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG51bGwsIHByb3BzLnZhbHVlLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlSG9vayA9IHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZWYoZWwsIFwiX192bm9kZVwiLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICBkZWYoZWwsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwgcGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihwYXJlbnRTdXNwZW5zZSwgdHJhbnNpdGlvbik7XG4gICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9XG4gICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcIm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBpZiAoc2NvcGVJZCkge1xuICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xuICAgIH1cbiAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RTY29wZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgbGV0IHN1YlRyZWUgPSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJiBzdWJUcmVlLnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICAgICAgc3ViVHJlZSA9IGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZSA9PT0gc3ViVHJlZSB8fCBpc1N1c3BlbnNlKHN1YlRyZWUudHlwZSkgJiYgKHN1YlRyZWUuc3NDb250ZW50ID09PSB2bm9kZSB8fCBzdWJUcmVlLnNzRmFsbGJhY2sgPT09IHZub2RlKSkge1xuICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcbiAgICAgICAgc2V0U2NvcGVJZChcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRWTm9kZSxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zY29wZUlkLFxuICAgICAgICAgIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQucGFyZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSkgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGVsLl9fdm5vZGUgPSBuMjtcbiAgICB9XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xuICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNjtcbiAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGlmICh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgICB9XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAob2xkUHJvcHMuaW5uZXJIVE1MICYmIG5ld1Byb3BzLmlubmVySFRNTCA9PSBudWxsIHx8IG9sZFByb3BzLnRleHRDb250ZW50ICYmIG5ld1Byb3BzLnRleHRDb250ZW50ID09IG51bGwpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgXCJcIik7XG4gICAgfVxuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UobjIsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZShuMiwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgICBwYXRjaFByb3BzKGVsLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAyKSB7XG4gICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJjbGFzc1wiLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgbmFtZXNwYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInN0eWxlXCIsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8IGtleSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEpIHtcbiAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICBwYXRjaFByb3BzKGVsLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlKTtcbiAgICB9XG4gICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcbiAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcInVwZGF0ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEJsb2NrQ2hpbGRyZW4gPSAob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBmYWxsYmFja0NvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IChcbiAgICAgICAgLy8gb2xkVk5vZGUgbWF5IGJlIGFuIGVycm9yZWQgYXN5bmMgc2V0dXAoKSBjb21wb25lbnQgaW5zaWRlIFN1c3BlbnNlXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcbiAgICAgICAgb2xkVk5vZGUuZWwgJiYgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXG4gICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxuICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXG4gICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IHwgNjQpKSA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKSA6IChcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcbiAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXG4gICAgICAgICAgZmFsbGJhY2tDb250YWluZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBvbGRWTm9kZSxcbiAgICAgICAgbmV3Vk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRQcm9wc1trZXldLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICBpZiAobmV4dCAhPT0gcHJldiAmJiBrZXkgIT09IFwidmFsdWVcIikge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gbjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgY29uc3QgZnJhZ21lbnRFbmRBbmNob3IgPSBuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgKGlzSG1yVXBkYXRpbmcgfHwgcGF0Y2hGbGFnICYgMjA0OCkpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgLy8gIzEwMDA3XG4gICAgICAgIC8vIHN1Y2ggZnJhZ21lbnQgbGlrZSBgPD48Lz5gIHdpbGwgYmUgY29tcGlsZWQgaW50b1xuICAgICAgICAvLyBhIGZyYWdtZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIGNoaWxkcmVuLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UgZmFsbGJhY2sgdG8gYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgbjIuY2hpbGRyZW4gfHwgW10sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0ICYmIGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjMjcxNSB0aGUgcHJldmlvdXMgZnJhZ21lbnQgY291bGQndmUgYmVlbiBhIEJBSUxlZCBvbmUgYXMgYSByZXN1bHRcbiAgICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXG4gICAgICBuMS5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxuICAgICAgICAgIC8vICBnZXQgbW92ZWQgYXJvdW5kLiBNYWtlIHN1cmUgYWxsIHJvb3QgbGV2ZWwgdm5vZGVzIGluaGVyaXQgZWwuXG4gICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXG4gICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cbiAgICAgICAgICBuMi5rZXkgIT0gbnVsbCB8fCBwYXJlbnRDb21wb25lbnQgJiYgbjIgPT09IHBhcmVudENvbXBvbmVudC5zdWJUcmVlXG4gICAgICAgICkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgLyogc2hhbGxvdyAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyKSB7XG4gICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShcbiAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgKSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcbiAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XG4gICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XG4gICAgfVxuICAgIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICAgIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBmYWxzZSwgb3B0aW1pemVkKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykgaW5pdGlhbFZOb2RlLmVsID0gbnVsbDtcbiAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkKTtcbiAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBpbml0aWFsVk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IG4yLmNvbXBvbmVudCA9IG4xLmNvbXBvbmVudDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG4yLCBvcHRpbWl6ZWQpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50VXBkYXRlRm4gPSAoKSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQsIHJvb3QsIHR5cGUgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcbiAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgdHlwZS5fX2FzeW5jSHlkcmF0ZSkge1xuICAgICAgICAgICAgdHlwZS5fX2FzeW5jSHlkcmF0ZShcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBoeWRyYXRlU3ViVHJlZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJvb3QuY2UpIHtcbiAgICAgICAgICAgIHJvb3QuY2UuX2luamVjdENoaWxkU3R5bGUodHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3ViVHJlZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkpIHtcbiAgICAgICAgICBjb25zdCBzY29wZWRJbml0aWFsVk5vZGUgPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IHx8IHBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihwYXJlbnQudm5vZGUpICYmIHBhcmVudC52bm9kZS5zaGFwZUZsYWcgJiAyNTYpIHtcbiAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbFZOb2RlID0gY29udGFpbmVyID0gYW5jaG9yID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vbkh5ZHJhdGVkQXN5bmNSb290ID0gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChub25IeWRyYXRlZEFzeW5jUm9vdCkge1xuICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub25IeWRyYXRlZEFzeW5jUm9vdC5hc3luY0RlcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFVwZGF0ZUZuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JpZ2luTmV4dCA9IG5leHQ7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnUpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBwcmV2VHJlZSxcbiAgICAgICAgICBuZXh0VHJlZSxcbiAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XG4gICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmVsID0gbmV4dFRyZWUuZWw7XG4gICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCBuZXh0VHJlZS5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZVVwZGF0ZWQpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbiAgICBjb25zdCBlZmZlY3QgPSBpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoY29tcG9uZW50VXBkYXRlRm4pO1xuICAgIGluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IGluc3RhbmNlLnVwZGF0ZSA9IGVmZmVjdC5ydW4uYmluZChlZmZlY3QpO1xuICAgIGNvbnN0IGpvYiA9IGluc3RhbmNlLmpvYiA9IGVmZmVjdC5ydW5JZkRpcnR5LmJpbmQoZWZmZWN0KTtcbiAgICBqb2IuaSA9IGluc3RhbmNlO1xuICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICBlZmZlY3Quc2NoZWR1bGVyID0gKCkgPT4gcXVldWVKb2Ioam9iKTtcbiAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZWZmZWN0Lm9uVHJhY2sgPSBpbnN0YW5jZS5ydGMgPyAoZSkgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRjLCBlKSA6IHZvaWQgMDtcbiAgICAgIGVmZmVjdC5vblRyaWdnZXIgPSBpbnN0YW5jZS5ydGcgPyAoZSkgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRnLCBlKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdXBkYXRlKCk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XG4gICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XG4gICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGZsdXNoUHJlRmx1c2hDYnMoaW5zdGFuY2UpO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xuICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcbiAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCkge1xuICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYpIHtcbiAgICAgICAgcGF0Y2hVbmtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGMyICE9PSBjMSkge1xuICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxuICAgICAgICAgICAgYzEsXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoVW5rZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcbiAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcbiAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XG4gICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xuICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGMxW2ldLFxuICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xuICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICBjMSxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgYzIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICBjb21tb25MZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsMiA9IGMyLmxlbmd0aDtcbiAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxO1xuICAgIGxldCBlMiA9IGwyIC0gMTtcbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2ldO1xuICAgICAgY29uc3QgbjIgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbZTJdID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGUxLS07XG4gICAgICBlMi0tO1xuICAgIH1cbiAgICBpZiAoaSA+IGUxKSB7XG4gICAgICBpZiAoaSA8PSBlMikge1xuICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgd2hpbGUgKGkgPD0gZTIpIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGkgPiBlMikge1xuICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcbiAgICAgICAgdW5tb3VudChjMVtpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgczEgPSBpO1xuICAgICAgY29uc3QgczIgPSBpO1xuICAgICAgY29uc3Qga2V5VG9OZXdJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGkgPSBzMjsgaSA8PSBlMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksXG4gICAgICAgICAgICAgIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBwYXRjaGVkID0gMDtcbiAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XG4gICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcbiAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdG9CZVBhdGNoZWQ7IGkrKykgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcbiAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldkNoaWxkID0gYzFbaV07XG4gICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdJbmRleDtcbiAgICAgICAgaWYgKHByZXZDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gczI7IGogPD0gZTI7IGorKykge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xuICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcbiAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xuICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgcHJldkNoaWxkLFxuICAgICAgICAgICAgYzJbbmV3SW5kZXhdLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwYXRjaGVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlID0gbW92ZWQgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApIDogRU1QVFlfQVJSO1xuICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHMyICsgaTtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPT09IDApIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uMiA9IG1vdmVUeXBlICE9PSAyICYmIHNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbjtcbiAgICBpZiAobmVlZFRyYW5zaXRpb24yKSB7XG4gICAgICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCByZW1vdmUyID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZTIoKTtcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZTIsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGRpcnMsXG4gICAgICBjYWNoZUluZGV4XG4gICAgfSA9IHZub2RlO1xuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoY2FjaGVJbmRleCAhPSBudWxsKSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQucmVuZGVyQ2FjaGVbY2FjaGVJbmRleF0gPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxICYmIGRpcnM7XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50KHZub2RlLmNvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVbm1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmIC8vICM1MTU0XG4gICAgICAvLyB3aGVuIHYtb25jZSBpcyB1c2VkIGluc2lkZSBhIGJsb2NrLCBzZXRCbG9ja1RyYWNraW5nKC0xKSBtYXJrcyB0aGVcbiAgICAgIC8vIHBhcmVudCBibG9jayB3aXRoIGhhc09uY2U6IHRydWVcbiAgICAgIC8vIHNvIHRoYXQgaXQgZG9lc24ndCB0YWtlIHRoZSBmYXN0IHBhdGggZHVyaW5nIHVubW91bnQgLSBvdGhlcndpc2VcbiAgICAgIC8vIGNvbXBvbmVudHMgbmVzdGVkIGluIHYtb25jZSBhcmUgbmV2ZXIgdW5tb3VudGVkLlxuICAgICAgIWR5bmFtaWNDaGlsZHJlbi5oYXNPbmNlICYmIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8IHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQpKSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRnJhZ21lbnQgJiYgcGF0Y2hGbGFnICYgKDEyOCB8IDI1NikgfHwgIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVtb3ZlKSB7XG4gICAgICAgIHJlbW92ZSh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwidW5tb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLnBhdGNoRmxhZyA+IDAgJiYgdm5vZGUucGF0Y2hGbGFnICYgMjA0OCAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQgJiYgdHJhbnNpdGlvbi5hZnRlckxlYXZlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICBkZWxheUxlYXZlKHZub2RlLmVsLCBwZXJmb3JtUmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGN1ciAhPT0gZW5kKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XG4gICAgICBob3N0UmVtb3ZlKGN1cik7XG4gICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGVuZCk7XG4gIH07XG4gIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgdW5yZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgam9iLCBzdWJUcmVlLCB1bSwgbSwgYSB9ID0gaW5zdGFuY2U7XG4gICAgaW52YWxpZGF0ZU1vdW50KG0pO1xuICAgIGludmFsaWRhdGVNb3VudChhKTtcbiAgICBpZiAoYnVtKSB7XG4gICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgIH1cbiAgICBzY29wZS5zdG9wKCk7XG4gICAgaWYgKGpvYikge1xuICAgICAgam9iLmZsYWdzIHw9IDg7XG4gICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH1cbiAgICBpZiAodW0pIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1bSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiYgaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgJiYgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldE5leHRIb3N0Tm9kZSA9ICh2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgcmV0dXJuIHZub2RlLnN1c3BlbnNlLm5leHQoKTtcbiAgICB9XG4gICAgY29uc3QgZWwgPSBob3N0TmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yIHx8IHZub2RlLmVsKTtcbiAgICBjb25zdCB0ZWxlcG9ydEVuZCA9IGVsICYmIGVsW1RlbGVwb3J0RW5kS2V5XTtcbiAgICByZXR1cm4gdGVsZXBvcnRFbmQgPyBob3N0TmV4dFNpYmxpbmcodGVsZXBvcnRFbmQpIDogZWw7XG4gIH07XG4gIGxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAodm5vZGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5fdm5vZGUpIHtcbiAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2goXG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgaWYgKCFpc0ZsdXNoaW5nKSB7XG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcDogcGF0Y2gsXG4gICAgdW06IHVubW91bnQsXG4gICAgbTogbW92ZSxcbiAgICByOiByZW1vdmUsXG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgIG46IGdldE5leHRIb3N0Tm9kZSxcbiAgICBvOiBvcHRpb25zXG4gIH07XG4gIGxldCBoeWRyYXRlO1xuICBsZXQgaHlkcmF0ZU5vZGU7XG4gIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKFxuICAgICAgaW50ZXJuYWxzXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbmRlcixcbiAgICBoeWRyYXRlLFxuICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZSh7IHR5cGUsIHByb3BzIH0sIGN1cnJlbnROYW1lc3BhY2UpIHtcbiAgcmV0dXJuIGN1cnJlbnROYW1lc3BhY2UgPT09IFwic3ZnXCIgJiYgdHlwZSA9PT0gXCJmb3JlaWduT2JqZWN0XCIgfHwgY3VycmVudE5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiAmJiB0eXBlID09PSBcImFubm90YXRpb24teG1sXCIgJiYgcHJvcHMgJiYgcHJvcHMuZW5jb2RpbmcgJiYgcHJvcHMuZW5jb2RpbmcuaW5jbHVkZXMoXCJodG1sXCIpID8gdm9pZCAwIDogY3VycmVudE5hbWVzcGFjZTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVJlY3Vyc2UoeyBlZmZlY3QsIGpvYiB9LCBhbGxvd2VkKSB7XG4gIGlmIChhbGxvd2VkKSB7XG4gICAgZWZmZWN0LmZsYWdzIHw9IDMyO1xuICAgIGpvYi5mbGFncyB8PSA0O1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5mbGFncyAmPSB+MzI7XG4gICAgam9iLmZsYWdzICY9IH40O1xuICB9XG59XG5mdW5jdGlvbiBuZWVkVHJhbnNpdGlvbihwYXJlbnRTdXNwZW5zZSwgdHJhbnNpdGlvbikge1xuICByZXR1cm4gKCFwYXJlbnRTdXNwZW5zZSB8fCBwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xuICBjb25zdCBjaDIgPSBuMi5jaGlsZHJlbjtcbiAgaWYgKGlzQXJyYXkoY2gxKSAmJiBpc0FycmF5KGNoMikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYzEgPSBjaDFbaV07XG4gICAgICBsZXQgYzIgPSBjaDJbaV07XG4gICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyKSB7XG4gICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xuICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFsbG93ICYmIGMyLnBhdGNoRmxhZyAhPT0gLTIpXG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xuICAgICAgfVxuICAgICAgaWYgKGMyLnR5cGUgPT09IFRleHQpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGMyLnR5cGUgPT09IENvbW1lbnQgJiYgIWMyLmVsKSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcbiAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xuICBjb25zdCByZXN1bHQgPSBbMF07XG4gIGxldCBpLCBqLCB1LCB2LCBjO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBhcnJJID0gYXJyW2ldO1xuICAgIGlmIChhcnJJICE9PSAwKSB7XG4gICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgIHBbaV0gPSBqO1xuICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB1ID0gMDtcbiAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICh1IDwgdikge1xuICAgICAgICBjID0gdSArIHYgPj4gMTtcbiAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xuICAgICAgICAgIHUgPSBjICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xuICAgICAgICBpZiAodSA+IDApIHtcbiAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1ID0gcmVzdWx0Lmxlbmd0aDtcbiAgdiA9IHJlc3VsdFt1IC0gMV07XG4gIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgcmVzdWx0W3VdID0gdjtcbiAgICB2ID0gcFt2XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qgc3ViQ29tcG9uZW50ID0gaW5zdGFuY2Uuc3ViVHJlZS5jb21wb25lbnQ7XG4gIGlmIChzdWJDb21wb25lbnQpIHtcbiAgICBpZiAoc3ViQ29tcG9uZW50LmFzeW5jRGVwICYmICFzdWJDb21wb25lbnQuYXN5bmNSZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIHN1YkNvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KHN1YkNvbXBvbmVudCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlTW91bnQoaG9va3MpIHtcbiAgaWYgKGhvb2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKylcbiAgICAgIGhvb2tzW2ldLmZsYWdzIHw9IDg7XG4gIH1cbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbC5mb3IoXCJ2LXNjeFwiKTtcbmNvbnN0IHVzZVNTUkNvbnRleHQgPSAoKSA9PiB7XG4gIHtcbiAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInBvc3RcIiB9KSA6IHsgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJzeW5jXCIgfSkgOiB7IGZsdXNoOiBcInN5bmNcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGNiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uY2UgfSA9IG9wdGlvbnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjYikge1xuICAgIGlmIChpbW1lZGlhdGUgIT09IHZvaWQgMCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWVwICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9uY2UgIT09IHZvaWQgMCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgd2F0Y2goKSBcIm9uY2VcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBiYXNlV2F0Y2hPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIGJhc2VXYXRjaE9wdGlvbnMub25XYXJuID0gd2FybiQxO1xuICBjb25zdCBydW5zSW1tZWRpYXRlbHkgPSBjYiAmJiBpbW1lZGlhdGUgfHwgIWNiICYmIGZsdXNoICE9PSBcInBvc3RcIjtcbiAgbGV0IHNzckNsZWFudXA7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBpZiAoZmx1c2ggPT09IFwic3luY1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB1c2VTU1JDb250ZXh0KCk7XG4gICAgICBzc3JDbGVhbnVwID0gY3R4Ll9fd2F0Y2hlckhhbmRsZXMgfHwgKGN0eC5fX3dhdGNoZXJIYW5kbGVzID0gW10pO1xuICAgIH0gZWxzZSBpZiAoIXJ1bnNJbW1lZGlhdGVseSkge1xuICAgICAgY29uc3Qgd2F0Y2hTdG9wSGFuZGxlID0gKCkgPT4ge1xuICAgICAgfTtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5zdG9wID0gTk9PUDtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5yZXN1bWUgPSBOT09QO1xuICAgICAgd2F0Y2hTdG9wSGFuZGxlLnBhdXNlID0gTk9PUDtcbiAgICAgIHJldHVybiB3YXRjaFN0b3BIYW5kbGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICBiYXNlV2F0Y2hPcHRpb25zLmNhbGwgPSAoZm4sIHR5cGUsIGFyZ3MpID0+IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gIGxldCBpc1ByZSA9IGZhbHNlO1xuICBpZiAoZmx1c2ggPT09IFwicG9zdFwiKSB7XG4gICAgYmFzZVdhdGNoT3B0aW9ucy5zY2hlZHVsZXIgPSAoam9iKSA9PiB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmbHVzaCAhPT0gXCJzeW5jXCIpIHtcbiAgICBpc1ByZSA9IHRydWU7XG4gICAgYmFzZVdhdGNoT3B0aW9ucy5zY2hlZHVsZXIgPSAoam9iLCBpc0ZpcnN0UnVuKSA9PiB7XG4gICAgICBpZiAoaXNGaXJzdFJ1bikge1xuICAgICAgICBqb2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSm9iKGpvYik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBiYXNlV2F0Y2hPcHRpb25zLmF1Z21lbnRKb2IgPSAoam9iKSA9PiB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgaWYgKGlzUHJlKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gMjtcbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB3YXRjaEhhbmRsZSA9IHdhdGNoJDEoc291cmNlLCBjYiwgYmFzZVdhdGNoT3B0aW9ucyk7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBpZiAoc3NyQ2xlYW51cCkge1xuICAgICAgc3NyQ2xlYW51cC5wdXNoKHdhdGNoSGFuZGxlKTtcbiAgICB9IGVsc2UgaWYgKHJ1bnNJbW1lZGlhdGVseSkge1xuICAgICAgd2F0Y2hIYW5kbGUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdhdGNoSGFuZGxlO1xufVxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xuICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpID8gc291cmNlLmluY2x1ZGVzKFwiLlwiKSA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKSA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXSA6IHNvdXJjZS5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICBsZXQgY2I7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGNiID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xuICAgIG9wdGlvbnMgPSB2YWx1ZTtcbiAgfVxuICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZSh0aGlzKTtcbiAgY29uc3QgcmVzID0gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMpO1xuICByZXNldCgpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgY3VyID0gY3R4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoICYmIGN1cjsgaSsrKSB7XG4gICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VNb2RlbChwcm9wcywgbmFtZSwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybiQxKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgY29uc3QgY2FtZWxpemVkTmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaS5wcm9wc09wdGlvbnNbMF1bY2FtZWxpemVkTmFtZV0pIHtcbiAgICB3YXJuJDEoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGggcHJvcCBcIiR7bmFtZX1cIiB3aGljaCBpcyBub3QgZGVjbGFyZWQuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGNvbnN0IGh5cGhlbmF0ZWROYW1lID0gaHlwaGVuYXRlKG5hbWUpO1xuICBjb25zdCBtb2RpZmllcnMgPSBnZXRNb2RlbE1vZGlmaWVycyhwcm9wcywgY2FtZWxpemVkTmFtZSk7XG4gIGNvbnN0IHJlcyA9IGN1c3RvbVJlZigodHJhY2ssIHRyaWdnZXIpID0+IHtcbiAgICBsZXQgbG9jYWxWYWx1ZTtcbiAgICBsZXQgcHJldlNldFZhbHVlID0gRU1QVFlfT0JKO1xuICAgIGxldCBwcmV2RW1pdHRlZFZhbHVlO1xuICAgIHdhdGNoU3luY0VmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wc1tjYW1lbGl6ZWROYW1lXTtcbiAgICAgIGlmIChoYXNDaGFuZ2VkKGxvY2FsVmFsdWUsIHByb3BWYWx1ZSkpIHtcbiAgICAgICAgbG9jYWxWYWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHRyYWNrKCk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmdldCA/IG9wdGlvbnMuZ2V0KGxvY2FsVmFsdWUpIDogbG9jYWxWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZW1pdHRlZFZhbHVlID0gb3B0aW9ucy5zZXQgPyBvcHRpb25zLnNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgbG9jYWxWYWx1ZSkgJiYgIShwcmV2U2V0VmFsdWUgIT09IEVNUFRZX09CSiAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdQcm9wcyA9IGkudm5vZGUucHJvcHM7XG4gICAgICAgIGlmICghKHJhd1Byb3BzICYmIC8vIGNoZWNrIGlmIHBhcmVudCBoYXMgcGFzc2VkIHYtbW9kZWxcbiAgICAgICAgKG5hbWUgaW4gcmF3UHJvcHMgfHwgY2FtZWxpemVkTmFtZSBpbiByYXdQcm9wcyB8fCBoeXBoZW5hdGVkTmFtZSBpbiByYXdQcm9wcykgJiYgKGBvblVwZGF0ZToke25hbWV9YCBpbiByYXdQcm9wcyB8fCBgb25VcGRhdGU6JHtjYW1lbGl6ZWROYW1lfWAgaW4gcmF3UHJvcHMgfHwgYG9uVXBkYXRlOiR7aHlwaGVuYXRlZE5hbWV9YCBpbiByYXdQcm9wcykpKSB7XG4gICAgICAgICAgbG9jYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpLmVtaXQoYHVwZGF0ZToke25hbWV9YCwgZW1pdHRlZFZhbHVlKTtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQodmFsdWUsIGVtaXR0ZWRWYWx1ZSkgJiYgaGFzQ2hhbmdlZCh2YWx1ZSwgcHJldlNldFZhbHVlKSAmJiAhaGFzQ2hhbmdlZChlbWl0dGVkVmFsdWUsIHByZXZFbWl0dGVkVmFsdWUpKSB7XG4gICAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZTZXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBwcmV2RW1pdHRlZFZhbHVlID0gZW1pdHRlZFZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXNbU3ltYm9sLml0ZXJhdG9yXSA9ICgpID0+IHtcbiAgICBsZXQgaTIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBpZiAoaTIgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGkyKysgPyBtb2RpZmllcnMgfHwgRU1QVFlfT0JKIDogcmVzLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBnZXRNb2RlbE1vZGlmaWVycyA9IChwcm9wcywgbW9kZWxOYW1lKSA9PiB7XG4gIHJldHVybiBtb2RlbE5hbWUgPT09IFwibW9kZWxWYWx1ZVwiIHx8IG1vZGVsTmFtZSA9PT0gXCJtb2RlbC12YWx1ZVwiID8gcHJvcHMubW9kZWxNb2RpZmllcnMgOiBwcm9wc1tgJHttb2RlbE5hbWV9TW9kaWZpZXJzYF0gfHwgcHJvcHNbYCR7Y2FtZWxpemUobW9kZWxOYW1lKX1Nb2RpZmllcnNgXSB8fCBwcm9wc1tgJHtoeXBoZW5hdGUobW9kZWxOYW1lKX1Nb2RpZmllcnNgXTtcbn07XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XG4gIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCkgcmV0dXJuO1xuICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbWl0c09wdGlvbnMsXG4gICAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gICAgfSA9IGluc3RhbmNlO1xuICAgIGlmIChlbWl0c09wdGlvbnMpIHtcbiAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiYgdHJ1ZSkge1xuICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpIGluIHByb3BzT3B0aW9ucykpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKX1cIiBwcm9wLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBlbWl0c09wdGlvbnNbZXZlbnRdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcbiAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBhcmdzID0gcmF3QXJncztcbiAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aChcInVwZGF0ZTpcIik7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBnZXRNb2RlbE1vZGlmaWVycyhwcm9wcywgZXZlbnQuc2xpY2UoNykpO1xuICBpZiAobW9kaWZpZXJzKSB7XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAoKGEpID0+IGlzU3RyaW5nKGEpID8gYS50cmltKCkgOiBhKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChsb29zZVRvTnVtYmVyKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50ICR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBpbnN0YW5jZS50eXBlXG4gICAgICAgICl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKFxuICAgICAgICAgIGV2ZW50XG4gICAgICAgICl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbGV0IGhhbmRsZXJOYW1lO1xuICBsZXQgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KV0gfHwgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxuICBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpXTtcbiAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xuICAgIGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKV07XG4gIH1cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcbiAgaWYgKG9uY2VIYW5kbGVyKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XG4gICAgICBpbnN0YW5jZS5lbWl0dGVkID0ge307XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBvbmNlSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcbiAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcyKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xuICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgcmF3LmZvckVhY2goKGtleSkgPT4gbm9ybWFsaXplZFtrZXldID0gbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XG4gIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sIFwiXCIpO1xuICByZXR1cm4gaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fCBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8IGhhc093bihvcHRpb25zLCBrZXkpO1xufVxuXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XG4gIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgdHlwZTogQ29tcG9uZW50LFxuICAgIHZub2RlLFxuICAgIHByb3h5LFxuICAgIHdpdGhQcm94eSxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLFxuICAgIHNsb3RzLFxuICAgIGF0dHJzLFxuICAgIGVtaXQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlckNhY2hlLFxuICAgIHByb3BzLFxuICAgIGRhdGEsXG4gICAgc2V0dXBTdGF0ZSxcbiAgICBjdHgsXG4gICAgaW5oZXJpdEF0dHJzXG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0KSB7XG4gICAgICBjb25zdCBwcm94eVRvVXNlID0gd2l0aFByb3h5IHx8IHByb3h5O1xuICAgICAgY29uc3QgdGhpc1Byb3h5ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCA/IG5ldyBQcm94eShwcm94eVRvVXNlLCB7XG4gICAgICAgIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgUHJvcGVydHkgJyR7U3RyaW5nKFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICl9JyB3YXMgYWNjZXNzZWQgdmlhICd0aGlzJy4gQXZvaWQgdXNpbmcgJ3RoaXMnIGluIHRlbXBsYXRlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgfSkgOiBwcm94eVRvVXNlO1xuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlci5jYWxsKFxuICAgICAgICAgIHRoaXNQcm94eSxcbiAgICAgICAgICBwcm94eVRvVXNlLFxuICAgICAgICAgIHJlbmRlckNhY2hlLFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXG4gICAgICAgICAgc2V0dXBTdGF0ZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGN0eFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZW5kZXIyID0gQ29tcG9uZW50O1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYXR0cnMgPT09IHByb3BzKSB7XG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyMi5sZW5ndGggPiAxID8gcmVuZGVyMihcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoYXR0cnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3RzLFxuICAgICAgICAgICAgZW1pdFxuICAgICAgICAgIH0gOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9XG4gICAgICAgICkgOiByZW5kZXIyKFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wcyA/IGF0dHJzIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcbiAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxKTtcbiAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfVxuICBsZXQgcm9vdCA9IHJlc3VsdDtcbiAgbGV0IHNldFJvb3QgPSB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgW3Jvb3QsIHNldFJvb3RdID0gZ2V0Q2hpbGRSb290KHJlc3VsdCk7XG4gIH1cbiAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDYpKSB7XG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcbiAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzLFxuICAgICAgICAgICAgcHJvcHNPcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XG4gICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBhbGxBdHRyc1tpXTtcbiAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoJHtleHRyYUF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCBvciB0ZWxlcG9ydCByb290IG5vZGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudEF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKCR7ZXZlbnRBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBUaGUgZGlyZWN0aXZlcyB3aWxsIG5vdCBmdW5jdGlvbiBhcyBpbnRlbmRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBudWxsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XG4gIH1cbiAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHJvb3QsIHZub2RlLnRyYW5zaXRpb24pO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldFJvb3QpIHtcbiAgICBzZXRSb290KHJvb3QpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHJvb3Q7XG4gIH1cbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbiwgZmFsc2UpO1xuICBpZiAoIWNoaWxkUm9vdCkge1xuICAgIHJldHVybiBbdm5vZGUsIHZvaWQgMF07XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGlsZFJvb3QucGF0Y2hGbGFnID4gMCAmJiBjaGlsZFJvb3QucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIHJldHVybiBnZXRDaGlsZFJvb3QoY2hpbGRSb290KTtcbiAgfVxuICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcbiAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xuICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XG4gICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcbn07XG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuLCByZWN1cnNlID0gdHJ1ZSkge1xuICBsZXQgc2luZ2xlUm9vdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gXCJ2LWlmXCIpIHtcbiAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJlY3Vyc2UgJiYgc2luZ2xlUm9vdC5wYXRjaEZsYWcgPiAwICYmIHNpbmdsZVJvb3QucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlclNpbmdsZVJvb3Qoc2luZ2xlUm9vdC5jaGlsZHJlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbmdsZVJvb3Q7XG59XG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcbiAgbGV0IHJlcztcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIgfHwga2V5ID09PSBcInN0eWxlXCIgfHwgaXNPbihrZXkpKSB7XG4gICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xuICBjb25zdCByZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xuICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmICg2IHwgMSkgfHwgdm5vZGUudHlwZSA9PT0gQ29tbWVudDtcbn07XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xuICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xuICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xuICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xuICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gICAgfSBlbHNlIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgIH1cbiAgICBpZiAoIW5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xuICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XG4gIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xuICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwpIHtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGNvbnN0IHJvb3QgPSBwYXJlbnQuc3ViVHJlZTtcbiAgICBpZiAocm9vdC5zdXNwZW5zZSAmJiByb290LnN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9PT0gdm5vZGUpIHtcbiAgICAgIHJvb3QuZWwgPSB2bm9kZS5lbDtcbiAgICB9XG4gICAgaWYgKHJvb3QgPT09IHZub2RlKSB7XG4gICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcbmxldCBzdXNwZW5zZUlkID0gMDtcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcbiAgbmFtZTogXCJTdXNwZW5zZVwiLFxuICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XG4gIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxuICAvLyBpbnRlcm5hbHMuXG4gIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudFN1c3BlbnNlKFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UuZGVwcyA+IDAgJiYgIW4xLnN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICAgICAgICBuMi5zdXNwZW5zZS52bm9kZSA9IG4yO1xuICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXRjaFN1c3BlbnNlKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxuICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cbn07XG5jb25zdCBTdXNwZW5zZSA9IFN1c3BlbnNlSW1wbCA7XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xuICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xuICAgIGV2ZW50TGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFsc1xuICApO1xuICBwYXRjaChcbiAgICBudWxsLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIG51bGwsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHNcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uUGVuZGluZ1wiKTtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25GYWxsYmFja1wiKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZS5zc0ZhbGxiYWNrLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICBjb25zdCBzdXNwZW5zZSA9IG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gIG4yLmVsID0gbjEuZWw7XG4gIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcbiAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XG4gIGlmIChwZW5kaW5nQnJhbmNoKSB7XG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gc3VzcGVuc2VJZCsrO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckV2ZW50KG4yLCBcIm9uUGVuZGluZ1wiKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICBpZiAobmV3QnJhbmNoLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBuZXdCcmFuY2guY29tcG9uZW50LnN1c3BlbnNlSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBzdXNwZW5zZUlkKys7XG4gICAgICB9XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUgJiYgIWhhc1dhcm5lZCkge1xuICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyBcImluZm9cIiA6IFwibG9nXCJdKFxuICAgICAgYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBtOiBtb3ZlLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG46IG5leHQsXG4gICAgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGxldCBwYXJlbnRTdXNwZW5zZUlkO1xuICBjb25zdCBpc1N1c3BlbnNpYmxlID0gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKTtcbiAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgcGFyZW50U3VzcGVuc2VJZCA9IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZDtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgdGltZW91dCA9IHZub2RlLnByb3BzID8gdG9OdW1iZXIodm5vZGUucHJvcHMudGltZW91dCkgOiB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHRpbWVvdXQsIGBTdXNwZW5zZSB0aW1lb3V0YCk7XG4gIH1cbiAgY29uc3QgaW5pdGlhbEFuY2hvciA9IGFuY2hvcjtcbiAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbmFtZXNwYWNlLFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgZGVwczogMCxcbiAgICBwZW5kaW5nSWQ6IHN1c3BlbnNlSWQrKyxcbiAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIiA/IHRpbWVvdXQgOiAtMSxcbiAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcbiAgICBpc0luRmFsbGJhY2s6ICFpc0h5ZHJhdGluZyxcbiAgICBpc0h5ZHJhdGluZyxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgZWZmZWN0czogW10sXG4gICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSwgc3luYyA9IGZhbHNlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB2bm9kZTogdm5vZGUyLFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdJZCxcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcjJcbiAgICAgIH0gPSBzdXNwZW5zZTtcbiAgICAgIGxldCBkZWxheUVudGVyID0gZmFsc2U7XG4gICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIG1vdmUoXG4gICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgICAgICAgIGFuY2hvciA9PT0gaW5pdGlhbEFuY2hvciA/IG5leHQoYWN0aXZlQnJhbmNoKSA6IGFuY2hvcixcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgaWYgKHBhcmVudE5vZGUoYWN0aXZlQnJhbmNoLmVsKSA9PT0gY29udGFpbmVyMikge1xuICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50Miwgc3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBwZW5kaW5nQnJhbmNoKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XG4gICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xuICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xuICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yICYmICFkZWxheUVudGVyKSB7XG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XG4gICAgICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiBwYXJlbnRTdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDAgJiYgIXN5bmMpIHtcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25SZXNvbHZlXCIpO1xuICAgIH0sXG4gICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xuICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsIGNvbnRhaW5lcjogY29udGFpbmVyMiwgbmFtZXNwYWNlOiBuYW1lc3BhY2UyIH0gPSBzdXNwZW5zZTtcbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25GYWxsYmFja1wiKTtcbiAgICAgIGNvbnN0IGFuY2hvcjIgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZhbGxiYWNrVk5vZGUsXG4gICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgIG5hbWVzcGFjZTIsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XG4gICAgICB1bm1vdW50KFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcbiAgICAgICAgdHJ1ZVxuICAgICAgICAvLyBzaG91bGRSZW1vdmVcbiAgICAgICk7XG4gICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgbW91bnRGYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW92ZShjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKSB7XG4gICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpO1xuICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyMjtcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkMikge1xuICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcbiAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XG4gICAgICAgIHN1c3BlbnNlLmRlcHMrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcbiAgICAgIGluc3RhbmNlLmFzeW5jRGVwLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCk7XG4gICAgICB9KS50aGVuKChhc3luY1NldHVwUmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcbiAgICAgICAgICB2bm9kZTIuZWwgPSBoeWRyYXRlZEVsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgdm5vZGUyLFxuICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIG1vdmVkIGJlZm9yZSByZXNvbHZlLlxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cbiAgICAgICAgICBwYXJlbnROb2RlKGh5ZHJhdGVkRWwgfHwgaW5zdGFuY2Uuc3ViVHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWQyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZTIuZWwpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UyLCBkb1JlbW92ZSkge1xuICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgaWYgKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCkge1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICB1bm1vdW50KFxuICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHN1c3BlbnNlO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgdm5vZGUsXG4gICAgcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIG5vZGUucGFyZW50Tm9kZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICBudWxsLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgIHRydWVcbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gaHlkcmF0ZU5vZGUoXG4gICAgbm9kZSxcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBzdXNwZW5zZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4odm5vZGUpIHtcbiAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMjtcbiAgdm5vZGUuc3NDb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KFxuICAgIGlzU2xvdENoaWxkcmVuID8gY2hpbGRyZW4uZGVmYXVsdCA6IGNoaWxkcmVuXG4gICk7XG4gIHZub2RlLnNzRmFsbGJhY2sgPSBpc1Nsb3RDaGlsZHJlbiA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaykgOiBjcmVhdGVWTm9kZShDb21tZW50KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XG4gIGxldCBibG9jaztcbiAgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICBjb25zdCB0cmFja0Jsb2NrID0gaXNCbG9ja1RyZWVFbmFibGVkICYmIHMuX2M7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSBmYWxzZTtcbiAgICAgIG9wZW5CbG9jaygpO1xuICAgIH1cbiAgICBzID0gcygpO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gdHJ1ZTtcbiAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xuICAgICAgY2xvc2VCbG9jaygpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNBcnJheShzKSkge1xuICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhc2luZ2xlQ2hpbGQgJiYgcy5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZCAhPT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkubGVuZ3RoID4gMCkge1xuICAgICAgd2FybiQxKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XG4gICAgfVxuICAgIHMgPSBzaW5nbGVDaGlsZDtcbiAgfVxuICBzID0gbm9ybWFsaXplVk5vZGUocyk7XG4gIGlmIChibG9jayAmJiAhcy5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICBzLmR5bmFtaWNDaGlsZHJlbiA9IGJsb2NrLmZpbHRlcigoYykgPT4gYyAhPT0gcyk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcbiAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICBpZiAoaXNBcnJheShmbikpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGJyYW5jaCkge1xuICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XG4gIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XG4gIGxldCBlbCA9IGJyYW5jaC5lbDtcbiAgd2hpbGUgKCFlbCAmJiBicmFuY2guY29tcG9uZW50KSB7XG4gICAgYnJhbmNoID0gYnJhbmNoLmNvbXBvbmVudC5zdWJUcmVlO1xuICAgIGVsID0gYnJhbmNoLmVsO1xuICB9XG4gIHZub2RlLmVsID0gZWw7XG4gIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XG4gICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpIHtcbiAgY29uc3Qgc3VzcGVuc2libGUgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5zdXNwZW5zaWJsZTtcbiAgcmV0dXJuIHN1c3BlbnNpYmxlICE9IG51bGwgJiYgc3VzcGVuc2libGUgIT09IGZhbHNlO1xufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWZndFwiKTtcbmNvbnN0IFRleHQgPSBTeW1ib2wuZm9yKFwidi10eHRcIik7XG5jb25zdCBDb21tZW50ID0gU3ltYm9sLmZvcihcInYtY210XCIpO1xuY29uc3QgU3RhdGljID0gU3ltYm9sLmZvcihcInYtc3RjXCIpO1xuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcbiAgYmxvY2tTdGFjay5wdXNoKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSk7XG59XG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xuICBibG9ja1N0YWNrLnBvcCgpO1xuICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xuZnVuY3Rpb24gc2V0QmxvY2tUcmFja2luZyh2YWx1ZSwgaW5WT25jZSA9IGZhbHNlKSB7XG4gIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbiAgaWYgKHZhbHVlIDwgMCAmJiBjdXJyZW50QmxvY2sgJiYgaW5WT25jZSkge1xuICAgIGN1cnJlbnRCbG9jay5oYXNPbmNlID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XG4gIGNsb3NlQmxvY2soKTtcbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlQmFzZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICB0cnVlXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbjIuc2hhcGVGbGFnICYgNiAmJiBuMS5jb21wb25lbnQpIHtcbiAgICBjb25zdCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQobjIudHlwZSk7XG4gICAgaWYgKGRpcnR5SW5zdGFuY2VzICYmIGRpcnR5SW5zdGFuY2VzLmhhcyhuMS5jb21wb25lbnQpKSB7XG4gICAgICBuMS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgICAgIG4yLnNoYXBlRmxhZyAmPSB+NTEyO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcbn1cbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xuICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xufVxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBfY3JlYXRlVk5vZGUoXG4gICAgLi4udm5vZGVBcmdzVHJhbnNmb3JtZXIgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIDogYXJnc1xuICApO1xufTtcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XG5jb25zdCBub3JtYWxpemVSZWYgPSAoe1xuICByZWYsXG4gIHJlZl9rZXksXG4gIHJlZl9mb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZWYgPSBcIlwiICsgcmVmO1xuICB9XG4gIHJldHVybiByZWYgIT0gbnVsbCA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZikgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfSA6IHJlZiA6IG51bGw7XG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHZub2RlID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAga2V5OiBwcm9wcyAmJiBub3JtYWxpemVLZXkocHJvcHMpLFxuICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcbiAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IG51bGwsXG4gICAgY2hpbGRyZW4sXG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIHN1c3BlbnNlOiBudWxsLFxuICAgIHNzQ29udGVudDogbnVsbCxcbiAgICBzc0ZhbGxiYWNrOiBudWxsLFxuICAgIGRpcnM6IG51bGwsXG4gICAgdHJhbnNpdGlvbjogbnVsbCxcbiAgICBlbDogbnVsbCxcbiAgICBhbmNob3I6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRhcmdldFN0YXJ0OiBudWxsLFxuICAgIHRhcmdldEFuY2hvcjogbnVsbCxcbiAgICBzdGF0aWNDb3VudDogMCxcbiAgICBzaGFwZUZsYWcsXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXG4gICAgYXBwQ29udGV4dDogbnVsbCxcbiAgICBjdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZVxuICB9O1xuICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gaXNTdHJpbmcoY2hpbGRyZW4pID8gOCA6IDE2O1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XG4gICAgd2FybiQxKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXG4gICFpc0Jsb2NrTm9kZSAmJiAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAgY3VycmVudEJsb2NrICYmIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXG4gIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxuICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cbiAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxuICAodm5vZGUucGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2KSAmJiAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcbiAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cbiAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMikge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlO1xuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXR5cGUpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XG4gICAgfVxuICAgIHR5cGUgPSBDb21tZW50O1xuICB9XG4gIGlmIChpc1ZOb2RlKHR5cGUpKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lZC5wYXRjaEZsYWcgPSAtMjtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XG4gICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICB9XG4gIGlmIChwcm9wcykge1xuICAgIHByb3BzID0gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKTtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcbiAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKSA/IDEgOiBpc1N1c3BlbnNlKHR5cGUpID8gMTI4IDogaXNUZWxlcG9ydCh0eXBlKSA/IDY0IDogaXNPYmplY3QodHlwZSkgPyA0IDogaXNGdW5jdGlvbih0eXBlKSA/IDIgOiAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzaGFwZUZsYWcgJiA0ICYmIGlzUHJveHkodHlwZSkpIHtcbiAgICB0eXBlID0gdG9SYXcodHlwZSk7XG4gICAgd2FybiQxKFxuICAgICAgYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB0aGF0IHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgaW5zdGVhZCBvZiBcXGByZWZcXGAuYCxcbiAgICAgIGBcbkNvbXBvbmVudCB0aGF0IHdhcyBtYWRlIHJlYWN0aXZlOiBgLFxuICAgICAgdHlwZVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJhc2VWTm9kZShcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgc2hhcGVGbGFnLFxuICAgIGlzQmxvY2tOb2RlLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IGlzSW50ZXJuYWxPYmplY3QocHJvcHMpID8gZXh0ZW5kKHt9LCBwcm9wcykgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UsIGNsb25lVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IGNsb25lZCA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlOiB2bm9kZS50eXBlLFxuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXG4gICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmID8gKFxuICAgICAgLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcbiAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXG4gICAgICBtZXJnZVJlZiAmJiByZWYgPyBpc0FycmF5KHJlZikgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSkgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXG4gICAgKSA6IHJlZixcbiAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgIGNoaWxkcmVuOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHBhdGNoRmxhZyA9PT0gLTEgJiYgaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpIDogY2hpbGRyZW4sXG4gICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXG4gICAgdGFyZ2V0U3RhcnQ6IHZub2RlLnRhcmdldFN0YXJ0LFxuICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxuICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcbiAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcbiAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xuICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgIC8vIGZhc3QgcGF0aHMgb25seS5cbiAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnQgPyBwYXRjaEZsYWcgPT09IC0xID8gMTYgOiBwYXRjaEZsYWcgfCAxNiA6IHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcbiAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxuICAgIGRpcnM6IHZub2RlLmRpcnMsXG4gICAgdHJhbnNpdGlvbixcbiAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXG4gICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcbiAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXG4gICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxuICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcbiAgICBlbDogdm5vZGUuZWwsXG4gICAgYW5jaG9yOiB2bm9kZS5hbmNob3IsXG4gICAgY3R4OiB2bm9kZS5jdHgsXG4gICAgY2U6IHZub2RlLmNlXG4gIH07XG4gIGlmICh0cmFuc2l0aW9uICYmIGNsb25lVHJhbnNpdGlvbikge1xuICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgIGNsb25lZCxcbiAgICAgIHRyYW5zaXRpb24uY2xvbmUoY2xvbmVkKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XG4gIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9IFwiIFwiLCBmbGFnID0gMCkge1xuICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcbiAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9IFwiXCIsIGFzQmxvY2sgPSBmYWxzZSkge1xuICByZXR1cm4gYXNCbG9jayA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xuICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXG4gICAgICBjaGlsZC5zbGljZSgpXG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgIHJldHVybiBjbG9uZUlmTW91bnRlZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xuICByZXR1cm4gY2hpbGQuZWwgPT09IG51bGwgJiYgY2hpbGQucGF0Y2hGbGFnICE9PSAtMSB8fCBjaGlsZC5tZW1vID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbikge1xuICBsZXQgdHlwZSA9IDA7XG4gIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICB0eXBlID0gMTY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNjQpKSB7XG4gICAgICBjb25zdCBzbG90ID0gY2hpbGRyZW4uZGVmYXVsdDtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSAzMjtcbiAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcbiAgICAgIGlmICghc2xvdEZsYWcgJiYgIWlzSW50ZXJuYWxPYmplY3QoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKHNsb3RGbGFnID09PSAzICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEpIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMjtcbiAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XG4gICAgdHlwZSA9IDMyO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUgPSAxNjtcbiAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gODtcbiAgICB9XG4gIH1cbiAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XG4gICAgICAgICAgcmV0LmNsYXNzID0gbm9ybWFsaXplQ2xhc3MoW3JldC5jbGFzcywgdG9NZXJnZS5jbGFzc10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XG4gICAgICAgIGNvbnN0IGluY29taW5nID0gdG9NZXJnZVtrZXldO1xuICAgICAgICBpZiAoaW5jb21pbmcgJiYgZXhpc3RpbmcgIT09IGluY29taW5nICYmICEoaXNBcnJheShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xuICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKSA6IGluY29taW5nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSAhPT0gXCJcIikge1xuICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcsIFtcbiAgICB2bm9kZSxcbiAgICBwcmV2Vk5vZGVcbiAgXSk7XG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbmxldCB1aWQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcbiAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XG4gIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHVpZDogdWlkKyssXG4gICAgdm5vZGUsXG4gICAgdHlwZSxcbiAgICBwYXJlbnQsXG4gICAgYXBwQ29udGV4dCxcbiAgICByb290OiBudWxsLFxuICAgIC8vIHRvIGJlIGltbWVkaWF0ZWx5IHNldFxuICAgIG5leHQ6IG51bGwsXG4gICAgc3ViVHJlZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgZWZmZWN0OiBudWxsLFxuICAgIHVwZGF0ZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgam9iOiBudWxsLFxuICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUoXG4gICAgICB0cnVlXG4gICAgICAvKiBkZXRhY2hlZCAqL1xuICAgICksXG4gICAgcmVuZGVyOiBudWxsLFxuICAgIHByb3h5OiBudWxsLFxuICAgIGV4cG9zZWQ6IG51bGwsXG4gICAgZXhwb3NlUHJveHk6IG51bGwsXG4gICAgd2l0aFByb3h5OiBudWxsLFxuICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxuICAgIGlkczogcGFyZW50ID8gcGFyZW50LmlkcyA6IFtcIlwiLCAwLCAwXSxcbiAgICBhY2Nlc3NDYWNoZTogbnVsbCxcbiAgICByZW5kZXJDYWNoZTogW10sXG4gICAgLy8gbG9jYWwgcmVzb2x2ZWQgYXNzZXRzXG4gICAgY29tcG9uZW50czogbnVsbCxcbiAgICBkaXJlY3RpdmVzOiBudWxsLFxuICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXG4gICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgZW1pdHNPcHRpb25zOiBub3JtYWxpemVFbWl0c09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgLy8gZW1pdFxuICAgIGVtaXQ6IG51bGwsXG4gICAgLy8gdG8gYmUgc2V0IGltbWVkaWF0ZWx5XG4gICAgZW1pdHRlZDogbnVsbCxcbiAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXG4gICAgcHJvcHNEZWZhdWx0czogRU1QVFlfT0JKLFxuICAgIC8vIGluaGVyaXRBdHRyc1xuICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXG4gICAgLy8gc3RhdGVcbiAgICBjdHg6IEVNUFRZX09CSixcbiAgICBkYXRhOiBFTVBUWV9PQkosXG4gICAgcHJvcHM6IEVNUFRZX09CSixcbiAgICBhdHRyczogRU1QVFlfT0JKLFxuICAgIHNsb3RzOiBFTVBUWV9PQkosXG4gICAgcmVmczogRU1QVFlfT0JKLFxuICAgIHNldHVwU3RhdGU6IEVNUFRZX09CSixcbiAgICBzZXR1cENvbnRleHQ6IG51bGwsXG4gICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxuICAgIHN1c3BlbnNlLFxuICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcbiAgICBhc3luY0RlcDogbnVsbCxcbiAgICBhc3luY1Jlc29sdmVkOiBmYWxzZSxcbiAgICAvLyBsaWZlY3ljbGUgaG9va3NcbiAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxuICAgIGJjOiBudWxsLFxuICAgIGM6IG51bGwsXG4gICAgYm06IG51bGwsXG4gICAgbTogbnVsbCxcbiAgICBidTogbnVsbCxcbiAgICB1OiBudWxsLFxuICAgIHVtOiBudWxsLFxuICAgIGJ1bTogbnVsbCxcbiAgICBkYTogbnVsbCxcbiAgICBhOiBudWxsLFxuICAgIHJ0ZzogbnVsbCxcbiAgICBydGM6IG51bGwsXG4gICAgZWM6IG51bGwsXG4gICAgc3A6IG51bGxcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XG4gIH1cbiAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XG4gIGluc3RhbmNlLmVtaXQgPSBlbWl0LmJpbmQobnVsbCwgaW5zdGFuY2UpO1xuICBpZiAodm5vZGUuY2UpIHtcbiAgICB2bm9kZS5jZShpbnN0YW5jZSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG5jb25zdCBnZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xubGV0IGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlO1xubGV0IHNldEluU1NSU2V0dXBTdGF0ZTtcbntcbiAgY29uc3QgZyA9IGdldEdsb2JhbFRoaXMoKTtcbiAgY29uc3QgcmVnaXN0ZXJHbG9iYWxTZXR0ZXIgPSAoa2V5LCBzZXR0ZXIpID0+IHtcbiAgICBsZXQgc2V0dGVycztcbiAgICBpZiAoIShzZXR0ZXJzID0gZ1trZXldKSkgc2V0dGVycyA9IGdba2V5XSA9IFtdO1xuICAgIHNldHRlcnMucHVzaChzZXR0ZXIpO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgaWYgKHNldHRlcnMubGVuZ3RoID4gMSkgc2V0dGVycy5mb3JFYWNoKChzZXQpID0+IHNldCh2KSk7XG4gICAgICBlbHNlIHNldHRlcnNbMF0odik7XG4gICAgfTtcbiAgfTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UgPSByZWdpc3Rlckdsb2JhbFNldHRlcihcbiAgICBgX19WVUVfSU5TVEFOQ0VfU0VUVEVSU19fYCxcbiAgICAodikgPT4gY3VycmVudEluc3RhbmNlID0gdlxuICApO1xuICBzZXRJblNTUlNldHVwU3RhdGUgPSByZWdpc3Rlckdsb2JhbFNldHRlcihcbiAgICBgX19WVUVfU1NSX1NFVFRFUlNfX2AsXG4gICAgKHYpID0+IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IHZcbiAgKTtcbn1cbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBwcmV2ID0gY3VycmVudEluc3RhbmNlO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gIGluc3RhbmNlLnNjb3BlLm9uKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UocHJldik7XG4gIH07XG59O1xuY29uc3QgdW5zZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiB7XG4gIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xufTtcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFwic2xvdCxjb21wb25lbnRcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgeyBpc05hdGl2ZVRhZyB9KSB7XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgaXNOYXRpdmVUYWcobmFtZSkpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIkRvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6IFwiICsgbmFtZVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDQ7XG59XG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpIHtcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGlzU1NSKTtcbiAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IGluc3RhbmNlLnZub2RlO1xuICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XG4gIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcbiAgaW5pdFNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIDogdm9pZCAwO1xuICBpc1NTUiAmJiBzZXRJblNTUlNldHVwU3RhdGUoZmFsc2UpO1xuICByZXR1cm4gc2V0dXBSZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xuICB2YXIgX2E7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKENvbXBvbmVudC5uYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuZGlyZWN0aXZlcykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpbnN0YW5jZS5wcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9XG4gIGNvbnN0IHsgc2V0dXAgfSA9IENvbXBvbmVudDtcbiAgaWYgKHNldHVwKSB7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IGluc3RhbmNlLnNldHVwQ29udGV4dCA9IHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbDtcbiAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICBzZXR1cCxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgMCxcbiAgICAgIFtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcyxcbiAgICAgICAgc2V0dXBDb250ZXh0XG4gICAgICBdXG4gICAgKTtcbiAgICBjb25zdCBpc0FzeW5jU2V0dXAgPSBpc1Byb21pc2Uoc2V0dXBSZXN1bHQpO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICByZXNldCgpO1xuICAgIGlmICgoaXNBc3luY1NldHVwIHx8IGluc3RhbmNlLnNwKSAmJiAhaXNBc3luY1dyYXBwZXIoaW5zdGFuY2UpKSB7XG4gICAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChpc0FzeW5jU2V0dXApIHtcbiAgICAgIHNldHVwUmVzdWx0LnRoZW4odW5zZXRDdXJyZW50SW5zdGFuY2UsIHVuc2V0Q3VycmVudEluc3RhbmNlKTtcbiAgICAgIGlmIChpc1NTUikge1xuICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHQudGhlbigocmVzb2x2ZWRSZXN1bHQpID0+IHtcbiAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQsIGlzU1NSKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IChfYSA9IENvbXBvbmVudC5uYW1lKSAhPSBudWxsID8gX2EgOiBcIkFub255bW91c1wiO1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBDb21wb25lbnQgPCR7bmFtZX0+OiBzZXR1cCBmdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UsIGJ1dCBubyA8U3VzcGVuc2U+IGJvdW5kYXJ5IHdhcyBmb3VuZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB0cmVlLiBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIHNldHVwKCkgbXVzdCBiZSBuZXN0ZWQgaW4gYSA8U3VzcGVuc2U+IGluIG9yZGVyIHRvIGJlIHJlbmRlcmVkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xuICAgIGlmIChpbnN0YW5jZS50eXBlLl9fc3NySW5saW5lUmVuZGVyKSB7XG4gICAgICBpbnN0YW5jZS5zc3JSZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzVk5vZGUoc2V0dXBSZXN1bHQpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XG4gICAgfVxuICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YFxuICAgICk7XG4gIH1cbiAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbn1cbmxldCBjb21waWxlO1xubGV0IGluc3RhbGxXaXRoUHJveHk7XG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xuICBjb21waWxlID0gX2NvbXBpbGU7XG4gIGluc3RhbGxXaXRoUHJveHkgPSAoaSkgPT4ge1xuICAgIGlmIChpLnJlbmRlci5fcmMpIHtcbiAgICAgIGkud2l0aFByb3h5ID0gbmV3IFByb3h5KGkuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcbiAgICBpZiAoIWlzU1NSICYmIGNvbXBpbGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gQ29tcG9uZW50LnRlbXBsYXRlIHx8IF9fVlVFX09QVElPTlNfQVBJX18gJiYgcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpLnRlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50LCBjb21waWxlck9wdGlvbnMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xuICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XG4gICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKFxuICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICBkZWxpbWl0ZXJzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjb21wb25lbnRDb21waWxlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLnJlbmRlciA9IENvbXBvbmVudC5yZW5kZXIgfHwgTk9PUDtcbiAgICBpZiAoaW5zdGFsbFdpdGhQcm94eSkge1xuICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHRydWUpIHtcbiAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIHRyeSB7XG4gICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XG4gICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMShgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uOiBgLCBDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgYXR0cnNQcm94eUhhbmRsZXJzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIFwiXCIpO1xuICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgfSxcbiAgc2V0KCkge1xuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59IDoge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIFwiXCIpO1xuICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFNsb3RzUHJveHkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZS5zbG90cywge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIFwiJHNsb3RzXCIpO1xuICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgZXhwb3NlID0gKGV4cG9zZWQpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgICAgd2FybiQxKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGV4cG9zZWRUeXBlID0gdHlwZW9mIGV4cG9zZWQ7XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVmKGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwicmVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBleHBvc2UoKSBzaG91bGQgYmUgcGFzc2VkIGEgcGxhaW4gb2JqZWN0LCByZWNlaXZlZCAke2V4cG9zZWRUeXBlfS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBsZXQgYXR0cnNQcm94eTtcbiAgICBsZXQgc2xvdHNQcm94eTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1Byb3h5IHx8IChhdHRyc1Byb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRyc1Byb3h5SGFuZGxlcnMpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgc2xvdHMoKSB7XG4gICAgICAgIHJldHVybiBzbG90c1Byb3h5IHx8IChzbG90c1Byb3h5ID0gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkpO1xuICAgICAgfSxcbiAgICAgIGdldCBlbWl0KCkge1xuICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBleHBvc2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cnM6IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSxcbiAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcbiAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXG4gICAgICBleHBvc2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5leHBvc2VQcm94eSB8fCAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcbiAgICAgICAgICByZXR1cm4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHRhcmdldCB8fCBrZXkgaW4gcHVibGljUHJvcGVydGllc01hcDtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnByb3h5O1xuICB9XG59XG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGluY2x1ZGVJbmZlcnJlZCA9IHRydWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KSA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSA6IENvbXBvbmVudC5uYW1lIHx8IGluY2x1ZGVJbmZlcnJlZCAmJiBDb21wb25lbnQuX19uYW1lO1xufVxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xuICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcbiAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH1cbiAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xuICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbmFtZSA9IGluZmVyRnJvbVJlZ2lzdHJ5KFxuICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyB8fCBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzXG4gICAgKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xuICB9XG4gIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgXCJfX3ZjY09wdHNcIiBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcbiAgY29uc3QgYyA9IGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmIChpICYmIGkuYXBwQ29udGV4dC5jb25maWcud2FyblJlY3Vyc2l2ZUNvbXB1dGVkKSB7XG4gICAgICBjLl93YXJuUmVjdXJzaXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGM7XG59O1xuXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChsID09PSAyKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobCA+IDMpIHtcbiAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB9IGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcbiAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZ1ZVN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojM2JhNzc2XCIgfTtcbiAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMxNjc3ZmZcIiB9O1xuICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2Y1MjIyZFwiIH07XG4gIGNvbnN0IGtleXdvcmRTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6I2ViMmY5NlwiIH07XG4gIGNvbnN0IGZvcm1hdHRlciA9IHtcbiAgICBfX3Z1ZV9jdXN0b21fZm9ybWF0dGVyOiB0cnVlLFxuICAgIGhlYWRlcihvYmopIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1wiZGl2XCIsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWYob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICAvLyBhdm9pZCBkZWJ1Z2dlciBhY2Nlc3NpbmcgdmFsdWUgYWZmZWN0aW5nIGJlaGF2aW9yXG4gICAgICAgICAgZm9ybWF0VmFsdWUoXCJfdmFsdWVcIiBpbiBvYmogPyBvYmouX3ZhbHVlIDogb2JqKSxcbiAgICAgICAgICBgPmBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWN0aXZlXCIgOiBcIlJlYWN0aXZlXCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgYD4ke2lzUmVhZG9ubHkob2JqKSA/IGAgKHJlYWRvbmx5KWAgOiBgYH1gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZG9ubHkob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFkb25seVwiIDogXCJSZWFkb25seVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIFwiPlwiXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGhhc0JvZHkob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xuICAgIH0sXG4gICAgYm9keShvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInByb3BzXCIsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwic2V0dXBcIiwgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiZGF0YVwiLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImNvbXB1dGVkXCIpO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImNvbXB1dGVkXCIsIGNvbXB1dGVkKSk7XG4gICAgfVxuICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiaW5qZWN0XCIpO1xuICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImluamVjdGVkXCIsIGluamVjdGVkKSk7XG4gICAgfVxuICAgIGJsb2Nrcy5wdXNoKFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7fSxcbiAgICAgIFtcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgXCI7b3BhY2l0eTowLjY2XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCIkIChpbnRlcm5hbCk6IFwiXG4gICAgICBdLFxuICAgICAgW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxuICAgIF0pO1xuICAgIHJldHVybiBibG9ja3M7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VCbG9jayh0eXBlLCB0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSBleHRlbmQoe30sIHRhcmdldCk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwge31dO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3R5bGU6IFwibGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW1cIiB9LFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwiY29sb3I6IzQ3NjU4MlwiXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJwYWRkaW5nLWxlZnQ6MS4yNWVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwga2V5ICsgXCI6IFwiXSxcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlKHRhcmdldFtrZXldLCBmYWxzZSlcbiAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICAgXVxuICAgIF07XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBudW1iZXJTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHYpKSB7XG4gICAgICByZXR1cm4gW1wib2JqZWN0XCIsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XG4gICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFjdGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XG4gICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xuICAgICAgICBleHRyYWN0ZWRba2V5XSA9IGluc3RhbmNlLmN0eFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdGVkO1xuICB9XG4gIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xuICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xuICAgIGlmIChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSB8fCBpc09iamVjdChvcHRzKSAmJiBrZXkgaW4gb3B0cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUoKG0pID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XG4gICAgaWYgKGlzU2hhbGxvdyh2KSkge1xuICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcbiAgICB9XG4gICAgaWYgKHYuZWZmZWN0KSB7XG4gICAgICByZXR1cm4gYENvbXB1dGVkUmVmYDtcbiAgICB9XG4gICAgcmV0dXJuIGBSZWZgO1xuICB9XG4gIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2luZGV4XTtcbiAgaWYgKGNhY2hlZCAmJiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJldCA9IHJlbmRlcigpO1xuICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcbiAgcmV0LmNhY2hlSW5kZXggPSBpbmRleDtcbiAgcmV0dXJuIGNhY2hlW2luZGV4XSA9IHJldDtcbn1cbmZ1bmN0aW9uIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSB7XG4gIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcbiAgaWYgKHByZXYubGVuZ3RoICE9IG1lbW8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChoYXNDaGFuZ2VkKHByZXZbaV0sIG1lbW9baV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IHZlcnNpb24gPSBcIjMuNS4xM1wiO1xuY29uc3Qgd2FybiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB3YXJuJDEgOiBOT09QO1xuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IEVycm9yVHlwZVN0cmluZ3MkMSA7XG5jb25zdCBkZXZ0b29scyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHJ1ZSA/IGRldnRvb2xzJDEgOiB2b2lkIDA7XG5jb25zdCBzZXREZXZ0b29sc0hvb2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBzZXREZXZ0b29sc0hvb2skMSA6IE5PT1A7XG5jb25zdCBfc3NyVXRpbHMgPSB7XG4gIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlLFxuICBzZXR1cENvbXBvbmVudCxcbiAgcmVuZGVyQ29tcG9uZW50Um9vdCxcbiAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlLFxuICBpc1ZOb2RlOiBpc1ZOb2RlLFxuICBub3JtYWxpemVWTm9kZSxcbiAgZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UsXG4gIGVuc3VyZVZhbGlkVk5vZGUsXG4gIHB1c2hXYXJuaW5nQ29udGV4dCxcbiAgcG9wV2FybmluZ0NvbnRleHRcbn07XG5jb25zdCBzc3JVdGlscyA9IF9zc3JVdGlscyA7XG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcbmNvbnN0IGNvbXBhdFV0aWxzID0gbnVsbDtcbmNvbnN0IERlcHJlY2F0aW9uVHlwZXMgPSBudWxsO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIENvbW1lbnQsIERlcHJlY2F0aW9uVHlwZXMsIEVycm9yQ29kZXMsIEVycm9yVHlwZVN0cmluZ3MsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBhc3NlcnROdW1iZXIsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBjYWxsV2l0aEVycm9ySGFuZGxpbmcsIGNsb25lVk5vZGUsIGNvbXBhdFV0aWxzLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudEJsb2NrLCBjcmVhdGVCYXNlVk5vZGUgYXMgY3JlYXRlRWxlbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUHJvcHNSZXN0UHJveHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXRzLCBkZWZpbmVFeHBvc2UsIGRlZmluZU1vZGVsLCBkZWZpbmVPcHRpb25zLCBkZWZpbmVQcm9wcywgZGVmaW5lU2xvdHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgZ3VhcmRSZWFjdGl2ZVByb3BzLCBoLCBoYW5kbGVFcnJvciwgaGFzSW5qZWN0aW9uQ29udGV4dCwgaHlkcmF0ZU9uSWRsZSwgaHlkcmF0ZU9uSW50ZXJhY3Rpb24sIGh5ZHJhdGVPbk1lZGlhUXVlcnksIGh5ZHJhdGVPblZpc2libGUsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNNZW1vU2FtZSwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VNb2RlbHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VJZCwgdXNlTW9kZWwsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUZW1wbGF0ZVJlZiwgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdhdGNoUG9zdEVmZmVjdCwgd2F0Y2hTeW5jRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoTWVtbywgd2l0aFNjb3BlSWQgfTtcbiIsIi8qKlxuKiBAdnVlL3J1bnRpbWUtZG9tIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IHdhcm4sIGgsIEJhc2VUcmFuc2l0aW9uLCBhc3NlcnROdW1iZXIsIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBnZXRDdXJyZW50SW5zdGFuY2UsIG9uQmVmb3JlVXBkYXRlLCBxdWV1ZVBvc3RGbHVzaENiLCBvbk1vdW50ZWQsIHdhdGNoLCBvblVubW91bnRlZCwgRnJhZ21lbnQsIFN0YXRpYywgY2FtZWxpemUsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCB1bnJlZiwgY3JlYXRlVk5vZGUsIHVzZVRyYW5zaXRpb25TdGF0ZSwgb25VcGRhdGVkLCB0b1JhdywgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBzZXRUcmFuc2l0aW9uSG9va3MsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIFRleHQsIGlzUnVudGltZU9ubHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGV4dGVuZCwgaXNPYmplY3QsIHRvTnVtYmVyLCBpc0FycmF5LCBOT09QLCBpc1N0cmluZywgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzU3ltYm9sLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNGdW5jdGlvbiwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBpc1BsYWluT2JqZWN0LCBoYXNPd24sIEVNUFRZX09CSiwgbG9vc2VUb051bWJlciwgbG9vc2VJbmRleE9mLCBpc1NldCwgbG9vc2VFcXVhbCwgaW52b2tlQXJyYXlGbnMsIGlzSFRNTFRhZywgaXNTVkdUYWcsIGlzTWF0aE1MVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5sZXQgcG9saWN5ID0gdm9pZCAwO1xuY29uc3QgdHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy50cnVzdGVkVHlwZXM7XG5pZiAodHQpIHtcbiAgdHJ5IHtcbiAgICBwb2xpY3kgPSAvKiBAX19QVVJFX18gKi8gdHQuY3JlYXRlUG9saWN5KFwidnVlXCIsIHtcbiAgICAgIGNyZWF0ZUhUTUw6ICh2YWwpID0+IHZhbFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBFcnJvciBjcmVhdGluZyB0cnVzdGVkIHR5cGVzIHBvbGljeTogJHtlfWApO1xuICB9XG59XG5jb25zdCB1bnNhZmVUb1RydXN0ZWRIVE1MID0gcG9saWN5ID8gKHZhbCkgPT4gcG9saWN5LmNyZWF0ZUhUTUwodmFsKSA6ICh2YWwpID0+IHZhbDtcbmNvbnN0IHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgbWF0aG1sTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qIEBfX1BVUkVfXyAqLyBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuY29uc3Qgbm9kZU9wcyA9IHtcbiAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xuICB9LFxuICByZW1vdmU6IChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIG5hbWVzcGFjZSwgaXMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgZWwgPSBuYW1lc3BhY2UgPT09IFwic3ZnXCIgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpIDogbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhtYXRobWxOUywgdGFnKSA6IGlzID8gZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7IGlzIH0pIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGFnID09PSBcInNlbGVjdFwiICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsIHByb3BzLm11bHRpcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9LFxuICBjcmVhdGVUZXh0OiAodGV4dCkgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpLFxuICBjcmVhdGVDb21tZW50OiAodGV4dCkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXG4gIHNldFRleHQ6IChub2RlLCB0ZXh0KSA9PiB7XG4gICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICB9LFxuICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9LFxuICBwYXJlbnROb2RlOiAobm9kZSkgPT4gbm9kZS5wYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogKG5vZGUpID0+IG5vZGUubmV4dFNpYmxpbmcsXG4gIHF1ZXJ5U2VsZWN0b3I6IChzZWxlY3RvcikgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICBzZXRTY29wZUlkKGVsLCBpZCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gIH0sXG4gIC8vIF9fVU5TQUZFX19cbiAgLy8gUmVhc29uOiBpbm5lckhUTUwuXG4gIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cbiAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgbmFtZXNwYWNlLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgaWYgKHN0YXJ0ICYmIChzdGFydCA9PT0gZW5kIHx8IHN0YXJ0Lm5leHRTaWJsaW5nKSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kIHx8ICEoc3RhcnQgPSBzdGFydC5uZXh0U2libGluZykpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSB1bnNhZmVUb1RydXN0ZWRIVE1MKFxuICAgICAgICBuYW1lc3BhY2UgPT09IFwic3ZnXCIgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiA/IGA8bWF0aD4ke2NvbnRlbnR9PC9tYXRoPmAgOiBjb250ZW50XG4gICAgICApO1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbnRhaW5lci5jb250ZW50O1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJzdmdcIiB8fCBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgYW5jaG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIGZpcnN0XG4gICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcbiAgICAgIC8vIGxhc3RcbiAgICAgIGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkXG4gICAgXTtcbiAgfVxufTtcblxuY29uc3QgVFJBTlNJVElPTiA9IFwidHJhbnNpdGlvblwiO1xuY29uc3QgQU5JTUFUSU9OID0gXCJhbmltYXRpb25cIjtcbmNvbnN0IHZ0Y0tleSA9IFN5bWJvbChcIl92dGNcIik7XG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgY3NzOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXG4gIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcbn07XG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgZGVjb3JhdGUkMSA9ICh0KSA9PiB7XG4gIHQuZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbiAgdC5wcm9wcyA9IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnM7XG4gIHJldHVybiB0O1xufTtcbmNvbnN0IFRyYW5zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gZGVjb3JhdGUkMShcbiAgKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cylcbik7XG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcbiAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICBob29rLmZvckVhY2goKGgyKSA9PiBoMiguLi5hcmdzKSk7XG4gIH0gZWxzZSBpZiAoaG9vaykge1xuICAgIGhvb2soLi4uYXJncyk7XG4gIH1cbn07XG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcbiAgcmV0dXJuIGhvb2sgPyBpc0FycmF5KGhvb2spID8gaG9vay5zb21lKChoMikgPT4gaDIubGVuZ3RoID4gMSkgOiBob29rLmxlbmd0aCA+IDEgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XG4gIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xuICAgIHJldHVybiBiYXNlUHJvcHM7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcInZcIixcbiAgICB0eXBlLFxuICAgIGR1cmF0aW9uLFxuICAgIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLFxuICAgIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsXG4gICAgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gXG4gIH0gPSByYXdQcm9wcztcbiAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xuICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XG4gIGNvbnN0IHtcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLFxuICAgIG9uQXBwZWFyID0gb25FbnRlcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWRcbiAgfSA9IGJhc2VQcm9wcztcbiAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lLCBpc0NhbmNlbGxlZCkgPT4ge1xuICAgIGVsLl9lbnRlckNhbmNlbGxlZCA9IGlzQ2FuY2VsbGVkO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBpZiAoIWVsLl9lbnRlckNhbmNlbGxlZCkge1xuICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIH1cbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlLCB2b2lkIDAsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIHRydWUsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICBjYWxsSG9vayhvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hMZWF2ZShlbCk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcbiAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xuICAgIHJldHVybiBbbiwgbl07XG4gIH1cbn1cbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xuICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcihyZXMsIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAoZWxbdnRjS2V5XSB8fCAoZWxbdnRjS2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpKS5hZGQoY2xzKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZGVsZXRlKGNscyk7XG4gICAgaWYgKCFfdnRjLnNpemUpIHtcbiAgICAgIGVsW3Z0Y0tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICB9KTtcbn1cbmxldCBlbmRJZCA9IDA7XG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XG4gIGNvbnN0IGlkID0gZWwuX2VuZElkID0gKytlbmRJZDtcbiAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XG4gICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGlmIChleHBsaWNpdFRpbWVvdXQgIT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyBcImVuZFwiO1xuICBsZXQgZW5kZWQgPSAwO1xuICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgXCJcIikuc3BsaXQoXCIsIFwiKTtcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfURlbGF5YCk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RGVsYXlgKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EdXJhdGlvbmApO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRpbWVvdXQgPSAwO1xuICBsZXQgcHJvcENvdW50ID0gMDtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMCA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dCA/IFRSQU5TSVRJT04gOiBBTklNQVRJT04gOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGUgPyB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGggOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChcbiAgICBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1Qcm9wZXJ0eWApLnRvU3RyaW5nKClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHRvTXMocykge1xuICBpZiAocyA9PT0gXCJhdXRvXCIpIHJldHVybiAwO1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiAxZTM7XG59XG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbFt2dGNLZXldO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbihcIiBcIik7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCB2U2hvd09yaWdpbmFsRGlzcGxheSA9IFN5bWJvbChcIl92b2RcIik7XG5jb25zdCB2U2hvd0hpZGRlbiA9IFN5bWJvbChcIl92c2hcIik7XG5jb25zdCB2U2hvdyA9IHtcbiAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gPSBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSByZXR1cm47XG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdHJ1ZSk7XG4gICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIHZTaG93Lm5hbWUgPSBcInNob3dcIjtcbn1cbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA6IFwibm9uZVwiO1xuICBlbFt2U2hvd0hpZGRlbl0gPSAhdmFsdWU7XG59XG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XG4gIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IENTU19WQVJfVEVYVCA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJDU1NfVkFSX1RFWFRcIiA6IFwiXCIpO1xuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgQXJyYXkuZnJvbShcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuZ2V0Q3NzVmFycyA9ICgpID0+IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gIH1cbiAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHtcbiAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICBpZiAoaW5zdGFuY2UuY2UpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoaW5zdGFuY2UuY2UsIHZhcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCB2YXJzKTtcbiAgICB9XG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICB9O1xuICBvbkJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihzZXRWYXJzKTtcbiAgfSk7XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgd2F0Y2goc2V0VmFycywgTk9PUCwgeyBmbHVzaDogXCJwb3N0XCIgfSk7XG4gICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdm5vZGUuZWwpIHtcbiAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgaWYgKGVsID09PSBhbmNob3IpIGJyZWFrO1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBsZXQgY3NzVGV4dCA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgIGNzc1RleHQgKz0gYC0tJHtrZXl9OiAke3ZhcnNba2V5XX07YDtcbiAgICB9XG4gICAgc3R5bGVbQ1NTX1ZBUl9URVhUXSA9IGNzc1RleHQ7XG4gIH1cbn1cblxuY29uc3QgZGlzcGxheVJFID0gLyhefDspXFxzKmRpc3BsYXlcXHMqOi87XG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGxldCBoYXNDb250cm9sbGVkRGlzcGxheSA9IGZhbHNlO1xuICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKCFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJldlN0eWxlIG9mIHByZXYuc3BsaXQoXCI7XCIpKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcHJldlN0eWxlLnNsaWNlKDAsIHByZXZTdHlsZS5pbmRleE9mKFwiOlwiKSkudHJpbSgpO1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0Nzc1N0cmluZykge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgY29uc3QgY3NzVmFyVGV4dCA9IHN0eWxlW0NTU19WQVJfVEVYVF07XG4gICAgICAgIGlmIChjc3NWYXJUZXh0KSB7XG4gICAgICAgICAgbmV4dCArPSBcIjtcIiArIGNzc1ZhclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gZGlzcGxheVJFLnRlc3QobmV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZTaG93T3JpZ2luYWxEaXNwbGF5IGluIGVsKSB7XG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gaGFzQ29udHJvbGxlZERpc3BsYXkgPyBzdHlsZS5kaXNwbGF5IDogXCJcIjtcbiAgICBpZiAoZWxbdlNob3dIaWRkZW5dKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XG4gIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaCgodikgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09IG51bGwpIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UsIGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSkpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIGtleSxcbiAgICAgICAgaXNCb29sZWFuID8gXCJcIiA6IGlzU3ltYm9sKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBwYXJlbnRDb21wb25lbnQsIGF0dHJOYW1lKSB7XG4gIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZWxba2V5XSA9IGtleSA9PT0gXCJpbm5lckhUTUxcIiA/IHVuc2FmZVRvVHJ1c3RlZEhUTUwodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgdGFnICE9PSBcIlBST0dSRVNTXCIgJiYgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcbiAgIXRhZy5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhZyA9PT0gXCJPUFRJT05cIiA/IGVsLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCIgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAoXG4gICAgICAvLyAjMTE2NDc6IHZhbHVlIHNob3VsZCBiZSBzZXQgYXMgZW1wdHkgc3RyaW5nIGZvciBudWxsIGFuZCB1bmRlZmluZWQsXG4gICAgICAvLyBidXQgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiPiBzaG91bGQgYmUgc2V0IGFzICdvbicuXG4gICAgICBlbC50eXBlID09PSBcImNoZWNrYm94XCIgPyBcIm9uXCIgOiBcIlwiXG4gICAgKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSB8fCAhKFwiX3ZhbHVlXCIgaW4gZWwpKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lIHx8IGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5jb25zdCB2ZWlLZXkgPSBTeW1ib2woXCJfdmVpXCIpO1xuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xuICBjb25zdCBpbnZva2VycyA9IGVsW3ZlaUtleV0gfHwgKGVsW3ZlaUtleV0gPSB7fSk7XG4gIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xuICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xuICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzYW5pdGl6ZUV2ZW50VmFsdWUobmV4dFZhbHVlLCByYXdOYW1lKSA6IG5leHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XG4gICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgY29uc3QgaW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlLFxuICAgICAgICBpbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gIGxldCBvcHRpb25zO1xuICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgbTtcbiAgICB3aGlsZSAobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50ID0gbmFtZVsyXSA9PT0gXCI6XCIgPyBuYW1lLnNsaWNlKDMpIDogaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpO1xuICByZXR1cm4gW2V2ZW50LCBvcHRpb25zXTtcbn1cbmxldCBjYWNoZWROb3cgPSAwO1xuY29uc3QgcCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IGNhY2hlZE5vdyA9IDApLCBjYWNoZWROb3cgPSBEYXRlLm5vdygpKTtcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xuICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICBpZiAoIWUuX3Z0cykge1xuICAgICAgZS5fdnRzID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDUsXG4gICAgICBbZV1cbiAgICApO1xuICB9O1xuICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XG4gIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gc2FuaXRpemVFdmVudFZhbHVlKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgd2FybihcbiAgICBgV3JvbmcgdHlwZSBwYXNzZWQgYXMgZXZlbnQgaGFuZGxlciB0byAke3Byb3BOYW1lfSAtIGRpZCB5b3UgZm9yZ2V0IEAgb3IgOiBpbiBmcm9udCBvZiB5b3VyIHByb3A/XG5FeHBlY3RlZCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMsIHJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgdmFsdWV9LmBcbiAgKTtcbiAgcmV0dXJuIE5PT1A7XG59XG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xuICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWUubWFwKFxuICAgICAgKGZuKSA9PiAoZTIpID0+ICFlMi5fc3RvcHBlZCAmJiBmbiAmJiBmbihlMilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5jb25zdCBpc05hdGl2ZU9uID0gKGtleSkgPT4ga2V5LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBrZXkuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIC8vIGxvd2VyY2FzZSBsZXR0ZXJcbmtleS5jaGFyQ29kZUF0KDIpID4gOTYgJiYga2V5LmNoYXJDb2RlQXQoMikgPCAxMjM7XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gIGNvbnN0IGlzU1ZHID0gbmFtZXNwYWNlID09PSBcInN2Z1wiO1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XG4gICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXlbMF0gPT09IFwiLlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgdHJ1ZSkgOiBrZXlbMF0gPT09IFwiXlwiID8gKGtleSA9IGtleS5zbGljZSgxKSwgZmFsc2UpIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XG4gICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSk7XG4gICAgaWYgKCFlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSAmJiAoa2V5ID09PSBcInZhbHVlXCIgfHwga2V5ID09PSBcImNoZWNrZWRcIiB8fCBrZXkgPT09IFwic2VsZWN0ZWRcIikpIHtcbiAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHLCBwYXJlbnRDb21wb25lbnQsIGtleSAhPT0gXCJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gIzExMDgxIGZvcmNlIHNldCBwcm9wcyBmb3IgcG9zc2libGUgYXN5bmMgY3VzdG9tIGVsZW1lbnRcbiAgICBlbC5faXNWdWVDRSAmJiAoL1tBLVpdLy50ZXN0KGtleSkgfHwgIWlzU3RyaW5nKG5leHRWYWx1ZSkpXG4gICkge1xuICAgIHBhdGNoRE9NUHJvcChlbCwgY2FtZWxpemUkMShrZXkpLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCwga2V5KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ID09PSBcInRydWUtdmFsdWVcIikge1xuICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJmYWxzZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xuICBpZiAoaXNTVkcpIHtcbiAgICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleSBpbiBlbCAmJiBpc05hdGl2ZU9uKGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJzcGVsbGNoZWNrXCIgfHwga2V5ID09PSBcImRyYWdnYWJsZVwiIHx8IGtleSA9PT0gXCJ0cmFuc2xhdGVcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwid2lkdGhcIiB8fCBrZXkgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICAgIGlmICh0YWcgPT09IFwiSU1HXCIgfHwgdGFnID09PSBcIlZJREVPXCIgfHwgdGFnID09PSBcIkNBTlZBU1wiIHx8IHRhZyA9PT0gXCJTT1VSQ0VcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYXRpdmVPbihrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5IGluIGVsO1xufVxuXG5jb25zdCBSRU1PVkFMID0ge307XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgX2NyZWF0ZUFwcCkge1xuICBjb25zdCBDb21wID0gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gIGlmIChpc1BsYWluT2JqZWN0KENvbXApKSBleHRlbmQoQ29tcCwgZXh0cmFPcHRpb25zKTtcbiAgY2xhc3MgVnVlQ3VzdG9tRWxlbWVudCBleHRlbmRzIFZ1ZUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxQcm9wcykge1xuICAgICAgc3VwZXIoQ29tcCwgaW5pdGlhbFByb3BzLCBfY3JlYXRlQXBwKTtcbiAgICB9XG4gIH1cbiAgVnVlQ3VzdG9tRWxlbWVudC5kZWYgPSBDb21wO1xuICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcbn1cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChvcHRpb25zLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgY3JlYXRlU1NSQXBwKTtcbn07XG5jb25zdCBCYXNlQ2xhc3MgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn07XG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIF9jcmVhdGVBcHAgPSBjcmVhdGVBcHApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RlZiA9IF9kZWY7XG4gICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XG4gICAgdGhpcy5fY3JlYXRlQXBwID0gX2NyZWF0ZUFwcDtcbiAgICB0aGlzLl9pc1Z1ZUNFID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYXBwID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9ub25jZSA9IHRoaXMuX2RlZi5ub25jZTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcbiAgICB0aGlzLl9zdHlsZUNoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5fb2IgPSBudWxsO1xuICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgX2NyZWF0ZUFwcCAhPT0gY3JlYXRlQXBwKSB7XG4gICAgICB0aGlzLl9yb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGRlZmluZWQgYXMgaHlkcmF0YWJsZS4gVXNlIFxcYGRlZmluZVNTUkN1c3RvbUVsZW1lbnRcXGAuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKF9kZWYuc2hhZG93Um9vdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlUHJvcHModGhpcy5fZGVmKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIHRoaXMuX3BhcnNlU2xvdHMoKTtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpIHtcbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5fcGVuZGluZ1Jlc29sdmUpIHtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IHBhcmVudC5fcGVuZGluZ1Jlc29sdmUudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldFBhcmVudChwYXJlbnQgPSB0aGlzLl9wYXJlbnQpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZS5wYXJlbnQgPSBwYXJlbnQuX2luc3RhbmNlO1xuICAgICAgdGhpcy5faW5zdGFuY2UucHJvdmlkZXMgPSBwYXJlbnQuX2luc3RhbmNlLnByb3ZpZGVzO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICBpZiAodGhpcy5fb2IpIHtcbiAgICAgICAgICB0aGlzLl9vYi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgdGhpcy5fb2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcCAmJiB0aGlzLl9hcHAudW5tb3VudCgpO1xuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHRoaXMuX2luc3RhbmNlLmNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9hcHAgPSB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAqL1xuICBfcmVzb2x2ZURlZigpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ1Jlc29sdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9vYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cihtLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX29iLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoZGVmLCBpc0FzeW5jID0gZmFsc2UpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gdm9pZCAwO1xuICAgICAgY29uc3QgeyBwcm9wcywgc3R5bGVzIH0gPSBkZWY7XG4gICAgICBsZXQgbnVtYmVyUHJvcHM7XG4gICAgICBpZiAocHJvcHMgJiYgIWlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcbiAgICAgICAgICBpZiAob3B0ID09PSBOdW1iZXIgfHwgb3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRvTnVtYmVyKHRoaXMuX3Byb3BzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSlbY2FtZWxpemUkMShrZXkpXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bWJlclByb3BzO1xuICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKGRlZik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3R5bGVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJDdXN0b20gZWxlbWVudCBzdHlsZSBpbmplY3Rpb24gaXMgbm90IHN1cHBvcnRlZCB3aGVuIHVzaW5nIHNoYWRvd1Jvb3Q6IGZhbHNlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vdW50KGRlZik7XG4gICAgfTtcbiAgICBjb25zdCBhc3luY0RlZiA9IHRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyO1xuICAgIGlmIChhc3luY0RlZikge1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBhc3luY0RlZigpLnRoZW4oXG4gICAgICAgIChkZWYpID0+IHJlc29sdmUodGhpcy5fZGVmID0gZGVmLCB0cnVlKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBfbW91bnQoZGVmKSB7XG4gICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgIWRlZi5uYW1lKSB7XG4gICAgICBkZWYubmFtZSA9IFwiVnVlRWxlbWVudFwiO1xuICAgIH1cbiAgICB0aGlzLl9hcHAgPSB0aGlzLl9jcmVhdGVBcHAoZGVmKTtcbiAgICBpZiAoZGVmLmNvbmZpZ3VyZUFwcCkge1xuICAgICAgZGVmLmNvbmZpZ3VyZUFwcCh0aGlzLl9hcHApO1xuICAgIH1cbiAgICB0aGlzLl9hcHAuX2NlVk5vZGUgPSB0aGlzLl9jcmVhdGVWTm9kZSgpO1xuICAgIHRoaXMuX2FwcC5tb3VudCh0aGlzLl9yb290KTtcbiAgICBjb25zdCBleHBvc2VkID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuZXhwb3NlZDtcbiAgICBpZiAoIWV4cG9zZWQpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBleHBvc2VkKSB7XG4gICAgICBpZiAoIWhhc093bih0aGlzLCBrZXkpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICAvLyB1bndyYXAgcmVmIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBwdWJsaWMgaW5zdGFuY2UgYmVoYXZpb3JcbiAgICAgICAgICBnZXQ6ICgpID0+IHVucmVmKGV4cG9zZWRba2V5XSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybihgRXhwb3NlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGFscmVhZHkgZXhpc3RzIG9uIGN1c3RvbSBlbGVtZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcmVzb2x2ZVByb3BzKGRlZikge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IGRlZjtcbiAgICBjb25zdCBkZWNsYXJlZFByb3BLZXlzID0gaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IE9iamVjdC5rZXlzKHByb3BzIHx8IHt9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgaWYgKGtleVswXSAhPT0gXCJfXCIgJiYgZGVjbGFyZWRQcm9wS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB0aGlzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWNsYXJlZFByb3BLZXlzLm1hcChjYW1lbGl6ZSQxKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB2YWwsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEF0dHIoa2V5KSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwiZGF0YS12LVwiKSkgcmV0dXJuO1xuICAgIGNvbnN0IGhhcyA9IHRoaXMuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgbGV0IHZhbHVlID0gaGFzID8gdGhpcy5nZXRBdHRyaWJ1dGUoa2V5KSA6IFJFTU9WQUw7XG4gICAgY29uc3QgY2FtZWxLZXkgPSBjYW1lbGl6ZSQxKGtleSk7XG4gICAgaWYgKGhhcyAmJiB0aGlzLl9udW1iZXJQcm9wcyAmJiB0aGlzLl9udW1iZXJQcm9wc1tjYW1lbEtleV0pIHtcbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRQcm9wKGNhbWVsS2V5LCB2YWx1ZSwgZmFsc2UsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRQcm9wKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRQcm9wKGtleSwgdmFsLCBzaG91bGRSZWZsZWN0ID0gdHJ1ZSwgc2hvdWxkVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAodmFsICE9PSB0aGlzLl9wcm9wc1trZXldKSB7XG4gICAgICBpZiAodmFsID09PSBSRU1PVkFMKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9wc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJrZXlcIiAmJiB0aGlzLl9hcHApIHtcbiAgICAgICAgICB0aGlzLl9hcHAuX2NlVk5vZGUua2V5ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlZmxlY3QpIHtcbiAgICAgICAgY29uc3Qgb2IgPSB0aGlzLl9vYjtcbiAgICAgICAgb2IgJiYgb2IuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIG9iICYmIG9iLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfdXBkYXRlKCkge1xuICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLl9yb290KTtcbiAgfVxuICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGJhc2VQcm9wcy5vblZub2RlTW91bnRlZCA9IGJhc2VQcm9wcy5vblZub2RlVXBkYXRlZCA9IHRoaXMuX3JlbmRlclNsb3RzLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoYmFzZVByb3BzLCB0aGlzLl9wcm9wcykpO1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHZub2RlLmNlID0gKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLmNlID0gdGhpcztcbiAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSAobmV3U3R5bGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKChzKSA9PiB0aGlzLl9yb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhuZXdTdHlsZXMpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwYXRjaCA9IChldmVudCwgYXJncykgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgIGlzUGxhaW5PYmplY3QoYXJnc1swXSkgPyBleHRlbmQoeyBkZXRhaWw6IGFyZ3MgfSwgYXJnc1swXSkgOiB7IGRldGFpbDogYXJncyB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICBpZiAoaHlwaGVuYXRlKGV2ZW50KSAhPT0gZXZlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGh5cGhlbmF0ZShldmVudCksIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgX2FwcGx5U3R5bGVzKHN0eWxlcywgb3duZXIpIHtcbiAgICBpZiAoIXN0eWxlcykgcmV0dXJuO1xuICAgIGlmIChvd25lcikge1xuICAgICAgaWYgKG93bmVyID09PSB0aGlzLl9kZWYgfHwgdGhpcy5fc3R5bGVDaGlsZHJlbi5oYXMob3duZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4uYWRkKG93bmVyKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSB0aGlzLl9ub25jZTtcbiAgICBmb3IgKGxldCBpID0gc3R5bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgaWYgKG5vbmNlKSBzLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgICAgIHMudGV4dENvbnRlbnQgPSBzdHlsZXNbaV07XG4gICAgICB0aGlzLnNoYWRvd1Jvb3QucHJlcGVuZChzKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGlmIChvd25lcikge1xuICAgICAgICAgIGlmIChvd25lci5fX2htcklkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NoaWxkU3R5bGVzKSB0aGlzLl9jaGlsZFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSB0aGlzLl9jaGlsZFN0eWxlcy5nZXQob3duZXIuX19obXJJZCk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NoaWxkU3R5bGVzLnNldChvd25lci5fX2htcklkLCBlbnRyeSA9IFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5LnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT25seSBjYWxsZWQgd2hlbiBzaGFkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcGFyc2VTbG90cygpIHtcbiAgICBjb25zdCBzbG90cyA9IHRoaXMuX3Nsb3RzID0ge307XG4gICAgbGV0IG47XG4gICAgd2hpbGUgKG4gPSB0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gbi5ub2RlVHlwZSA9PT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcInNsb3RcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAoc2xvdHNbc2xvdE5hbWVdIHx8IChzbG90c1tzbG90TmFtZV0gPSBbXSkpLnB1c2gobik7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKG4pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT25seSBjYWxsZWQgd2hlbiBzaGFkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcmVuZGVyU2xvdHMoKSB7XG4gICAgY29uc3Qgb3V0bGV0cyA9ICh0aGlzLl90ZWxlcG9ydFRhcmdldCB8fCB0aGlzKS5xdWVyeVNlbGVjdG9yQWxsKFwic2xvdFwiKTtcbiAgICBjb25zdCBzY29wZUlkID0gdGhpcy5faW5zdGFuY2UudHlwZS5fX3Njb3BlSWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gb3V0bGV0c1tpXTtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gby5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX3Nsb3RzW3Nsb3ROYW1lXTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG8ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBjb250ZW50KSB7XG4gICAgICAgICAgaWYgKHNjb3BlSWQgJiYgbi5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBzY29wZUlkICsgXCItc1wiO1xuICAgICAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihuLCAxKTtcbiAgICAgICAgICAgIG4uc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCA9IHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobiwgbyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChvLmZpcnN0Q2hpbGQpIHBhcmVudC5pbnNlcnRCZWZvcmUoby5maXJzdENoaWxkLCBvKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChvKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2luamVjdENoaWxkU3R5bGUoY29tcCkge1xuICAgIHRoaXMuX2FwcGx5U3R5bGVzKGNvbXAuc3R5bGVzLCBjb21wKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmVtb3ZlQ2hpbGRTdHlsZShjb21wKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4uZGVsZXRlKGNvbXApO1xuICAgICAgaWYgKHRoaXMuX2NoaWxkU3R5bGVzICYmIGNvbXAuX19obXJJZCkge1xuICAgICAgICBjb25zdCBvbGRTdHlsZXMgPSB0aGlzLl9jaGlsZFN0eWxlcy5nZXQoY29tcC5fX2htcklkKTtcbiAgICAgICAgaWYgKG9sZFN0eWxlcykge1xuICAgICAgICAgIG9sZFN0eWxlcy5mb3JFYWNoKChzKSA9PiB0aGlzLl9yb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICBvbGRTdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdXNlSG9zdChjYWxsZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgZWwgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jZTtcbiAgaWYgKGVsKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYWxsZXIgfHwgXCJ1c2VIb3N0XCJ9IGNhbGxlZCB3aXRob3V0IGFuIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FsbGVyIHx8IFwidXNlSG9zdFwifSBjYW4gb25seSBiZSB1c2VkIGluIGNvbXBvbmVudHMgZGVmaW5lZCB2aWEgZGVmaW5lQ3VzdG9tRWxlbWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNoYWRvd1Jvb3QoKSB7XG4gIGNvbnN0IGVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHVzZUhvc3QoXCJ1c2VTaGFkb3dSb290XCIpIDogdXNlSG9zdCgpO1xuICByZXR1cm4gZWwgJiYgZWwuc2hhZG93Um9vdDtcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSBcIiRzdHlsZVwiKSB7XG4gIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XG4gICAgaWYgKCFtb2R1bGVzKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlcyBpbmplY3RlZC5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XG4gICAgaWYgKCFtb2QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICByZXR1cm4gbW9kO1xuICB9XG59XG5cbmNvbnN0IHBvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbW92ZUNiS2V5ID0gU3ltYm9sKFwiX21vdmVDYlwiKTtcbmNvbnN0IGVudGVyQ2JLZXkgPSBTeW1ib2woXCJfZW50ZXJDYlwiKTtcbmNvbnN0IGRlY29yYXRlID0gKHQpID0+IHtcbiAgZGVsZXRlIHQucHJvcHMubW9kZTtcbiAgcmV0dXJuIHQ7XG59O1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IC8qIEBfX1BVUkVfXyAqLyBkZWNvcmF0ZSh7XG4gIG5hbWU6IFwiVHJhbnNpdGlvbkdyb3VwXCIsXG4gIHByb3BzOiAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XG4gICAgdGFnOiBTdHJpbmcsXG4gICAgbW92ZUNsYXNzOiBTdHJpbmdcbiAgfSksXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgbGV0IHByZXZDaGlsZHJlbjtcbiAgICBsZXQgY2hpbGRyZW47XG4gICAgb25VcGRhdGVkKCgpID0+IHtcbiAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCBcInZcIn0tbW92ZWA7XG4gICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShcbiAgICAgICAgcHJldkNoaWxkcmVuWzBdLmVsLFxuICAgICAgICBpbnN0YW5jZS52bm9kZS5lbCxcbiAgICAgICAgbW92ZUNsYXNzXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG1vdmVkQ2hpbGRyZW4gPSBwcmV2Q2hpbGRyZW4uZmlsdGVyKGFwcGx5VHJhbnNsYXRpb24pO1xuICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCJcIjtcbiAgICAgICAgY29uc3QgY2IgPSBlbFttb3ZlQ2JLZXldID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgICAgICAgZWxbbW92ZUNiS2V5XSA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcbiAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XG4gICAgICBwcmV2Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBpZiAoY2hpbGQuZWwgJiYgY2hpbGQuZWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICAgIGNzc1RyYW5zaXRpb25Qcm9wcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KFxuICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGlsZC50eXBlICE9PSBUZXh0KSB7XG4gICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgY29uc3QgZWwgPSBjLmVsO1xuICBpZiAoZWxbbW92ZUNiS2V5XSkge1xuICAgIGVsW21vdmVDYktleV0oKTtcbiAgfVxuICBpZiAoZWxbZW50ZXJDYktleV0pIHtcbiAgICBlbFtlbnRlckNiS2V5XSgpO1xuICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xuICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiMHNcIjtcbiAgICByZXR1cm4gYztcbiAgfVxufVxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcbiAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgfSk7XG4gIH1cbiAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgY2xvbmUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICBjb25zdCBjb250YWluZXIgPSByb290Lm5vZGVUeXBlID09PSAxID8gcm9vdCA6IHJvb3QucGFyZW50Tm9kZTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCBmbiA9IHZub2RlLnByb3BzW1wib25VcGRhdGU6bW9kZWxWYWx1ZVwiXSB8fCBmYWxzZTtcbiAgcmV0dXJuIGlzQXJyYXkoZm4pID8gKHZhbHVlKSA9PiBpbnZva2VBcnJheUZucyhmbiwgdmFsdWUpIDogZm47XG59O1xuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xuICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcbiAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIikpO1xuICB9XG59XG5jb25zdCBhc3NpZ25LZXkgPSBTeW1ib2woXCJfYXNzaWduXCIpO1xuY29uc3Qgdk1vZGVsVGV4dCA9IHtcbiAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09IFwibnVtYmVyXCI7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKSByZXR1cm47XG4gICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgIGlmICh0cmltKSB7XG4gICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc3RUb051bWJlcikge1xuICAgICAgICBkb21WYWx1ZSA9IGxvb3NlVG9OdW1iZXIoZG9tVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxbYXNzaWduS2V5XShkb21WYWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFsYXp5KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25lbmRcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICB9XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKGVsLmNvbXBvc2luZykgcmV0dXJuO1xuICAgIGNvbnN0IGVsVmFsdWUgPSAobnVtYmVyIHx8IGVsLnR5cGUgPT09IFwibnVtYmVyXCIpICYmICEvXjBcXGQvLnRlc3QoZWwudmFsdWUpID8gbG9vc2VUb051bWJlcihlbC52YWx1ZSkgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gICAgaWYgKGVsVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCAmJiBlbC50eXBlICE9PSBcInJhbmdlXCIpIHtcbiAgICAgIGlmIChsYXp5ICYmIHZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgfVxufTtcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xuICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xuICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgICBjb25zdCBhc3NpZ24gPSBlbFthc3NpZ25LZXldO1xuICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XG4gICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xuICAgICAgICAgIGFzc2lnbihtb2RlbFZhbHVlLmNvbmNhdChlbGVtZW50VmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xuICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBjbG9uZWQgPSBuZXcgU2V0KG1vZGVsVmFsdWUpO1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduKGNsb25lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcbiAgbW91bnRlZDogc2V0Q2hlY2tlZCxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xuICBsZXQgY2hlY2tlZDtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuICAgIGNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XG4gIH1cbiAgaWYgKGVsLmNoZWNrZWQgIT09IGNoZWNrZWQpIHtcbiAgICBlbC5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxufVxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBlbFthc3NpZ25LZXldKGdldFZhbHVlKGVsKSk7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB2TW9kZWxTZWxlY3QgPSB7XG4gIC8vIDxzZWxlY3QgbXVsdGlwbGU+IHZhbHVlIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogdHJ1ZSxcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZCkubWFwKFxuICAgICAgICAobykgPT4gbnVtYmVyID8gbG9vc2VUb051bWJlcihnZXRWYWx1ZShvKSkgOiBnZXRWYWx1ZShvKVxuICAgICAgKTtcbiAgICAgIGVsW2Fzc2lnbktleV0oXG4gICAgICAgIGVsLm11bHRpcGxlID8gaXNTZXRNb2RlbCA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpIDogc2VsZWN0ZWRWYWwgOiBzZWxlY3RlZFZhbFswXVxuICAgICAgKTtcbiAgICAgIGVsLl9hc3NpZ25pbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBlbC5fYXNzaWduaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cbiAgLy8gPG9wdGlvbj5zLlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgaWYgKCFlbC5fYXNzaWduaW5nKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xuICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGNvbnN0IGlzQXJyYXlWYWx1ZSA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheVZhbHVlICYmICFpc1NldCh2YWx1ZSkpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICBgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZ2V0VmFsdWUob3B0aW9uKTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICBjb25zdCBvcHRpb25UeXBlID0gdHlwZW9mIG9wdGlvblZhbHVlO1xuICAgICAgICBpZiAob3B0aW9uVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvcHRpb25UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuc29tZSgodikgPT4gU3RyaW5nKHYpID09PSBTdHJpbmcob3B0aW9uVmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5oYXMob3B0aW9uVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShlbCkge1xuICByZXR1cm4gXCJfdmFsdWVcIiBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xuICBjb25zdCBrZXkgPSBjaGVja2VkID8gXCJfdHJ1ZVZhbHVlXCIgOiBcIl9mYWxzZVZhbHVlXCI7XG4gIHJldHVybiBrZXkgaW4gZWwgPyBlbFtrZXldIDogY2hlY2tlZDtcbn1cbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XG4gIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwiY3JlYXRlZFwiKTtcbiAgfSxcbiAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJtb3VudGVkXCIpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgfSxcbiAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwidXBkYXRlZFwiKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljTW9kZWwodGFnTmFtZSwgdHlwZSkge1xuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiU0VMRUNUXCI6XG4gICAgICByZXR1cm4gdk1vZGVsU2VsZWN0O1xuICAgIGNhc2UgXCJURVhUQVJFQVwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsQ2hlY2tib3g7XG4gICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xuICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICBlbC50YWdOYW1lLFxuICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgKTtcbiAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xuICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XG59XG5mdW5jdGlvbiBpbml0Vk1vZGVsRm9yU1NSKCkge1xuICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XG4gIHZNb2RlbFJhZGlvLmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VFcXVhbCh2bm9kZS5wcm9wcy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxDaGVja2JveC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgfVxuICB9O1xuICB2TW9kZWxEeW5hbWljLmdldFNTUlByb3BzID0gKGJpbmRpbmcsIHZub2RlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2bm9kZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgICAgLy8gcmVzb2x2ZUR5bmFtaWNNb2RlbCBleHBlY3RzIGFuIHVwcGVyY2FzZSB0YWcgbmFtZSwgYnV0IHZub2RlLnR5cGUgaXMgbG93ZXJjYXNlXG4gICAgICB2bm9kZS50eXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICAgKTtcbiAgICBpZiAobW9kZWxUb1VzZS5nZXRTU1JQcm9wcykge1xuICAgICAgcmV0dXJuIG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMoYmluZGluZywgdm5vZGUpO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gW1wiY3RybFwiLCBcInNoaWZ0XCIsIFwiYWx0XCIsIFwibWV0YVwiXTtcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xuICBzdG9wOiAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcbiAgcHJldmVudDogKGUpID0+IGUucHJldmVudERlZmF1bHQoKSxcbiAgc2VsZjogKGUpID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXG4gIGN0cmw6IChlKSA9PiAhZS5jdHJsS2V5LFxuICBzaGlmdDogKGUpID0+ICFlLnNoaWZ0S2V5LFxuICBhbHQ6IChlKSA9PiAhZS5hbHRLZXksXG4gIG1ldGE6IChlKSA9PiAhZS5tZXRhS2V5LFxuICBsZWZ0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxuICBtaWRkbGU6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDEsXG4gIHJpZ2h0OiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxuICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUoKG0pID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxufTtcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICBjb25zdCBjYWNoZSA9IGZuLl93aXRoTW9kcyB8fCAoZm4uX3dpdGhNb2RzID0ge30pO1xuICBjb25zdCBjYWNoZUtleSA9IG1vZGlmaWVycy5qb2luKFwiLlwiKTtcbiAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XSB8fCAoY2FjaGVbY2FjaGVLZXldID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcbiAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSkgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xuICB9KTtcbn07XG5jb25zdCBrZXlOYW1lcyA9IHtcbiAgZXNjOiBcImVzY2FwZVwiLFxuICBzcGFjZTogXCIgXCIsXG4gIHVwOiBcImFycm93LXVwXCIsXG4gIGxlZnQ6IFwiYXJyb3ctbGVmdFwiLFxuICByaWdodDogXCJhcnJvdy1yaWdodFwiLFxuICBkb3duOiBcImFycm93LWRvd25cIixcbiAgZGVsZXRlOiBcImJhY2tzcGFjZVwiXG59O1xuY29uc3Qgd2l0aEtleXMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICBjb25zdCBjYWNoZSA9IGZuLl93aXRoS2V5cyB8fCAoZm4uX3dpdGhLZXlzID0ge30pO1xuICBjb25zdCBjYWNoZUtleSA9IG1vZGlmaWVycy5qb2luKFwiLlwiKTtcbiAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XSB8fCAoY2FjaGVbY2FjaGVLZXldID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCEoXCJrZXlcIiBpbiBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcbiAgICBpZiAobW9kaWZpZXJzLnNvbWUoXG4gICAgICAoaykgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5XG4gICAgKSkge1xuICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcbmxldCByZW5kZXJlcjtcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcbiAgcmV0dXJuIHJlbmRlcmVyIHx8IChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpO1xufVxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XG4gIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvbiA/IHJlbmRlcmVyIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcbiAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XG4gIHJldHVybiByZW5kZXJlcjtcbn1cbmNvbnN0IHJlbmRlciA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGh5ZHJhdGUgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XG59O1xuY29uc3QgY3JlYXRlQXBwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICB9XG4gIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcbiAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcbiAgICBpZiAoIWlzRnVuY3Rpb24oY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikpO1xuICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKFwidi1jbG9ha1wiKTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtYXBwXCIsIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuY29uc3QgY3JlYXRlU1NSQXBwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xuICB9XG4gIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmZ1bmN0aW9uIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikge1xuICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIHJldHVybiBcInN2Z1wiO1xuICB9XG4gIGlmICh0eXBlb2YgTWF0aE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIE1hdGhNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJtYXRobWxcIjtcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzTmF0aXZlVGFnXCIsIHtcbiAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSB8fCBpc01hdGhNTFRhZyh0YWcpLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xuICBpZiAoaXNSdW50aW1lT25seSgpKSB7XG4gICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNDdXN0b21FbGVtZW50XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudDtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucztcbiAgICBjb25zdCBtc2cgPSBgVGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUuanMgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlciAoYWthIFwiZnVsbCBidWlsZFwiKS4gU2luY2UgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBjb21waWxlck9wdGlvbnNcXGAgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXG4tIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXG4tIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxuLSBGb3Igdml0ZTogcGFzcyBpdCB2aWEgQHZpdGVqcy9wbHVnaW4tdnVlIG9wdGlvbnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUtcGx1Z2luLXZ1ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItc2ZjYDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJjb21waWxlck9wdGlvbnNcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcbiAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCAmJiBjb250YWluZXIubW9kZSA9PT0gXCJjbG9zZWRcIikge1xuICAgIHdhcm4oXG4gICAgICBgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2BcbiAgICApO1xuICB9XG4gIHJldHVybiBjb250YWluZXI7XG59XG5sZXQgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmNvbnN0IGluaXREaXJlY3RpdmVzRm9yU1NSID0gKCkgPT4ge1xuICBpZiAoIXNzckRpcmVjdGl2ZUluaXRpYWxpemVkKSB7XG4gICAgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGluaXRWTW9kZWxGb3JTU1IoKTtcbiAgICBpbml0VlNob3dGb3JTU1IoKTtcbiAgfVxufSA7XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgVnVlRWxlbWVudCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRlZmluZVNTUkN1c3RvbUVsZW1lbnQsIGh5ZHJhdGUsIGluaXREaXJlY3RpdmVzRm9yU1NSLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdXNlSG9zdCwgdXNlU2hhZG93Um9vdCwgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIiwiLyoqXG4qIHZ1ZSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBpbml0Q3VzdG9tRm9ybWF0dGVyLCB3YXJuIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcbiAge1xuICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcbiAgfVxufVxuXG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBpbml0RGV2KCk7XG59XG5jb25zdCBjb21waWxlID0gKCkgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oXG4gICAgICBgUnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgeyBjb21waWxlIH07XG4iLCJmdW5jdGlvbiBub29wKCkgeyB9XG5cbmV4cG9ydCB7IG5vb3AgfTtcbiIsImZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IHsgaXNQcmltaXRpdmUgfTtcbiIsImZ1bmN0aW9uIGlzVHlwZWRBcnJheSh4KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG5cbmV4cG9ydCB7IGlzVHlwZWRBcnJheSB9O1xuIiwiZnVuY3Rpb24gZ2V0U3ltYm9scyhvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpLmZpbHRlcihzeW1ib2wgPT4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKSk7XG59XG5cbmV4cG9ydCB7IGdldFN5bWJvbHMgfTtcbiIsImZ1bmN0aW9uIGdldFRhZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJ1tvYmplY3QgVW5kZWZpbmVkXScgOiAnW29iamVjdCBOdWxsXSc7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgeyBnZXRUYWcgfTtcbiIsImNvbnN0IHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuY29uc3Qgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5jb25zdCBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJztcbmNvbnN0IGJvb2xlYW5UYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5jb25zdCBhcmd1bWVudHNUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbmNvbnN0IHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuY29uc3QgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJztcbmNvbnN0IG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuY29uc3Qgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG5jb25zdCBmdW5jdGlvblRhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5jb25zdCBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG5jb25zdCBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcbmNvbnN0IGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcbmNvbnN0IHVpbnQ4QXJyYXlUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XSc7XG5jb25zdCB1aW50OENsYW1wZWRBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc7XG5jb25zdCB1aW50MTZBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XSc7XG5jb25zdCB1aW50MzJBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5jb25zdCBiaWdVaW50NjRBcnJheVRhZyA9ICdbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XSc7XG5jb25zdCBpbnQ4QXJyYXlUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJztcbmNvbnN0IGludDE2QXJyYXlUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XSc7XG5jb25zdCBpbnQzMkFycmF5VGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nO1xuY29uc3QgYmlnSW50NjRBcnJheVRhZyA9ICdbb2JqZWN0IEJpZ0ludDY0QXJyYXldJztcbmNvbnN0IGZsb2F0MzJBcnJheVRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nO1xuY29uc3QgZmxvYXQ2NEFycmF5VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7XG5cbmV4cG9ydCB7IGFyZ3VtZW50c1RhZywgYXJyYXlCdWZmZXJUYWcsIGFycmF5VGFnLCBiaWdJbnQ2NEFycmF5VGFnLCBiaWdVaW50NjRBcnJheVRhZywgYm9vbGVhblRhZywgZGF0YVZpZXdUYWcsIGRhdGVUYWcsIGVycm9yVGFnLCBmbG9hdDMyQXJyYXlUYWcsIGZsb2F0NjRBcnJheVRhZywgZnVuY3Rpb25UYWcsIGludDE2QXJyYXlUYWcsIGludDMyQXJyYXlUYWcsIGludDhBcnJheVRhZywgbWFwVGFnLCBudW1iZXJUYWcsIG9iamVjdFRhZywgcmVnZXhwVGFnLCBzZXRUYWcsIHN0cmluZ1RhZywgc3ltYm9sVGFnLCB1aW50MTZBcnJheVRhZywgdWludDMyQXJyYXlUYWcsIHVpbnQ4QXJyYXlUYWcsIHVpbnQ4Q2xhbXBlZEFycmF5VGFnIH07XG4iLCJpbXBvcnQgeyBnZXRTeW1ib2xzIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRTeW1ib2xzLm1qcyc7XG5pbXBvcnQgeyBnZXRUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL2dldFRhZy5tanMnO1xuaW1wb3J0IHsgdWludDMyQXJyYXlUYWcsIHVpbnQxNkFycmF5VGFnLCB1aW50OENsYW1wZWRBcnJheVRhZywgdWludDhBcnJheVRhZywgc3ltYm9sVGFnLCBzdHJpbmdUYWcsIHNldFRhZywgcmVnZXhwVGFnLCBvYmplY3RUYWcsIG51bWJlclRhZywgbWFwVGFnLCBpbnQzMkFycmF5VGFnLCBpbnQxNkFycmF5VGFnLCBpbnQ4QXJyYXlUYWcsIGZsb2F0NjRBcnJheVRhZywgZmxvYXQzMkFycmF5VGFnLCBkYXRlVGFnLCBib29sZWFuVGFnLCBkYXRhVmlld1RhZywgYXJyYXlCdWZmZXJUYWcsIGFycmF5VGFnLCBhcmd1bWVudHNUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL3RhZ3MubWpzJztcbmltcG9ydCB7IGlzUHJpbWl0aXZlIH0gZnJvbSAnLi4vcHJlZGljYXRlL2lzUHJpbWl0aXZlLm1qcyc7XG5pbXBvcnQgeyBpc1R5cGVkQXJyYXkgfSBmcm9tICcuLi9wcmVkaWNhdGUvaXNUeXBlZEFycmF5Lm1qcyc7XG5cbmZ1bmN0aW9uIGNsb25lRGVlcFdpdGgob2JqLCBjbG9uZVZhbHVlKSB7XG4gICAgcmV0dXJuIGNsb25lRGVlcFdpdGhJbXBsKG9iaiwgdW5kZWZpbmVkLCBvYmosIG5ldyBNYXAoKSwgY2xvbmVWYWx1ZSk7XG59XG5mdW5jdGlvbiBjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZVRvQ2xvbmUsIGtleVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrID0gbmV3IE1hcCgpLCBjbG9uZVZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWYWx1ZT8uKHZhbHVlVG9DbG9uZSwga2V5VG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2spO1xuICAgIGlmIChjbG9uZWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgICBpZiAoaXNQcmltaXRpdmUodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVUb0Nsb25lO1xuICAgIH1cbiAgICBpZiAoc3RhY2suaGFzKHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrLmdldCh2YWx1ZVRvQ2xvbmUpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSh2YWx1ZVRvQ2xvbmUubGVuZ3RoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZVRvQ2xvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlVG9DbG9uZVtpXSwgaSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHZhbHVlVG9DbG9uZSwgJ2luZGV4JykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlVG9DbG9uZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih2YWx1ZVRvQ2xvbmUsICdpbnB1dCcpKSB7XG4gICAgICAgICAgICByZXN1bHQuaW5wdXQgPSB2YWx1ZVRvQ2xvbmUuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlVG9DbG9uZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSZWdFeHAodmFsdWVUb0Nsb25lLnNvdXJjZSwgdmFsdWVUb0Nsb25lLmZsYWdzKTtcbiAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHZhbHVlVG9DbG9uZS5sYXN0SW5kZXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWx1ZVRvQ2xvbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZSwga2V5LCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlVG9DbG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZSwgdW5kZWZpbmVkLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVUb0Nsb25lLnN1YmFycmF5KCk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVkQXJyYXkodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZVRvQ2xvbmUpLmNvbnN0cnVjdG9yKSh2YWx1ZVRvQ2xvbmUubGVuZ3RoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZVRvQ2xvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlVG9DbG9uZVtpXSwgaSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9DbG9uZS5zbGljZSgwKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRhVmlldyh2YWx1ZVRvQ2xvbmUuYnVmZmVyLnNsaWNlKDApLCB2YWx1ZVRvQ2xvbmUuYnl0ZU9mZnNldCwgdmFsdWVUb0Nsb25lLmJ5dGVMZW5ndGgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZpbGUoW3ZhbHVlVG9DbG9uZV0sIHZhbHVlVG9DbG9uZS5uYW1lLCB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZVRvQ2xvbmUudHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBCbG9iKFt2YWx1ZVRvQ2xvbmVdLCB7IHR5cGU6IHZhbHVlVG9DbG9uZS50eXBlIH0pO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IHZhbHVlVG9DbG9uZS5jb25zdHJ1Y3RvcigpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQubWVzc2FnZSA9IHZhbHVlVG9DbG9uZS5tZXNzYWdlO1xuICAgICAgICByZXN1bHQubmFtZSA9IHZhbHVlVG9DbG9uZS5uYW1lO1xuICAgICAgICByZXN1bHQuc3RhY2sgPSB2YWx1ZVRvQ2xvbmUuc3RhY2s7XG4gICAgICAgIHJlc3VsdC5jYXVzZSA9IHZhbHVlVG9DbG9uZS5jYXVzZTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZVRvQ2xvbmUgPT09ICdvYmplY3QnICYmIGlzQ2xvbmVhYmxlT2JqZWN0KHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWVUb0Nsb25lKSk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVRvQ2xvbmU7XG59XG5mdW5jdGlvbiBjb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgb2JqZWN0VG9DbG9uZSA9IHRhcmdldCwgc3RhY2ssIGNsb25lVmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5rZXlzKHNvdXJjZSksIC4uLmdldFN5bWJvbHMoc291cmNlKV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgPT0gbnVsbCB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lRGVlcFdpdGhJbXBsKHNvdXJjZVtrZXldLCBrZXksIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ2xvbmVhYmxlT2JqZWN0KG9iamVjdCkge1xuICAgIHN3aXRjaCAoZ2V0VGFnKG9iamVjdCkpIHtcbiAgICAgICAgY2FzZSBhcmd1bWVudHNUYWc6XG4gICAgICAgIGNhc2UgYXJyYXlUYWc6XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgIGNhc2UgYm9vbGVhblRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIGZsb2F0MzJBcnJheVRhZzpcbiAgICAgICAgY2FzZSBmbG9hdDY0QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgaW50OEFycmF5VGFnOlxuICAgICAgICBjYXNlIGludDE2QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgaW50MzJBcnJheVRhZzpcbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIG9iamVjdFRhZzpcbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgIGNhc2UgdWludDhBcnJheVRhZzpcbiAgICAgICAgY2FzZSB1aW50OENsYW1wZWRBcnJheVRhZzpcbiAgICAgICAgY2FzZSB1aW50MTZBcnJheVRhZzpcbiAgICAgICAgY2FzZSB1aW50MzJBcnJheVRhZzoge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBjbG9uZURlZXBXaXRoLCBjbG9uZURlZXBXaXRoSW1wbCwgY29weVByb3BlcnRpZXMgfTtcbiIsImltcG9ydCB7IGNsb25lRGVlcFdpdGhJbXBsIH0gZnJvbSAnLi9jbG9uZURlZXBXaXRoLm1qcyc7XG5cbmZ1bmN0aW9uIGNsb25lRGVlcChvYmopIHtcbiAgICByZXR1cm4gY2xvbmVEZWVwV2l0aEltcGwob2JqLCB1bmRlZmluZWQsIG9iaiwgbmV3IE1hcCgpLCB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgeyBjbG9uZURlZXAgfTtcbiIsImZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgY29uc3QgaGFzT2JqZWN0UHJvdG90eXBlID0gcHJvdG8gPT09IG51bGwgfHxcbiAgICAgICAgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSA9PT0gbnVsbDtcbiAgICBpZiAoIWhhc09iamVjdFByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZXhwb3J0IHsgaXNQbGFpbk9iamVjdCB9O1xuIiwiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uL3ByZWRpY2F0ZS9pc1BsYWluT2JqZWN0Lm1qcyc7XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gICAgY29uc3Qgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZShbXSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHt9LCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCB7IG1lcmdlIH07XG4iLCJmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IChOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc05hTihvdGhlcikpO1xufVxuXG5leHBvcnQgeyBlcSB9O1xuIiwiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdC5tanMnO1xuaW1wb3J0IHsgZ2V0U3ltYm9scyB9IGZyb20gJy4uL2NvbXBhdC9faW50ZXJuYWwvZ2V0U3ltYm9scy5tanMnO1xuaW1wb3J0IHsgZ2V0VGFnIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRUYWcubWpzJztcbmltcG9ydCB7IGZ1bmN0aW9uVGFnLCByZWdleHBUYWcsIHN5bWJvbFRhZywgZGF0ZVRhZywgYm9vbGVhblRhZywgbnVtYmVyVGFnLCBzdHJpbmdUYWcsIG9iamVjdFRhZywgZXJyb3JUYWcsIGRhdGFWaWV3VGFnLCBhcnJheUJ1ZmZlclRhZywgZmxvYXQ2NEFycmF5VGFnLCBmbG9hdDMyQXJyYXlUYWcsIGJpZ0ludDY0QXJyYXlUYWcsIGludDMyQXJyYXlUYWcsIGludDE2QXJyYXlUYWcsIGludDhBcnJheVRhZywgYmlnVWludDY0QXJyYXlUYWcsIHVpbnQzMkFycmF5VGFnLCB1aW50MTZBcnJheVRhZywgdWludDhDbGFtcGVkQXJyYXlUYWcsIHVpbnQ4QXJyYXlUYWcsIGFycmF5VGFnLCBzZXRUYWcsIG1hcFRhZywgYXJndW1lbnRzVGFnIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC90YWdzLm1qcyc7XG5pbXBvcnQgeyBlcSB9IGZyb20gJy4uL2NvbXBhdC91dGlsL2VxLm1qcyc7XG5cbmZ1bmN0aW9uIGlzRXF1YWxXaXRoKGEsIGIsIGFyZVZhbHVlc0VxdWFsKSB7XG4gICAgcmV0dXJuIGlzRXF1YWxXaXRoSW1wbChhLCBiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZVZhbHVlc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxXaXRoSW1wbChhLCBiLCBwcm9wZXJ0eSwgYVBhcmVudCwgYlBhcmVudCwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXJlVmFsdWVzRXF1YWwoYSwgYiwgcHJvcGVydHksIGFQYXJlbnQsIGJQYXJlbnQsIHN0YWNrKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSB0eXBlb2YgYikge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYiB8fCBPYmplY3QuaXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xufVxuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCkge1xuICAgIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBhVGFnID0gZ2V0VGFnKGEpO1xuICAgIGxldCBiVGFnID0gZ2V0VGFnKGIpO1xuICAgIGlmIChhVGFnID09PSBhcmd1bWVudHNUYWcpIHtcbiAgICAgICAgYVRhZyA9IG9iamVjdFRhZztcbiAgICB9XG4gICAgaWYgKGJUYWcgPT09IGFyZ3VtZW50c1RhZykge1xuICAgICAgICBiVGFnID0gb2JqZWN0VGFnO1xuICAgIH1cbiAgICBpZiAoYVRhZyAhPT0gYlRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoYVRhZykge1xuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBiLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiBlcSh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGJvb2xlYW5UYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmlzKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSk7XG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOiB7XG4gICAgICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBmdW5jdGlvblRhZzoge1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sgPSBzdGFjayA/PyBuZXcgTWFwKCk7XG4gICAgY29uc3QgYVN0YWNrID0gc3RhY2suZ2V0KGEpO1xuICAgIGNvbnN0IGJTdGFjayA9IHN0YWNrLmdldChiKTtcbiAgICBpZiAoYVN0YWNrICE9IG51bGwgJiYgYlN0YWNrICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFTdGFjayA9PT0gYjtcbiAgICB9XG4gICAgc3RhY2suc2V0KGEsIGIpO1xuICAgIHN0YWNrLnNldChiLCBhKTtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKGFUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgbWFwVGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiLmhhcyhrZXkpIHx8ICFpc0VxdWFsV2l0aEltcGwodmFsdWUsIGIuZ2V0KGtleSksIGtleSwgYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBzZXRUYWc6IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhVmFsdWVzID0gQXJyYXkuZnJvbShhLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiVmFsdWVzID0gQXJyYXkuZnJvbShiLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVZhbHVlID0gYVZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBiVmFsdWVzLmZpbmRJbmRleChiVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWxXaXRoSW1wbChhVmFsdWUsIGJWYWx1ZSwgdW5kZWZpbmVkLCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJWYWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50OEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50OENsYW1wZWRBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDE2QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQzMkFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBiaWdVaW50NjRBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50OEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBpbnQxNkFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBpbnQzMkFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBiaWdJbnQ2NEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBmbG9hdDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGZsb2F0NjRBcnJheVRhZzoge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIoYSkgIT09IEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsV2l0aEltcGwoYVtpXSwgYltpXSwgaSwgYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzoge1xuICAgICAgICAgICAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwobmV3IFVpbnQ4QXJyYXkoYSksIG5ldyBVaW50OEFycmF5KGIpLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBkYXRhVmlld1RhZzoge1xuICAgICAgICAgICAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCB8fCBhLmJ5dGVPZmZzZXQgIT09IGIuYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwobmV3IFVpbnQ4QXJyYXkoYSksIG5ldyBVaW50OEFycmF5KGIpLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBlcnJvclRhZzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUgPT09IGIubmFtZSAmJiBhLm1lc3NhZ2UgPT09IGIubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2Ugb2JqZWN0VGFnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJlRXF1YWxJbnN0YW5jZXMgPSBhcmVPYmplY3RzRXF1YWwoYS5jb25zdHJ1Y3RvciwgYi5jb25zdHJ1Y3Rvciwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYUtleXMgPSBbLi4uT2JqZWN0LmtleXMoYSksIC4uLmdldFN5bWJvbHMoYSldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJLZXlzID0gWy4uLk9iamVjdC5rZXlzKGIpLCAuLi5nZXRTeW1ib2xzKGIpXTtcbiAgICAgICAgICAgICAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BLZXkgPSBhS2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVByb3AgPSBhW3Byb3BLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oYiwgcHJvcEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiUHJvcCA9IGJbcHJvcEtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcXVhbFdpdGhJbXBsKGFQcm9wLCBiUHJvcCwgcHJvcEtleSwgYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc3RhY2suZGVsZXRlKGEpO1xuICAgICAgICBzdGFjay5kZWxldGUoYik7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpc0VxdWFsV2l0aCB9O1xuIiwiaW1wb3J0IHsgaXNFcXVhbFdpdGggfSBmcm9tICcuL2lzRXF1YWxXaXRoLm1qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vZnVuY3Rpb24vbm9vcC5tanMnO1xuXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gaXNFcXVhbFdpdGgoYSwgYiwgbm9vcCk7XG59XG5cbmV4cG9ydCB7IGlzRXF1YWwgfTtcbiIsImltcG9ydCB7IEFueVNjaGVtYU9iamVjdCB9IGZyb20gXCJhanZcIjtcbmltcG9ydCB7IFR5cGUgfSBmcm9tIFwiQHNpbmNsYWlyL3R5cGVib3hcIjtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdHNGcm9tU2NoZW1hKFxuICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdFxuKTogUmVjb3JkPHN0cmluZywgeyB0eXBlPzogc3RyaW5nOyByZXF1aXJlZDogYm9vbGVhbjsgdmFsdWU6IGFueSB9PiB7XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IHR5cGU/OiBzdHJpbmc7IHJlcXVpcmVkOiBib29sZWFuOyB2YWx1ZTogYW55IH1cbiAgPiA9IHt9O1xuXG4gIGNvbnNvbGUubG9nKFwiZ2V0RGVmYXVsdHNGcm9tU2NoZW1hXCIpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgZXhjbHVkZWQgZnJvbSBkZWZhdWx0cyBiZWNhdXNlIHRoZXkgbXVzdCBiZSBzZXQgYnkgdGhlIGVkaXRvclxuICAgIGlmIChbXCJ4XCIsIFwieVwiLCBcInpcIiwgXCJnXCIsIFwid2lyZXNcIiwgXCJ0eXBlXCIsIFwiaWRcIl0uaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgcHJvcGVydHkgPSB2YWx1ZSBhcyB7IGRlZmF1bHQ/OiBhbnk7IG5vZGVUeXBlPzogc3RyaW5nIH07XG4gICAgY29uc29sZS5sb2coa2V5KTtcbiAgICBjb25zb2xlLmxvZyhwcm9wZXJ0eSk7XG5cbiAgICByZXN1bHRba2V5XSA9IHtcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBwcm9wZXJ0eS5kZWZhdWx0ID8/IHVuZGVmaW5lZCxcbiAgICAgIC8vIE5PVEU6IEknbSB1c2luZyBhIGN1c3RvbSBqc29uIHNjaGVtYSBrZXl3b3JkIHRvIGRldGVybWluZSB0aGUgbm9kZSB0eXBlXG4gICAgICB0eXBlOiBwcm9wZXJ0eS5ub2RlVHlwZSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hKFxuICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdFxuKTogUmVjb3JkPHN0cmluZywgeyB0eXBlOiBzdHJpbmc7IHJlcXVpcmVkOiBib29sZWFuOyB2YWx1ZTogYW55IH0+IHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHsgdHlwZTogc3RyaW5nOyByZXF1aXJlZDogYm9vbGVhbjsgdmFsdWU6IGFueSB9XG4gID4gPSB7fTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHZhbHVlIGFzIHtcbiAgICAgIGRlZmF1bHQ/OiBhbnk7XG4gICAgICBmb3JtYXQ6IHN0cmluZztcbiAgICAgIG5vZGVUeXBlPzogc3RyaW5nO1xuICAgIH07XG4gICAgY29uc29sZS5sb2cocHJvcGVydHkpO1xuICAgIGNvbnN0IGlzUGFzc3dvcmQgPSBwcm9wZXJ0eS5mb3JtYXQgPT09IFwicGFzc3dvcmRcIjtcbiAgICByZXN1bHRba2V5XSA9IHtcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIHR5cGU6IGlzUGFzc3dvcmQgPyBcInBhc3N3b3JkXCIgOiBcInRleHRcIixcbiAgICAgIHZhbHVlOiBwcm9wZXJ0eS5kZWZhdWx0ID8/IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgZ2V0RGVmYXVsdHNGcm9tU2NoZW1hLCBnZXRDcmVkZW50aWFsc0Zyb21TY2hlbWEgfTtcbiIsInZhciBoYXNFeGNhcGUgPSAvfi9cbnZhciBlc2NhcGVNYXRjaGVyID0gL35bMDFdL2dcbmZ1bmN0aW9uIGVzY2FwZVJlcGxhY2VyIChtKSB7XG4gIHN3aXRjaCAobSkge1xuICAgIGNhc2UgJ34xJzogcmV0dXJuICcvJ1xuICAgIGNhc2UgJ34wJzogcmV0dXJuICd+J1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0aWxkZSBlc2NhcGU6ICcgKyBtKVxufVxuXG5mdW5jdGlvbiB1bnRpbGRlIChzdHIpIHtcbiAgaWYgKCFoYXNFeGNhcGUudGVzdChzdHIpKSByZXR1cm4gc3RyXG4gIHJldHVybiBzdHIucmVwbGFjZShlc2NhcGVNYXRjaGVyLCBlc2NhcGVSZXBsYWNlcilcbn1cblxuZnVuY3Rpb24gc2V0dGVyIChvYmosIHBvaW50ZXIsIHZhbHVlKSB7XG4gIHZhciBwYXJ0XG4gIHZhciBoYXNOZXh0UGFydFxuXG4gIGZvciAodmFyIHAgPSAxLCBsZW4gPSBwb2ludGVyLmxlbmd0aDsgcCA8IGxlbjspIHtcbiAgICBpZiAocG9pbnRlcltwXSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBwb2ludGVyW3BdID09PSAncHJvdG90eXBlJyB8fCBwb2ludGVyW3BdID09PSAnX19wcm90b19fJykgcmV0dXJuIG9ialxuXG4gICAgcGFydCA9IHVudGlsZGUocG9pbnRlcltwKytdKVxuICAgIGhhc05leHRQYXJ0ID0gbGVuID4gcFxuXG4gICAgaWYgKHR5cGVvZiBvYmpbcGFydF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBzdXBwb3J0IHNldHRpbmcgb2YgLy1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiYgcGFydCA9PT0gJy0nKSB7XG4gICAgICAgIHBhcnQgPSBvYmoubGVuZ3RoXG4gICAgICB9XG5cbiAgICAgIC8vIHN1cHBvcnQgbmVzdGVkIG9iamVjdHMvYXJyYXkgd2hlbiBzZXR0aW5nIHZhbHVlc1xuICAgICAgaWYgKGhhc05leHRQYXJ0KSB7XG4gICAgICAgIGlmICgocG9pbnRlcltwXSAhPT0gJycgJiYgcG9pbnRlcltwXSA8IEluZmluaXR5KSB8fCBwb2ludGVyW3BdID09PSAnLScpIG9ialtwYXJ0XSA9IFtdXG4gICAgICAgIGVsc2Ugb2JqW3BhcnRdID0ge31cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhc05leHRQYXJ0KSBicmVha1xuICAgIG9iaiA9IG9ialtwYXJ0XVxuICB9XG5cbiAgdmFyIG9sZFZhbHVlID0gb2JqW3BhcnRdXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgb2JqW3BhcnRdXG4gIGVsc2Ugb2JqW3BhcnRdID0gdmFsdWVcbiAgcmV0dXJuIG9sZFZhbHVlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQb2ludGVyIChwb2ludGVyKSB7XG4gIGlmICh0eXBlb2YgcG9pbnRlciA9PT0gJ3N0cmluZycpIHtcbiAgICBwb2ludGVyID0gcG9pbnRlci5zcGxpdCgnLycpXG4gICAgaWYgKHBvaW50ZXJbMF0gPT09ICcnKSByZXR1cm4gcG9pbnRlclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIuJylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBvaW50ZXIpKSB7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBvaW50ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHBhcnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIuIE11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgbnVtYmVyLicpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb2ludGVyXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLicpXG59XG5cbmZ1bmN0aW9uIGdldCAob2JqLCBwb2ludGVyKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IG9iamVjdC4nKVxuICBwb2ludGVyID0gY29tcGlsZVBvaW50ZXIocG9pbnRlcilcbiAgdmFyIGxlbiA9IHBvaW50ZXIubGVuZ3RoXG4gIGlmIChsZW4gPT09IDEpIHJldHVybiBvYmpcblxuICBmb3IgKHZhciBwID0gMTsgcCA8IGxlbjspIHtcbiAgICBvYmogPSBvYmpbdW50aWxkZShwb2ludGVyW3ArK10pXVxuICAgIGlmIChsZW4gPT09IHApIHJldHVybiBvYmpcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0IChvYmosIHBvaW50ZXIsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IG9iamVjdC4nKVxuICBwb2ludGVyID0gY29tcGlsZVBvaW50ZXIocG9pbnRlcilcbiAgaWYgKHBvaW50ZXIubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyIGZvciBzZXQuJylcbiAgcmV0dXJuIHNldHRlcihvYmosIHBvaW50ZXIsIHZhbHVlKVxufVxuXG5mdW5jdGlvbiBjb21waWxlIChwb2ludGVyKSB7XG4gIHZhciBjb21waWxlZCA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZ2V0KG9iamVjdCwgY29tcGlsZWQpXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChvYmplY3QsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0KG9iamVjdCwgY29tcGlsZWQsIHZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmdldCA9IGdldFxuZXhwb3J0cy5zZXQgPSBzZXRcbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBzdHlsZT1cIndpZHRoOiAxMDAlXCI+XG4gICAgPE5vZGVSZWROb2RlRm9ybSA6bm9kZT1cImxvY2FsTm9kZVwiIDplcnJvcnM9XCJlcnJvcnNcIiBzdHlsZT1cIndpZHRoOiAxMDAlXCIgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuaW1wb3J0IHsgdmFsaWRhdG9yU2VydmljZSB9IGZyb20gXCIuL3ZhbGlkYXRvclwiO1xuaW1wb3J0IGpzb25wb2ludGVyIGZyb20gXCJqc29ucG9pbnRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiTm9kZVJlZFZ1ZUFwcFwiLFxuICBwcm9wczoge1xuICAgIG5vZGU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG4gICAgdmFsaWRhdG9yOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG4gICAgZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYWxOb2RlOiB0aGlzLm5vZGUsXG4gICAgICBlcnJvcnM6IHt9LFxuICAgIH07XG4gIH0sXG4gIGJlZm9yZU1vdW50KCkge1xuICAgIHRoaXMudmFsaWRhdG9yKHRoaXMubG9jYWxOb2RlKTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMubG9jYWxOb2RlLl9kZWYuZGVmYXVsdHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIHRoaXMuJHdhdGNoKFxuICAgICAgICAoKSA9PiB0aGlzLmxvY2FsTm9kZVtwcm9wXSxcbiAgICAgICAgKG5ld1ZhbCkgPT4ge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBkZWVwOiB0cnVlIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmxvY2FsTm9kZS5fZGVmLmNyZWRlbnRpYWxzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHNbcHJvcF0udHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbcHJvcF0gPSBcIl9fUFdEX19cIjtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kd2F0Y2goXG4gICAgICAgICgpID0+IHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdLFxuICAgICAgICAobmV3VmFsLCBvbGRWYWwpID0+IHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmxvY2FsTm9kZS5fZGVmLmNyZWRlbnRpYWxzW3Byb3BdLnR5cGUgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICAgICAgbmV3VmFsICE9PSBvbGRWYWxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdID0gISFuZXdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGRlZXA6IHRydWUgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlU2F2ZUJ1dHRvbk9uRXJyb3IpIHtcbiAgICAgICQoXCIjbm9kZS1kaWFsb2ctb2tcIik/LnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSkucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICQoXCIjbm9kZS1jb25maWctZGlhbG9nLW9rXCIpXG4gICAgICAgID8ucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICQoXCIjcmVkLXVpLXdvcmtzcGFjZVwiKS5nZXQoMCkuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIlwiKTtcbiAgICAgIC8vICQoXCIjcmVkLXVpLXdvcmtzcGFjZS1jaGFydCBzdmdcIilcbiAgICAgIC8vICAgLmdldCgwKVxuICAgICAgLy8gICAuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBtdXN0IHNldCBjcmVkZW50aWFscyBwcm9wIHRvIHVuZGVmaW5lZCB0byBhdm9pZCB1cGRhdGluZyBpdCB0byBfX1BXRF9fIGluIHRoZSBzZXJ2ZXJcbiAgICBPYmplY3Qua2V5cyh0aGlzLmxvY2FsTm9kZS5fZGVmLmNyZWRlbnRpYWxzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHNbcHJvcF0udHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdICYmXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdID09PSBcIl9fUFdEX19cIlxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdG9yKHRoaXMubG9jYWxOb2RlKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy52YWxpZGF0b3IuZXJyb3JzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycy5yZWR1Y2UoKGFjYywgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zdCBlcnJvclZhbHVlID0ganNvbnBvaW50ZXIuZ2V0KFxuICAgICAgICAgICAgdGhpcy5sb2NhbE5vZGUsXG4gICAgICAgICAgICBlcnJvci5pbnN0YW5jZVBhdGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVycm9yLnBhcmVudFNjaGVtYS5mb3JtYXQgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICAgICAgZXJyb3JWYWx1ZSA9PT0gXCJfX1BXRF9fXCJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBcInBhc3N3b3JkIGZpZWxkcyB3aXRoIHZhbHVlIGVxdWFsIHRvIF9fUFdEX18gc2hvdWxkIG5vdCBiZSBhbiBlcnJvclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYG5vZGUke2Vycm9yLmluc3RhbmNlUGF0aC5yZXBsYWNlQWxsKFwiL1wiLCBcIi5cIil9YDtcbiAgICAgICAgICAgIGFjY1trZXldID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlU2F2ZUJ1dHRvbk9uRXJyb3IpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgICAkKFwiI25vZGUtZGlhbG9nLW9rXCIpPy5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSkuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAkKFwiI25vZGUtY29uZmlnLWRpYWxvZy1va1wiKVxuICAgICAgICAgICAgPy5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgICAgICQoXCIjcmVkLXVpLXdvcmtzcGFjZVwiKVxuICAgICAgICAgICAgLmdldCgwKVxuICAgICAgICAgICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIsIFwiaW1wb3J0YW50XCIpO1xuICAgICAgICAgIC8vICQoXCIjcmVkLXVpLXdvcmtzcGFjZS1jaGFydCBzdmdcIilcbiAgICAgICAgICAvLyAgIC5nZXQoMClcbiAgICAgICAgICAvLyAgIC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiLCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkKFwiI25vZGUtZGlhbG9nLW9rXCIpLnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSkucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAkKFwiI25vZGUtY29uZmlnLWRpYWxvZy1va1wiKVxuICAgICAgICAgICAgLnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSlcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgICAgICQoXCIjcmVkLXVpLXdvcmtzcGFjZVwiKS5nZXQoMCkuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIlwiKTtcbiAgICAgICAgICAvLyAkKFwiI3JlZC11aS13b3Jrc3BhY2UtY2hhcnQgc3ZnXCIpXG4gICAgICAgICAgLy8gICAuZ2V0KDApXG4gICAgICAgICAgLy8gICAuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiNhcHAgLm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlIHtcbiAgY29sb3I6IHZhcigtLXJlZC11aS1mb3JtLWlucHV0LWJvcmRlci1lcnJvci1jb2xvcik7XG59XG5cbiNhcHAgbGFiZWwge1xuICB3aWR0aDogMTAwJTtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dFxuICAgICAgcmVmPVwiaW5wdXRGaWVsZFwiXG4gICAgICA6dHlwZT1cInR5cGVcIlxuICAgICAgOnZhbHVlPVwiaW50ZXJuYWxWYWx1ZVwiXG4gICAgICA6cGxhY2Vob2xkZXI9XCJwbGFjZWhvbGRlclwiXG4gICAgICBAaW5wdXQ9XCJvbklucHV0XCJcbiAgICAgIEBmb2N1cz1cIm9uRm9jdXNcIlxuICAgICAgQGJsdXI9XCJvbkJsdXJcIlxuICAgICAgc3R5bGU9XCJmbGV4OiAxOyB3aWR0aDogMTAwJVwiXG4gICAgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCIsIFwiaW5wdXRcIl0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVybmFsVmFsdWU6IFwiXCIsXG4gICAgICBzZWNyZXRQYXR0ZXJuOiBcIioqKioqKioqKioqKipcIixcbiAgICB9O1xuICB9LFxuICBiZWZvcmVNb3VudCgpIHtcbiAgICB0aGlzLmludGVybmFsVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMub25CbHVyKCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0KGV2ZW50KSB7XG4gICAgICB0aGlzLmludGVybmFsVmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIHRoaXMuaW50ZXJuYWxWYWx1ZSk7XG4gICAgICB0aGlzLiRlbWl0KFwiaW5wdXRcIiwgdGhpcy5pbnRlcm5hbFZhbHVlKTtcbiAgICB9LFxuICAgIG9uRm9jdXMoKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMudHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9PT0gdGhpcy5zZWNyZXRQYXR0ZXJuXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gXCJcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQmx1cigpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwicGFzc3dvcmRcIiAmJiB0aGlzLnZhbHVlID09PSBcIl9fUFdEX19cIikge1xuICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB0aGlzLnNlY3JldFBhdHRlcm47XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImNvbnN0IFRZUEVEX0lOUFVUX1RZUEVTID0gW1xuICBcIm1zZ1wiLFxuICBcImZsb3dcIixcbiAgXCJnbG9iYWxcIixcbiAgXCJzdHJcIixcbiAgXCJudW1cIixcbiAgXCJib29sXCIsXG4gIFwianNvblwiLFxuICBcImJpblwiLFxuICBcInJlXCIsXG4gIFwianNvbmF0YVwiLFxuICBcImRhdGVcIixcbiAgXCJlbnZcIixcbiAgXCJub2RlXCIsXG4gIFwiY3JlZFwiLFxuXTtcblxuZXhwb3J0IHsgVFlQRURfSU5QVVRfVFlQRVMgfTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlXCI+XG4gICAgPGlucHV0XG4gICAgICB0eXBlPVwidGV4dFwiXG4gICAgICByZWY9XCJ0eXBlZElucHV0XCJcbiAgICAgIGNsYXNzPVwibm9kZS1yZWQtdHlwZWQtaW5wdXRcIlxuICAgICAgc3R5bGU9XCJmbGV4OiAxOyB3aWR0aDogMTAwJVwiXG4gICAgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IFRZUEVEX0lOUFVUX1RZUEVTIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW1dBUk5dIEludmFsaWQgdmFsdWUgZm9yICd2YWx1ZScgcHJvcGVydHkuIEl0IG11c3QgYmUgYW4gb2JqZWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9XG4gICAgICAgICAgdHlwZW9mIG9iaj8udmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iaj8udHlwZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJbV0FSTl0gSW52YWxpZCB2YWx1ZSBmb3IgJ3ZhbHVlJyBwcm9wZXJ0eS4gSXQgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCAndmFsdWUnIGFuZCAndHlwZScgcHJvcGVydGllcyBiZWluZyBzdHJpbmdzLlwiLFxuICAgICAgICAgICAgb2JqXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICAgIH0sXG4gICAgfSxcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiAoKSA9PiBUWVBFRF9JTlBVVF9UWVBFUyxcbiAgICB9LFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlwiLFxuICAgIH0sXG4gIH0sXG4gIGVtaXRzOiBbXCJ1cGRhdGU6dmFsdWVcIl0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNQcm92aWRlZFZhbHVlVHlwZVZhbGlkKCkge1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudmFsdWUudHlwZTtcbiAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy50eXBlcztcblxuICAgICAgcmV0dXJuIHR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuICAgIH0sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgaW5wdXRFbGVtZW50ID0gdGhpcy4kcmVmcy50eXBlZElucHV0O1xuICAgIHRoaXMuJGlucHV0ID0gJChpbnB1dEVsZW1lbnQpLnR5cGVkSW5wdXQoe1xuICAgICAgZGVmYXVsdDogdGhpcy52YWx1ZS50eXBlIHx8IHRoaXMudHlwZXNbMF0sXG4gICAgICB0eXBlczogdGhpcy50eXBlcyxcbiAgICB9KTtcblxuICAgIHRoaXMuJGlucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiLCB0aGlzLnZhbHVlLnZhbHVlIHx8IFwiXCIpO1xuICAgIHRoaXMuJGlucHV0LnR5cGVkSW5wdXQoXCJ0eXBlXCIsIHRoaXMudmFsdWUudHlwZSB8fCB0aGlzLnR5cGVzWzBdKTtcblxuICAgIC8vIE5PVEU6IHdoZW4gdHlwZWQgaW5wdXQgaXMganVzdCBhIHRleHQgaW5wdXQsIGl0IGlzbid0IGVtaXRpbmcgY2hhbmdlIHdoaWxlIHR5cGluZyBiZWNhdXNlIGl0IGlzIHVwZGF0aW5nIHRoZSB2YWx1ZSBpbiBhIGhpZGRlbiBpbnB1dFxuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGlucHV0RWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcInZhbHVlXCJdLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfSk7XG5cbiAgICAvLyBOT1RFOiB0aGlzIGVtaXRzIGNoYW5nZXMgdG8gYWxsIHR5cGVzIHRoYXQgbG9zZSBmb2N1cyB3aGVuIGNob29zaW5nIGEgdmFsdWUsIGJ1dCB0ZXh0IGlucHV0c1xuICAgIHRoaXMuJGlucHV0Lm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9KTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBpc1Byb3ZpZGVkVmFsdWVUeXBlVmFsaWQ6IHtcbiAgICAgIGhhbmRsZXIobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKCFuZXdWYWx1ZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBWYWxpZGF0aW9uIGZhaWxlZDogdGhpcy52YWx1ZS50eXBlICgke3RoaXMudmFsdWUudHlwZX0pIG11c3QgYmUgb25lIG9mIHRoZSBwcm92aWRlZCB0eXBlcyAoJHt0aGlzLnR5cGVzfSkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgfSxcbiAgICBlcnJvcihuZXdWYWwpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGl2ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBcIi5yZWQtdWktdHlwZWRJbnB1dC1jb250YWluZXJcIlxuICAgICAgICApO1xuICAgICAgICBpZiAobmV3VmFsKSB7XG4gICAgICAgICAgdGFyZ2V0RGl2LmNsYXNzTGlzdC5hZGQoXCJpbnB1dC1lcnJvclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXREaXYuY2xhc3NMaXN0LnJlbW92ZShcImlucHV0LWVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DaGFuZ2UoKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuJGlucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiKTtcbiAgICAgIGNvbnN0IG5ld1R5cGUgPSB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidHlwZVwiKTtcbiAgICAgIGlmICh0aGlzLnZhbHVlLnZhbHVlICE9PSBuZXdWYWx1ZSB8fCB0aGlzLnZhbHVlLnR5cGUgIT09IG5ld1R5cGUpIHtcbiAgICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCB7XG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIHR5cGU6IG5ld1R5cGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIDppZD1cImlucHV0SWRcIiBzdHlsZT1cIndpZHRoOiAxMDAlXCIgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCJdLFxuICBjb21wdXRlZDoge1xuICAgIGlucHV0UHJlZml4KCkge1xuICAgICAgcmV0dXJuIFwibm9kZS1pbnB1dC1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KTtcbiAgICB9LFxuICAgIGlucHV0SWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnB1dFByZWZpeCArIFwiLVwiICsgdGhpcy52YWx1ZTtcbiAgICB9LFxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIFJFRC5lZGl0b3IucHJlcGFyZUNvbmZpZ05vZGVTZWxlY3QoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy52YWx1ZSxcbiAgICAgIHRoaXMudHlwZSxcbiAgICAgIHRoaXMuaW5wdXRQcmVmaXhcbiAgICApO1xuXG4gICAgY29uc3QgaW5wdXQgPSAkKFwiI1wiICsgdGhpcy5pbnB1dElkKTtcbiAgICBpbnB1dC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIGlucHV0LnZhbCgpKTtcbiAgICB9KTtcblxuICAgIGlucHV0LnZhbCh0aGlzLnZhbHVlIHx8IFwiX0FERF9cIik7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgcmVmPVwic2VsZWN0SW5wdXRcIlxuICAgICAgY2xhc3M9XCJub2RlLWlucHV0LXNlbGVjdFwiXG4gICAgICBzdHlsZT1cIndpZHRoOiAxMDAlXCJcbiAgICAvPlxuICAgIDxkaXYgdi1pZj1cImVycm9yXCIgY2xhc3M9XCJub2RlLXJlZC12dWUtaW5wdXQtZXJyb3ItbWVzc2FnZVwiPlxuICAgICAge3sgZXJyb3IgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcgfCBBcnJheSxcbiAgICBvcHRpb25zOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW1dBUk5dIEludmFsaWQgdmFsdWUgZm9yICdvcHRpb25zJyBwcm9wZXJ0eS4gSXQgbXVzdCBiZSBhbiBhcnJheS5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWx1ZS5ldmVyeSgoaXRlbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgaXRlbSAhPT0gbnVsbDtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGl0ZW0uaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSAmJlxuICAgICAgICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eShcImxhYmVsXCIpICYmXG4gICAgICAgICAgICB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGl0ZW0ubGFiZWwgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIltXQVJOXSBJbnZhbGlkIHZhbHVlIGZvciAnb3B0aW9ucycgcHJvcGVydHkuIEVhY2ggaXRlbSBtdXN0IGJlIGFuIG9iamVjdCB3aXRoICd2YWx1ZScgYW5kICdsYWJlbCcgcHJvcGVydGllcyBiZWluZyBzdHJpbmdzLlwiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcbiAgICB9LFxuICAgIG11bHRpcGxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCJdLFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IHRoaXMuJHJlZnMuc2VsZWN0SW5wdXQ7XG4gICAgY29uc3QgJHNlbGVjdElucHV0ID0gJChpbnB1dEVsZW1lbnQpO1xuICAgICRzZWxlY3RJbnB1dC50eXBlZElucHV0KHtcbiAgICAgIHR5cGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtdWx0aXBsZTogdGhpcy5tdWx0aXBsZSxcbiAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgJHNlbGVjdElucHV0LnR5cGVkSW5wdXQoXG4gICAgICBcInZhbHVlXCIsXG4gICAgICBBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpID8gdGhpcy52YWx1ZS5qb2luKFwiLFwiKSA6IHRoaXMudmFsdWVcbiAgICApO1xuICAgICRzZWxlY3RJbnB1dC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMubXVsdGlwbGVcbiAgICAgICAgPyAkc2VsZWN0SW5wdXQudHlwZWRJbnB1dChcInZhbHVlXCIpPy5zcGxpdChcIixcIilcbiAgICAgICAgOiAkc2VsZWN0SW5wdXQudHlwZWRJbnB1dChcInZhbHVlXCIpO1xuICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCBuZXdWYWx1ZSk7XG4gICAgfSk7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgcmVmPVwiY29udGFpbmVyRGl2XCIgY2xhc3M9XCJub2RlLXRleHQtZWRpdG9yLWNvbnRhaW5lclwiPlxuICAgIDxkaXYgcmVmPVwiZWRpdG9yRGl2XCIgOmlkPVwiZWRpdG9ySWRcIiBjbGFzcz1cIm5vZGUtdGV4dC1lZGl0b3JcIj48L2Rpdj5cbiAgICA8ZGl2IHYtc2hvdz1cImVycm9yXCIgY2xhc3M9XCJub2RlLXJlZC12dWUtaW5wdXQtZXJyb3ItbWVzc2FnZVwiPlxuICAgICAge3sgZXJyb3IgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgbGFuZ3VhZ2U6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwianNvblwiLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZExhbmd1YWdlcyA9IFtcbiAgICAgICAgICBcImFiYXBcIixcbiAgICAgICAgICBcImFwZXhcIixcbiAgICAgICAgICBcImF6Y2xpXCIsXG4gICAgICAgICAgXCJiYXRcIixcbiAgICAgICAgICBcImJpY2VwXCIsXG4gICAgICAgICAgXCJjYW1lbGlnb1wiLFxuICAgICAgICAgIFwiY2xvanVyZVwiLFxuICAgICAgICAgIFwiY29mZmVlXCIsXG4gICAgICAgICAgXCJjcHBcIixcbiAgICAgICAgICBcImNzaGFycFwiLFxuICAgICAgICAgIFwiY3NwXCIsXG4gICAgICAgICAgXCJjc3NcIixcbiAgICAgICAgICBcImN5cGhlclwiLFxuICAgICAgICAgIFwiZGFydFwiLFxuICAgICAgICAgIFwiZG9ja2VyZmlsZVwiLFxuICAgICAgICAgIFwiZWNsXCIsXG4gICAgICAgICAgXCJlbGl4aXJcIixcbiAgICAgICAgICBcImZsb3c5XCIsXG4gICAgICAgICAgXCJmcmVlbWFya2VyMlwiLFxuICAgICAgICAgIFwiZnNoYXJwXCIsXG4gICAgICAgICAgXCJnb1wiLFxuICAgICAgICAgIFwiZ3JhcGhxbFwiLFxuICAgICAgICAgIFwiaGFuZGxlYmFyc1wiLFxuICAgICAgICAgIFwiaGNsXCIsXG4gICAgICAgICAgXCJodG1sXCIsXG4gICAgICAgICAgXCJpbmlcIixcbiAgICAgICAgICBcImphdmFcIixcbiAgICAgICAgICBcImphdmFzY3JpcHRcIixcbiAgICAgICAgICBcImpzb25cIixcbiAgICAgICAgICBcImp1bGlhXCIsXG4gICAgICAgICAgXCJrb3RsaW5cIixcbiAgICAgICAgICBcImxlc3NcIixcbiAgICAgICAgICBcImxleG9uXCIsXG4gICAgICAgICAgXCJsaXF1aWRcIixcbiAgICAgICAgICBcImx1YVwiLFxuICAgICAgICAgIFwibTNcIixcbiAgICAgICAgICBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJtZHhcIixcbiAgICAgICAgICBcIm1pcHNcIixcbiAgICAgICAgICBcIm1zZGF4XCIsXG4gICAgICAgICAgXCJteXNxbFwiLFxuICAgICAgICAgIFwib2JqZWN0aXZlLWNcIixcbiAgICAgICAgICBcInBhc2NhbFwiLFxuICAgICAgICAgIFwicGFzY2FsaWdvXCIsXG4gICAgICAgICAgXCJwZXJsXCIsXG4gICAgICAgICAgXCJwZ3NxbFwiLFxuICAgICAgICAgIFwicGhwXCIsXG4gICAgICAgICAgXCJwbGFcIixcbiAgICAgICAgICBcInBvc3RpYXRzXCIsXG4gICAgICAgICAgXCJwb3dlcnF1ZXJ5XCIsXG4gICAgICAgICAgXCJwb3dlcnNoZWxsXCIsXG4gICAgICAgICAgXCJwcm90b2J1ZlwiLFxuICAgICAgICAgIFwicHViXCIsXG4gICAgICAgICAgXCJweXRob25cIixcbiAgICAgICAgICBcInFzaGFycFwiLFxuICAgICAgICAgIFwiclwiLFxuICAgICAgICAgIFwicmF6b3JcIixcbiAgICAgICAgICBcInJlZGlzXCIsXG4gICAgICAgICAgXCJyZWRzaGlmdFwiLFxuICAgICAgICAgIFwicmVzdHJ1Y3R1cmVkdGV4dFwiLFxuICAgICAgICAgIFwicnVieVwiLFxuICAgICAgICAgIFwicnVzdFwiLFxuICAgICAgICAgIFwic2JcIixcbiAgICAgICAgICBcInNjYWxhXCIsXG4gICAgICAgICAgXCJzY2hlbWVcIixcbiAgICAgICAgICBcInNjc3NcIixcbiAgICAgICAgICBcInNoZWxsXCIsXG4gICAgICAgICAgXCJzb2xpZGl0eVwiLFxuICAgICAgICAgIFwic29waGlhXCIsXG4gICAgICAgICAgXCJzcGFycWxcIixcbiAgICAgICAgICBcInNxbFwiLFxuICAgICAgICAgIFwic3RcIixcbiAgICAgICAgICBcInN3aWZ0XCIsXG4gICAgICAgICAgXCJzeXN0ZW12ZXJpbG9nXCIsXG4gICAgICAgICAgXCJ0Y2xcIixcbiAgICAgICAgICBcInR3aWdcIixcbiAgICAgICAgICBcInR5cGVzY3JpcHRcIixcbiAgICAgICAgICBcInR5cGVzcGVjXCIsXG4gICAgICAgICAgXCJ2YlwiLFxuICAgICAgICAgIFwid2dzbFwiLFxuICAgICAgICAgIFwieG1sXCIsXG4gICAgICAgICAgXCJ5YW1sXCIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhbGxvd2VkTGFuZ3VhZ2VzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFtXQVJOXTogSW52YWxpZCB2YWx1ZSBmb3IgJ3R5cGUnIHByb3BlcnR5OiBcIiR7dmFsdWV9XCIuIGAgK1xuICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mOiAke2FsbG93ZWRMYW5ndWFnZXMuam9pbihcIiwgXCIpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlwiLFxuICAgIH0sXG4gIH0sXG4gIGVtaXRzOiBbXCJ1cGRhdGU6dmFsdWVcIl0sXG4gIGVkaXRvcjogbnVsbCxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9ySWQ6IFwibm9kZS1yZWQtZWRpdG9yLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpLFxuICAgIH07XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5tb3VudEVkaXRvcigpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbW91bnRFZGl0b3IoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckVsID0gdGhpcy4kcmVmcy5jb250YWluZXJEaXY7XG4gICAgICAgIGNvbnN0IGVkaXRvckVsID0gdGhpcy4kcmVmcy5lZGl0b3JEaXY7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lckVsICYmIGVkaXRvckVsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZUhlaWdodCA9IGNvbnRhaW5lckVsLnN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZVdpZHRoID0gY29udGFpbmVyRWwuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBpZiAoaW5saW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLmhlaWdodCA9IGlubGluZUhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLmhlaWdodCA9IFwiMjAwcHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLndpZHRoID0gaW5saW5lV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3JFbC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUVkaXRvckluc3RhbmNlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJbTm9kZVJlZEVkaXRvcklucHV0XSBFcnJvciBzZXR0aW5nIGluaXRpYWwgZWRpdG9yIHN0eWxlOlwiLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVFZGl0b3JJbnN0YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJbTm9kZVJlZEVkaXRvcklucHV0XSBDb250YWluZXIgb3IgRWRpdG9yIGRpdiByZWZzIG5vdCBmb3VuZCBvbiBtb3VudC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlRWRpdG9ySW5zdGFuY2UoKSB7XG4gICAgICB0aGlzLmVkaXRvckluc3RhbmNlID0gUkVELmVkaXRvci5jcmVhdGVFZGl0b3Ioe1xuICAgICAgICBpZDogdGhpcy5lZGl0b3JJZCxcbiAgICAgICAgbW9kZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UuZ2V0U2Vzc2lvbigpLm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5lZGl0b3JJbnN0YW5jZS5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBiZWZvcmVVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmVkaXRvckluc3RhbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmVkaXRvckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXN0cm95aW5nIGVkaXRvciBmb3IgSUQgJHt0aGlzLmVkaXRvcklkfTpgLCBlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLmdldEVzbUV4cG9ydE5hbWUgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuYWRkQ29kZUFyZyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLl9Db2RlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5JREVOVElGSUVSID0gZXhwb3J0cy5fQ29kZU9yTmFtZSA9IHZvaWQgMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzc1xuY2xhc3MgX0NvZGVPck5hbWUge1xufVxuZXhwb3J0cy5fQ29kZU9yTmFtZSA9IF9Db2RlT3JOYW1lO1xuZXhwb3J0cy5JREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG5jbGFzcyBOYW1lIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCFleHBvcnRzLklERU5USUZJRVIudGVzdChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5hbWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcIik7XG4gICAgICAgIHRoaXMuc3RyID0gcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4geyBbdGhpcy5zdHJdOiAxIH07XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lID0gTmFtZTtcbmNsYXNzIF9Db2RlIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gXCJcIiB8fCBpdGVtID09PSAnXCJcIic7XG4gICAgfVxuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9zdHIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9zdHIgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKHMsIGMpID0+IGAke3N9JHtjfWAsIFwiXCIpKSk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX25hbWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fbmFtZXMgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzLCBjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgICAgIH0sIHt9KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuX0NvZGUgPSBfQ29kZTtcbmV4cG9ydHMubmlsID0gbmV3IF9Db2RlKFwiXCIpO1xuZnVuY3Rpb24gXyhzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29kZSA9IFtzdHJzWzBdXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBhZGRDb2RlQXJnKGNvZGUsIGFyZ3NbaV0pO1xuICAgICAgICBjb2RlLnB1c2goc3Ryc1srK2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKTtcbn1cbmV4cG9ydHMuXyA9IF87XG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKTtcbmZ1bmN0aW9uIHN0cihzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXhwciA9IFtzYWZlU3RyaW5naWZ5KHN0cnNbMF0pXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBleHByLnB1c2gocGx1cyk7XG4gICAgICAgIGFkZENvZGVBcmcoZXhwciwgYXJnc1tpXSk7XG4gICAgICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShleHByKTtcbiAgICByZXR1cm4gbmV3IF9Db2RlKGV4cHIpO1xufVxuZXhwb3J0cy5zdHIgPSBzdHI7XG5mdW5jdGlvbiBhZGRDb2RlQXJnKGNvZGUsIGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBfQ29kZSlcbiAgICAgICAgY29kZS5wdXNoKC4uLmFyZy5faXRlbXMpO1xuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgIGNvZGUucHVzaChhcmcpO1xuICAgIGVsc2VcbiAgICAgICAgY29kZS5wdXNoKGludGVycG9sYXRlKGFyZykpO1xufVxuZXhwb3J0cy5hZGRDb2RlQXJnID0gYWRkQ29kZUFyZztcbmZ1bmN0aW9uIG9wdGltaXplKGV4cHIpIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgd2hpbGUgKGkgPCBleHByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGV4cHJbaV0gPT09IHBsdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG1lcmdlRXhwckl0ZW1zKGV4cHJbaSAtIDFdLCBleHByW2kgKyAxXSk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHByLnNwbGljZShpIC0gMSwgMywgcmVzKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJbaSsrXSA9IFwiK1wiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZUV4cHJJdGVtcyhhLCBiKSB7XG4gICAgaWYgKGIgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKGEgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBOYW1lIHx8IGFbYS5sZW5ndGggLSAxXSAhPT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gYCR7YS5zbGljZSgwLCAtMSl9JHtifVwiYDtcbiAgICAgICAgaWYgKGJbMF0gPT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgwLCAtMSkgKyBiLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpXG4gICAgICAgIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWA7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gc3RyQ29uY2F0KGMxLCBjMikge1xuICAgIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHIgYCR7YzF9JHtjMn1gO1xufVxuZXhwb3J0cy5zdHJDb25jYXQgPSBzdHJDb25jYXQ7XG4vLyBUT0RPIGRvIG5vdCBhbGxvdyBhcnJheXMgaGVyZVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHggPT09IG51bGxcbiAgICAgICAgPyB4XG4gICAgICAgIDogc2FmZVN0cmluZ2lmeShBcnJheS5pc0FycmF5KHgpID8geC5qb2luKFwiLFwiKSA6IHgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKHNhZmVTdHJpbmdpZnkoeCkpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeClcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIik7XG59XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5O1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfIGBbJHtrZXl9XWA7XG59XG5leHBvcnRzLmdldFByb3BlcnR5ID0gZ2V0UHJvcGVydHk7XG4vL0RvZXMgYmVzdCBlZmZvcnQgdG8gZm9ybWF0IHRoZSBuYW1lIHByb3Blcmx5XG5mdW5jdGlvbiBnZXRFc21FeHBvcnROYW1lKGtleSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgZXhwb3J0cy5JREVOVElGSUVSLnRlc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gbmV3IF9Db2RlKGAke2tleX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBpbnZhbGlkIGV4cG9ydCBuYW1lOiAke2tleX0sIHVzZSBleHBsaWNpdCAkaWQgbmFtZSBtYXBwaW5nYCk7XG59XG5leHBvcnRzLmdldEVzbUV4cG9ydE5hbWUgPSBnZXRFc21FeHBvcnROYW1lO1xuZnVuY3Rpb24gcmVnZXhwQ29kZShyeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUocngudG9TdHJpbmcoKSk7XG59XG5leHBvcnRzLnJlZ2V4cENvZGUgPSByZWdleHBDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmFtZS52YWx1ZTtcbiAgICB9XG59XG52YXIgVXNlZFZhbHVlU3RhdGU7XG4oZnVuY3Rpb24gKFVzZWRWYWx1ZVN0YXRlKSB7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJTdGFydGVkXCJdID0gMF0gPSBcIlN0YXJ0ZWRcIjtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9IDFdID0gXCJDb21wbGV0ZWRcIjtcbn0pKFVzZWRWYWx1ZVN0YXRlIHx8IChleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0gVXNlZFZhbHVlU3RhdGUgPSB7fSkpO1xuZXhwb3J0cy52YXJLaW5kcyA9IHtcbiAgICBjb25zdDogbmV3IGNvZGVfMS5OYW1lKFwiY29uc3RcIiksXG4gICAgbGV0OiBuZXcgY29kZV8xLk5hbWUoXCJsZXRcIiksXG4gICAgdmFyOiBuZXcgY29kZV8xLk5hbWUoXCJ2YXJcIiksXG59O1xuY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4ZXMsIHBhcmVudCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fbmFtZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJlZml4ZXMgPSBwcmVmaXhlcztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICB0b05hbWUobmFtZU9yUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuYW1lT3JQcmVmaXggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5OYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIF9uZXdOYW1lKHByZWZpeCkge1xuICAgICAgICBjb25zdCBuZyA9IHRoaXMuX25hbWVzW3ByZWZpeF0gfHwgdGhpcy5fbmFtZUdyb3VwKHByZWZpeCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtuZy5pbmRleCsrfWA7XG4gICAgfVxuICAgIF9uYW1lR3JvdXAocHJlZml4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5fcGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3ByZWZpeGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGFzKHByZWZpeCkpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7IHByZWZpeCwgaW5kZXg6IDAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xuY2xhc3MgVmFsdWVTY29wZU5hbWUgZXh0ZW5kcyBjb2RlXzEuTmFtZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4LCBuYW1lU3RyKSB7XG4gICAgICAgIHN1cGVyKG5hbWVTdHIpO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHksIGl0ZW1JbmRleCB9KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY29wZVBhdGggPSAoMCwgY29kZV8xLl8pIGAuJHtuZXcgY29kZV8xLk5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYDtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gVmFsdWVTY29wZU5hbWU7XG5jb25zdCBsaW5lID0gKDAsIGNvZGVfMS5fKSBgXFxuYDtcbmNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBjb2RlXzEubmlsIH07XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlU2NvcGVOYW1lKHByZWZpeCwgdGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgdmFsdWUobmFtZU9yUHJlZml4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IHJlZiBtdXN0IGJlIHBhc3NlZCBpbiB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSBuYW1lO1xuICAgICAgICBjb25zdCB2YWx1ZUtleSA9IChfYSA9IHZhbHVlLmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWUucmVmO1xuICAgICAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKHZzKSB7XG4gICAgICAgICAgICBjb25zdCBfbmFtZSA9IHZzLmdldCh2YWx1ZUtleSk7XG4gICAgICAgICAgICBpZiAoX25hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB2cy5zZXQodmFsdWVLZXksIG5hbWUpO1xuICAgICAgICBjb25zdCBzID0gdGhpcy5fc2NvcGVbcHJlZml4XSB8fCAodGhpcy5fc2NvcGVbcHJlZml4XSA9IFtdKTtcbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGg7XG4gICAgICAgIHNbaXRlbUluZGV4XSA9IHZhbHVlLnJlZjtcbiAgICAgICAgbmFtZS5zZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eTogcHJlZml4LCBpdGVtSW5kZXggfSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB2cy5nZXQoa2V5T3JSZWYpO1xuICAgIH1cbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lLCB2YWx1ZXMgPSB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVfMS5fKSBgJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKHZhbHVlcyA9IHRoaXMuX3ZhbHVlcywgdXNlZFZhbHVlcywgZ2V0Q29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUudmFsdWUuY29kZTtcbiAgICAgICAgfSwgdXNlZFZhbHVlcywgZ2V0Q29kZSk7XG4gICAgfVxuICAgIF9yZWR1Y2VWYWx1ZXModmFsdWVzLCB2YWx1ZUNvZGUsIHVzZWRWYWx1ZXMgPSB7fSwgZ2V0Q29kZSkge1xuICAgICAgICBsZXQgY29kZSA9IGNvZGVfMS5uaWw7XG4gICAgICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBuYW1lU2V0ID0gKHVzZWRWYWx1ZXNbcHJlZml4XSA9IHVzZWRWYWx1ZXNbcHJlZml4XSB8fCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgdnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpO1xuICAgICAgICAgICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IHRoaXMub3B0cy5lczUgPyBleHBvcnRzLnZhcktpbmRzLnZhciA6IGV4cG9ydHMudmFyS2luZHMuY29uc3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtkZWZ9ICR7bmFtZX0gPSAke2N9OyR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjID0gZ2V0Q29kZSA9PT0gbnVsbCB8fCBnZXRDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRDb2RlKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gKDAsIGNvZGVfMS5fKSBgJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGUgPSBWYWx1ZVNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9yID0gZXhwb3J0cy5hbmQgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMub3BlcmF0b3JzID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlZhbHVlU2NvcGUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gdm9pZCAwO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbmNvbnN0IHNjb3BlXzEgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbnZhciBjb2RlXzIgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJDb25jYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJDb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLmdldFByb3BlcnR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnZXhwQ29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnJlZ2V4cENvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuTmFtZTsgfSB9KTtcbnZhciBzY29wZV8yID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5TY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGVOYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFyS2luZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIudmFyS2luZHM7IH0gfSk7XG5leHBvcnRzLm9wZXJhdG9ycyA9IHtcbiAgICBHVDogbmV3IGNvZGVfMS5fQ29kZShcIj5cIiksXG4gICAgR1RFOiBuZXcgY29kZV8xLl9Db2RlKFwiPj1cIiksXG4gICAgTFQ6IG5ldyBjb2RlXzEuX0NvZGUoXCI8XCIpLFxuICAgIExURTogbmV3IGNvZGVfMS5fQ29kZShcIjw9XCIpLFxuICAgIEVROiBuZXcgY29kZV8xLl9Db2RlKFwiPT09XCIpLFxuICAgIE5FUTogbmV3IGNvZGVfMS5fQ29kZShcIiE9PVwiKSxcbiAgICBOT1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCIhXCIpLFxuICAgIE9SOiBuZXcgY29kZV8xLl9Db2RlKFwifHxcIiksXG4gICAgQU5EOiBuZXcgY29kZV8xLl9Db2RlKFwiJiZcIiksXG4gICAgQUREOiBuZXcgY29kZV8xLl9Db2RlKFwiK1wiKSxcbn07XG5jbGFzcyBOb2RlIHtcbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhfbmFtZXMsIF9jb25zdGFudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgRGVmIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgcmhzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgIH1cbiAgICByZW5kZXIoeyBlczUsIF9uIH0pIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IGVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWA7XG4gICAgICAgIHJldHVybiBgJHt2YXJLaW5kfSAke3RoaXMubmFtZX0ke3Joc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFuYW1lc1t0aGlzLm5hbWUuc3RyXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucmhzKVxuICAgICAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaHMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLnJocy5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIHRoaXMuc2lkZUVmZmVjdHMgPSBzaWRlRWZmZWN0cztcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ID0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgIW5hbWVzW3RoaXMubGhzLnN0cl0gJiYgIXRoaXMuc2lkZUVmZmVjdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8ge30gOiB7IC4uLnRoaXMubGhzLm5hbWVzIH07XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMucmhzKTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gICAgY29uc3RydWN0b3IobGhzLCBvcCwgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcihsaHMsIHJocywgc2lkZUVmZmVjdHMpO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgTGFiZWwgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIEJyZWFrIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsID8gYCAke3RoaXMubGFiZWx9YCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgYnJlYWske2xhYmVsfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgVGhyb3cgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfbjtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvci5uYW1lcztcbiAgICB9XG59XG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5jb2RlLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGVzID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGNvZGUsIG4pID0+IGNvZGUgKyBuLnJlbmRlcihvcHRzKSwgXCJcIik7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobikpXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pO1xuICAgICAgICAgICAgZWxzZSBpZiAobilcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChuLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBuLm5hbWVzKTtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChuYW1lcywgbikgPT4gYWRkTmFtZXMobmFtZXMsIG4ubmFtZXMpLCB7fSk7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgb3B0cy5fbiArIHN1cGVyLnJlbmRlcihvcHRzKSArIFwifVwiICsgb3B0cy5fbjtcbiAgICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgUGFyZW50Tm9kZSB7XG59XG5jbGFzcyBFbHNlIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkVsc2Uua2luZCA9IFwiZWxzZVwiO1xuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmRpdGlvbiwgbm9kZXMpIHtcbiAgICAgICAgc3VwZXIobm9kZXMpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgY29uc3QgY29uZCA9IHRoaXMuY29uZGl0aW9uO1xuICAgICAgICBpZiAoY29uZCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzOyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgICAgICBsZXQgZSA9IHRoaXMuZWxzZTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBlID0gdGhpcy5lbHNlID0gQXJyYXkuaXNBcnJheShucykgPyBuZXcgRWxzZShucykgOiBucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSWYgPyBlIDogZS5ub2RlcztcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWxzZSA9IChfYSA9IHRoaXMuZWxzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIGlmICghKHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykgfHwgdGhpcy5lbHNlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5jb25kaXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMuY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmVsc2UubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuSWYua2luZCA9IFwiaWZcIjtcbmNsYXNzIEZvciBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5Gb3Iua2luZCA9IFwiZm9yXCI7XG5jbGFzcyBGb3JMb29wIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBpdGVyYXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy5pdGVyYXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmF0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhdGlvbi5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZnJvbSwgdG8gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dmFyS2luZH0gJHtuYW1lfT0ke2Zyb219OyAke25hbWV9PCR7dG99OyAke25hbWV9KyspYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGFkZEV4cHJOYW1lcyhzdXBlci5uYW1lcywgdGhpcy5mcm9tKTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgRm9ySXRlciBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IobG9vcCwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMudmFyS2luZH0gJHt0aGlzLm5hbWV9ICR7dGhpcy5sb29wfSAke3RoaXMuaXRlcmFibGV9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYWJsZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYWJsZS5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgYXN5bmMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5hc3luYyA9IGFzeW5jO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCBfYXN5bmMgPSB0aGlzLmFzeW5jID8gXCJhc3luYyBcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgJHtfYXN5bmN9ZnVuY3Rpb24gJHt0aGlzLm5hbWV9KCR7dGhpcy5hcmdzfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZ1bmMua2luZCA9IFwiZnVuY1wiO1xuY2xhc3MgUmV0dXJuIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cblJldHVybi5raW5kID0gXCJyZXR1cm5cIjtcbmNsYXNzIFRyeSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBcInRyeVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5jYXRjaC5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuZmluYWxseS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIENhdGNoIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgY2F0Y2goJHt0aGlzLmVycm9yfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkNhdGNoLmtpbmQgPSBcImNhdGNoXCI7XG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRmluYWxseS5raW5kID0gXCJmaW5hbGx5XCI7XG5jbGFzcyBDb2RlR2VuIHtcbiAgICBjb25zdHJ1Y3RvcihleHRTY29wZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IFwiXFxuXCIgOiBcIlwiIH07XG4gICAgICAgIHRoaXMuX2V4dFNjb3BlID0gZXh0U2NvcGU7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gbmV3IHNjb3BlXzEuU2NvcGUoeyBwYXJlbnQ6IGV4dFNjb3BlIH0pO1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LnJlbmRlcih0aGlzLm9wdHMpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHVuaXF1ZSBuYW1lIGluIHRoZSBpbnRlcm5hbCBzY29wZVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICAgIHNjb3BlTmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gICAgc2NvcGVWYWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdIHx8ICh0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdID0gbmV3IFNldCgpKTtcbiAgICAgICAgdnMuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0U2NvcGVWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5nZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGNvZGUgdGhhdCBhc3NpZ25zIHZhbHVlcyBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgdG8gdGhlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseVxuICAgIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlQ29kZSh0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBfZGVmKHZhcktpbmQsIG5hbWVPclByZWZpeCwgcmhzLCBjb25zdGFudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmIChyaHMgIT09IHVuZGVmaW5lZCAmJiBjb25zdGFudClcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1tuYW1lLnN0cl0gPSByaHM7XG4gICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBEZWYodmFyS2luZCwgbmFtZSwgcmhzKSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBjb25zdChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgbGV0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmxldCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGB2YXJgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudFxuICAgIHZhcihuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy52YXIsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBhc3NpZ25tZW50IGNvZGVcbiAgICBhc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykpO1xuICAgIH1cbiAgICAvLyBgKz1gIGNvZGVcbiAgICBhZGQobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ25PcChsaHMsIGV4cG9ydHMub3BlcmF0b3JzLkFERCwgcmhzKSk7XG4gICAgfVxuICAgIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgICBjb2RlKGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGMoKTtcbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gY29kZV8xLm5pbClcbiAgICAgICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBBbnlDb2RlKGMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgY29kZSBmb3Igb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBwYXNzZWQgYXJndW1lbnQgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAgICBvYmplY3QoLi4ua2V5VmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXCJ7XCJdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiLFwiKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdmFsdWUgfHwgdGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIjpcIik7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5hZGRDb2RlQXJnKShjb2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29kZS5wdXNoKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoY29kZSk7XG4gICAgfVxuICAgIC8vIGBpZmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYHRoZW5Cb2R5YCBhbmQsIG9wdGlvbmFsbHksIGBlbHNlQm9keWAgYXJlIHBhc3NlZClcbiAgICBpZihjb25kaXRpb24sIHRoZW5Cb2R5LCBlbHNlQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgICAgICBpZiAodGhlbkJvZHkgJiYgZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZWxzZSgpLmNvZGUoZWxzZUJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhlbkJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiBib2R5IHdpdGhvdXQgXCJ0aGVuXCIgYm9keScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZWxzZSBpZmAgY2xhdXNlIC0gaW52YWxpZCB3aXRob3V0IGBpZmAgb3IgYWZ0ZXIgYGVsc2VgIGNsYXVzZXNcbiAgICBlbHNlSWYoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgfVxuICAgIC8vIGBlbHNlYCBjbGF1c2UgLSBvbmx5IHZhbGlkIGFmdGVyIGBpZmAgb3IgYGVsc2UgaWZgIGNsYXVzZXNcbiAgICBlbHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IEVsc2UoKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgaWZgIHN0YXRlbWVudCAobmVlZGVkIGlmIGdlbi5pZiB3YXMgdXNlZCBvbmx5IHdpdGggY29uZGl0aW9uKVxuICAgIGVuZElmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKElmLCBFbHNlKTtcbiAgICB9XG4gICAgX2Zvcihub2RlLCBmb3JCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgaWYgKGZvckJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZm9yQm9keSkuZW5kRm9yKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBhIGdlbmVyaWMgYGZvcmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYGZvckJvZHlgIGlzIHBhc3NlZClcbiAgICBmb3IoaXRlcmF0aW9uLCBmb3JCb2R5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckxvb3AoaXRlcmF0aW9uKSwgZm9yQm9keSk7XG4gICAgfVxuICAgIC8vIGBmb3JgIHN0YXRlbWVudCBmb3IgYSByYW5nZSBvZiB2YWx1ZXNcbiAgICBmb3JSYW5nZShuYW1lT3JQcmVmaXgsIGZyb20sIHRvLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5sZXQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JSYW5nZSh2YXJLaW5kLCBuYW1lLCBmcm9tLCB0byksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLW9mYCBzdGF0ZW1lbnQgKGluIGVzNSBtb2RlIHJlcGxhY2Ugd2l0aCBhIG5vcm1hbCBmb3IgbG9vcClcbiAgICBmb3JPZihuYW1lT3JQcmVmaXgsIGl0ZXJhYmxlLCBmb3JCb2R5LCB2YXJLaW5kID0gc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBpdGVyYWJsZSBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gaXRlcmFibGUgOiB0aGlzLnZhcihcIl9hcnJcIiwgaXRlcmFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yUmFuZ2UoXCJfaVwiLCAwLCAoMCwgY29kZV8xLl8pIGAke2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcihuYW1lLCAoMCwgY29kZV8xLl8pIGAke2Fycn1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBmb3JCb2R5KG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcIm9mXCIsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3ItaW5gIHN0YXRlbWVudC5cbiAgICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gICAgZm9ySW4obmFtZU9yUHJlZml4LCBvYmosIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yT2YobmFtZU9yUHJlZml4LCAoMCwgY29kZV8xLl8pIGBPYmplY3Qua2V5cygke29ian0pYCwgZm9yQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwiaW5cIiwgdmFyS2luZCwgbmFtZSwgb2JqKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgZm9yYCBsb29wXG4gICAgZW5kRm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZvcik7XG4gICAgfVxuICAgIC8vIGBsYWJlbGAgc3RhdGVtZW50XG4gICAgbGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBMYWJlbChsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgYnJlYWtgIHN0YXRlbWVudFxuICAgIGJyZWFrKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQnJlYWsobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYHJldHVybmAgc3RhdGVtZW50XG4gICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgUmV0dXJuKCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInJldHVyblwiIHNob3VsZCBoYXZlIG9uZSBub2RlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoUmV0dXJuKTtcbiAgICB9XG4gICAgLy8gYHRyeWAgc3RhdGVtZW50XG4gICAgdHJ5KHRyeUJvZHksIGNhdGNoQ29kZSwgZmluYWxseUNvZGUpIHtcbiAgICAgICAgaWYgKCFjYXRjaENvZGUgJiYgIWZpbmFsbHlDb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInRyeVwiIHdpdGhvdXQgXCJjYXRjaFwiIGFuZCBcImZpbmFsbHlcIicpO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFRyeSgpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh0cnlCb2R5KTtcbiAgICAgICAgaWYgKGNhdGNoQ29kZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLm5hbWUoXCJlXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmNhdGNoID0gbmV3IENhdGNoKGVycm9yKTtcbiAgICAgICAgICAgIGNhdGNoQ29kZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsbHlDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuZmluYWxseSA9IG5ldyBGaW5hbGx5KCk7XG4gICAgICAgICAgICB0aGlzLmNvZGUoZmluYWxseUNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoQ2F0Y2gsIEZpbmFsbHkpO1xuICAgIH1cbiAgICAvLyBgdGhyb3dgIHN0YXRlbWVudFxuICAgIHRocm93KGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgVGhyb3coZXJyb3IpKTtcbiAgICB9XG4gICAgLy8gc3RhcnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBibG9jayhib2R5LCBub2RlQ291bnQpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMucHVzaCh0aGlzLl9ub2Rlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShib2R5KS5lbmRCbG9jayhub2RlQ291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIHRoZSBjdXJyZW50IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgZW5kQmxvY2sobm9kZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuX2Jsb2NrU3RhcnRzLnBvcCgpO1xuICAgICAgICBpZiAobGVuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBub3QgaW4gc2VsZi1iYWxhbmNpbmcgYmxvY2tcIik7XG4gICAgICAgIGNvbnN0IHRvQ2xvc2UgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSBsZW47XG4gICAgICAgIGlmICh0b0Nsb3NlIDwgMCB8fCAobm9kZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgdG9DbG9zZSAhPT0gbm9kZUNvdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiB3cm9uZyBudW1iZXIgb2Ygbm9kZXM6ICR7dG9DbG9zZX0gdnMgJHtub2RlQ291bnR9IGV4cGVjdGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gbGVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGZ1bmN0aW9uYCBoZWFkaW5nIChvciBkZWZpbml0aW9uIGlmIGZ1bmNCb2R5IGlzIHBhc3NlZClcbiAgICBmdW5jKG5hbWUsIGFyZ3MgPSBjb2RlXzEubmlsLCBhc3luYywgZnVuY0JvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBGdW5jKG5hbWUsIGFyZ3MsIGFzeW5jKSk7XG4gICAgICAgIGlmIChmdW5jQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmdW5jQm9keSkuZW5kRnVuYygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICBlbmRGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZ1bmMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShuID0gMSkge1xuICAgICAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTmFtZXModGhpcy5fcm9vdC5uYW1lcywgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbGVhZk5vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2Jsb2NrTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIF9lbmRCbG9ja05vZGUoTjEsIE4yKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBOMSB8fCAoTjIgJiYgbiBpbnN0YW5jZW9mIE4yKSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5vdCBpbiBibG9jayBcIiR7TjIgPyBgJHtOMS5raW5kfS8ke04yLmtpbmR9YCA6IE4xLmtpbmR9XCJgKTtcbiAgICB9XG4gICAgX2Vsc2VOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAoIShuIGluc3RhbmNlb2YgSWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIHdpdGhvdXQgXCJpZlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBuLmVsc2UgPSBub2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IF9yb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF07XG4gICAgfVxuICAgIGdldCBfY3Vyck5vZGUoKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIHJldHVybiBuc1tucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgc2V0IF9jdXJyTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIG5zW25zLmxlbmd0aCAtIDFdID0gbm9kZTtcbiAgICB9XG59XG5leHBvcnRzLkNvZGVHZW4gPSBDb2RlR2VuO1xuZnVuY3Rpb24gYWRkTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgKyAoZnJvbVtuXSB8fCAwKTtcbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBhZGRFeHByTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IGFkZE5hbWVzKG5hbWVzLCBmcm9tLm5hbWVzKSA6IG5hbWVzO1xufVxuZnVuY3Rpb24gb3B0aW1pemVFeHByKGV4cHIsIG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICByZXR1cm4gcmVwbGFjZU5hbWUoZXhwcik7XG4gICAgaWYgKCFjYW5PcHRpbWl6ZShleHByKSlcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoZXhwci5faXRlbXMucmVkdWNlKChpdGVtcywgYykgPT4ge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICAgICAgYyA9IHJlcGxhY2VOYW1lKGMpO1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSlcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goLi4uYy5faXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpdGVtcy5wdXNoKGMpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSwgW10pKTtcbiAgICBmdW5jdGlvbiByZXBsYWNlTmFtZShuKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjb25zdGFudHNbbi5zdHJdO1xuICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkIHx8IG5hbWVzW24uc3RyXSAhPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICBkZWxldGUgbmFtZXNbbi5zdHJdO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoZSkge1xuICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUgJiZcbiAgICAgICAgICAgIGUuX2l0ZW1zLnNvbWUoKGMpID0+IGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiBuYW1lc1tjLnN0cl0gPT09IDEgJiYgY29uc3RhbnRzW2Muc3RyXSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3VidHJhY3ROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSAtIChmcm9tW25dIHx8IDApO1xufVxuZnVuY3Rpb24gbm90KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB4ID09PSBudWxsID8gIXggOiAoMCwgY29kZV8xLl8pIGAhJHtwYXIoeCl9YDtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuQU5EKTtcbi8vIGJvb2xlYW4gQU5EICgmJikgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKTtcbn1cbmV4cG9ydHMuYW5kID0gYW5kO1xuY29uc3Qgb3JDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5PUik7XG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKG9yQ29kZSk7XG59XG5leHBvcnRzLm9yID0gb3I7XG5mdW5jdGlvbiBtYXBwZW5kKG9wKSB7XG4gICAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gY29kZV8xLm5pbCA/IHkgOiB5ID09PSBjb2RlXzEubmlsID8geCA6ICgwLCBjb2RlXzEuXykgYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKTtcbn1cbmZ1bmN0aW9uIHBhcih4KSB7XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHggOiAoMCwgY29kZV8xLl8pIGAoJHt4fSlgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZXhwb3J0cy5UeXBlID0gZXhwb3J0cy51c2VGdW5jID0gZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBleHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IGV4cG9ydHMuZWFjaEl0ZW0gPSBleHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IGV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBleHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gZXhwb3J0cy50b0hhc2ggPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZWdlbi9jb2RlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2UgU2V0XG5mdW5jdGlvbiB0b0hhc2goYXJyKSB7XG4gICAgY29uc3QgaGFzaCA9IHt9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpXG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIHJldHVybiBoYXNoO1xufVxuZXhwb3J0cy50b0hhc2ggPSB0b0hhc2g7XG5mdW5jdGlvbiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hKTtcbiAgICByZXR1cm4gIXNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgaXQuc2VsZi5SVUxFUy5hbGwpO1xufVxuZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGFsd2F5c1ZhbGlkU2NoZW1hO1xuZnVuY3Rpb24gY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSA9IGl0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgaWYgKCFvcHRzLnN0cmljdFNjaGVtYSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGVzID0gc2VsZi5SVUxFUy5rZXl3b3JkcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFydWxlc1trZXldKVxuICAgICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgdW5rbm93biBrZXl3b3JkOiBcIiR7a2V5fVwiYCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGNoZWNrVW5rbm93blJ1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBydWxlcykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChydWxlc1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IHNjaGVtYUhhc1J1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBSVUxFUykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiICYmIFJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IHNjaGVtYUhhc1J1bGVzQnV0UmVmO1xuZnVuY3Rpb24gc2NoZW1hUmVmT3JWYWwoeyB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSwgc2NoZW1hLCBrZXl3b3JkLCAkZGF0YSkge1xuICAgIGlmICghJGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX1gO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9YDtcbn1cbmV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBzY2hlbWFSZWZPclZhbDtcbmZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlSnNvblBvaW50ZXIoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gdW5lc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlSnNvblBvaW50ZXIoc3RyKSk7XG59XG5leHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gYCR7c3RyfWA7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG5leHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IHVuZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiBlYWNoSXRlbSh4cywgZikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHhzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHggb2YgeHMpXG4gICAgICAgICAgICBmKHgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZih4cyk7XG4gICAgfVxufVxuZXhwb3J0cy5lYWNoSXRlbSA9IGVhY2hJdGVtO1xuZnVuY3Rpb24gbWFrZU1lcmdlRXZhbHVhdGVkKHsgbWVyZ2VOYW1lcywgbWVyZ2VUb05hbWUsIG1lcmdlVmFsdWVzLCByZXN1bHRUb05hbWUsIH0pIHtcbiAgICByZXR1cm4gKGdlbiwgZnJvbSwgdG8sIHRvTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSB0byA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGZyb21cbiAgICAgICAgICAgIDogdG8gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgID8gKGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IG1lcmdlTmFtZXMoZ2VuLCBmcm9tLCB0bykgOiBtZXJnZVRvTmFtZShnZW4sIGZyb20sIHRvKSwgdG8pXG4gICAgICAgICAgICAgICAgOiBmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyAobWVyZ2VUb05hbWUoZ2VuLCB0bywgZnJvbSksIGZyb20pXG4gICAgICAgICAgICAgICAgICAgIDogbWVyZ2VWYWx1ZXMoZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdG9OYW1lID09PSBjb2RlZ2VuXzEuTmFtZSAmJiAhKHJlcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSA/IHJlc3VsdFRvTmFtZShnZW4sIHJlcykgOiByZXM7XG4gICAgfTtcbn1cbmV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSB7XG4gICAgcHJvcHM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZnJvbX0gPT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCB0cnVlKSwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gfHwge31gKS5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5hc3NpZ24oJHt0b30sICR7ZnJvbX0pYCkpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWVgLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gfHwge31gKTtcbiAgICAgICAgICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCB0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiB7IC4uLmZyb20sIC4uLnRvIH0pLFxuICAgICAgICByZXN1bHRUb05hbWU6IGV2YWx1YXRlZFByb3BzVG9OYW1lLFxuICAgIH0pLFxuICAgIGl0ZW1zOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24odG8sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnJvbX0gPT09IHRydWUgPyB0cnVlIDogJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIGZyb20gPT09IHRydWUgPyB0cnVlIDogKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgICAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICAgIH0pLFxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgcHMpIHtcbiAgICBpZiAocHMgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBnZW4udmFyKFwicHJvcHNcIiwgdHJ1ZSk7XG4gICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICBpZiAocHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5leHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXZhbHVhdGVkUHJvcHNUb05hbWU7XG5mdW5jdGlvbiBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocCl9YCwgdHJ1ZSkpO1xufVxuZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBzZXRFdmFsdWF0ZWQ7XG5jb25zdCBzbmlwcGV0cyA9IHt9O1xuZnVuY3Rpb24gdXNlRnVuYyhnZW4sIGYpIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgcmVmOiBmLFxuICAgICAgICBjb2RlOiBzbmlwcGV0c1tmLmNvZGVdIHx8IChzbmlwcGV0c1tmLmNvZGVdID0gbmV3IGNvZGVfMS5fQ29kZShmLmNvZGUpKSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlRnVuYyA9IHVzZUZ1bmM7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk51bVwiXSA9IDBdID0gXCJOdW1cIjtcbiAgICBUeXBlW1R5cGVbXCJTdHJcIl0gPSAxXSA9IFwiU3RyXCI7XG59KShUeXBlIHx8IChleHBvcnRzLlR5cGUgPSBUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldEVycm9yUGF0aChkYXRhUHJvcCwgZGF0YVByb3BUeXBlLCBqc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgLy8gbGV0IHBhdGhcbiAgICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkge1xuICAgICAgICBjb25zdCBpc051bWJlciA9IGRhdGFQcm9wVHlwZSA9PT0gVHlwZS5OdW07XG4gICAgICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4XG4gICAgICAgICAgICA/IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYDsgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgICB9XG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyAoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApO1xufVxuZXhwb3J0cy5nZXRFcnJvclBhdGggPSBnZXRFcnJvclBhdGg7XG5mdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgbW9kZSA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gO1xuICAgIGlmIChtb2RlID09PSB0cnVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZyk7XG59XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGNoZWNrU3RyaWN0TW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXMgPSB7XG4gICAgLy8gdmFsaWRhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICBkYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkYXRhXCIpLCAvLyBkYXRhIHBhc3NlZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgLy8gYXJncyBwYXNzZWQgZnJvbSByZWZlcmVuY2luZyBzY2hlbWFcbiAgICB2YWxDeHQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInZhbEN4dFwiKSwgLy8gdmFsaWRhdGlvbi9kYXRhIGNvbnRleHQgLSBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGl0IGlzIGRlc3RydWN0dXJlZCB0byB0aGUgbmFtZXMgYmVsb3dcbiAgICBpbnN0YW5jZVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImluc3RhbmNlUGF0aFwiKSxcbiAgICBwYXJlbnREYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhXCIpLFxuICAgIHBhcmVudERhdGFQcm9wZXJ0eTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50RGF0YVByb3BlcnR5XCIpLFxuICAgIHJvb3REYXRhOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJyb290RGF0YVwiKSwgLy8gcm9vdCBkYXRhIC0gc2FtZSBhcyB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGZpcnN0L3RvcCB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgZHluYW1pY0FuY2hvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLCAvLyB1c2VkIHRvIHN1cHBvcnQgcmVjdXJzaXZlUmVmIGFuZCBkeW5hbWljUmVmXG4gICAgLy8gZnVuY3Rpb24gc2NvcGVkIHZhcmlhYmxlc1xuICAgIHZFcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInZFcnJvcnNcIiksIC8vIG51bGwgb3IgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICBlcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImVycm9yc1wiKSwgLy8gY291bnRlciBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHRoaXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInRoaXNcIiksXG4gICAgLy8gXCJnbG9iYWxzXCJcbiAgICBzZWxmOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzZWxmXCIpLFxuICAgIHNjb3BlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJzY29wZVwiKSxcbiAgICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICAgIGpzb246IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25cIiksXG4gICAganNvblBvczogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBvc1wiKSxcbiAgICBqc29uTGVuOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uTGVuXCIpLFxuICAgIGpzb25QYXJ0OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUGFydFwiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBuYW1lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRFcnJvcnMgPSBleHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSBleHBvcnRzLnJlcG9ydEV4dHJhRXJyb3IgPSBleHBvcnRzLnJlcG9ydEVycm9yID0gZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5leHBvcnRzLmtleXdvcmRFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBwYXNzIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgdmFsaWRhdGlvbmAsXG59O1xuZXhwb3J0cy5rZXl3b3JkJERhdGFFcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFUeXBlIH0pID0+IHNjaGVtYVR5cGVcbiAgICAgICAgPyAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbXVzdCBiZSAke3NjaGVtYVR5cGV9ICgkZGF0YSlgXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5zdHIpIGBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIGlzIGludmFsaWQgKCRkYXRhKWAsXG59O1xuZnVuY3Rpb24gcmVwb3J0RXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzLCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzIH0gPSBpdDtcbiAgICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG4gICAgaWYgKG92ZXJyaWRlQWxsRXJyb3JzICE9PSBudWxsICYmIG92ZXJyaWRlQWxsRXJyb3JzICE9PSB2b2lkIDAgPyBvdmVycmlkZUFsbEVycm9ycyA6IChjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJPYmp9XWApO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXJyb3IgPSByZXBvcnRFcnJvcjtcbmZ1bmN0aW9uIHJlcG9ydEV4dHJhRXJyb3IoY3h0LCBlcnJvciA9IGV4cG9ydHMua2V5d29yZEVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgaWYgKCEoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IHJlcG9ydEV4dHJhRXJyb3I7XG5mdW5jdGlvbiByZXNldEVycm9yc0NvdW50KGdlbiwgZXJyc0NvdW50KSB7XG4gICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBlcnJzQ291bnQpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+IGdlbi5pZihlcnJzQ291bnQsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCwgZXJyc0NvdW50KSwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCkpKTtcbn1cbmV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IHJlc2V0RXJyb3JzQ291bnQ7XG5mdW5jdGlvbiBleHRlbmRFcnJvcnMoeyBnZW4sIGtleXdvcmQsIHNjaGVtYVZhbHVlLCBkYXRhLCBlcnJzQ291bnQsIGl0LCB9KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVycnNDb3VudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgZXJyID0gZ2VuLm5hbWUoXCJlcnJcIik7XG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBlcnJzQ291bnQsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIChpKSA9PiB7XG4gICAgICAgIGdlbi5jb25zdChlcnIsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9WyR7aX1dYCk7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaXQuZXJyb3JQYXRoKSkpO1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFQYXRoYCwgKDAsIGNvZGVnZW5fMS5zdHIpIGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uc2NoZW1hYCwgc2NoZW1hVmFsdWUpO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2Vycn0uZGF0YWAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4dGVuZEVycm9ycztcbmZ1bmN0aW9uIGFkZEVycm9yKGdlbiwgZXJyT2JqKSB7XG4gICAgY29uc3QgZXJyID0gZ2VuLmNvbnN0KFwiZXJyXCIsIGVyck9iaik7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsYCwgKCkgPT4gZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgWyR7ZXJyfV1gKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ucHVzaCgke2Vycn0pYCk7XG4gICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSsrYCk7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJvcnMoaXQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KCR7ZXJyc30pYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBlcnJzKTtcbiAgICAgICAgZ2VuLnJldHVybihmYWxzZSk7XG4gICAgfVxufVxuY29uc3QgRSA9IHtcbiAgICBrZXl3b3JkOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJrZXl3b3JkXCIpLFxuICAgIHNjaGVtYVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVBhdGhcIiksIC8vIGFsc28gdXNlZCBpbiBKVEQgZXJyb3JzXG4gICAgcGFyYW1zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJhbXNcIiksXG4gICAgcHJvcGVydHlOYW1lOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwcm9wZXJ0eU5hbWVcIiksXG4gICAgbWVzc2FnZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwibWVzc2FnZVwiKSxcbiAgICBzY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVwiKSxcbiAgICBwYXJlbnRTY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudFNjaGVtYVwiKSxcbn07XG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgY3JlYXRlRXJyb3JzIH0gPSBjeHQuaXQ7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB7fWA7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xufVxuZnVuY3Rpb24gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyA9IHt9KSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3Qga2V5VmFsdWVzID0gW1xuICAgICAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgICAgIGVycm9yU2NoZW1hUGF0aChjeHQsIGVycm9yUGF0aHMpLFxuICAgIF07XG4gICAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcyk7XG4gICAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGVycm9ySW5zdGFuY2VQYXRoKHsgZXJyb3JQYXRoIH0sIHsgaW5zdGFuY2VQYXRoIH0pIHtcbiAgICBjb25zdCBpbnN0UGF0aCA9IGluc3RhbmNlUGF0aFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJvclBhdGh9JHsoMCwgdXRpbF8xLmdldEVycm9yUGF0aCkoaW5zdGFuY2VQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWBcbiAgICAgICAgOiBlcnJvclBhdGg7XG4gICAgcmV0dXJuIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXTtcbn1cbmZ1bmN0aW9uIGVycm9yU2NoZW1hUGF0aCh7IGtleXdvcmQsIGl0OiB7IGVyclNjaGVtYVBhdGggfSB9LCB7IHNjaGVtYVBhdGgsIHBhcmVudFNjaGVtYSB9KSB7XG4gICAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogKDAsIGNvZGVnZW5fMS5zdHIpIGAke2VyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gO1xuICAgIGlmIChzY2hlbWFQYXRoKSB7XG4gICAgICAgIHNjaFBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7c2NoUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShzY2hlbWFQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWA7XG4gICAgfVxuICAgIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXTtcbn1cbmZ1bmN0aW9uIGV4dHJhRXJyb3JQcm9wcyhjeHQsIHsgcGFyYW1zLCBtZXNzYWdlIH0sIGtleVZhbHVlcykge1xuICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBvcHRzLCBwcm9wZXJ0eU5hbWUsIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAga2V5VmFsdWVzLnB1c2goW0Uua2V5d29yZCwga2V5d29yZF0sIFtFLnBhcmFtcywgdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoY3h0KSA6IHBhcmFtcyB8fCAoMCwgY29kZWdlbl8xLl8pIGB7fWBdKTtcbiAgICBpZiAob3B0cy5tZXNzYWdlcykge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5tZXNzYWdlLCB0eXBlb2YgbWVzc2FnZSA9PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGN4dCkgOiBtZXNzYWdlXSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0Uuc2NoZW1hLCBzY2hlbWFWYWx1ZV0sIFtFLnBhcmVudFNjaGVtYSwgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLCBbbmFtZXNfMS5kZWZhdWx0LmRhdGEsIGRhdGFdKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5TmFtZSlcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBleHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgYm9vbEVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn07XG5mdW5jdGlvbiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG51bGwpO1xuICAgICAgICBnZW4ucmV0dXJuKHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB0b3BCb29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIGZhbHNlKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTsgLy8gVE9ETyB2YXJcbiAgICB9XG59XG5leHBvcnRzLmJvb2xPckVtcHR5U2NoZW1hID0gYm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBmYWxzZVNjaGVtYUVycm9yKGl0LCBvdmVycmlkZUFsbEVycm9ycykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhIH0gPSBpdDtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgb3RoZXIgaW50ZXJmYWNlIHNob3VsZCBiZSB1c2VkIGZvciBub24ta2V5d29yZCB2YWxpZGF0aW9uIGVycm9ycy4uLlxuICAgIGNvbnN0IGN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcImZhbHNlIHNjaGVtYVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IGZhbHNlLFxuICAgICAgICBzY2hlbWFDb2RlOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IGZhbHNlLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCBib29sRXJyb3IsIHVuZGVmaW5lZCwgb3ZlcnJpZGVBbGxFcnJvcnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbFNjaGVtYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UnVsZXMgPSBleHBvcnRzLmlzSlNPTlR5cGUgPSB2b2lkIDA7XG5jb25zdCBfanNvblR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIl07XG5jb25zdCBqc29uVHlwZXMgPSBuZXcgU2V0KF9qc29uVHlwZXMpO1xuZnVuY3Rpb24gaXNKU09OVHlwZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KTtcbn1cbmV4cG9ydHMuaXNKU09OVHlwZSA9IGlzSlNPTlR5cGU7XG5mdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICBjb25zdCBncm91cHMgPSB7XG4gICAgICAgIG51bWJlcjogeyB0eXBlOiBcIm51bWJlclwiLCBydWxlczogW10gfSxcbiAgICAgICAgc3RyaW5nOiB7IHR5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBhcnJheTogeyB0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBvYmplY3Q6IHsgdHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdIH0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlczogeyAuLi5ncm91cHMsIGludGVnZXI6IHRydWUsIGJvb2xlYW46IHRydWUsIG51bGw6IHRydWUgfSxcbiAgICAgICAgcnVsZXM6IFt7IHJ1bGVzOiBbXSB9LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgICAgICBwb3N0OiB7IHJ1bGVzOiBbXSB9LFxuICAgICAgICBhbGw6IHt9LFxuICAgICAgICBrZXl3b3Jkczoge30sXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UnVsZXMgPSBnZXRSdWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gdm9pZCAwO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNGb3JUeXBlKHsgc2NoZW1hLCBzZWxmIH0sIHR5cGUpIHtcbiAgICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV07XG4gICAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSBzY2hlbWFIYXNSdWxlc0ZvclR5cGU7XG5mdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLnJ1bGVzLnNvbWUoKHJ1bGUpID0+IHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZUdyb3VwID0gc2hvdWxkVXNlR3JvdXA7XG5mdW5jdGlvbiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKChfYSA9IHJ1bGUuZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VSdWxlID0gc2hvdWxkVXNlUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGxpY2FiaWxpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmdldEpTT05UeXBlcyA9IGV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBleHBvcnRzLkRhdGFUeXBlID0gdm9pZCAwO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuLi9ydWxlc1wiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIERhdGFUeXBlO1xuKGZ1bmN0aW9uIChEYXRhVHlwZSkge1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiQ29ycmVjdFwiXSA9IDBdID0gXCJDb3JyZWN0XCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJXcm9uZ1wiXSA9IDFdID0gXCJXcm9uZ1wiO1xufSkoRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSBEYXRhVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlcyhzY2hlbWEpIHtcbiAgICBjb25zdCB0eXBlcyA9IGdldEpTT05UeXBlcyhzY2hlbWEudHlwZSk7XG4gICAgY29uc3QgaGFzTnVsbCA9IHR5cGVzLmluY2x1ZGVzKFwibnVsbFwiKTtcbiAgICBpZiAoaGFzTnVsbCkge1xuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGU6IG51bGwgY29udHJhZGljdHMgbnVsbGFibGU6IGZhbHNlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0eXBlcy5sZW5ndGggJiYgc2NoZW1hLm51bGxhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJudWxsYWJsZVwiIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSB0cnVlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChcIm51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cbmV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBnZXRTY2hlbWFUeXBlcztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG5mdW5jdGlvbiBnZXRKU09OVHlwZXModHMpIHtcbiAgICBjb25zdCB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXTtcbiAgICBpZiAodHlwZXMuZXZlcnkocnVsZXNfMS5pc0pTT05UeXBlKSlcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSBKU09OVHlwZSBvciBKU09OVHlwZVtdOiBcIiArIHR5cGVzLmpvaW4oXCIsXCIpKTtcbn1cbmV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZ2V0SlNPTlR5cGVzO1xuZnVuY3Rpb24gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKTtcbiAgICBjb25zdCBjaGVja1R5cGVzID0gdHlwZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgKDAsIGFwcGxpY2FiaWxpdHlfMS5zY2hlbWFIYXNSdWxlc0ZvclR5cGUpKGl0LCB0eXBlc1swXSkpO1xuICAgIGlmIChjaGVja1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKTtcbiAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tUeXBlcztcbn1cbmV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGNvZXJjZUFuZENoZWNrRGF0YVR5cGU7XG5jb25zdCBDT0VSQ0lCTEUgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSk7XG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKHR5cGVzLCBjb2VyY2VUeXBlcykge1xuICAgIHJldHVybiBjb2VyY2VUeXBlc1xuICAgICAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgICAgICA6IFtdO1xufVxuZnVuY3Rpb24gY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2VuLmxldChcImRhdGFUeXBlXCIsICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9YCk7XG4gICAgY29uc3QgY29lcmNlZCA9IGdlbi5sZXQoXCJjb2VyY2VkXCIsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+IGdlblxuICAgICAgICAgICAgLmFzc2lnbihkYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9WzBdYClcbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YVR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSkpO1xuICAgIH1cbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCk7XG4gICAgZm9yIChjb25zdCB0IG9mIGNvZXJjZVRvKSB7XG4gICAgICAgIGlmIChDT0VSQ0lCTEUuaGFzKHQpIHx8ICh0ID09PSBcImFycmF5XCIgJiYgb3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgY29lcmNlU3BlY2lmaWNUeXBlKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbi5lbHNlKCk7XG4gICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICBnZW4uZW5kSWYoKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICBnZW4uYXNzaWduKGRhdGEsIGNvZXJjZWQpO1xuICAgICAgICBhc3NpZ25QYXJlbnREYXRhKGl0LCBjb2VyY2VkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjb2VyY2VTcGVjaWZpY1R5cGUodCkge1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSBcIm51bWJlclwiIHx8ICR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiICsgJHtkYXRhfWApXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgXCJcImApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiZmFsc2VcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwidHJ1ZVwiIHx8ICR7ZGF0YX0gPT09IDFgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBcIlwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNvZXJjZWQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiIHx8ICR7ZGF0YVR5cGV9ID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgIHx8ICR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtkYXRhfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoeyBnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSB9LCBleHByKSB7XG4gICAgLy8gVE9ETyB1c2UgZ2VuLnByb3BlcnR5XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7cGFyZW50RGF0YX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfVske3BhcmVudERhdGFQcm9wZXJ0eX1dYCwgZXhwcikpO1xufVxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCA9IERhdGFUeXBlLkNvcnJlY3QpIHtcbiAgICBjb25zdCBFUSA9IGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkVRIDogY29kZWdlbl8xLm9wZXJhdG9ycy5ORVE7XG4gICAgbGV0IGNvbmQ7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJHtFUX0gbnVsbGA7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ICYmIHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgoMCwgY29kZWdlbl8xLl8pIGAhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gJHtFUX0gJHtkYXRhVHlwZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiAoMCwgY29kZWdlbl8xLm5vdCkoY29uZCk7XG4gICAgZnVuY3Rpb24gbnVtQ29uZChfY29uZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuYW5kKSgoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSA9PSBcIm51bWJlclwiYCwgX2NvbmQsIHN0cmljdE51bXMgPyAoMCwgY29kZWdlbl8xLl8pIGBpc0Zpbml0ZSgke2RhdGF9KWAgOiBjb2RlZ2VuXzEubmlsKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBjaGVja0RhdGFUeXBlO1xuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoZGF0YVR5cGVzLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSB7XG4gICAgaWYgKGRhdGFUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KTtcbiAgICB9XG4gICAgbGV0IGNvbmQ7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgdXRpbF8xLnRvSGFzaCkoZGF0YVR5cGVzKTtcbiAgICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5vdE9iaiA9ICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ICE9IFwib2JqZWN0XCJgO1xuICAgICAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6ICgwLCBjb2RlZ2VuXzEuXykgYCEke2RhdGF9IHx8ICR7bm90T2JqfWA7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5udWxsO1xuICAgICAgICBkZWxldGUgdHlwZXMuYXJyYXk7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5vYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25kID0gY29kZWdlbl8xLm5pbDtcbiAgICB9XG4gICAgaWYgKHR5cGVzLm51bWJlcilcbiAgICAgICAgZGVsZXRlIHR5cGVzLmludGVnZXI7XG4gICAgZm9yIChjb25zdCB0IGluIHR5cGVzKVxuICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5hbmQpKGNvbmQsIGNoZWNrRGF0YVR5cGUodCwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpO1xuICAgIHJldHVybiBjb25kO1xufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGNoZWNrRGF0YVR5cGVzO1xuY29uc3QgdHlwZUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYSB9KSA9PiBgbXVzdCBiZSAke3NjaGVtYX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hLCBzY2hlbWFWYWx1ZSB9KSA9PiB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyAoMCwgY29kZWdlbl8xLl8pIGB7dHlwZTogJHtzY2hlbWF9fWAgOiAoMCwgY29kZWdlbl8xLl8pIGB7dHlwZTogJHtzY2hlbWFWYWx1ZX19YCxcbn07XG5mdW5jdGlvbiByZXBvcnRUeXBlRXJyb3IoaXQpIHtcbiAgICBjb25zdCBjeHQgPSBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KTtcbiAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKGN4dCwgdHlwZUVycm9yKTtcbn1cbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gcmVwb3J0VHlwZUVycm9yO1xuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEgfSA9IGl0O1xuICAgIGNvbnN0IHNjaGVtYUNvZGUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgc2NoZW1hLCBcInR5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEudHlwZSxcbiAgICAgICAgc2NoZW1hQ29kZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IHNjaGVtYUNvZGUsXG4gICAgICAgIHBhcmVudFNjaGVtYTogc2NoZW1hLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKGl0LCB0eSkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcywgaXRlbXMgfSA9IGl0LnNjaGVtYTtcbiAgICBpZiAodHkgPT09IFwib2JqZWN0XCIgJiYgcHJvcGVydGllcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBhc3NpZ25EZWZhdWx0KGl0LCBrZXksIHByb3BlcnRpZXNba2V5XS5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKHNjaCwgaSkgPT4gYXNzaWduRGVmYXVsdChpdCwgaSwgc2NoLmRlZmF1bHQpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2lnbkRlZmF1bHRzID0gYXNzaWduRGVmYXVsdHM7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KGl0LCBwcm9wLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB7IGdlbiwgY29tcG9zaXRlUnVsZSwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgY2hpbGREYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcCl9YDtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSkge1xuICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBkZWZhdWx0IGlzIGlnbm9yZWQgZm9yOiAke2NoaWxkRGF0YX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY29uZGl0aW9uID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgO1xuICAgIGlmIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIpIHtcbiAgICAgICAgY29uZGl0aW9uID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kaXRpb259IHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgO1xuICAgIH1cbiAgICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgICAvLyAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiID8gYCB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYCA6IFwiXCIpXG4gICAgZ2VuLmlmKGNvbmRpdGlvbiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtjaGlsZERhdGF9ID0gJHsoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkoZGVmYXVsdFZhbHVlKX1gKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gZXhwb3J0cy51c2VQYXR0ZXJuID0gZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gZXhwb3J0cy5zY2hlbWFQcm9wZXJ0aWVzID0gZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMuaXNPd25Qcm9wZXJ0eSA9IGV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBleHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gZXhwb3J0cy5jaGVja1JlcG9ydE1pc3NpbmdQcm9wID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vY29tcGlsZS91dGlsXCIpO1xuZnVuY3Rpb24gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogKDAsIGNvZGVnZW5fMS5fKSBgJHtwcm9wfWAgfSwgdHJ1ZSk7XG4gICAgICAgIGN4dC5lcnJvcigpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jaGVja1JlcG9ydE1pc3NpbmdQcm9wID0gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGNoZWNrTWlzc2luZ1Byb3AoeyBnZW4sIGRhdGEsIGl0OiB7IG9wdHMgfSB9LCBwcm9wZXJ0aWVzLCBtaXNzaW5nKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEub3IpKC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PiAoMCwgY29kZWdlbl8xLmFuZCkobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksICgwLCBjb2RlZ2VuXzEuXykgYCR7bWlzc2luZ30gPSAke3Byb3B9YCkpKTtcbn1cbmV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGNoZWNrTWlzc2luZ1Byb3A7XG5mdW5jdGlvbiByZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpIHtcbiAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nIH0sIHRydWUpO1xuICAgIGN4dC5lcnJvcigpO1xufVxuZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IHJlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gaGFzUHJvcEZ1bmMoZ2VuKSB7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgcmVmOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBoYXNQcm9wRnVuYztcbmZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2hhc1Byb3BGdW5jKGdlbil9LmNhbGwoJHtkYXRhfSwgJHtwcm9wZXJ0eX0pYDtcbn1cbmV4cG9ydHMuaXNPd25Qcm9wZXJ0eSA9IGlzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gIT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7aXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KX1gIDogY29uZDtcbn1cbmV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBwcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wZXJ0eSl9ID09PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gKDAsIGNvZGVnZW5fMS5vcikoY29uZCwgKDAsIGNvZGVnZW5fMS5ub3QpKGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkpKSA6IGNvbmQ7XG59XG5leHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBub1Byb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gc2NoZW1hTWFwID8gT2JqZWN0LmtleXMoc2NoZW1hTWFwKS5maWx0ZXIoKHApID0+IHAgIT09IFwiX19wcm90b19fXCIpIDogW107XG59XG5leHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gc2NoZW1hUHJvcGVydGllcyhpdCwgc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKS5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hTWFwW3BdKSk7XG59XG5leHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBzY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gY2FsbFZhbGlkYXRlQ29kZSh7IHNjaGVtYUNvZGUsIGRhdGEsIGl0OiB7IGdlbiwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoLCBlcnJvclBhdGggfSwgaXQgfSwgZnVuYywgY29udGV4dCwgcGFzc1NjaGVtYSkge1xuICAgIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSwgJHtkYXRhfSwgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWAgOiBkYXRhO1xuICAgIGNvbnN0IHZhbEN4dCA9IFtcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBlcnJvclBhdGgpXSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBpdC5wYXJlbnREYXRhXSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksIGl0LnBhcmVudERhdGFQcm9wZXJ0eV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YV0sXG4gICAgXTtcbiAgICBpZiAoaXQub3B0cy5keW5hbWljUmVmKVxuICAgICAgICB2YWxDeHQucHVzaChbbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCBuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnNdKTtcbiAgICBjb25zdCBhcmdzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhQW5kU2NoZW1hfSwgJHtnZW4ub2JqZWN0KC4uLnZhbEN4dCl9YDtcbiAgICByZXR1cm4gY29udGV4dCAhPT0gY29kZWdlbl8xLm5pbCA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30uY2FsbCgke2NvbnRleHR9LCAke2FyZ3N9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Z1bmN9KCR7YXJnc30pYDtcbn1cbmV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGNhbGxWYWxpZGF0ZUNvZGU7XG5jb25zdCBuZXdSZWdFeHAgPSAoMCwgY29kZWdlbl8xLl8pIGBuZXcgUmVnRXhwYDtcbmZ1bmN0aW9uIHVzZVBhdHRlcm4oeyBnZW4sIGl0OiB7IG9wdHMgfSB9LCBwYXR0ZXJuKSB7XG4gICAgY29uc3QgdSA9IG9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICBjb25zdCB7IHJlZ0V4cCB9ID0gb3B0cy5jb2RlO1xuICAgIGNvbnN0IHJ4ID0gcmVnRXhwKHBhdHRlcm4sIHUpO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICBrZXk6IHJ4LnRvU3RyaW5nKCksXG4gICAgICAgIHJlZjogcngsXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cmVnRXhwLmNvZGUgPT09IFwibmV3IFJlZ0V4cFwiID8gbmV3UmVnRXhwIDogKDAsIHV0aWxfMi51c2VGdW5jKShnZW4sIHJlZ0V4cCl9KCR7cGF0dGVybn0sICR7dX0pYCxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlUGF0dGVybiA9IHVzZVBhdHRlcm47XG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5hc3NpZ24odmFsaWRBcnIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiB2YWxpZEFycjtcbiAgICB9XG4gICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgcmV0dXJuIHZhbGlkO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMobm90VmFsaWQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCBub3RWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBcnJheSA9IHZhbGlkYXRlQXJyYXk7XG5mdW5jdGlvbiB2YWxpZGF0ZVVuaW9uKGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBhbHdheXNWYWxpZCA9IHNjaGVtYS5zb21lKChzY2gpID0+ICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKTtcbiAgICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICBnZW4uYmxvY2soKCkgPT4gc2NoZW1hLmZvckVhY2goKF9zY2gsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZH0gfHwgJHtzY2hWYWxpZH1gKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCBzY2hWYWxpZCk7XG4gICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXMvSXRlbXNgIG5vdCBzdXBwb3J0ZWQgKG9wdHMudW5ldmFsdWF0ZWQgIT09IHRydWUpXG4gICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIGFuZCBpdGVtcyB3ZXJlIGV2YWx1YXRlZCAoaXQucHJvcHMgPT09IHRydWUgJiYgaXQuaXRlbXMgPT09IHRydWUpXG4gICAgICAgIGlmICghbWVyZ2VkKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCkpO1xuICAgIH0pKTtcbiAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IHZhbGlkYXRlVW5pb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IGV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gZXhwb3J0cy5mdW5jS2V5d29yZENvZGUgPSBleHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vLi4vdm9jYWJ1bGFyaWVzL2NvZGVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5mdW5jdGlvbiBtYWNyb0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IG1hY3JvU2NoZW1hID0gZGVmLm1hY3JvLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KTtcbiAgICBjb25zdCBzY2hlbWFSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgbWFjcm9TY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSlcbiAgICAgICAgaXQuc2VsZi52YWxpZGF0ZVNjaGVtYShtYWNyb1NjaGVtYSwgdHJ1ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICBzY2hlbWE6IG1hY3JvU2NoZW1hLFxuICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hlbWFSZWYsXG4gICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgfSwgdmFsaWQpO1xuICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gbWFjcm9LZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrQXN5bmNLZXl3b3JkKGl0LCBkZWYpO1xuICAgIGNvbnN0IHZhbGlkYXRlID0gISRkYXRhICYmIGRlZi5jb21waWxlID8gZGVmLmNvbXBpbGUuY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpIDogZGVmLnZhbGlkYXRlO1xuICAgIGNvbnN0IHZhbGlkYXRlUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHZhbGlkYXRlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVLZXl3b3JkKTtcbiAgICBjeHQub2soKF9hID0gZGVmLnZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWxpZCk7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkKCkge1xuICAgICAgICBpZiAoZGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFzc2lnblZhbGlkKCk7XG4gICAgICAgICAgICBpZiAoZGVmLm1vZGlmeWluZylcbiAgICAgICAgICAgICAgICBtb2RpZnlEYXRhKGN4dCk7XG4gICAgICAgICAgICByZXBvcnRFcnJzKCgpID0+IGN4dC5lcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZGVmLmFzeW5jID8gdmFsaWRhdGVBc3luYygpIDogdmFsaWRhdGVTeW5jKCk7XG4gICAgICAgICAgICBpZiAoZGVmLm1vZGlmeWluZylcbiAgICAgICAgICAgICAgICBtb2RpZnlEYXRhKGN4dCk7XG4gICAgICAgICAgICByZXBvcnRFcnJzKCgpID0+IGFkZEVycnMoY3h0LCBydWxlRXJycykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZ2VuLmxldChcInJ1bGVFcnJzXCIsIG51bGwpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IGFzc2lnblZhbGlkKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0IGApLCAoZSkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvcn1gLCAoKSA9PiBnZW4uYXNzaWduKHJ1bGVFcnJzLCAoMCwgY29kZWdlbl8xLl8pIGAke2V9LmVycm9yc2ApLCAoKSA9PiBnZW4udGhyb3coZSkpKTtcbiAgICAgICAgcmV0dXJuIHJ1bGVFcnJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlRXJycyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVSZWZ9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWRhdGVFcnJzLCBudWxsKTtcbiAgICAgICAgYXNzaWduVmFsaWQoY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdCA9IGRlZi5hc3luYyA/ICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0IGAgOiBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGNvbnN0IHBhc3NDeHQgPSBpdC5vcHRzLnBhc3NDb250ZXh0ID8gbmFtZXNfMS5kZWZhdWx0LnRoaXMgOiBuYW1lc18xLmRlZmF1bHQuc2VsZjtcbiAgICAgICAgY29uc3QgcGFzc1NjaGVtYSA9ICEoKFwiY29tcGlsZVwiIGluIGRlZiAmJiAhJGRhdGEpIHx8IGRlZi5zY2hlbWEgPT09IGZhbHNlKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtfYXdhaXR9JHsoMCwgY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUpKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsIGRlZi5tb2RpZnlpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBvcnRFcnJzKGVycm9ycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoKF9hID0gZGVmLnZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWxpZCksIGVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5mdW5jS2V5d29yZENvZGUgPSBmdW5jS2V5d29yZENvZGU7XG5mdW5jdGlvbiBtb2RpZnlEYXRhKGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihpdC5wYXJlbnREYXRhLCAoKSA9PiBnZW4uYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQucGFyZW50RGF0YX1bJHtpdC5wYXJlbnREYXRhUHJvcGVydHl9XWApKTtcbn1cbmZ1bmN0aW9uIGFkZEVycnMoY3h0LCBlcnJzKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2VycnN9KWAsICgpID0+IHtcbiAgICAgICAgZ2VuXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKVxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgKTtcbiAgICAgICAgKDAsIGVycm9yc18xLmV4dGVuZEVycm9ycykoY3h0KTtcbiAgICB9LCAoKSA9PiBjeHQuZXJyb3IoKSk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jS2V5d29yZCh7IHNjaGVtYUVudiB9LCBkZWYpIHtcbiAgICBpZiAoZGVmLmFzeW5jICYmICFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYCk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwia2V5d29yZFwiLCB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIiA/IHsgcmVmOiByZXN1bHQgfSA6IHsgcmVmOiByZXN1bHQsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShyZXN1bHQpIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRTY2hlbWFUeXBlKHNjaGVtYSwgc2NoZW1hVHlwZSwgYWxsb3dVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIC8vIFRPRE8gYWRkIHRlc3RzXG4gICAgcmV0dXJuICghc2NoZW1hVHlwZS5sZW5ndGggfHxcbiAgICAgICAgc2NoZW1hVHlwZS5zb21lKChzdCkgPT4gc3QgPT09IFwiYXJyYXlcIlxuICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgIDogc3QgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICA/IHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PSBzdCB8fCAoYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHNjaGVtYSA9PSBcInVuZGVmaW5lZFwiKSkpO1xufVxuZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSB2YWxpZFNjaGVtYVR5cGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmRVc2FnZSh7IHNjaGVtYSwgb3B0cywgc2VsZiwgZXJyU2NoZW1hUGF0aCB9LCBkZWYsIGtleXdvcmQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWYua2V5d29yZCkgPyAhZGVmLmtleXdvcmQuaW5jbHVkZXMoa2V5d29yZCkgOiBkZWYua2V5d29yZCAhPT0ga2V5d29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlcHMgPSBkZWYuZGVwZW5kZW5jaWVzO1xuICAgIGlmIChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMuc29tZSgoa3dkKSA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga3dkKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJlbnQgc2NoZW1hIG11c3QgaGF2ZSBkZXBlbmRlbmNpZXMgb2YgJHtrZXl3b3JkfTogJHtkZXBzLmpvaW4oXCIsXCIpfWApO1xuICAgIH1cbiAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZGVmLnZhbGlkYXRlU2NoZW1hKHNjaGVtYVtrZXl3b3JkXSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIHZhbHVlIGlzIGludmFsaWQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cIjogYCArXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnNUZXh0KGRlZi52YWxpZGF0ZVNjaGVtYS5lcnJvcnMpO1xuICAgICAgICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSB2YWxpZGF0ZUtleXdvcmRVc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXdvcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHBvcnRzLmdldFN1YnNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBnZXRTdWJzY2hlbWEoaXQsIHsga2V5d29yZCwgc2NoZW1hUHJvcCwgc2NoZW1hLCBzY2hlbWFQYXRoLCBlcnJTY2hlbWFQYXRoLCB0b3BTY2hlbWFSZWYgfSkge1xuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwia2V5d29yZFwiIGFuZCBcInNjaGVtYVwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6ICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuc2NoZW1hUGF0aH0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGtleXdvcmQpfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7KDAsIHV0aWxfMS5lc2NhcGVGcmFnbWVudCkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgXCJrZXl3b3JkXCIgb3IgXCJzY2hlbWFcIiBtdXN0IGJlIHBhc3NlZCcpO1xufVxuZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSBnZXRTdWJzY2hlbWE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgaXQsIHsgZGF0YVByb3AsIGRhdGFQcm9wVHlwZTogZHBUeXBlLCBkYXRhLCBkYXRhVHlwZXMsIHByb3BlcnR5TmFtZSB9KSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImRhdGFcIiBhbmQgXCJkYXRhUHJvcFwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGdlbiB9ID0gaXQ7XG4gICAgaWYgKGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0LmRhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShkYXRhUHJvcCl9YCwgdHJ1ZSk7XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBzdWJzY2hlbWEuZXJyb3JQYXRoID0gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShkYXRhUHJvcCwgZHBUeXBlLCBvcHRzLmpzUHJvcGVydHlTeW50YXgpfWA7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHkgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFQcm9wfWA7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhUGF0aEFyciA9IFsuLi5kYXRhUGF0aEFyciwgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eV07XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSk7IC8vIHJlcGxhY2VhYmxlIGlmIHVzZWQgb25jZT9cbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIFRPRE8gc29tZXRoaW5nIGlzIHBvc3NpYmx5IHdyb25nIGhlcmUgd2l0aCBub3QgY2hhbmdpbmcgcGFyZW50RGF0YVByb3BlcnR5IGFuZCBub3QgYXBwZW5kaW5nIGRhdGFQYXRoQXJyXG4gICAgfVxuICAgIGlmIChkYXRhVHlwZXMpXG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXM7XG4gICAgZnVuY3Rpb24gZGF0YUNvbnRleHRQcm9wcyhfbmV4dERhdGEpIHtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW107XG4gICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTmFtZXMgPSBbLi4uaXQuZGF0YU5hbWVzLCBfbmV4dERhdGFdO1xuICAgIH1cbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4dGVuZFN1YnNjaGVtYURhdGE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgeyBqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnMgfSkge1xuICAgIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZTtcbiAgICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnM7XG4gICAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzO1xuICAgIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvcjsgLy8gbm90IGluaGVyaXRlZFxuICAgIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhOyAvLyBub3QgaW5oZXJpdGVkXG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHRlbmRTdWJzY2hlbWFNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NoZW1hLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdHMsIGNiKSB7XG4gIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2MC4zLjEgYW5kIGVhcmxpZXIuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNiID0gb3B0cy5jYiB8fCBjYjtcbiAgdmFyIHByZSA9ICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgPyBjYiA6IGNiLnByZSB8fCBmdW5jdGlvbigpIHt9O1xuICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcblxuICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsICcnLCBzY2hlbWEpO1xufTtcblxuXG50cmF2ZXJzZS5rZXl3b3JkcyA9IHtcbiAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICBpdGVtczogdHJ1ZSxcbiAgY29udGFpbnM6IHRydWUsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICBub3Q6IHRydWUsXG4gIGlmOiB0cnVlLFxuICB0aGVuOiB0cnVlLFxuICBlbHNlOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICBpdGVtczogdHJ1ZSxcbiAgYWxsT2Y6IHRydWUsXG4gIGFueU9mOiB0cnVlLFxuICBvbmVPZjogdHJ1ZVxufTtcblxudHJhdmVyc2UucHJvcHNLZXl3b3JkcyA9IHtcbiAgJGRlZnM6IHRydWUsXG4gIGRlZmluaXRpb25zOiB0cnVlLFxuICBwcm9wZXJ0aWVzOiB0cnVlLFxuICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgZGVwZW5kZW5jaWVzOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5za2lwS2V5d29yZHMgPSB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIGVudW06IHRydWUsXG4gIGNvbnN0OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgbWF4aW11bTogdHJ1ZSxcbiAgbWluaW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWluaW11bTogdHJ1ZSxcbiAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgbWF4TGVuZ3RoOiB0cnVlLFxuICBtaW5MZW5ndGg6IHRydWUsXG4gIHBhdHRlcm46IHRydWUsXG4gIGZvcm1hdDogdHJ1ZSxcbiAgbWF4SXRlbXM6IHRydWUsXG4gIG1pbkl0ZW1zOiB0cnVlLFxuICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgbWF4UHJvcGVydGllczogdHJ1ZSxcbiAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcblxuXG5mdW5jdGlvbiBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBwcmUoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICB2YXIgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2gubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbaV0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBpLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHNjaCAmJiB0eXBlb2Ygc2NoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbcHJvcF0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLmtleXdvcmRzIHx8IChvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkpIHtcbiAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoLCBqc29uUHRyICsgJy8nICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25QdHIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGV4cG9ydHMucmVzb2x2ZVVybCA9IGV4cG9ydHMubm9ybWFsaXplSWQgPSBleHBvcnRzLl9nZXRGdWxsUGF0aCA9IGV4cG9ydHMuZ2V0RnVsbFBhdGggPSBleHBvcnRzLmlubGluZVJlZiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5jb25zdCB0cmF2ZXJzZSA9IHJlcXVpcmUoXCJqc29uLXNjaGVtYS10cmF2ZXJzZVwiKTtcbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIGtleXdvcmQgZGVmaW5pdGlvbnNcbmNvbnN0IFNJTVBMRV9JTkxJTkVEID0gbmV3IFNldChbXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJmb3JtYXRcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcIm1heExlbmd0aFwiLFxuICAgIFwibWluTGVuZ3RoXCIsXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJtYXhJdGVtc1wiLFxuICAgIFwibWluSXRlbXNcIixcbiAgICBcIm1heGltdW1cIixcbiAgICBcIm1pbmltdW1cIixcbiAgICBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgXCJtdWx0aXBsZU9mXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiY29uc3RcIixcbl0pO1xuZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYSwgbGltaXQgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChsaW1pdCA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuICFoYXNSZWYoc2NoZW1hKTtcbiAgICBpZiAoIWxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0O1xufVxuZXhwb3J0cy5pbmxpbmVSZWYgPSBpbmxpbmVSZWY7XG5jb25zdCBSRUZfS0VZV09SRFMgPSBuZXcgU2V0KFtcbiAgICBcIiRyZWZcIixcbiAgICBcIiRyZWN1cnNpdmVSZWZcIixcbiAgICBcIiRyZWN1cnNpdmVBbmNob3JcIixcbiAgICBcIiRkeW5hbWljUmVmXCIsXG4gICAgXCIkZHluYW1pY0FuY2hvclwiLFxuXSk7XG5mdW5jdGlvbiBoYXNSZWYoc2NoZW1hKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChSRUZfS0VZV09SRFMuaGFzKGtleSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkgJiYgc2NoLnNvbWUoaGFzUmVmKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiICYmIGhhc1JlZihzY2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWEpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIiRyZWZcIilcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgaWYgKFNJTVBMRV9JTkxJTkVELmhhcyhrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoc2NoZW1hW2tleV0sIChzY2gpID0+IChjb3VudCArPSBjb3VudEtleXMoc2NoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKHJlc29sdmVyLCBpZCA9IFwiXCIsIG5vcm1hbGl6ZSkge1xuICAgIGlmIChub3JtYWxpemUgIT09IGZhbHNlKVxuICAgICAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgICBjb25zdCBwID0gcmVzb2x2ZXIucGFyc2UoaWQpO1xuICAgIHJldHVybiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApO1xufVxuZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGdldEZ1bGxQYXRoO1xuZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHJlc29sdmVyLCBwKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHJlc29sdmVyLnNlcmlhbGl6ZShwKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZC5zcGxpdChcIiNcIilbMF0gKyBcIiNcIjtcbn1cbmV4cG9ydHMuX2dldEZ1bGxQYXRoID0gX2dldEZ1bGxQYXRoO1xuY29uc3QgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvO1xuZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgICByZXR1cm4gaWQgPyBpZC5yZXBsYWNlKFRSQUlMSU5HX1NMQVNIX0hBU0gsIFwiXCIpIDogXCJcIjtcbn1cbmV4cG9ydHMubm9ybWFsaXplSWQgPSBub3JtYWxpemVJZDtcbmZ1bmN0aW9uIHJlc29sdmVVcmwocmVzb2x2ZXIsIGJhc2VJZCwgaWQpIHtcbiAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKTtcbiAgICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZShiYXNlSWQsIGlkKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVVybCA9IHJlc29sdmVVcmw7XG5jb25zdCBBTkNIT1IgPSAvXlthLXpfXVstYS16MC05Ll9dKiQvaTtcbmZ1bmN0aW9uIGdldFNjaGVtYVJlZnMoc2NoZW1hLCBiYXNlSWQpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgc2NoZW1hSWQsIHVyaVJlc29sdmVyIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3Qgc2NoSWQgPSBub3JtYWxpemVJZChzY2hlbWFbc2NoZW1hSWRdIHx8IGJhc2VJZCk7XG4gICAgY29uc3QgYmFzZUlkcyA9IHsgXCJcIjogc2NoSWQgfTtcbiAgICBjb25zdCBwYXRoUHJlZml4ID0gZ2V0RnVsbFBhdGgodXJpUmVzb2x2ZXIsIHNjaElkLCBmYWxzZSk7XG4gICAgY29uc3QgbG9jYWxSZWZzID0ge307XG4gICAgY29uc3Qgc2NoZW1hUmVmcyA9IG5ldyBTZXQoKTtcbiAgICB0cmF2ZXJzZShzY2hlbWEsIHsgYWxsS2V5czogdHJ1ZSB9LCAoc2NoLCBqc29uUHRyLCBfLCBwYXJlbnRKc29uUHRyKSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnRKc29uUHRyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aFByZWZpeCArIGpzb25QdHI7XG4gICAgICAgIGxldCBpbm5lckJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoW3NjaGVtYUlkXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5uZXJCYXNlSWQgPSBhZGRSZWYuY2FsbCh0aGlzLCBzY2hbc2NoZW1hSWRdKTtcbiAgICAgICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRhbmNob3IpO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGR5bmFtaWNBbmNob3IpO1xuICAgICAgICBiYXNlSWRzW2pzb25QdHJdID0gaW5uZXJCYXNlSWQ7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJlZihyZWYpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIGNvbnN0IF9yZXNvbHZlID0gdGhpcy5vcHRzLnVyaVJlc29sdmVyLnJlc29sdmU7XG4gICAgICAgICAgICByZWYgPSBub3JtYWxpemVJZChpbm5lckJhc2VJZCA/IF9yZXNvbHZlKGlubmVyQmFzZUlkLCByZWYpIDogcmVmKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFSZWZzLmhhcyhyZWYpKVxuICAgICAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgICAgICAgICBzY2hlbWFSZWZzLmFkZChyZWYpO1xuICAgICAgICAgICAgbGV0IHNjaE9yUmVmID0gdGhpcy5yZWZzW3JlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgc2NoT3JSZWYgPSB0aGlzLnJlZnNbc2NoT3JSZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIHNjaE9yUmVmLnNjaGVtYSwgcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIGxvY2FsUmVmc1tyZWZdLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRBbmNob3IoYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBTkNIT1IudGVzdChhbmNob3IpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYW5jaG9yIFwiJHthbmNob3J9XCJgKTtcbiAgICAgICAgICAgICAgICBhZGRSZWYuY2FsbCh0aGlzLCBgIyR7YW5jaG9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvY2FsUmVmcztcbiAgICBmdW5jdGlvbiBjaGVja0FtYmlndW9zUmVmKHNjaDEsIHNjaDIsIHJlZikge1xuICAgICAgICBpZiAoc2NoMiAhPT0gdW5kZWZpbmVkICYmICFlcXVhbChzY2gxLCBzY2gyKSlcbiAgICAgICAgICAgIHRocm93IGFtYmlndW9zKHJlZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtYmlndW9zKHJlZikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGByZWZlcmVuY2UgXCIke3JlZn1cIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYWApO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U2NoZW1hUmVmcyA9IGdldFNjaGVtYVJlZnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREYXRhID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGJvb2xTY2hlbWFfMSA9IHJlcXVpcmUoXCIuL2Jvb2xTY2hlbWFcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZGF0YVR5cGVfMiA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgZGVmYXVsdHNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuY29uc3Qga2V5d29yZF8xID0gcmVxdWlyZShcIi4va2V5d29yZFwiKTtcbmNvbnN0IHN1YnNjaGVtYV8xID0gcmVxdWlyZShcIi4vc3Vic2NoZW1hXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIGdlbmVyYXRlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBzdWJzY2hlbWFDb2RlIChiZWxvdykgaXMgdXNlZCBmb3Igc3Vic2NoZW1hc1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiAoMCwgYm9vbFNjaGVtYV8xLnRvcEJvb2xPckVtcHR5U2NoZW1hKShpdCkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZhbGlkYXRlRnVuY3Rpb25Db2RlO1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbih7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0cyB9LCBib2R5KSB7XG4gICAgaWYgKG9wdHMuY29kZS5lczUpIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKTtcbiAgICAgICAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cyk7XG4gICAgICAgICAgICBnZW4uY29kZShib2R5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IGdlbi5jb2RlKGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSkuY29kZShib2R5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cykge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB7JHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofT1cIlwiLCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fSwgJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9PSR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9JHtvcHRzLmR5bmFtaWNSZWYgPyAoMCwgY29kZWdlbl8xLl8pIGAsICR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfT17fWAgOiBjb2RlZ2VuXzEubmlsfX09e31gO1xufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKSB7XG4gICAgZ2VuLmlmKG5hbWVzXzEuZGVmYXVsdC52YWxDeHQsICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aH1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX1gKTtcbiAgICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfWApO1xuICAgIH0sICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMsIGdlbiB9ID0gaXQ7XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4ge1xuICAgICAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgICAgIGNoZWNrTm9EZWZhdWx0KGl0KTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LmVycm9ycywgMCk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmVzZXRFdmFsdWF0ZWQoaXQpO1xuICAgICAgICB0eXBlQW5kS2V5d29yZHMoaXQpO1xuICAgICAgICByZXR1cm5SZXN1bHRzKGl0KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiByZXNldEV2YWx1YXRlZChpdCkge1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBob29rIHRvIGV4ZWN1dGUgaXQgaW4gdGhlIGVuZCB0byBjaGVjayB3aGV0aGVyIHByb3BzL2l0ZW1zIGFyZSBOYW1lLCBhcyBpbiBhc3NpZ25FdmFsdWF0ZWRcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0ucHJvcHNgLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKSk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbn1cbmZ1bmN0aW9uIGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSB7XG4gICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdO1xuICAgIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyAoMCwgY29kZWdlbl8xLl8pIGAvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IGNvZGVnZW5fMS5uaWw7XG59XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQsIHZhbGlkKSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBib29sU2NoZW1hXzEuYm9vbE9yRW1wdHlTY2hlbWEpKGl0LCB2YWxpZCk7XG59XG5mdW5jdGlvbiBzY2hlbWFDeHRIYXNSdWxlcyh7IHNjaGVtYSwgc2VsZiB9KSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQuc2NoZW1hICE9IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZ2VuLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICB1cGRhdGVDb250ZXh0KGl0KTtcbiAgICBjaGVja0FzeW5jU2NoZW1hKGl0KTtcbiAgICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCk7XG4gICAgLy8gVE9ETyB2YXJcbiAgICBnZW4udmFyKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZHMoaXQpIHtcbiAgICAoMCwgdXRpbF8xLmNoZWNrVW5rbm93blJ1bGVzKShpdCk7XG4gICAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpO1xufVxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpIHtcbiAgICBpZiAoaXQub3B0cy5qdGQpXG4gICAgICAgIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpO1xuICAgIGNvbnN0IHR5cGVzID0gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKGl0LnNjaGVtYSk7XG4gICAgY29uc3QgY2hlY2tlZFR5cGVzID0gKDAsIGRhdGFUeXBlXzEuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSkoaXQsIHR5cGVzKTtcbiAgICBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsICFjaGVja2VkVHlwZXMsIGVycnNDb3VudCk7XG59XG5mdW5jdGlvbiBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0KSB7XG4gICAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF07XG4gICAgaWYgKHNjaElkKVxuICAgICAgICBpdC5iYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgc2NoSWQpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY1NjaGVtYShpdCkge1xuICAgIGlmIChpdC5zY2hlbWEuJGFzeW5jICYmICFpdC5zY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiBjb21tZW50S2V5d29yZCh7IGdlbiwgc2NoZW1hRW52LCBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMgfSkge1xuICAgIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudDtcbiAgICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgO1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogc2NoZW1hRW52LnJvb3QgfSk7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9Lm9wdHMuJGNvbW1lbnQoJHttc2d9LCAke3NjaGVtYVBhdGh9LCAke3Jvb3ROYW1lfS5zY2hlbWEpYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFFbnYsIHZhbGlkYXRlTmFtZSwgVmFsaWRhdGlvbkVycm9yLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGAsICgpID0+IGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpLCAoKSA9PiBnZW4udGhyb3coKDAsIGNvZGVnZW5fMS5fKSBgbmV3ICR7VmFsaWRhdGlvbkVycm9yfSgke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSlgKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgYXNzaWduRXZhbHVhdGVkKGl0KTtcbiAgICAgICAgZ2VuLnJldHVybigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHsgZ2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtcyB9KSB7XG4gICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9LnByb3BzYCwgcHJvcHMpO1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgdHlwZUVycm9ycywgZXJyc0NvdW50KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgYWxsRXJyb3JzLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSBzZWxmO1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiAob3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgfHwgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgICAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCBSVUxFUy5hbGwuJHJlZi5kZWZpbml0aW9uKSk7IC8vIFRPRE8gdHlwZWNhc3RcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuanRkKVxuICAgICAgICBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcylcbiAgICAgICAgICAgIGdyb3VwS2V5d29yZHMoZ3JvdXApO1xuICAgICAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXApIHtcbiAgICAgICAgaWYgKCEoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZUdyb3VwKShzY2hlbWEsIGdyb3VwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlKShncm91cC50eXBlLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpKTtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gZ3JvdXAudHlwZSAmJiB0eXBlRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgICAgICAoMCwgZGF0YVR5cGVfMi5yZXBvcnRUeXBlRXJyb3IpKGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBvcHRzOiB7IHVzZURlZmF1bHRzIH0sIH0gPSBpdDtcbiAgICBpZiAodXNlRGVmYXVsdHMpXG4gICAgICAgICgwLCBkZWZhdWx0c18xLmFzc2lnbkRlZmF1bHRzKShpdCwgZ3JvdXAudHlwZSk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpXG4gICAgICAgIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgaXQuZGF0YVR5cGVzID0gdHlwZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG5hcnJvd1NjaGVtYVR5cGVzKGl0LCB0eXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja011bHRpcGxlVHlwZXMoaXQsIHRzKSB7XG4gICAgaWYgKHRzLmxlbmd0aCA+IDEgJiYgISh0cy5sZW5ndGggPT09IDIgJiYgdHMuaW5jbHVkZXMoXCJudWxsXCIpKSkge1xuICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0LCB0cykge1xuICAgIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGw7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYG1pc3NpbmcgdHlwZSBcIiR7dHlwZS5qb2luKFwiLFwiKX1cIiBmb3Iga2V5d29yZCBcIiR7a2V5d29yZH1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQXBwbGljYWJsZVR5cGUoc2NoVHMsIGt3ZFQpIHtcbiAgICByZXR1cm4gc2NoVHMuaW5jbHVkZXMoa3dkVCkgfHwgKGt3ZFQgPT09IFwibnVtYmVyXCIgJiYgc2NoVHMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzVHlwZSh0cywgdCkge1xuICAgIHJldHVybiB0cy5pbmNsdWRlcyh0KSB8fCAodCA9PT0gXCJpbnRlZ2VyXCIgJiYgdHMuaW5jbHVkZXMoXCJudW1iZXJcIikpO1xufVxuZnVuY3Rpb24gbmFycm93U2NoZW1hVHlwZXMoaXQsIHdpdGhUeXBlcykge1xuICAgIGNvbnN0IHRzID0gW107XG4gICAgZm9yIChjb25zdCB0IG9mIGl0LmRhdGFUeXBlcykge1xuICAgICAgICBpZiAoaW5jbHVkZXNUeXBlKHdpdGhUeXBlcywgdCkpXG4gICAgICAgICAgICB0cy5wdXNoKHQpO1xuICAgICAgICBlbHNlIGlmICh3aXRoVHlwZXMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpICYmIHQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0cy5wdXNoKFwiaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaXQuZGF0YVR5cGVzID0gdHM7XG59XG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0LCBtc2cpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWA7XG4gICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpO1xufVxuY2xhc3MgS2V5d29yZEN4dCB7XG4gICAgY29uc3RydWN0b3IoaXQsIGRlZiwga2V5d29yZCkge1xuICAgICAgICAoMCwga2V5d29yZF8xLnZhbGlkYXRlS2V5d29yZFVzYWdlKShpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICAgICAgdGhpcy5nZW4gPSBpdC5nZW47XG4gICAgICAgIHRoaXMuYWxsRXJyb3JzID0gaXQuYWxsRXJyb3JzO1xuICAgICAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmRhdGEgPSBpdC5kYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYVZhbHVlID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGU7XG4gICAgICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLml0ID0gaXQ7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgaWYgKCEoMCwga2V5d29yZF8xLnZhbGlkU2NoZW1hVHlwZSkodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbFJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKGZhaWxBY3Rpb24pXG4gICAgICAgICAgICBmYWlsQWN0aW9uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NBY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhc3MoY29uZGl0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdCgoMCwgY29kZWdlbl8xLm5vdCkoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGZhbHNlKTsgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgIH1cbiAgICBmYWlsJGRhdGEoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFDb2RlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZhaWwoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgkeygwLCBjb2RlZ2VuXzEub3IpKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApO1xuICAgIH1cbiAgICBlcnJvcihhcHBlbmQsIGVycm9yUGFyYW1zLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIGlmIChlcnJvclBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoZXJyb3JQYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICBfZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIDtcbiAgICAgICAgKGFwcGVuZCA/IGVycm9yc18xLnJlcG9ydEV4dHJhRXJyb3IgOiBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICAkZGF0YUVycm9yKCkge1xuICAgICAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwgZXJyb3JzXzEua2V5d29yZCREYXRhRXJyb3IpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJyk7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXNldEVycm9yc0NvdW50KSh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpO1xuICAgIH1cbiAgICBvayhjb25kKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5pZihjb25kKTtcbiAgICB9XG4gICAgc2V0UGFyYW1zKG9iaiwgYXNzaWduKSB7XG4gICAgICAgIGlmIChhc3NpZ24pXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucGFyYW1zLCBvYmopO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9iajtcbiAgICB9XG4gICAgYmxvY2skZGF0YSh2YWxpZCwgY29kZUJsb2NrLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpO1xuICAgICAgICAgICAgY29kZUJsb2NrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVjayRkYXRhKHZhbGlkID0gY29kZWdlbl8xLm5pbCwgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmIH0gPSB0aGlzO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5vcikoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpO1xuICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMuJGRhdGFFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW4uZWxzZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkJGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpO1xuICAgICAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghKHNjaGVtYUNvZGUgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGVzKShzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8yLkRhdGFUeXBlLldyb25nKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHsgcmVmOiBkZWYudmFsaWRhdGVTY2hlbWEgfSk7IC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NoZW1hKGFwcGwsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9ICgwLCBzdWJzY2hlbWFfMS5nZXRTdWJzY2hlbWEpKHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hRGF0YSkoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgKDAsIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYU1vZGUpKHN1YnNjaGVtYSwgYXBwbCk7XG4gICAgICAgIGNvbnN0IG5leHRDb250ZXh0ID0geyAuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpO1xuICAgICAgICByZXR1cm4gbmV4dENvbnRleHQ7XG4gICAgfVxuICAgIG1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgdG9OYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoZW1hQ3h0Lml0ZW1zLCBpdC5pdGVtcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiAoaXQucHJvcHMgIT09IHRydWUgfHwgaXQuaXRlbXMgIT09IHRydWUpKSB7XG4gICAgICAgICAgICBnZW4uaWYodmFsaWQsICgpID0+IHRoaXMubWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCBjb2RlZ2VuXzEuTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLktleXdvcmRDeHQgPSBLZXl3b3JkQ3h0O1xuZnVuY3Rpb24ga2V5d29yZENvZGUoaXQsIGtleXdvcmQsIGRlZiwgcnVsZVR5cGUpIHtcbiAgICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwibWFjcm9cIiBpbiBkZWYpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5tYWNyb0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgICAgICAoMCwga2V5d29yZF8xLmZ1bmNLZXl3b3JkQ29kZSkoY3h0LCBkZWYpO1xuICAgIH1cbn1cbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC87XG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kLztcbmZ1bmN0aW9uIGdldERhdGEoJGRhdGEsIHsgZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyIH0pIHtcbiAgICBsZXQganNvblBvaW50ZXI7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKCRkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIGlmICgkZGF0YVswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBqc29uUG9pbnRlciA9ICRkYXRhO1xuICAgICAgICBkYXRhID0gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAgY29uc3QgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgICAgICBpZiAoanNvblBvaW50ZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAodXAgPj0gZGF0YUxldmVsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVBhdGhBcnJbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cCA+IGRhdGFMZXZlbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKTtcbiAgICAgICAgZGF0YSA9IGRhdGFOYW1lc1tkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIGlmICghanNvblBvaW50ZXIpXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgbGV0IGV4cHIgPSBkYXRhO1xuICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgZGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKCgwLCB1dGlsXzEudW5lc2NhcGVKc29uUG9pbnRlcikoc2VnbWVudCkpfWA7XG4gICAgICAgICAgICBleHByID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtleHByfSAmJiAke2RhdGF9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZSwgdXApIHtcbiAgICAgICAgcmV0dXJuIGBDYW5ub3QgYWNjZXNzICR7cG9pbnRlclR5cGV9ICR7dXB9IGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAke2RhdGFMZXZlbH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RGF0YSA9IGdldERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoXCJ2YWxpZGF0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBWYWxpZGF0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uX2Vycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNsYXNzIE1pc3NpbmdSZWZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvbHZlciwgYmFzZUlkLCByZWYsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgYGNhbid0IHJlc29sdmUgcmVmZXJlbmNlICR7cmVmfSBmcm9tIGlkICR7YmFzZUlkfWApO1xuICAgICAgICB0aGlzLm1pc3NpbmdSZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHJlc29sdmVyLCBiYXNlSWQsIHJlZik7XG4gICAgICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKCgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHJlc29sdmVyLCB0aGlzLm1pc3NpbmdSZWYpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNaXNzaW5nUmVmRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZfZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSBleHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGV4cG9ydHMucmVzb2x2ZVJlZiA9IGV4cG9ydHMuY29tcGlsZVNjaGVtYSA9IGV4cG9ydHMuU2NoZW1hRW52ID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0ZVwiKTtcbmNsYXNzIFNjaGVtYUVudiB7XG4gICAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZHluYW1pY0FuY2hvcnMgPSB7fTtcbiAgICAgICAgbGV0IHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBzY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hSWQgPSBlbnYuc2NoZW1hSWQ7XG4gICAgICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuYmFzZUlkID0gKF9hID0gZW52LmJhc2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hW2Vudi5zY2hlbWFJZCB8fCBcIiRpZFwiXSk7XG4gICAgICAgIHRoaXMuc2NoZW1hUGF0aCA9IGVudi5zY2hlbWFQYXRoO1xuICAgICAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnM7XG4gICAgICAgIHRoaXMubWV0YSA9IGVudi5tZXRhO1xuICAgICAgICB0aGlzLiRhc3luYyA9IHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYS4kYXN5bmM7XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2NoZW1hRW52ID0gU2NoZW1hRW52O1xuLy8gbGV0IGNvZGVTaXplID0gMFxuLy8gbGV0IG5vZGVDb3VudCA9IDBcbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEoc2NoKSB7XG4gICAgLy8gVE9ETyByZWZhY3RvciAtIHJlbW92ZSBjb21waWxhdGlvbnNcbiAgICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICBpZiAoX3NjaClcbiAgICAgICAgcmV0dXJuIF9zY2g7XG4gICAgY29uc3Qgcm9vdElkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBzY2gucm9vdC5iYXNlSWQpOyAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgY29uc3QgeyBvd25Qcm9wZXJ0aWVzIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3QgZ2VuID0gbmV3IGNvZGVnZW5fMS5Db2RlR2VuKHRoaXMuc2NvcGUsIHsgZXM1LCBsaW5lcywgb3duUHJvcGVydGllcyB9KTtcbiAgICBsZXQgX1ZhbGlkYXRpb25FcnJvcjtcbiAgICBpZiAoc2NoLiRhc3luYykge1xuICAgICAgICBfVmFsaWRhdGlvbkVycm9yID0gZ2VuLnNjb3BlVmFsdWUoXCJFcnJvclwiLCB7XG4gICAgICAgICAgICByZWY6IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0LFxuICAgICAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgcmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKS5kZWZhdWx0YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKTtcbiAgICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lO1xuICAgIGNvbnN0IHNjaGVtYUN4dCA9IHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBhbGxFcnJvcnM6IHRoaXMub3B0cy5hbGxFcnJvcnMsXG4gICAgICAgIGRhdGE6IG5hbWVzXzEuZGVmYXVsdC5kYXRhLFxuICAgICAgICBwYXJlbnREYXRhOiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSxcbiAgICAgICAgcGFyZW50RGF0YVByb3BlcnR5OiBuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LFxuICAgICAgICBkYXRhTmFtZXM6IFtuYW1lc18xLmRlZmF1bHQuZGF0YV0sXG4gICAgICAgIGRhdGFQYXRoQXJyOiBbY29kZWdlbl8xLm5pbF0sIC8vIFRPRE8gY2FuIGl0cyBsZW5ndGggYmUgdXNlZCBhcyBkYXRhTGV2ZWwgaWYgbmlsIGlzIHJlbW92ZWQ/XG4gICAgICAgIGRhdGFMZXZlbDogMCxcbiAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdG9wU2NoZW1hUmVmOiBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCB0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWVcbiAgICAgICAgICAgID8geyByZWY6IHNjaC5zY2hlbWEsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2guc2NoZW1hKSB9XG4gICAgICAgICAgICA6IHsgcmVmOiBzY2guc2NoZW1hIH0pLFxuICAgICAgICB2YWxpZGF0ZU5hbWUsXG4gICAgICAgIFZhbGlkYXRpb25FcnJvcjogX1ZhbGlkYXRpb25FcnJvcixcbiAgICAgICAgc2NoZW1hOiBzY2guc2NoZW1hLFxuICAgICAgICBzY2hlbWFFbnY6IHNjaCxcbiAgICAgICAgcm9vdElkLFxuICAgICAgICBiYXNlSWQ6IHNjaC5iYXNlSWQgfHwgcm9vdElkLFxuICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICBlcnJTY2hlbWFQYXRoOiBzY2guc2NoZW1hUGF0aCB8fCAodGhpcy5vcHRzLmp0ZCA/IFwiXCIgOiBcIiNcIiksXG4gICAgICAgIGVycm9yUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgXCJcImAsXG4gICAgICAgIG9wdHM6IHRoaXMub3B0cyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICB9O1xuICAgIGxldCBzb3VyY2VDb2RlO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5hZGQoc2NoKTtcbiAgICAgICAgKDAsIHZhbGlkYXRlXzEudmFsaWRhdGVGdW5jdGlvbkNvZGUpKHNjaGVtYUN4dCk7XG4gICAgICAgIGdlbi5vcHRpbWl6ZSh0aGlzLm9wdHMuY29kZS5vcHRpbWl6ZSk7XG4gICAgICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgICAgICBjb25zdCB2YWxpZGF0ZUNvZGUgPSBnZW4udG9TdHJpbmcoKTtcbiAgICAgICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMobmFtZXNfMS5kZWZhdWx0LnNjb3BlKX1yZXR1cm4gJHt2YWxpZGF0ZUNvZGV9YDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coKGNvZGVTaXplICs9IHNvdXJjZUNvZGUubGVuZ3RoKSwgKG5vZGVDb3VudCArPSBnZW4ubm9kZUNvdW50KSlcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnByb2Nlc3MpXG4gICAgICAgICAgICBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUpXG4gICAgICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn1gLCBgJHtuYW1lc18xLmRlZmF1bHQuc2NvcGV9YCwgc291cmNlQ29kZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpO1xuICAgICAgICB0aGlzLnNjb3BlLnZhbHVlKHZhbGlkYXRlTmFtZSwgeyByZWY6IHZhbGlkYXRlIH0pO1xuICAgICAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hO1xuICAgICAgICB2YWxpZGF0ZS5zY2hlbWFFbnYgPSBzY2g7XG4gICAgICAgIGlmIChzY2guJGFzeW5jKVxuICAgICAgICAgICAgdmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlID0geyB2YWxpZGF0ZU5hbWUsIHZhbGlkYXRlQ29kZSwgc2NvcGVWYWx1ZXM6IGdlbi5fdmFsdWVzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgaXRlbXMgfSA9IHNjaGVtYUN4dDtcbiAgICAgICAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgICAgICAgICAgZHluYW1pY1Byb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNJdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsaWRhdGUuc291cmNlKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkodmFsaWRhdGUuZXZhbHVhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzY2gudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZTtcbiAgICAgICAgZGVsZXRlIHNjaC52YWxpZGF0ZU5hbWU7XG4gICAgICAgIGlmIChzb3VyY2VDb2RlKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2NoZW1hLCBmdW5jdGlvbiBjb2RlOlwiLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlLCB0aGlzLm9wdHMpXG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMuZGVsZXRlKHNjaCk7XG4gICAgfVxufVxuZXhwb3J0cy5jb21waWxlU2NoZW1hID0gY29tcGlsZVNjaGVtYTtcbmZ1bmN0aW9uIHJlc29sdmVSZWYocm9vdCwgYmFzZUlkLCByZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICBjb25zdCBzY2hPckZ1bmMgPSByb290LnJlZnNbcmVmXTtcbiAgICBpZiAoc2NoT3JGdW5jKVxuICAgICAgICByZXR1cm4gc2NoT3JGdW5jO1xuICAgIGxldCBfc2NoID0gcmVzb2x2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSAoX2EgPSByb290LmxvY2FsUmVmcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3JlZl07IC8vIFRPRE8gbWF5YmUgbG9jYWxSZWZzIHNob3VsZCBob2xkIFNjaGVtYUVudlxuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBfc2NoID0gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSk7XG59XG5leHBvcnRzLnJlc29sdmVSZWYgPSByZXNvbHZlUmVmO1xuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHNjaCkge1xuICAgIGlmICgoMCwgcmVzb2x2ZV8xLmlubGluZVJlZikoc2NoLnNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpKVxuICAgICAgICByZXR1cm4gc2NoLnNjaGVtYTtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlID8gc2NoIDogY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG59XG4vLyBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG5mdW5jdGlvbiBnZXRDb21waWxpbmdTY2hlbWEoc2NoRW52KSB7XG4gICAgZm9yIChjb25zdCBzY2ggb2YgdGhpcy5fY29tcGlsYXRpb25zKSB7XG4gICAgICAgIGlmIChzYW1lU2NoZW1hRW52KHNjaCwgc2NoRW52KSlcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRDb21waWxpbmdTY2hlbWEgPSBnZXRDb21waWxpbmdTY2hlbWE7XG5mdW5jdGlvbiBzYW1lU2NoZW1hRW52KHMxLCBzMikge1xuICAgIHJldHVybiBzMS5zY2hlbWEgPT09IHMyLnNjaGVtYSAmJiBzMS5yb290ID09PSBzMi5yb290ICYmIHMxLmJhc2VJZCA9PT0gczIuYmFzZUlkO1xufVxuLy8gcmVzb2x2ZSBhbmQgY29tcGlsZSB0aGUgcmVmZXJlbmNlcyAoJHJlZilcbi8vIFRPRE8gcmV0dXJucyBBbnlTY2hlbWFPYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbmZ1bmN0aW9uIHJlc29sdmUocm9vdCwgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGUgY3VycmVudCBzY2hlbWFcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgbGV0IHNjaDtcbiAgICB3aGlsZSAodHlwZW9mIChzY2ggPSB0aGlzLnJlZnNbcmVmXSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVmID0gc2NoO1xuICAgIHJldHVybiBzY2ggfHwgdGhpcy5zY2hlbWFzW3JlZl0gfHwgcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG59XG4vLyBSZXNvbHZlIHNjaGVtYSwgaXRzIHJvb3QgYW5kIGJhc2VJZFxuZnVuY3Rpb24gcmVzb2x2ZVNjaGVtYShyb290LCAvLyByb290IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc2NoZW1hLCByZWZzIFRPRE8gYmVsb3cgU2NoZW1hRW52IGlzIGFzc2lnbmVkIHRvIGl0XG5yZWYgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbikge1xuICAgIGNvbnN0IHAgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucGFyc2UocmVmKTtcbiAgICBjb25zdCByZWZQYXRoID0gKDAsIHJlc29sdmVfMS5fZ2V0RnVsbFBhdGgpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcCk7XG4gICAgbGV0IGJhc2VJZCA9ICgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcm9vdC5iYXNlSWQsIHVuZGVmaW5lZCk7XG4gICAgLy8gVE9ETyBgT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDBgIHNob3VsZCBub3QgYmUgbmVlZGVkIC0gYnV0IHJlbW92aW5nIGJyZWFrcyAyIHRlc3RzXG4gICAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgICAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCByb290KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShyZWZQYXRoKTtcbiAgICBjb25zdCBzY2hPclJlZiA9IHRoaXMucmVmc1tpZF0gfHwgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHNjaE9yUmVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHNjaE9yUmVmID09PSBudWxsIHx8IHNjaE9yUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hPclJlZi5zY2hlbWEpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFzY2hPclJlZi52YWxpZGF0ZSlcbiAgICAgICAgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaE9yUmVmKTtcbiAgICBpZiAoaWQgPT09ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZikpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHNjaE9yUmVmO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgaWYgKHNjaElkKVxuICAgICAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoT3JSZWYpO1xufVxuZXhwb3J0cy5yZXNvbHZlU2NoZW1hID0gcmVzb2x2ZVNjaGVtYTtcbmNvbnN0IFBSRVZFTlRfU0NPUEVfQ0hBTkdFID0gbmV3IFNldChbXG4gICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuXSk7XG5mdW5jdGlvbiBnZXRKc29uUG9pbnRlcihwYXJzZWRSZWYsIHsgYmFzZUlkLCBzY2hlbWEsIHJvb3QgfSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKChfYSA9IHBhcnNlZFJlZi5mcmFnbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAhPT0gXCIvXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFyc2VkUmVmLmZyYWdtZW50LnNsaWNlKDEpLnNwbGl0KFwiL1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhcnRTY2hlbWEgPSBzY2hlbWFbKDAsIHV0aWxfMS51bmVzY2FwZUZyYWdtZW50KShwYXJ0KV07XG4gICAgICAgIGlmIChwYXJ0U2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNjaGVtYSA9IHBhcnRTY2hlbWE7XG4gICAgICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICAgICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiICYmIHNjaGVtYVt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFLmhhcyhwYXJ0KSAmJiBzY2hJZCkge1xuICAgICAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlbnY7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIgJiYgc2NoZW1hLiRyZWYgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgdGhpcy5SVUxFUykpIHtcbiAgICAgICAgY29uc3QgJHJlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgZW52ID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsICRyZWYpO1xuICAgIH1cbiAgICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gICAgLy8gc28gdGhhdCBjb21waWxlQXN5bmMgbG9hZHMgbWlzc2luZyBzY2hlbWEuXG4gICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIGlmIChlbnYuc2NoZW1hICE9PSBlbnYucm9vdC5zY2hlbWEpXG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBIRVggPSB7XG4gIDA6IDAsXG4gIDE6IDEsXG4gIDI6IDIsXG4gIDM6IDMsXG4gIDQ6IDQsXG4gIDU6IDUsXG4gIDY6IDYsXG4gIDc6IDcsXG4gIDg6IDgsXG4gIDk6IDksXG4gIGE6IDEwLFxuICBBOiAxMCxcbiAgYjogMTEsXG4gIEI6IDExLFxuICBjOiAxMixcbiAgQzogMTIsXG4gIGQ6IDEzLFxuICBEOiAxMyxcbiAgZTogMTQsXG4gIEU6IDE0LFxuICBmOiAxNSxcbiAgRjogMTVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhFWFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSEVYIH0gPSByZXF1aXJlKCcuL3Njb3BlZENoYXJzJylcblxuY29uc3QgSVBWNF9SRUcgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkezJ9fFsxLTldXFxkfFxcZCkkL3VcblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NCAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICcuJykgPCAzKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfSB9XG4gIGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKElQVjRfUkVHKSB8fCBbXVxuICBjb25zdCBbYWRkcmVzc10gPSBtYXRjaGVzXG4gIGlmIChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHsgaG9zdDogc3RyaXBMZWFkaW5nWmVyb3MoYWRkcmVzcywgJy4nKSwgaXNJUFY0OiB0cnVlIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBob3N0LCBpc0lQVjQ6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwWmVybz1mYWxzZV1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQgKGlucHV0LCBrZWVwWmVybyA9IGZhbHNlKSB7XG4gIGxldCBhY2MgPSAnJ1xuICBsZXQgc3RyaXAgPSB0cnVlXG4gIGZvciAoY29uc3QgYyBvZiBpbnB1dCkge1xuICAgIGlmIChIRVhbY10gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmIChjICE9PSAnMCcgJiYgc3RyaXAgPT09IHRydWUpIHN0cmlwID0gZmFsc2VcbiAgICBpZiAoIXN0cmlwKSBhY2MgKz0gY1xuICB9XG4gIGlmIChrZWVwWmVybyAmJiBhY2MubGVuZ3RoID09PSAwKSBhY2MgPSAnMCdcbiAgcmV0dXJuIGFjY1xufVxuXG5mdW5jdGlvbiBnZXRJUFY2IChpbnB1dCkge1xuICBsZXQgdG9rZW5Db3VudCA9IDBcbiAgY29uc3Qgb3V0cHV0ID0geyBlcnJvcjogZmFsc2UsIGFkZHJlc3M6ICcnLCB6b25lOiAnJyB9XG4gIGNvbnN0IGFkZHJlc3MgPSBbXVxuICBjb25zdCBidWZmZXIgPSBbXVxuICBsZXQgaXNab25lID0gZmFsc2VcbiAgbGV0IGVuZGlwdjZFbmNvdW50ZXJlZCA9IGZhbHNlXG4gIGxldCBlbmRJcHY2ID0gZmFsc2VcblxuICBmdW5jdGlvbiBjb25zdW1lICgpIHtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGlzWm9uZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcilcbiAgICAgICAgaWYgKGhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkcmVzcy5wdXNoKGhleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3Vyc29yID0gaW5wdXRbaV1cbiAgICBpZiAoY3Vyc29yID09PSAnWycgfHwgY3Vyc29yID09PSAnXScpIHsgY29udGludWUgfVxuICAgIGlmIChjdXJzb3IgPT09ICc6Jykge1xuICAgICAgaWYgKGVuZGlwdjZFbmNvdW50ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlbmRJcHY2ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgdG9rZW5Db3VudCsrXG4gICAgICBhZGRyZXNzLnB1c2goJzonKVxuICAgICAgaWYgKHRva2VuQ291bnQgPiA3KSB7XG4gICAgICAgIC8vIG5vdCB2YWxpZFxuICAgICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaSAtIDEgPj0gMCAmJiBpbnB1dFtpIC0gMV0gPT09ICc6Jykge1xuICAgICAgICBlbmRpcHY2RW5jb3VudGVyZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoY3Vyc29yID09PSAnJScpIHtcbiAgICAgIGlmICghY29uc3VtZSgpKSB7IGJyZWFrIH1cbiAgICAgIC8vIHN3aXRjaCB0byB6b25lIGRldGVjdGlvblxuICAgICAgaXNab25lID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJzb3IpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChpc1pvbmUpIHtcbiAgICAgIG91dHB1dC56b25lID0gYnVmZmVyLmpvaW4oJycpXG4gICAgfSBlbHNlIGlmIChlbmRJcHY2KSB7XG4gICAgICBhZGRyZXNzLnB1c2goYnVmZmVyLmpvaW4oJycpKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRyZXNzLnB1c2goc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcikpXG4gICAgfVxuICB9XG4gIG91dHB1dC5hZGRyZXNzID0gYWRkcmVzcy5qb2luKCcnKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlQdjYgKGhvc3QpIHtcbiAgaWYgKGZpbmRUb2tlbihob3N0LCAnOicpIDwgMikgeyByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH0gfVxuICBjb25zdCBpcHY2ID0gZ2V0SVBWNihob3N0KVxuXG4gIGlmICghaXB2Ni5lcnJvcikge1xuICAgIGxldCBuZXdIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgbGV0IGVzY2FwZWRIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgaWYgKGlwdjYuem9uZSkge1xuICAgICAgbmV3SG9zdCArPSAnJScgKyBpcHY2LnpvbmVcbiAgICAgIGVzY2FwZWRIb3N0ICs9ICclMjUnICsgaXB2Ni56b25lXG4gICAgfVxuICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3QsIGVzY2FwZWRIb3N0LCBpc0lQVjY6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwTGVhZGluZ1plcm9zIChzdHIsIHRva2VuKSB7XG4gIGxldCBvdXQgPSAnJ1xuICBsZXQgc2tpcCA9IHRydWVcbiAgY29uc3QgbCA9IHN0ci5sZW5ndGhcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBjID0gc3RyW2ldXG4gICAgaWYgKGMgPT09ICcwJyAmJiBza2lwKSB7XG4gICAgICBpZiAoKGkgKyAxIDw9IGwgJiYgc3RyW2kgKyAxXSA9PT0gdG9rZW4pIHx8IGkgKyAxID09PSBsKSB7XG4gICAgICAgIG91dCArPSBjXG4gICAgICAgIHNraXAgPSBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYyA9PT0gdG9rZW4pIHtcbiAgICAgICAgc2tpcCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXAgPSBmYWxzZVxuICAgICAgfVxuICAgICAgb3V0ICs9IGNcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBmaW5kVG9rZW4gKHN0ciwgdG9rZW4pIHtcbiAgbGV0IGluZCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSB0b2tlbikgaW5kKytcbiAgfVxuICByZXR1cm4gaW5kXG59XG5cbmNvbnN0IFJEUzEgPSAvXlxcLlxcLj9cXC8vdVxuY29uc3QgUkRTMiA9IC9eXFwvXFwuKD86XFwvfCQpL3VcbmNvbnN0IFJEUzMgPSAvXlxcL1xcLlxcLig/OlxcL3wkKS91XG5jb25zdCBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvdVxuXG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyAoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW11cblxuICB3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XG4gICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgJycpXG4gICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsICcvJylcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzMpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMywgJy8nKVxuICAgICAgb3V0cHV0LnBvcCgpXG4gICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gJy4nIHx8IGlucHV0ID09PSAnLi4nKSB7XG4gICAgICBpbnB1dCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGltID0gaW5wdXQubWF0Y2goUkRTNSlcbiAgICAgIGlmIChpbSkge1xuICAgICAgICBjb25zdCBzID0gaW1bMF1cbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aClcbiAgICAgICAgb3V0cHV0LnB1c2gocylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb24nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIChjb21wb25lbnRzLCBlc2MpIHtcbiAgY29uc3QgZnVuYyA9IGVzYyAhPT0gdHJ1ZSA/IGVzY2FwZSA6IHVuZXNjYXBlXG4gIGlmIChjb21wb25lbnRzLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5zY2hlbWUgPSBmdW5jKGNvbXBvbmVudHMuc2NoZW1lKVxuICB9XG4gIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gZnVuYyhjb21wb25lbnRzLnVzZXJpbmZvKVxuICB9XG4gIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuaG9zdCA9IGZ1bmMoY29tcG9uZW50cy5ob3N0KVxuICB9XG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMucGF0aCA9IGZ1bmMoY29tcG9uZW50cy5wYXRoKVxuICB9XG4gIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZnVuYyhjb21wb25lbnRzLnF1ZXJ5KVxuICB9XG4gIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gZnVuYyhjb21wb25lbnRzLmZyYWdtZW50KVxuICB9XG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHJlY29tcG9zZUF1dGhvcml0eSAoY29tcG9uZW50cykge1xuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKVxuICAgIHVyaVRva2Vucy5wdXNoKCdAJylcbiAgfVxuXG4gIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBob3N0ID0gdW5lc2NhcGUoY29tcG9uZW50cy5ob3N0KVxuICAgIGNvbnN0IGlwVjRyZXMgPSBub3JtYWxpemVJUHY0KGhvc3QpXG5cbiAgICBpZiAoaXBWNHJlcy5pc0lQVjQpIHtcbiAgICAgIGhvc3QgPSBpcFY0cmVzLmhvc3RcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXBWNnJlcyA9IG5vcm1hbGl6ZUlQdjYoaXBWNHJlcy5ob3N0KVxuICAgICAgaWYgKGlwVjZyZXMuaXNJUFY2ID09PSB0cnVlKSB7XG4gICAgICAgIGhvc3QgPSBgWyR7aXBWNnJlcy5lc2NhcGVkSG9zdH1dYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9zdCA9IGNvbXBvbmVudHMuaG9zdFxuICAgICAgfVxuICAgIH1cbiAgICB1cmlUb2tlbnMucHVzaChob3N0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJzonKVxuICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKVxuICB9XG5cbiAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbignJykgOiB1bmRlZmluZWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWNvbXBvc2VBdXRob3JpdHksXG4gIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLFxuICByZW1vdmVEb3RTZWdtZW50cyxcbiAgbm9ybWFsaXplSVB2NCxcbiAgbm9ybWFsaXplSVB2NixcbiAgc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgVVVJRF9SRUcgPSAvXltcXGRhLWZdezh9LVtcXGRhLWZdezR9LVtcXGRhLWZdezR9LVtcXGRhLWZdezR9LVtcXGRhLWZdezEyfSQvaXVcbmNvbnN0IFVSTl9SRUcgPSAvKFtcXGRhLXpdW1xcZFxcLWEtel17MCwzMX0pOigoPzpbXFx3ISQnKCkqKyxcXC0uOjs9QF18JVtcXGRhLWZdezJ9KSspL2l1XG5cbmZ1bmN0aW9uIGlzU2VjdXJlICh3c0NvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicgPyB3c0NvbXBvbmVudHMuc2VjdXJlIDogU3RyaW5nKHdzQ29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09ICd3c3MnXG59XG5cbmZ1bmN0aW9uIGh0dHBQYXJzZSAoY29tcG9uZW50cykge1xuICBpZiAoIWNvbXBvbmVudHMuaG9zdCkge1xuICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8ICdIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC4nXG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiBodHRwU2VyaWFsaXplIChjb21wb25lbnRzKSB7XG4gIGNvbnN0IHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ2h0dHBzJ1xuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmIChjb21wb25lbnRzLnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50cy5wb3J0ID09PSAnJykge1xuICAgIGNvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgY29tcG9uZW50cy5wYXRoID0gJy8nXG4gIH1cblxuICAvLyBOT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gIC8vIGFzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAvLyBhbmQgbm90IHRoZSBIVFRQIHNwZWMuXG5cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gd3NQYXJzZSAod3NDb21wb25lbnRzKSB7XG4vLyBpbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gIHdzQ29tcG9uZW50cy5zZWN1cmUgPSBpc1NlY3VyZSh3c0NvbXBvbmVudHMpXG5cbiAgLy8gY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpXG4gIHdzQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkXG4gIHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gd3NTZXJpYWxpemUgKHdzQ29tcG9uZW50cykge1xuLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gJycpIHtcbiAgICB3c0NvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gIGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgd3NDb21wb25lbnRzLnNjaGVtZSA9ICh3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnKVxuICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIHJlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gIGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG4gICAgY29uc3QgW3BhdGgsIHF1ZXJ5XSA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKVxuICAgIHdzQ29tcG9uZW50cy5wYXRoID0gKHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZClcbiAgICB3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeVxuICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm5QYXJzZSAodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICBpZiAoIXVybkNvbXBvbmVudHMucGF0aCkge1xuICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSAnVVJOIGNhbiBub3QgYmUgcGFyc2VkJ1xuICAgIHJldHVybiB1cm5Db21wb25lbnRzXG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHVybkNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUkVHKVxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8ICd1cm4nXG4gICAgdXJuQ29tcG9uZW50cy5uaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcbiAgICB1cm5Db21wb25lbnRzLm5zcyA9IG1hdGNoZXNbMl1cbiAgICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgdXJuQ29tcG9uZW50cy5uaWR9YFxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV1cbiAgICB1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWRcblxuICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCAnVVJOIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuXG4gIHJldHVybiB1cm5Db21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVyblNlcmlhbGl6ZSAodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCAndXJuJ1xuICBjb25zdCBuaWQgPSB1cm5Db21wb25lbnRzLm5pZC50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCBuaWR9YFxuICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdXG5cbiAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50cywgb3B0aW9ucylcbiAgfVxuXG4gIGNvbnN0IHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzXG4gIGNvbnN0IG5zcyA9IHVybkNvbXBvbmVudHMubnNzXG4gIHVyaUNvbXBvbmVudHMucGF0aCA9IGAke25pZCB8fCBvcHRpb25zLm5pZH06JHtuc3N9YFxuXG4gIG9wdGlvbnMuc2tpcEVzY2FwZSA9IHRydWVcbiAgcmV0dXJuIHVyaUNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJudXVpZFBhcnNlICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50c1xuICB1dWlkQ29tcG9uZW50cy51dWlkID0gdXVpZENvbXBvbmVudHMubnNzXG4gIHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZFxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnRzLnV1aWQgfHwgIVVVSURfUkVHLnRlc3QodXVpZENvbXBvbmVudHMudXVpZCkpKSB7XG4gICAgdXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCAnVVVJRCBpcyBub3QgdmFsaWQuJ1xuICB9XG5cbiAgcmV0dXJuIHV1aWRDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVybnV1aWRTZXJpYWxpemUgKHV1aWRDb21wb25lbnRzKSB7XG4gIGNvbnN0IHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50c1xuICAvLyBub3JtYWxpemUgVVVJRFxuICB1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8ICcnKS50b0xvd2VyQ2FzZSgpXG4gIHJldHVybiB1cm5Db21wb25lbnRzXG59XG5cbmNvbnN0IGh0dHAgPSB7XG4gIHNjaGVtZTogJ2h0dHAnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn1cblxuY29uc3QgaHR0cHMgPSB7XG4gIHNjaGVtZTogJ2h0dHBzJyxcbiAgZG9tYWluSG9zdDogaHR0cC5kb21haW5Ib3N0LFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn1cblxuY29uc3Qgd3MgPSB7XG4gIHNjaGVtZTogJ3dzJyxcbiAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgcGFyc2U6IHdzUGFyc2UsXG4gIHNlcmlhbGl6ZTogd3NTZXJpYWxpemVcbn1cblxuY29uc3Qgd3NzID0ge1xuICBzY2hlbWU6ICd3c3MnLFxuICBkb21haW5Ib3N0OiB3cy5kb21haW5Ib3N0LFxuICBwYXJzZTogd3MucGFyc2UsXG4gIHNlcmlhbGl6ZTogd3Muc2VyaWFsaXplXG59XG5cbmNvbnN0IHVybiA9IHtcbiAgc2NoZW1lOiAndXJuJyxcbiAgcGFyc2U6IHVyblBhcnNlLFxuICBzZXJpYWxpemU6IHVyblNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufVxuXG5jb25zdCB1cm51dWlkID0ge1xuICBzY2hlbWU6ICd1cm46dXVpZCcsXG4gIHBhcnNlOiB1cm51dWlkUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJudXVpZFNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufVxuXG5jb25zdCBTQ0hFTUVTID0ge1xuICBodHRwLFxuICBodHRwcyxcbiAgd3MsXG4gIHdzcyxcbiAgdXJuLFxuICAndXJuOnV1aWQnOiB1cm51dWlkXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU0NIRU1FU1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbm9ybWFsaXplSVB2Niwgbm9ybWFsaXplSVB2NCwgcmVtb3ZlRG90U2VnbWVudHMsIHJlY29tcG9zZUF1dGhvcml0eSwgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgfSA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJylcbmNvbnN0IFNDSEVNRVMgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWVzJylcblxuZnVuY3Rpb24gbm9ybWFsaXplICh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpID0gc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmkgPSBwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgfVxuICByZXR1cm4gdXJpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmUgKGJhc2VVUkksIHJlbGF0aXZlVVJJLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZWxlc3NPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpXG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSlcbiAgcmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlZCwgeyAuLi5zY2hlbWVsZXNzT3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyAoYmFzZSwgcmVsYXRpdmUsIG9wdGlvbnMsIHNraXBOb3JtYWxpemF0aW9uKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9XG4gIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgcmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50c1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWVcbiAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoXG4gICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9ICcvJyArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICB9XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnRcbiAgICB9XG4gICAgdGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lXG4gIH1cblxuICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudFxuXG4gIHJldHVybiB0YXJnZXRcbn1cblxuZnVuY3Rpb24gZXF1YWwgKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmlBID09PSAnc3RyaW5nJykge1xuICAgIHVyaUEgPSB1bmVzY2FwZSh1cmlBKVxuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQSwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUEsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXJpQiA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlCID0gdW5lc2NhcGUodXJpQilcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUIgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlCLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICByZXR1cm4gdXJpQS50b0xvd2VyQ2FzZSgpID09PSB1cmlCLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplIChjbXB0cywgb3B0cykge1xuICBjb25zdCBjb21wb25lbnRzID0ge1xuICAgIGhvc3Q6IGNtcHRzLmhvc3QsXG4gICAgc2NoZW1lOiBjbXB0cy5zY2hlbWUsXG4gICAgdXNlcmluZm86IGNtcHRzLnVzZXJpbmZvLFxuICAgIHBvcnQ6IGNtcHRzLnBvcnQsXG4gICAgcGF0aDogY21wdHMucGF0aCxcbiAgICBxdWVyeTogY21wdHMucXVlcnksXG4gICAgbmlkOiBjbXB0cy5uaWQsXG4gICAgbnNzOiBjbXB0cy5uc3MsXG4gICAgdXVpZDogY21wdHMudXVpZCxcbiAgICBmcmFnbWVudDogY21wdHMuZnJhZ21lbnQsXG4gICAgcmVmZXJlbmNlOiBjbXB0cy5yZWZlcmVuY2UsXG4gICAgcmVzb3VyY2VOYW1lOiBjbXB0cy5yZXNvdXJjZU5hbWUsXG4gICAgc2VjdXJlOiBjbXB0cy5zZWN1cmUsXG4gICAgZXJyb3I6ICcnXG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgJycpLnRvTG93ZXJDYXNlKCldXG5cbiAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucylcblxuICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcEVzY2FwZSkge1xuICAgICAgY29tcG9uZW50cy5wYXRoID0gZXNjYXBlKGNvbXBvbmVudHMucGF0aClcblxuICAgICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50cy5wYXRoID0gY29tcG9uZW50cy5wYXRoLnNwbGl0KCclM0EnKS5qb2luKCc6JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50cy5wYXRoID0gdW5lc2NhcGUoY29tcG9uZW50cy5wYXRoKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgY29tcG9uZW50cy5zY2hlbWUpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSwgJzonKVxuICB9XG5cbiAgY29uc3QgYXV0aG9yaXR5ID0gcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMpXG4gIGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvLycpXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KVxuXG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvJylcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHMgPSBjb21wb25lbnRzLnBhdGhcblxuICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKVxuICAgIH1cblxuICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IHMucmVwbGFjZSgvXlxcL1xcLy91LCAnLyUyRicpIC8vIGRvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2gocylcbiAgfVxuXG4gIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnPycsIGNvbXBvbmVudHMucXVlcnkpXG4gIH1cblxuICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJyMnLCBjb21wb25lbnRzLmZyYWdtZW50KVxuICB9XG4gIHJldHVybiB1cmlUb2tlbnMuam9pbignJylcbn1cblxuY29uc3QgaGV4TG9va1VwID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTI3IH0sIChfdiwgaykgPT4gL1teIVwiJCYnKCkqKyxcXC0uOz1fYGEtent9fl0vdS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaykpKVxuXG5mdW5jdGlvbiBub25TaW1wbGVEb21haW4gKHZhbHVlKSB7XG4gIGxldCBjb2RlID0gMFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKVxuICAgIGlmIChjb2RlID4gMTI2IHx8IGhleExvb2tVcFtjb2RlXSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteIy86P10rKTopPyg/OlxcL1xcLygoPzooW14jLz9AXSopQCk/KFxcW1teIy8/XFxdXStcXF18W14jLzo/XSopKD86OihcXGQqKSk/KSk/KFteIz9dKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58W1xcblxccl0pKikpPy91XG5cbmZ1bmN0aW9uIHBhcnNlICh1cmksIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIGNvbnN0IHBhcnNlZCA9IHtcbiAgICBzY2hlbWU6IHVuZGVmaW5lZCxcbiAgICB1c2VyaW5mbzogdW5kZWZpbmVkLFxuICAgIGhvc3Q6ICcnLFxuICAgIHBvcnQ6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiAnJyxcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxuICAgIGZyYWdtZW50OiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBnb3RFbmNvZGluZyA9IHVyaS5pbmRleE9mKCclJykgIT09IC0xXG4gIGxldCBpc0lQID0gZmFsc2VcbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSAnc3VmZml4JykgdXJpID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyAnOicgOiAnJykgKyAnLy8nICsgdXJpXG5cbiAgY29uc3QgbWF0Y2hlcyA9IHVyaS5tYXRjaChVUklfUEFSU0UpXG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICAvLyBzdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgIHBhcnNlZC5zY2hlbWUgPSBtYXRjaGVzWzFdXG4gICAgcGFyc2VkLnVzZXJpbmZvID0gbWF0Y2hlc1szXVxuICAgIHBhcnNlZC5ob3N0ID0gbWF0Y2hlc1s0XVxuICAgIHBhcnNlZC5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApXG4gICAgcGFyc2VkLnBhdGggPSBtYXRjaGVzWzZdIHx8ICcnXG4gICAgcGFyc2VkLnF1ZXJ5ID0gbWF0Y2hlc1s3XVxuICAgIHBhcnNlZC5mcmFnbWVudCA9IG1hdGNoZXNbOF1cblxuICAgIC8vIGZpeCBwb3J0IG51bWJlclxuICAgIGlmIChpc05hTihwYXJzZWQucG9ydCkpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gbWF0Y2hlc1s1XVxuICAgIH1cbiAgICBpZiAocGFyc2VkLmhvc3QpIHtcbiAgICAgIGNvbnN0IGlwdjRyZXN1bHQgPSBub3JtYWxpemVJUHY0KHBhcnNlZC5ob3N0KVxuICAgICAgaWYgKGlwdjRyZXN1bHQuaXNJUFY0ID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpcHY2cmVzdWx0ID0gbm9ybWFsaXplSVB2NihpcHY0cmVzdWx0Lmhvc3QpXG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NnJlc3VsdC5ob3N0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgaXNJUCA9IGlwdjZyZXN1bHQuaXNJUFY2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQuaG9zdCA9IGlwdjRyZXN1bHQuaG9zdFxuICAgICAgICBpc0lQID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5ob3N0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnBvcnQgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucXVlcnkgPT09IHVuZGVmaW5lZCAmJiAhcGFyc2VkLnBhdGgpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnc2FtZS1kb2N1bWVudCdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdyZWxhdGl2ZSdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ2Fic29sdXRlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3VyaSdcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IHBhcnNlZC5yZWZlcmVuY2UpIHtcbiAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGlzIG5vdCBhICcgKyBvcHRpb25zLnJlZmVyZW5jZSArICcgcmVmZXJlbmNlLidcbiAgICB9XG5cbiAgICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IHBhcnNlZC5zY2hlbWUgfHwgJycpLnRvTG93ZXJDYXNlKCldXG5cbiAgICAvLyBjaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcbiAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgLy8gaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgaWYgKHBhcnNlZC5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkgJiYgaXNJUCA9PT0gZmFsc2UgJiYgbm9uU2ltcGxlRG9tYWluKHBhcnNlZC5ob3N0KSkge1xuICAgICAgICAvLyBjb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZC5ob3N0ID0gVVJMLmRvbWFpblRvQVNDSUkocGFyc2VkLmhvc3QudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSTogXCIgKyBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgSVJJIC0+IFVSSVxuICAgIH1cblxuICAgIGlmICghc2NoZW1lSGFuZGxlciB8fCAoc2NoZW1lSGFuZGxlciAmJiAhc2NoZW1lSGFuZGxlci5za2lwTm9ybWFsaXplKSkge1xuICAgICAgaWYgKGdvdEVuY29kaW5nICYmIHBhcnNlZC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzZWQuc2NoZW1lID0gdW5lc2NhcGUocGFyc2VkLnNjaGVtZSlcbiAgICAgIH1cbiAgICAgIGlmIChnb3RFbmNvZGluZyAmJiBwYXJzZWQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5ob3N0ID0gdW5lc2NhcGUocGFyc2VkLmhvc3QpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBlc2NhcGUodW5lc2NhcGUocGFyc2VkLnBhdGgpKVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5mcmFnbWVudCkge1xuICAgICAgICBwYXJzZWQuZnJhZ21lbnQgPSBlbmNvZGVVUkkoZGVjb2RlVVJJQ29tcG9uZW50KHBhcnNlZC5mcmFnbWVudCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcbiAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UocGFyc2VkLCBvcHRpb25zKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cbiAgcmV0dXJuIHBhcnNlZFxufVxuXG5jb25zdCBmYXN0VXJpID0ge1xuICBTQ0hFTUVTLFxuICBub3JtYWxpemUsXG4gIHJlc29sdmUsXG4gIHJlc29sdmVDb21wb25lbnRzLFxuICBlcXVhbCxcbiAgc2VyaWFsaXplLFxuICBwYXJzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5mYXN0VXJpID0gZmFzdFVyaVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1cmkgPSByZXF1aXJlKFwiZmFzdC11cmlcIik7XG51cmkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91cmlcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSB1cmk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSB2b2lkIDA7XG52YXIgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJLZXl3b3JkQ3h0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLktleXdvcmRDeHQ7IH0gfSk7XG52YXIgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGVHZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5Db2RlR2VuOyB9IH0pO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHJ1bGVzXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3J1bGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZVwiKTtcbmNvbnN0IGNvZGVnZW5fMiA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVzb2x2ZVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgJGRhdGFSZWZTY2hlbWEgPSByZXF1aXJlKFwiLi9yZWZzL2RhdGEuanNvblwiKTtcbmNvbnN0IHVyaV8xID0gcmVxdWlyZShcIi4vcnVudGltZS91cmlcIik7XG5jb25zdCBkZWZhdWx0UmVnRXhwID0gKHN0ciwgZmxhZ3MpID0+IG5ldyBSZWdFeHAoc3RyLCBmbGFncyk7XG5kZWZhdWx0UmVnRXhwLmNvZGUgPSBcIm5ldyBSZWdFeHBcIjtcbmNvbnN0IE1FVEFfSUdOT1JFX09QVElPTlMgPSBbXCJyZW1vdmVBZGRpdGlvbmFsXCIsIFwidXNlRGVmYXVsdHNcIiwgXCJjb2VyY2VUeXBlc1wiXTtcbmNvbnN0IEVYVF9TQ09QRV9OQU1FUyA9IG5ldyBTZXQoW1xuICAgIFwidmFsaWRhdGVcIixcbiAgICBcInNlcmlhbGl6ZVwiLFxuICAgIFwicGFyc2VcIixcbiAgICBcIndyYXBwZXJcIixcbiAgICBcInJvb3RcIixcbiAgICBcInNjaGVtYVwiLFxuICAgIFwia2V5d29yZFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwiZm9ybWF0c1wiLFxuICAgIFwidmFsaWRhdGUkZGF0YVwiLFxuICAgIFwiZnVuY1wiLFxuICAgIFwib2JqXCIsXG4gICAgXCJFcnJvclwiLFxuXSk7XG5jb25zdCByZW1vdmVkT3B0aW9ucyA9IHtcbiAgICBlcnJvckRhdGFQYXRoOiBcIlwiLFxuICAgIGZvcm1hdDogXCJgdmFsaWRhdGVGb3JtYXRzOiBmYWxzZWAgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBudWxsYWJsZTogJ1wibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0LicsXG4gICAganNvblBvaW50ZXJzOiBcIkRlcHJlY2F0ZWQganNQcm9wZXJ0eVN5bnRheCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIGV4dGVuZFJlZnM6IFwiRGVwcmVjYXRlZCBpZ25vcmVLZXl3b3Jkc1dpdGhSZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBtaXNzaW5nUmVmczogXCJQYXNzIGVtcHR5IHNjaGVtYSB3aXRoICRpZCB0aGF0IHNob3VsZCBiZSBpZ25vcmVkIHRvIGFqdi5hZGRTY2hlbWEuXCIsXG4gICAgcHJvY2Vzc0NvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3Byb2Nlc3M6IChjb2RlLCBzY2hlbWFFbnY6IG9iamVjdCkgPT4gc3RyaW5nfWBcIixcbiAgICBzb3VyY2VDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtzb3VyY2U6IHRydWV9YFwiLFxuICAgIHN0cmljdERlZmF1bHRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHN0cmljdEtleXdvcmRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICAgIHVuaXF1ZUl0ZW1zOiAnXCJ1bmlxdWVJdGVtc1wiIGtleXdvcmQgaXMgYWx3YXlzIHZhbGlkYXRlZC4nLFxuICAgIHVua25vd25Gb3JtYXRzOiBcIkRpc2FibGUgc3RyaWN0IG1vZGUgb3IgcGFzcyBgdHJ1ZWAgdG8gYGFqdi5hZGRGb3JtYXRgIChvciBgZm9ybWF0c2Agb3B0aW9uKS5cIixcbiAgICBjYWNoZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgc2VyaWFsaXplOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBhanZFcnJvcnM6IFwiSXQgaXMgZGVmYXVsdCBub3cuXCIsXG59O1xuY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSB7XG4gICAgaWdub3JlS2V5d29yZHNXaXRoUmVmOiBcIlwiLFxuICAgIGpzUHJvcGVydHlTeW50YXg6IFwiXCIsXG4gICAgdW5pY29kZTogJ1wibWluTGVuZ3RoXCIvXCJtYXhMZW5ndGhcIiBhY2NvdW50IGZvciB1bmljb2RlIGNoYXJhY3RlcnMgYnkgZGVmYXVsdC4nLFxufTtcbmNvbnN0IE1BWF9FWFBSRVNTSU9OID0gMjAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHJlcXVpcmVkT3B0aW9ucyhvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94LCBfeSwgX3osIF8wO1xuICAgIGNvbnN0IHMgPSBvLnN0cmljdDtcbiAgICBjb25zdCBfb3B0eiA9IChfYSA9IG8uY29kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplO1xuICAgIGNvbnN0IG9wdGltaXplID0gX29wdHogPT09IHRydWUgfHwgX29wdHogPT09IHVuZGVmaW5lZCA/IDEgOiBfb3B0eiB8fCAwO1xuICAgIGNvbnN0IHJlZ0V4cCA9IChfYyA9IChfYiA9IG8uY29kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ0V4cCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFJlZ0V4cDtcbiAgICBjb25zdCB1cmlSZXNvbHZlciA9IChfZCA9IG8udXJpUmVzb2x2ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVyaV8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWN0U2NoZW1hOiAoX2YgPSAoX2UgPSBvLnN0cmljdFNjaGVtYSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0TnVtYmVyczogKF9oID0gKF9nID0gby5zdHJpY3ROdW1iZXJzKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB0cnVlLFxuICAgICAgICBzdHJpY3RUeXBlczogKF9rID0gKF9qID0gby5zdHJpY3RUeXBlcykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogcykgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0VHVwbGVzOiAoX20gPSAoX2wgPSBvLnN0cmljdFR1cGxlcykgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogcykgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0UmVxdWlyZWQ6IChfcCA9IChfbyA9IG8uc3RyaWN0UmVxdWlyZWQpICE9PSBudWxsICYmIF9vICE9PSB2b2lkIDAgPyBfbyA6IHMpICE9PSBudWxsICYmIF9wICE9PSB2b2lkIDAgPyBfcCA6IGZhbHNlLFxuICAgICAgICBjb2RlOiBvLmNvZGUgPyB7IC4uLm8uY29kZSwgb3B0aW1pemUsIHJlZ0V4cCB9IDogeyBvcHRpbWl6ZSwgcmVnRXhwIH0sXG4gICAgICAgIGxvb3BSZXF1aXJlZDogKF9xID0gby5sb29wUmVxdWlyZWQpICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBsb29wRW51bTogKF9yID0gby5sb29wRW51bSkgIT09IG51bGwgJiYgX3IgIT09IHZvaWQgMCA/IF9yIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIG1ldGE6IChfcyA9IG8ubWV0YSkgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZXM6IChfdCA9IG8ubWVzc2FnZXMpICE9PSBudWxsICYmIF90ICE9PSB2b2lkIDAgPyBfdCA6IHRydWUsXG4gICAgICAgIGlubGluZVJlZnM6IChfdSA9IG8uaW5saW5lUmVmcykgIT09IG51bGwgJiYgX3UgIT09IHZvaWQgMCA/IF91IDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hSWQ6IChfdiA9IG8uc2NoZW1hSWQpICE9PSBudWxsICYmIF92ICE9PSB2b2lkIDAgPyBfdiA6IFwiJGlkXCIsXG4gICAgICAgIGFkZFVzZWRTY2hlbWE6IChfdyA9IG8uYWRkVXNlZFNjaGVtYSkgIT09IG51bGwgJiYgX3cgIT09IHZvaWQgMCA/IF93IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVTY2hlbWE6IChfeCA9IG8udmFsaWRhdGVTY2hlbWEpICE9PSBudWxsICYmIF94ICE9PSB2b2lkIDAgPyBfeCA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlRm9ybWF0czogKF95ID0gby52YWxpZGF0ZUZvcm1hdHMpICE9PSBudWxsICYmIF95ICE9PSB2b2lkIDAgPyBfeSA6IHRydWUsXG4gICAgICAgIHVuaWNvZGVSZWdFeHA6IChfeiA9IG8udW5pY29kZVJlZ0V4cCkgIT09IG51bGwgJiYgX3ogIT09IHZvaWQgMCA/IF96IDogdHJ1ZSxcbiAgICAgICAgaW50MzJyYW5nZTogKF8wID0gby5pbnQzMnJhbmdlKSAhPT0gbnVsbCAmJiBfMCAhPT0gdm9pZCAwID8gXzAgOiB0cnVlLFxuICAgICAgICB1cmlSZXNvbHZlcjogdXJpUmVzb2x2ZXIsXG4gICAgfTtcbn1cbmNsYXNzIEFqdiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0ge307XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0cyA9IHsgLi4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpIH07XG4gICAgICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgY29kZWdlbl8yLlZhbHVlU2NvcGUoeyBzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXMgfSk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKTtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHM7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuUlVMRVMgPSAoMCwgcnVsZXNfMS5nZXRSdWxlcykoKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgcmVtb3ZlZE9wdGlvbnMsIG9wdHMsIFwiTk9UIFNVUFBPUlRFRFwiKTtcbiAgICAgICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIik7XG4gICAgICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnMuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKG9wdHMuZm9ybWF0cylcbiAgICAgICAgICAgIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgICAgIGFkZEluaXRpYWxLZXl3b3Jkcy5jYWxsKHRoaXMsIG9wdHMua2V5d29yZHMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG9wdHMubWV0YSk7XG4gICAgICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcyk7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZm9ybWF0T3B0O1xuICAgIH1cbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIik7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgY29uc3QgeyAkZGF0YSwgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgbGV0IF9kYXRhUmVmU2NoZW1hID0gJGRhdGFSZWZTY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWFJZCA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYSA9IHsgLi4uJGRhdGFSZWZTY2hlbWEgfTtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hLmlkID0gX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YSAmJiAkZGF0YSlcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShfZGF0YVJlZlNjaGVtYSwgX2RhdGFSZWZTY2hlbWFbc2NoZW1hSWRdLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICBjb25zdCB7IG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID0gdHlwZW9mIG1ldGEgPT0gXCJvYmplY3RcIiA/IG1ldGFbc2NoZW1hSWRdIHx8IG1ldGEgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIC8vIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuICAgIGRhdGEgLy8gdG8gYmUgdmFsaWRhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCB2O1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5nZXRTY2hlbWEoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghdilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCIke3NjaGVtYUtleVJlZn1cImApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IHRoaXMuY29tcGlsZShzY2hlbWFLZXlSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdihkYXRhKTtcbiAgICAgICAgaWYgKCEoXCIkYXN5bmNcIiBpbiB2KSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdi5lcnJvcnM7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgY29tcGlsZShzY2hlbWEsIF9tZXRhKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKTtcbiAgICB9XG4gICAgY29tcGlsZUFzeW5jKHNjaGVtYSwgbWV0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5sb2FkU2NoZW1hICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbG9hZFNjaGVtYSB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoZW1hLCBtZXRhKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcnVuQ29tcGlsZUFzeW5jKF9zY2hlbWEsIF9tZXRhKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoX3NjaGVtYSwgX21ldGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZSB8fCBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWV0YVNjaGVtYSgkcmVmKSB7XG4gICAgICAgICAgICBpZiAoJHJlZiAmJiAhdGhpcy5nZXRTY2hlbWEoJHJlZikpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCB7ICRyZWYgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2NvbXBpbGVBc3luYyhzY2gpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIHJlZl9lcnJvcl8xLmRlZmF1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZGVkLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZE1pc3NpbmdTY2hlbWEuY2FsbCh0aGlzLCBlLm1pc3NpbmdTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xvYWRlZCh7IG1pc3NpbmdTY2hlbWE6IHJlZiwgbWlzc2luZ1JlZiB9KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZzW3JlZl0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFueVNjaGVtYSAke3JlZn0gaXMgbG9hZGVkIGJ1dCAke21pc3NpbmdSZWZ9IGNhbm5vdCBiZSByZXNvbHZlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKHJlZikge1xuICAgICAgICAgICAgY29uc3QgX3NjaGVtYSA9IGF3YWl0IF9sb2FkU2NoZW1hLmNhbGwodGhpcywgcmVmKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShfc2NoZW1hLCByZWYsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkU2NoZW1hKHJlZikge1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIGlmIChwKVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuX2xvYWRpbmdbcmVmXSA9IGxvYWRTY2hlbWEocmVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZVxuICAgIGFkZFNjaGVtYShzY2hlbWEsIC8vIElmIGFycmF5IGlzIHBhc3NlZCwgYGtleWAgd2lsbCBiZSBpZ25vcmVkXG4gICAga2V5LCAvLyBPcHRpb25hbCBzY2hlbWEga2V5LiBDYW4gYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgbWV0aG9kIGluc3RlYWQgb2Ygc2NoZW1hIG9iamVjdCBvciBpZC9yZWYuIE9uZSBzY2hlbWEgcGVyIGluc3RhbmNlIGNhbiBoYXZlIGVtcHR5IGBpZGAgYW5kIGBrZXlgLlxuICAgIF9tZXRhLCAvLyB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHksIGFkZE1ldGFTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbi4gVXNlZCBpbnRlcm5hbGx5LCBvcHRpb24gdmFsaWRhdGVTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY2ggb2Ygc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaCwgdW5kZWZpbmVkLCBfbWV0YSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgJHtzY2hlbWFJZH0gbXVzdCBiZSBzdHJpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShrZXkgfHwgaWQpO1xuICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShrZXkpO1xuICAgICAgICB0aGlzLnNjaGVtYXNba2V5XSA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhLCBrZXksIF92YWxpZGF0ZVNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgICAvLyBvcHRpb25zIGluIE1FVEFfSUdOT1JFX09QVElPTlMgYXJlIGFsd2F5IHNldCB0byBmYWxzZVxuICAgIGFkZE1ldGFTY2hlbWEoc2NoZW1hLCBrZXksIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICAgICkge1xuICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgdHJ1ZSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgICB2YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgJHNjaGVtYTtcbiAgICAgICAgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgICAgICBpZiAoJHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAkc2NoZW1hICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLm9wdHMuZGVmYXVsdE1ldGEgfHwgdGhpcy5kZWZhdWx0TWV0YSgpO1xuICAgICAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJzY2hlbWEgaXMgaW52YWxpZDogXCIgKyB0aGlzLmVycm9yc1RleHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLy8gR2V0IGNvbXBpbGVkIHNjaGVtYSBieSBga2V5YCBvciBgcmVmYC5cbiAgICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgICBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gICAgICAgIGxldCBzY2g7XG4gICAgICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIGtleVJlZikpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBrZXlSZWYgPSBzY2g7XG4gICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hOiB7fSwgc2NoZW1hSWQgfSk7XG4gICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIGtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXNjaClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlZnNba2V5UmVmXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgICAvLyBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gSWYgUmVnRXhwIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyB3aXRoIGtleS9pZCBtYXRjaGluZyBwYXR0ZXJuIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICAgIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgaWYgKHNjaGVtYUtleVJlZiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjaGVtYUtleVJlZjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHNjaGVtYUtleVJlZlt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LnJlbW92ZVNjaGVtYTogaW52YWxpZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIFwidm9jYWJ1bGFyeVwiIC0gYSBjb2xsZWN0aW9uIG9mIGtleXdvcmRzXG4gICAgYWRkVm9jYWJ1bGFyeShkZWZpbml0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZpbml0aW9ucylcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5d29yZChkZWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkS2V5d29yZChrd2RPckRlZiwgZGVmIC8vIGRlcHJlY2F0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IGtleXdvcmQ7XG4gICAgICAgIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5d29yZCA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJ0aGVzZSBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkLCBzZWUgZG9jcyBmb3IgYWRkS2V5d29yZFwiKTtcbiAgICAgICAgICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwib2JqZWN0XCIgJiYgZGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZiA9IGt3ZE9yRGVmO1xuICAgICAgICAgICAga2V5d29yZCA9IGRlZi5rZXl3b3JkO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5d29yZCkgJiYgIWtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkS2V5d29yZHM6IGtleXdvcmQgbXVzdCBiZSBzdHJpbmcgb3Igbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZGRLZXl3b3JkcyBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrS2V5d29yZC5jYWxsKHRoaXMsIGtleXdvcmQsIGRlZik7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShrZXl3b3JkLCAoa3dkKSA9PiBhZGRSdWxlLmNhbGwodGhpcywga3dkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3JkTWV0YXNjaGVtYS5jYWxsKHRoaXMsIGRlZik7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgICB0eXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnNjaGVtYVR5cGUpLFxuICAgICAgICB9O1xuICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShrZXl3b3JkLCBkZWZpbml0aW9uLnR5cGUubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IChrKSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbilcbiAgICAgICAgICAgIDogKGspID0+IGRlZmluaXRpb24udHlwZS5mb3JFYWNoKCh0KSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbiwgdCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICBjb25zdCBydWxlID0gdGhpcy5SVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIHJldHVybiB0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiID8gcnVsZS5kZWZpbml0aW9uIDogISFydWxlO1xuICAgIH1cbiAgICAvLyBSZW1vdmUga2V5d29yZFxuICAgIHJlbW92ZUtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICAvLyBUT0RPIHJldHVybiB0eXBlIHNob3VsZCBiZSBBanZcbiAgICAgICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICAgICAgZGVsZXRlIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdO1xuICAgICAgICBkZWxldGUgUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ3JvdXAucnVsZXMuZmluZEluZGV4KChydWxlKSA9PiBydWxlLmtleXdvcmQgPT09IGtleXdvcmQpO1xuICAgICAgICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgICAgICAgICBncm91cC5ydWxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBmb3JtYXRcbiAgICBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdCk7XG4gICAgICAgIHRoaXMuZm9ybWF0c1tuYW1lXSA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVycm9yc1RleHQoZXJyb3JzID0gdGhpcy5lcnJvcnMsIC8vIG9wdGlvbmFsIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgeyBzZXBhcmF0b3IgPSBcIiwgXCIsIGRhdGFWYXIgPSBcImRhdGFcIiB9ID0ge30gLy8gb3B0aW9uYWwgb3B0aW9ucyB3aXRoIHByb3BlcnRpZXMgYHNlcGFyYXRvcmAgYW5kIGBkYXRhVmFyYFxuICAgICkge1xuICAgICAgICBpZiAoIWVycm9ycyB8fCBlcnJvcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFwiTm8gZXJyb3JzXCI7XG4gICAgICAgIHJldHVybiBlcnJvcnNcbiAgICAgICAgICAgIC5tYXAoKGUpID0+IGAke2RhdGFWYXJ9JHtlLmluc3RhbmNlUGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHRleHQsIG1zZykgPT4gdGV4dCArIHNlcGFyYXRvciArIG1zZyk7XG4gICAgfVxuICAgICRkYXRhTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICBjb25zdCBydWxlcyA9IHRoaXMuUlVMRVMuYWxsO1xuICAgICAgICBtZXRhU2NoZW1hID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhU2NoZW1hKSk7XG4gICAgICAgIGZvciAoY29uc3QganNvblBvaW50ZXIgb2Yga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpLnNsaWNlKDEpOyAvLyBmaXJzdCBzZWdtZW50IGlzIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgbGV0IGtleXdvcmRzID0gbWV0YVNjaGVtYTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnIG9mIHNlZ21lbnRzKVxuICAgICAgICAgICAgICAgIGtleXdvcmRzID0ga2V5d29yZHNbc2VnXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgJGRhdGEgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBrZXl3b3Jkc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICgkZGF0YSAmJiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmRzW2tleV0gPSBzY2hlbWFPckRhdGEoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YVNjaGVtYTtcbiAgICB9XG4gICAgX3JlbW92ZUFsbFNjaGVtYXMoc2NoZW1hcywgcmVnZXgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXlSZWYgaW4gc2NoZW1hcykge1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgaWYgKCFyZWdleCB8fCByZWdleC50ZXN0KGtleVJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaCAmJiAhc2NoLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkU2NoZW1hKHNjaGVtYSwgbWV0YSwgYmFzZUlkLCB2YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSwgYWRkU2NoZW1hID0gdGhpcy5vcHRzLmFkZFVzZWRTY2hlbWEpIHtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuanRkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdFwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0IG9yIGJvb2xlYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjaCA9IHRoaXMuX2NhY2hlLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAoc2NoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gc2NoO1xuICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShpZCB8fCBiYXNlSWQpO1xuICAgICAgICBjb25zdCBsb2NhbFJlZnMgPSByZXNvbHZlXzEuZ2V0U2NoZW1hUmVmcy5jYWxsKHRoaXMsIHNjaGVtYSwgYmFzZUlkKTtcbiAgICAgICAgc2NoID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCBtZXRhLCBiYXNlSWQsIGxvY2FsUmVmcyB9KTtcbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0KHNjaC5zY2hlbWEsIHNjaCk7XG4gICAgICAgIGlmIChhZGRTY2hlbWEgJiYgIWJhc2VJZC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICAgICAgLy8gVE9ETyBhdG0gaXQgaXMgYWxsb3dlZCB0byBvdmVyd3JpdGUgc2NoZW1hcyB3aXRob3V0IGlkIChpbnN0ZWFkIG9mIG5vdCBhZGRpbmcgdGhlbSlcbiAgICAgICAgICAgIGlmIChiYXNlSWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoYmFzZUlkKTtcbiAgICAgICAgICAgIHRoaXMucmVmc1tiYXNlSWRdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZGF0ZVNjaGVtYSlcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG4gICAgX2NoZWNrVW5pcXVlKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLnNjaGVtYXNbaWRdIHx8IHRoaXMucmVmc1tpZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJHtpZH1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb21waWxlU2NoZW1hRW52KHNjaCkge1xuICAgICAgICBpZiAoc2NoLm1ldGEpXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlTWV0YVNjaGVtYShzY2gpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXNjaC52YWxpZGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZTtcbiAgICB9XG4gICAgX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCkge1xuICAgICAgICBjb25zdCBjdXJyZW50T3B0cyA9IHRoaXMub3B0cztcbiAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5fbWV0YU9wdHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMgPSBjdXJyZW50T3B0cztcbiAgICAgICAgfVxuICAgIH1cbn1cbkFqdi5WYWxpZGF0aW9uRXJyb3IgPSB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdDtcbkFqdi5NaXNzaW5nUmVmRXJyb3IgPSByZWZfZXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xuZnVuY3Rpb24gY2hlY2tPcHRpb25zKGNoZWNrT3B0cywgb3B0aW9ucywgbXNnLCBsb2cgPSBcImVycm9yXCIpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGVja09wdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0ga2V5O1xuICAgICAgICBpZiAob3B0IGluIG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlcltsb2ddKGAke21zZ306IG9wdGlvbiAke2tleX0uICR7Y2hlY2tPcHRzW29wdF19YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2NoRW52KGtleVJlZikge1xuICAgIGtleVJlZiA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleVJlZik7IC8vIFRPRE8gdGVzdHMgZmFpbCB3aXRob3V0IHRoaXMgbGluZVxuICAgIHJldHVybiB0aGlzLnNjaGVtYXNba2V5UmVmXSB8fCB0aGlzLnJlZnNba2V5UmVmXTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxTY2hlbWFzKCkge1xuICAgIGNvbnN0IG9wdHNTY2hlbWFzID0gdGhpcy5vcHRzLnNjaGVtYXM7XG4gICAgaWYgKCFvcHRzU2NoZW1hcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHNTY2hlbWFzKSlcbiAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXMpO1xuICAgIGVsc2VcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0c1NjaGVtYXMpXG4gICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hc1trZXldLCBrZXkpO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEZvcm1hdHMoKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMub3B0cy5mb3JtYXRzKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMub3B0cy5mb3JtYXRzW25hbWVdO1xuICAgICAgICBpZiAoZm9ybWF0KVxuICAgICAgICAgICAgdGhpcy5hZGRGb3JtYXQobmFtZSwgZm9ybWF0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsS2V5d29yZHMoZGVmcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZnMpKSB7XG4gICAgICAgIHRoaXMuYWRkVm9jYWJ1bGFyeShkZWZzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci53YXJuKFwia2V5d29yZHMgb3B0aW9uIGFzIG1hcCBpcyBkZXByZWNhdGVkLCBwYXNzIGFycmF5XCIpO1xuICAgIGZvciAoY29uc3Qga2V5d29yZCBpbiBkZWZzKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IGRlZnNba2V5d29yZF07XG4gICAgICAgIGlmICghZGVmLmtleXdvcmQpXG4gICAgICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChkZWYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1ldGFTY2hlbWFPcHRpb25zKCkge1xuICAgIGNvbnN0IG1ldGFPcHRzID0geyAuLi50aGlzLm9wdHMgfTtcbiAgICBmb3IgKGNvbnN0IG9wdCBvZiBNRVRBX0lHTk9SRV9PUFRJT05TKVxuICAgICAgICBkZWxldGUgbWV0YU9wdHNbb3B0XTtcbiAgICByZXR1cm4gbWV0YU9wdHM7XG59XG5jb25zdCBub0xvZ3MgPSB7IGxvZygpIHsgfSwgd2FybigpIHsgfSwgZXJyb3IoKSB7IH0gfTtcbmZ1bmN0aW9uIGdldExvZ2dlcihsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIG5vTG9ncztcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBjb25zb2xlO1xuICAgIGlmIChsb2dnZXIubG9nICYmIGxvZ2dlci53YXJuICYmIGxvZ2dlci5lcnJvcilcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2dnZXIgbXVzdCBpbXBsZW1lbnQgbG9nLCB3YXJuIGFuZCBlcnJvciBtZXRob2RzXCIpO1xufVxuY29uc3QgS0VZV09SRF9OQU1FID0gL15bYS16XyRdW2EtejAtOV8kOi1dKiQvaTtcbmZ1bmN0aW9uIGNoZWNrS2V5d29yZChrZXl3b3JkLCBkZWYpIHtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IHtcbiAgICAgICAgaWYgKFJVTEVTLmtleXdvcmRzW2t3ZF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApO1xuICAgICAgICBpZiAoIUtFWVdPUkRfTkFNRS50ZXN0KGt3ZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKTtcbiAgICB9KTtcbiAgICBpZiAoIWRlZilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCckZGF0YSBrZXl3b3JkIG11c3QgaGF2ZSBcImNvZGVcIiBvciBcInZhbGlkYXRlXCIgZnVuY3Rpb24nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRSdWxlKGtleXdvcmQsIGRlZmluaXRpb24sIGRhdGFUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvc3QgPSBkZWZpbml0aW9uID09PSBudWxsIHx8IGRlZmluaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmluaXRpb24ucG9zdDtcbiAgICBpZiAoZGF0YVR5cGUgJiYgcG9zdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXl3b3JkIHdpdGggXCJwb3N0XCIgZmxhZyBjYW5ub3QgaGF2ZSBcInR5cGVcIicpO1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgbGV0IHJ1bGVHcm91cCA9IHBvc3QgPyBSVUxFUy5wb3N0IDogUlVMRVMucnVsZXMuZmluZCgoeyB0eXBlOiB0IH0pID0+IHQgPT09IGRhdGFUeXBlKTtcbiAgICBpZiAoIXJ1bGVHcm91cCkge1xuICAgICAgICBydWxlR3JvdXAgPSB7IHR5cGU6IGRhdGFUeXBlLCBydWxlczogW10gfTtcbiAgICAgICAgUlVMRVMucnVsZXMucHVzaChydWxlR3JvdXApO1xuICAgIH1cbiAgICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IHRydWU7XG4gICAgaWYgKCFkZWZpbml0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgZGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgLi4uZGVmaW5pdGlvbixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmaW5pdGlvbi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmaW5pdGlvbi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChkZWZpbml0aW9uLmJlZm9yZSlcbiAgICAgICAgYWRkQmVmb3JlUnVsZS5jYWxsKHRoaXMsIHJ1bGVHcm91cCwgcnVsZSwgZGVmaW5pdGlvbi5iZWZvcmUpO1xuICAgIGVsc2VcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgUlVMRVMuYWxsW2tleXdvcmRdID0gcnVsZTtcbiAgICAoX2EgPSBkZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChrd2QpID0+IHRoaXMuYWRkS2V5d29yZChrd2QpKTtcbn1cbmZ1bmN0aW9uIGFkZEJlZm9yZVJ1bGUocnVsZUdyb3VwLCBydWxlLCBiZWZvcmUpIHtcbiAgICBjb25zdCBpID0gcnVsZUdyb3VwLnJ1bGVzLmZpbmRJbmRleCgoX3J1bGUpID0+IF9ydWxlLmtleXdvcmQgPT09IGJlZm9yZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHJ1bGUgJHtiZWZvcmV9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5d29yZE1ldGFzY2hlbWEoZGVmKSB7XG4gICAgbGV0IHsgbWV0YVNjaGVtYSB9ID0gZGVmO1xuICAgIGlmIChtZXRhU2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGVmLiRkYXRhICYmIHRoaXMub3B0cy4kZGF0YSlcbiAgICAgICAgbWV0YVNjaGVtYSA9IHNjaGVtYU9yRGF0YShtZXRhU2NoZW1hKTtcbiAgICBkZWYudmFsaWRhdGVTY2hlbWEgPSB0aGlzLmNvbXBpbGUobWV0YVNjaGVtYSwgdHJ1ZSk7XG59XG5jb25zdCAkZGF0YVJlZiA9IHtcbiAgICAkcmVmOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxufTtcbmZ1bmN0aW9uIHNjaGVtYU9yRGF0YShzY2hlbWEpIHtcbiAgICByZXR1cm4geyBhbnlPZjogW3NjaGVtYSwgJGRhdGFSZWZdIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWRcIixcbiAgICBjb2RlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05PVCBTVVBQT1JURUQ6IGtleXdvcmQgXCJpZFwiLCB1c2UgXCIkaWRcIiBmb3Igc2NoZW1hIElEJyk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsbFJlZiA9IGV4cG9ydHMuZ2V0VmFsaWRhdGUgPSB2b2lkIDA7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIiRyZWZcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWE6ICRyZWYsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgYmFzZUlkLCBzY2hlbWFFbnY6IGVudiwgdmFsaWRhdGVOYW1lLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgY29uc3QgeyByb290IH0gPSBlbnY7XG4gICAgICAgIGlmICgoJHJlZiA9PT0gXCIjXCIgfHwgJHJlZiA9PT0gXCIjL1wiKSAmJiBiYXNlSWQgPT09IHJvb3QuYmFzZUlkKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxSb290UmVmKCk7XG4gICAgICAgIGNvbnN0IHNjaE9yRW52ID0gY29tcGlsZV8xLnJlc29sdmVSZWYuY2FsbChzZWxmLCByb290LCBiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyByZWZfZXJyb3JfMS5kZWZhdWx0KGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFZhbGlkYXRlKHNjaE9yRW52KTtcbiAgICAgICAgcmV0dXJuIGlubGluZVJlZlNjaGVtYShzY2hPckVudik7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxSb290UmVmKCkge1xuICAgICAgICAgICAgaWYgKGVudiA9PT0gcm9vdClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsIHZhbGlkYXRlTmFtZSwgZW52LCBlbnYuJGFzeW5jKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiByb290IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCAoMCwgY29kZWdlbl8xLl8pIGAke3Jvb3ROYW1lfS52YWxpZGF0ZWAsIHJvb3QsIHJvb3QuJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpO1xuICAgICAgICAgICAgY2FsbFJlZihjeHQsIHYsIHNjaCwgc2NoLiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5saW5lUmVmU2NoZW1hKHNjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIG9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUgPyB7IHJlZjogc2NoLCBjb2RlOiAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkoc2NoKSB9IDogeyByZWY6IHNjaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaE5hbWUsXG4gICAgICAgICAgICAgICAgZXJyU2NoZW1hUGF0aDogJHJlZixcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIHJldHVybiBzY2gudmFsaWRhdGVcbiAgICAgICAgPyBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlXCIsIHsgcmVmOiBzY2gudmFsaWRhdGUgfSlcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2dlbi5zY29wZVZhbHVlKFwid3JhcHBlclwiLCB7IHJlZjogc2NoIH0pfS52YWxpZGF0ZWA7XG59XG5leHBvcnRzLmdldFZhbGlkYXRlID0gZ2V0VmFsaWRhdGU7XG5mdW5jdGlvbiBjYWxsUmVmKGN4dCwgdiwgc2NoLCAkYXN5bmMpIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IGFsbEVycm9ycywgc2NoZW1hRW52OiBlbnYsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IHBhc3NDeHQgPSBvcHRzLnBhc3NDb250ZXh0ID8gbmFtZXNfMS5kZWZhdWx0LnRoaXMgOiBjb2RlZ2VuXzEubmlsO1xuICAgIGlmICgkYXN5bmMpXG4gICAgICAgIGNhbGxBc3luY1JlZigpO1xuICAgIGVsc2VcbiAgICAgICAgY2FsbFN5bmNSZWYoKTtcbiAgICBmdW5jdGlvbiBjYWxsQXN5bmNSZWYoKSB7XG4gICAgICAgIGlmICghZW52LiRhc3luYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSByZWZlcmVuY2VkIGJ5IHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCAkeygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KX1gKTtcbiAgICAgICAgICAgIGFkZEV2YWx1YXRlZEZyb20odik7IC8vIFRPRE8gd2lsbCBub3Qgd29yayB3aXRoIGFzeW5jLCBpdCBoYXMgdG8gYmUgcmV0dXJuZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAhKCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvcn0pYCwgKCkgPT4gZ2VuLnRocm93KGUpKTtcbiAgICAgICAgICAgIGFkZEVycm9yc0Zyb20oZSk7XG4gICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsU3luY1JlZigpIHtcbiAgICAgICAgY3h0LnJlc3VsdCgoMCwgY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUpKGN4dCwgdiwgcGFzc0N4dCksICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksICgpID0+IGFkZEVycm9yc0Zyb20odikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFcnJvcnNGcm9tKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBlcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApOyAvLyBUT0RPIHRhZ2dlZFxuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFdmFsdWF0ZWRGcm9tKHNvdXJjZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoRXZhbHVhdGVkID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZhbHVhdGVkO1xuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yXG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7c291cmNlfS5ldmFsdWF0ZWQucHJvcHNgKTtcbiAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHByb3BzLCBpdC5wcm9wcywgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNJdGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEV2YWx1YXRlZC5pdGVtcywgaXQuaXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZ2VuLnZhcihcIml0ZW1zXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7c291cmNlfS5ldmFsdWF0ZWQuaXRlbXNgKTtcbiAgICAgICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIGl0ZW1zLCBpdC5pdGVtcywgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jYWxsUmVmID0gY2FsbFJlZjtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGlkXzEgPSByZXF1aXJlKFwiLi9pZFwiKTtcbmNvbnN0IHJlZl8xID0gcmVxdWlyZShcIi4vcmVmXCIpO1xuY29uc3QgY29yZSA9IFtcbiAgICBcIiRzY2hlbWFcIixcbiAgICBcIiRpZFwiLFxuICAgIFwiJGRlZnNcIixcbiAgICBcIiR2b2NhYnVsYXJ5XCIsXG4gICAgeyBrZXl3b3JkOiBcIiRjb21tZW50XCIgfSxcbiAgICBcImRlZmluaXRpb25zXCIsXG4gICAgaWRfMS5kZWZhdWx0LFxuICAgIHJlZl8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG9wcyA9IGNvZGVnZW5fMS5vcGVyYXRvcnM7XG5jb25zdCBLV0RzID0ge1xuICAgIG1heGltdW06IHsgb2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVCB9LFxuICAgIG1pbmltdW06IHsgb2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVCB9LFxuICAgIGV4Y2x1c2l2ZU1heGltdW06IHsgb2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFIH0sXG4gICAgZXhjbHVzaXZlTWluaW11bTogeyBva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEUgfSxcbn07XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmRdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJHtLV0RzW2tleXdvcmRdLmZhaWx9ICR7c2NoZW1hQ29kZX0gfHwgaXNOYU4oJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlIG11bHRpcGxlIG9mICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm11bHRpcGxlT2ZcIixcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIGNvbnN0IGJkdCA9IGJhZCREYXRhVHlwZShzY2hlbWFDb2RlLCA8c3RyaW5nPmRlZi5zY2hlbWFUeXBlLCAkZGF0YSlcbiAgICAgICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcmVzID0gZ2VuLmxldChcInJlc1wiKTtcbiAgICAgICAgY29uc3QgaW52YWxpZCA9IHByZWNcbiAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgTWF0aC5hYnMoTWF0aC5yb3VuZCgke3Jlc30pIC0gJHtyZXN9KSA+IDFlLSR7cHJlY31gXG4gICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5mdW5jdGlvbiB1Y3MybGVuZ3RoKHN0cikge1xuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhkODAwICYmIHZhbHVlIDw9IDB4ZGJmZiAmJiBwb3MgPCBsZW4pIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmMwMCkgPT09IDB4ZGMwMClcbiAgICAgICAgICAgICAgICBwb3MrKzsgLy8gbG93IHN1cnJvZ2F0ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1Y3MybGVuZ3RoO1xudWNzMmxlbmd0aC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VjczJsZW5ndGhcIikuZGVmYXVsdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11Y3MybGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1Y3MybGVuZ3RoXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS91Y3MybGVuZ3RoXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGNoYXJhY3RlcnNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIl0sXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UgPyAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGAgOiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCB1dGlsXzEudXNlRnVuYykoY3h0LmdlbiwgdWNzMmxlbmd0aF8xLmRlZmF1bHQpfSgke2RhdGF9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TGVuZ3RoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggcGF0dGVybiBcIiR7c2NoZW1hQ29kZX1cImAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwYXR0ZXJuOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIFRPRE8gcmVnZXhwIHNob3VsZCBiZSB3cmFwcGVkIGluIHRyeS9jYXRjaHNcbiAgICAgICAgY29uc3QgdSA9IGl0Lm9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICAgICAgY29uc3QgcmVnRXhwID0gJGRhdGEgPyAoMCwgY29kZWdlbl8xLl8pIGAobmV3IFJlZ0V4cCgke3NjaGVtYUNvZGV9LCAke3V9KSlgIDogKDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHNjaGVtYSk7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7cmVnRXhwfS50ZXN0KCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gcHJvcGVydGllc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5rZXlzKCR7ZGF0YX0pLmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICcke21pc3NpbmdQcm9wZXJ0eX0nYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IG9wdHMubG9vcFJlcXVpcmVkO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgYWxsRXJyb3JzTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBleGl0T25FcnJvck1vZGUoKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0UmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gY3h0LnBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY29uc3QgeyBkZWZpbmVkUHJvcGVydGllcyB9ID0gY3h0Lml0O1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wc1tyZXF1aXJlZEtleV0pID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgO1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RSZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFsbEVycm9yc01vZGUoKSB7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKGNvZGVnZW5fMS5uaWwsIGxvb3BBbGxSZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhpdE9uRXJyb3JNb2RlKCkge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgKCkgPT4gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkpO1xuICAgICAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5jaGVja01pc3NpbmdQcm9wKShjeHQsIHNjaGVtYSwgbWlzc2luZykpO1xuICAgICAgICAgICAgICAgICgwLCBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wQWxsUmVxdWlyZWQoKSB7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJwcm9wXCIsIHNjaGVtYUNvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogcHJvcCB9KTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5ub1Byb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpIHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YobWlzc2luZywgc2NoZW1hQ29kZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVpcmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGl0ZW1zYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiXSxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdEl0ZW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fqdi12YWxpZGF0b3IvYWp2L2lzc3Vlcy84ODlcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmVxdWFsLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvZXF1YWxcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSBlcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVxdWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjICR7an0gYW5kICR7aX0gYXJlIGlkZW50aWNhbClgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7aTogJHtpfSwgajogJHtqfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlcyA9IHBhcmVudFNjaGVtYS5pdGVtcyA/ICgwLCBkYXRhVHlwZV8xLmdldFNjaGVtYVR5cGVzKShwYXJlbnRTY2hlbWEuaXRlbXMpIDogW107XG4gICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZVVuaXF1ZUl0ZW1zLCAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSBmYWxzZWApO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVVuaXF1ZUl0ZW1zKCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdlbi5sZXQoXCJpXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgICAgICBjb25zdCBqID0gZ2VuLmxldChcImpcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaSwgaiB9KTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aX0gPiAxYCwgKCkgPT4gKGNhbk9wdGltaXplKCkgPyBsb29wTiA6IGxvb3BOMikoaSwgaikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1UeXBlcy5sZW5ndGggPiAwICYmICFpdGVtVHlwZXMuc29tZSgodCkgPT4gdCA9PT0gXCJvYmplY3RcIiB8fCB0ID09PSBcImFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOKGksIGopIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZW4ubmFtZShcIml0ZW1cIik7XG4gICAgICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSAoMCwgZGF0YVR5cGVfMS5jaGVja0RhdGFUeXBlcykoaXRlbVR5cGVzLCBpdGVtLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzEuRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IGdlbi5jb25zdChcImluZGljZXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICAgICAgICAgIGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgOyR7aX0tLTtgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmxldChpdGVtLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgY29udGludWVgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpdGVtfSA9PSBcInN0cmluZ1wiYCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdGVtfSArPSBcIl9cImApO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7aW5kaWNlc31bJHtpdGVtfV0gPT0gXCJudW1iZXJcImAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCAoMCwgY29kZWdlbl8xLl8pIGAke2luZGljZXN9WyR7aXRlbX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2luZGljZXN9WyR7aXRlbX1dID0gJHtpfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4yKGksIGopIHtcbiAgICAgICAgICAgIGNvbnN0IGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXIgPSBnZW4ubmFtZShcIm91dGVyXCIpO1xuICAgICAgICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgOyR7aX0tLTtgLCAoKSA9PiBnZW4uZm9yKCgwLCBjb2RlZ2VuXzEuXykgYCR7an0gPSAke2l9OyAke2p9LS07YCwgKCkgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXFsfSgke2RhdGF9WyR7aX1dLCAke2RhdGF9WyR7an1dKWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsob3V0ZXIpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBjb25zdGFudFwiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7YWxsb3dlZFZhbHVlOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYUNvZGUsIHNjaGVtYSB9ID0gY3h0O1xuICAgICAgICBpZiAoJGRhdGEgfHwgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCEkeygwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpfSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3h0LmZhaWwoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWF9ICE9PSAke2RhdGF9YCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7YWxsb3dlZFZhbHVlczogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImVudW1cIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVudW0gbXVzdCBoYXZlIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gaXQub3B0cy5sb29wRW51bTtcbiAgICAgICAgbGV0IGVxbDtcbiAgICAgICAgY29uc3QgZ2V0RXFsID0gKCkgPT4gKGVxbCAhPT0gbnVsbCAmJiBlcWwgIT09IHZvaWQgMCA/IGVxbCA6IChlcWwgPSAoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KSkpO1xuICAgICAgICBsZXQgdmFsaWQ7XG4gICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCBsb29wRW51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZTY2hlbWEgPSBnZW4uY29uc3QoXCJ2U2NoZW1hXCIsIHNjaGVtYUNvZGUpO1xuICAgICAgICAgICAgdmFsaWQgPSAoMCwgY29kZWdlbl8xLm9yKSguLi5zY2hlbWEubWFwKChfeCwgaSkgPT4gZXF1YWxDb2RlKHZTY2hlbWEsIGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiBsb29wRW51bSgpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInZcIiwgc2NoZW1hQ29kZSwgKHYpID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2dldEVxbCgpfSgke2RhdGF9LCAke3Z9KWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlcXVhbENvZGUodlNjaGVtYSwgaSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2ldO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2ggPT09IFwib2JqZWN0XCIgJiYgc2NoICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAke2dldEVxbCgpfSgke2RhdGF9LCAke3ZTY2hlbWF9WyR7aX1dKWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09ICR7c2NofWA7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsaW1pdE51bWJlcl8xID0gcmVxdWlyZShcIi4vbGltaXROdW1iZXJcIik7XG5jb25zdCBtdWx0aXBsZU9mXzEgPSByZXF1aXJlKFwiLi9tdWx0aXBsZU9mXCIpO1xuY29uc3QgbGltaXRMZW5ndGhfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TGVuZ3RoXCIpO1xuY29uc3QgcGF0dGVybl8xID0gcmVxdWlyZShcIi4vcGF0dGVyblwiKTtcbmNvbnN0IGxpbWl0UHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vbGltaXRQcm9wZXJ0aWVzXCIpO1xuY29uc3QgcmVxdWlyZWRfMSA9IHJlcXVpcmUoXCIuL3JlcXVpcmVkXCIpO1xuY29uc3QgbGltaXRJdGVtc18xID0gcmVxdWlyZShcIi4vbGltaXRJdGVtc1wiKTtcbmNvbnN0IHVuaXF1ZUl0ZW1zXzEgPSByZXF1aXJlKFwiLi91bmlxdWVJdGVtc1wiKTtcbmNvbnN0IGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbmNvbnN0IGVudW1fMSA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5jb25zdCB2YWxpZGF0aW9uID0gW1xuICAgIC8vIG51bWJlclxuICAgIGxpbWl0TnVtYmVyXzEuZGVmYXVsdCxcbiAgICBtdWx0aXBsZU9mXzEuZGVmYXVsdCxcbiAgICAvLyBzdHJpbmdcbiAgICBsaW1pdExlbmd0aF8xLmRlZmF1bHQsXG4gICAgcGF0dGVybl8xLmRlZmF1bHQsXG4gICAgLy8gb2JqZWN0XG4gICAgbGltaXRQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICByZXF1aXJlZF8xLmRlZmF1bHQsXG4gICAgLy8gYXJyYXlcbiAgICBsaW1pdEl0ZW1zXzEuZGVmYXVsdCxcbiAgICB1bmlxdWVJdGVtc18xLmRlZmF1bHQsXG4gICAgLy8gYW55XG4gICAgeyBrZXl3b3JkOiBcInR5cGVcIiwgc2NoZW1hVHlwZTogW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0gfSxcbiAgICB7IGtleXdvcmQ6IFwibnVsbGFibGVcIiwgc2NoZW1hVHlwZTogXCJib29sZWFuXCIgfSxcbiAgICBjb25zdF8xLmRlZmF1bHQsXG4gICAgZW51bV8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7bGVufX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgJ1wiYWRkaXRpb25hbEl0ZW1zXCIgaXMgaWdub3JlZCB3aGVuIFwiaXRlbXNcIiBpcyBub3QgYW4gYXJyYXkgb2Ygc2NoZW1hcycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcykge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBsZW46IGl0ZW1zLmxlbmd0aCB9KTtcbiAgICAgICAgY3h0LnBhc3MoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLnZhcihcInZhbGlkXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHZhbGlkYXRlSXRlbXModmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZCkge1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGl0ZW1zLmxlbmd0aCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIGRhdGFQcm9wOiBpLCBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlVHVwbGUoY3h0LCBcImFkZGl0aW9uYWxJdGVtc1wiLCBzY2hlbWEpO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3h0Lm9rKCgwLCBjb2RlXzEudmFsaWRhdGVBcnJheSkoY3h0KSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVR1cGxlKGN4dCwgZXh0cmFJdGVtcywgc2NoQXJyID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hBcnIubGVuZ3RoLCBpdC5pdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICBzY2hBcnIuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+ICR7aX1gLCAoKSA9PiBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgIH0sIHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hlY2tTdHJpY3RUdXBsZShzY2gpIHtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbCA9IHNjaEFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZ1bGxUdXBsZSA9IGwgPT09IHNjaC5taW5JdGVtcyAmJiAobCA9PT0gc2NoLm1heEl0ZW1zIHx8IHNjaFtleHRyYUl0ZW1zXSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBvcHRzLnN0cmljdFR1cGxlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2YWxpZGF0ZVR1cGxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcmVmaXhJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJhcnJheVwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBjb2RlOiAoY3h0KSA9PiAoMCwgaXRlbXNfMS52YWxpZGF0ZVR1cGxlKShjeHQsIFwiaXRlbXNcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZml4SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IHByZWZpeEl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocHJlZml4SXRlbXMpXG4gICAgICAgICAgICAoMCwgYWRkaXRpb25hbEl0ZW1zXzEudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMpKGN4dCwgcHJlZml4SXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zMjAyMC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gdmFsaWQgaXRlbShzKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gYW5kIG5vIG1vcmUgdGhhbiAke21heH0gdmFsaWQgaXRlbShzKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZCA/ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59fWAgOiAoMCwgY29kZWdlbl8xLl8pIGB7bWluQ29udGFpbnM6ICR7bWlufSwgbWF4Q29udGFpbnM6ICR7bWF4fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBsZXQgbWluO1xuICAgICAgICBsZXQgbWF4O1xuICAgICAgICBjb25zdCB7IG1pbkNvbnRhaW5zLCBtYXhDb250YWlucyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICAgICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zO1xuICAgICAgICAgICAgbWF4ID0gbWF4Q29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWluLCBtYXggfSk7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDApIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwibWluQ29udGFpbnNcIiA9PSAwIHdpdGhvdXQgXCJtYXhDb250YWluc1wiOiBcImNvbnRhaW5zXCIga2V5d29yZCBpZ25vcmVkYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIG1pbiA+IG1heCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgbGV0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPj0gJHttaW59YDtcbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YDtcbiAgICAgICAgICAgIGN4dC5wYXNzKGNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAxKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHZhbGlkLCAoKSA9PiBnZW4uaWYodmFsaWQsICgpID0+IGdlbi5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWluID09PSAwKSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGggPiAwYCwgdmFsaWRhdGVJdGVtc1dpdGhDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZ2VuLmxldChcImNvdW50XCIsIDApO1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtcyhzY2hWYWxpZCwgKCkgPT4gZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiBjaGVja0xpbWl0cyhjb3VudCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKF92YWxpZCwgYmxvY2spIHtcbiAgICAgICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xpbWl0cyhjb3VudCkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0rK2ApO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlU2NoZW1hRGVwcyA9IGV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSBleHBvcnRzLmVycm9yID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmV4cG9ydHMuZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMgfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5X2llcyA9IGRlcHNDb3VudCA9PT0gMSA/IFwicHJvcGVydHlcIiA6IFwicHJvcGVydGllc1wiO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgJHtwcm9wZXJ0eV9pZXN9ICR7ZGVwc30gd2hlbiBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBwcmVzZW50YDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwcm9wZXJ0eTogJHtwcm9wZXJ0eX0sXG4gICAgbWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX0sXG4gICAgZGVwc0NvdW50OiAke2RlcHNDb3VudH0sXG4gICAgZGVwczogJHtkZXBzfX1gLCAvLyBUT0RPIGNoYW5nZSB0byByZWZlcmVuY2Vcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkZXBlbmRlbmNpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXJyb3I6IGV4cG9ydHMuZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgW3Byb3BEZXBzLCBzY2hEZXBzXSA9IHNwbGl0RGVwZW5kZW5jaWVzKGN4dCk7XG4gICAgICAgIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcERlcHMpO1xuICAgICAgICB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hEZXBzKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHNwbGl0RGVwZW5kZW5jaWVzKHsgc2NoZW1hIH0pIHtcbiAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFEZXBzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZGVwcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pID8gcHJvcGVydHlEZXBzIDogc2NoZW1hRGVwcztcbiAgICAgICAgZGVwc1trZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHJldHVybiBbcHJvcGVydHlEZXBzLCBzY2hlbWFEZXBzXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcGVydHlEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0eURlcHMpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHlEZXBzKSB7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBwcm9wZXJ0eURlcHNbcHJvcF07XG4gICAgICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBoYXNQcm9wZXJ0eSA9ICgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7XG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgIGRlcHNDb3VudDogZGVwcy5sZW5ndGgsXG4gICAgICAgICAgICBkZXBzOiBkZXBzLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgIGdlbi5pZihoYXNQcm9wZXJ0eSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVwUHJvcCBvZiBkZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBkZXBQcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2hhc1Byb3BlcnR5fSAmJiAoJHsoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgZGVwcywgbWlzc2luZyl9KWApO1xuICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gdmFsaWRhdGVQcm9wZXJ0eURlcHM7XG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hlbWFEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYURlcHNbcHJvcF0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBzY2hlbWFQcm9wOiBwcm9wIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpO1xuICAgICAgICB9LCAoKSA9PiBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICAgICAgICApO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gdmFsaWRhdGVTY2hlbWFEZXBzO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwZW5kZW5jaWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcInByb3BlcnR5IG5hbWUgbXVzdCBiZSB2YWxpZFwiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IHByb3BlcnR5TmFtZToga2V5IH0pO1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YToga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlczogW1wic3RyaW5nXCJdLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZToga2V5LFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0eU5hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZXJyc0NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB7IGFsbEVycm9ycywgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGl0LnByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3QgcGF0UHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTtcbiAgICAgICAgY3h0Lm9rKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xuICAgICAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmxlbmd0aCAmJiAhcGF0UHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoaXNBZGRpdGlvbmFsKGtleSksICgpID0+IGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0FkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBsZXQgZGVmaW5lZFByb3A7XG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgYW4gb3B0aW9uIGluc3RlYWQgb2YgaGFyZC1jb2RlZCA4P1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzLCBcInByb3BlcnRpZXNcIik7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZV8xLmlzT3duUHJvcGVydHkpKGdlbiwgcHJvcHNTY2hlbWEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnByb3BzLm1hcCgocCkgPT4gKDAsIGNvZGVnZW5fMS5fKSBgJHtrZXl9ID09PSAke3B9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdFByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgcCl9LnRlc3QoJHtrZXl9KWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm5vdCkoZGVmaW5lZFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGBkZWxldGUgJHtkYXRhfVske2tleX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgfHwgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAmJiBzY2hlbWEgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBhZGRpdGlvbmFsUHJvcGVydHk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJmYWlsaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5TdHIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbFByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiAmJiBwYXJlbnRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LmNvZGUobmV3IHZhbGlkYXRlXzEuS2V5d29yZEN4dChpdCwgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGFsbFByb3BzKSB7XG4gICAgICAgICAgICBpdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgYWxsUHJvcHMubGVuZ3RoICYmIGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sICgwLCB1dGlsXzEudG9IYXNoKShhbGxQcm9wcyksIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcykpO1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5lbHNlKCkudmFyKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5pdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0RlZmF1bHQocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgc2NoZW1hW3Byb3BdLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApIHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHByb3AsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IHByb3AsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+ICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKGFsd2F5c1ZhbGlkUGF0dGVybnMubGVuZ3RoID09PSBwYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQgfHwgaXQucHJvcHMgPT09IHRydWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrUHJvcGVydGllcyA9IG9wdHMuc3RyaWN0U2NoZW1hICYmICFvcHRzLmFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzICYmIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiAhKGl0LnByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9ICgwLCB1dGlsXzIuZXZhbHVhdGVkUHJvcHNUb05hbWUpKGdlbiwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IGl0O1xuICAgICAgICB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdCBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1Byb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2hlY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAocGF0KS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwYXQpfS50ZXN0KCR7a2V5fSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gYWx3YXlzVmFsaWRQYXR0ZXJucy5pbmNsdWRlcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsd2F5c1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzIuVHlwZS5TdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgcHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbHdheXNWYWxpZCAmJiAhaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzYCBpcyBub3Qgc3VwcG9ydGVkIChvcHRzLm5leHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgd2VyZSBldmFsdWF0ZWQgKHByb3BzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm5Qcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgIGN4dC5mYWlsUmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgIH0sXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogXCJtdXN0IE5PVCBiZSB2YWxpZFwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhbnlPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlOiBjb2RlXzEudmFsaWRhdGVVbmlvbixcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggYSBzY2hlbWEgaW4gYW55T2ZcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFueU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Bhc3NpbmdTY2hlbWFzOiAke3BhcmFtcy5wYXNzaW5nfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBpZiAoaXQub3B0cy5kaXNjcmltaW5hdG9yICYmIHBhcmVudFNjaGVtYS5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hBcnIgPSBzY2hlbWE7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcGFzc2luZyA9IGdlbi5sZXQoXCJwYXNzaW5nXCIsIG51bGwpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcGFzc2luZyB9KTtcbiAgICAgICAgLy8gVE9ETyBwb3NzaWJseSBmYWlsIHN0cmFpZ2h0IGF3YXkgKHdpdGggd2FybmluZyBvciBleGNlcHRpb24pIGlmIHRoZXJlIGFyZSB0d28gZW1wdHkgYWx3YXlzIHZhbGlkIHNjaGVtYXNcbiAgICAgICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpO1xuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPbmVPZigpIHtcbiAgICAgICAgICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoQ3h0O1xuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSkge1xuICAgICAgICAgICAgICAgICAgICBnZW4udmFyKHNjaFZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoVmFsaWR9ICYmICR7dmFsaWR9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihwYXNzaW5nLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtwYXNzaW5nfSwgJHtpfV1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVsc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHBhc3NpbmcsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoQ3h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFsbE9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBzY2hlbWEuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwiYWxsT2ZcIiwgc2NoZW1hUHJvcDogaSB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggXCIke3BhcmFtcy5pZkNsYXVzZX1cIiBzY2hlbWFgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpO1xuICAgICAgICBjb25zdCBoYXNFbHNlID0gaGFzU2NoZW1hKGl0LCBcImVsc2VcIik7XG4gICAgICAgIGlmICghaGFzVGhlbiAmJiAhaGFzRWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIHZhbGlkYXRlSWYoKTtcbiAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgIGlmIChoYXNUaGVuICYmIGhhc0Vsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGlmQ2xhdXNlID0gZ2VuLmxldChcImlmQ2xhdXNlXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlIH0pO1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNUaGVuKSB7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHNjaFZhbGlkKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJZigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2xhdXNlKGtleXdvcmQsIGlmQ2xhdXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGlmQ2xhdXNlKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGlmQ2xhdXNlLCAoMCwgY29kZWdlbl8xLl8pIGAke2tleXdvcmR9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2U6IGtleXdvcmQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBoYXNTY2hlbWEoaXQsIGtleXdvcmQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGNvZGUoeyBrZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGl0IH0pIHtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS5pZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCIke2tleXdvcmR9XCIgd2l0aG91dCBcImlmXCIgaXMgaWdub3JlZGApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhlbkVsc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IHByZWZpeEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9wcmVmaXhJdGVtc1wiKTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGl0ZW1zMjAyMF8xID0gcmVxdWlyZShcIi4vaXRlbXMyMDIwXCIpO1xuY29uc3QgY29udGFpbnNfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zXCIpO1xuY29uc3QgZGVwZW5kZW5jaWVzXzEgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXNcIik7XG5jb25zdCBwcm9wZXJ0eU5hbWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eU5hbWVzXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgcHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllc1wiKTtcbmNvbnN0IHBhdHRlcm5Qcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuUHJvcGVydGllc1wiKTtcbmNvbnN0IG5vdF8xID0gcmVxdWlyZShcIi4vbm90XCIpO1xuY29uc3QgYW55T2ZfMSA9IHJlcXVpcmUoXCIuL2FueU9mXCIpO1xuY29uc3Qgb25lT2ZfMSA9IHJlcXVpcmUoXCIuL29uZU9mXCIpO1xuY29uc3QgYWxsT2ZfMSA9IHJlcXVpcmUoXCIuL2FsbE9mXCIpO1xuY29uc3QgaWZfMSA9IHJlcXVpcmUoXCIuL2lmXCIpO1xuY29uc3QgdGhlbkVsc2VfMSA9IHJlcXVpcmUoXCIuL3RoZW5FbHNlXCIpO1xuZnVuY3Rpb24gZ2V0QXBwbGljYXRvcihkcmFmdDIwMjAgPSBmYWxzZSkge1xuICAgIGNvbnN0IGFwcGxpY2F0b3IgPSBbXG4gICAgICAgIC8vIGFueVxuICAgICAgICBub3RfMS5kZWZhdWx0LFxuICAgICAgICBhbnlPZl8xLmRlZmF1bHQsXG4gICAgICAgIG9uZU9mXzEuZGVmYXVsdCxcbiAgICAgICAgYWxsT2ZfMS5kZWZhdWx0LFxuICAgICAgICBpZl8xLmRlZmF1bHQsXG4gICAgICAgIHRoZW5FbHNlXzEuZGVmYXVsdCxcbiAgICAgICAgLy8gb2JqZWN0XG4gICAgICAgIHByb3BlcnR5TmFtZXNfMS5kZWZhdWx0LFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIGRlcGVuZGVuY2llc18xLmRlZmF1bHQsXG4gICAgICAgIHByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwYXR0ZXJuUHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgXTtcbiAgICAvLyBhcnJheVxuICAgIGlmIChkcmFmdDIwMjApXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChwcmVmaXhJdGVtc18xLmRlZmF1bHQsIGl0ZW1zMjAyMF8xLmRlZmF1bHQpO1xuICAgIGVsc2VcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKGFkZGl0aW9uYWxJdGVtc18xLmRlZmF1bHQsIGl0ZW1zXzEuZGVmYXVsdCk7XG4gICAgYXBwbGljYXRvci5wdXNoKGNvbnRhaW5zXzEuZGVmYXVsdCk7XG4gICAgcmV0dXJuIGFwcGxpY2F0b3I7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRBcHBsaWNhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Zvcm1hdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICAgIHR5cGU6IFtcIm51bWJlclwiLCBcInN0cmluZ1wiXSxcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0LCBydWxlVHlwZSkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoLCBzY2hlbWFFbnYsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZkRlZiA9IGdlbi5jb25zdChcImZEZWZcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRzfVske3NjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY29uc3QgZlR5cGUgPSBnZW4ubGV0KFwiZlR5cGVcIik7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBnZW4ubGV0KFwiZm9ybWF0XCIpO1xuICAgICAgICAgICAgLy8gVE9ETyBzaW1wbGlmeVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZkRlZn0udHlwZSB8fCBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS52YWxpZGF0ZWApLCAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZikpO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLm9yKSh1bmtub3duRm10KCksIGludmFsaWRGbXQoKSkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZtdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSAmJiAhJHtmb3JtYXR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludmFsaWRGbXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbEZvcm1hdCA9IHNjaGVtYUVudi4kYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmb3JtYXR9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAodHlwZW9mICR7Zm9ybWF0fSA9PSBcImZ1bmN0aW9uXCIgPyAke2NhbGxGb3JtYXR9IDogJHtmb3JtYXR9LnRlc3QoJHtkYXRhfSkpYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXREZWYgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXTtcbiAgICAgICAgICAgIGlmICghZm9ybWF0RGVmKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgW2ZtdFR5cGUsIGZvcm1hdCwgZm10UmVmXSA9IGdldEZvcm1hdChmb3JtYXREZWYpO1xuICAgICAgICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKVxuICAgICAgICAgICAgICAgIGN4dC5wYXNzKHZhbGlkQ29uZGl0aW9uKCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHVua25vd24gZm9ybWF0IFwiJHtzY2hlbWF9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9ybWF0KGZtdERlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLnJlZ2V4cENvZGUpKGZtdERlZilcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLmNvZGUuZm9ybWF0c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAke29wdHMuY29kZS5mb3JtYXRzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoc2NoZW1hKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwgeyBrZXk6IHNjaGVtYSwgcmVmOiBmbXREZWYsIGNvZGUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10fS52YWxpZGF0ZWBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wic3RyaW5nXCIsIGZtdERlZiwgZm10XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0RGVmID09IFwib2JqZWN0XCIgJiYgIShmb3JtYXREZWYgaW5zdGFuY2VvZiBSZWdFeHApICYmIGZvcm1hdERlZi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBmb3JtYXQgaW4gc3luYyBzY2hlbWFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCAke2ZtdFJlZn0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PSBcImZ1bmN0aW9uXCIgPyAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0oJHtkYXRhfSlgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRSZWZ9LnRlc3QoJHtkYXRhfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IGZvcm1hdCA9IFtmb3JtYXRfMS5kZWZhdWx0XTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IGV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gdm9pZCAwO1xuZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSBbXG4gICAgXCJ0aXRsZVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlcHJlY2F0ZWRcIixcbiAgICBcInJlYWRPbmx5XCIsXG4gICAgXCJ3cml0ZU9ubHlcIixcbiAgICBcImV4YW1wbGVzXCIsXG5dO1xuZXhwb3J0cy5jb250ZW50Vm9jYWJ1bGFyeSA9IFtcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIixcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICAgIFwiY29udGVudFNjaGVtYVwiLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG5jb25zdCBhcHBsaWNhdG9yXzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhdG9yXCIpO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBkcmFmdDdWb2NhYnVsYXJpZXMgPSBbXG4gICAgY29yZV8xLmRlZmF1bHQsXG4gICAgdmFsaWRhdGlvbl8xLmRlZmF1bHQsXG4gICAgKDAsIGFwcGxpY2F0b3JfMS5kZWZhdWx0KSgpLFxuICAgIGZvcm1hdF8xLmRlZmF1bHQsXG4gICAgbWV0YWRhdGFfMS5tZXRhZGF0YVZvY2FidWxhcnksXG4gICAgbWV0YWRhdGFfMS5jb250ZW50Vm9jYWJ1bGFyeSxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBkcmFmdDdWb2NhYnVsYXJpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFmdDcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpc2NyRXJyb3IgPSB2b2lkIDA7XG52YXIgRGlzY3JFcnJvcjtcbihmdW5jdGlvbiAoRGlzY3JFcnJvcikge1xuICAgIERpc2NyRXJyb3JbXCJUYWdcIl0gPSBcInRhZ1wiO1xuICAgIERpc2NyRXJyb3JbXCJNYXBwaW5nXCJdID0gXCJtYXBwaW5nXCI7XG59KShEaXNjckVycm9yIHx8IChleHBvcnRzLkRpc2NyRXJyb3IgPSBEaXNjckVycm9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vZGlzY3JpbWluYXRvci90eXBlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlXCIpO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZ05hbWUgfSB9KSA9PiBkaXNjckVycm9yID09PSB0eXBlc18xLkRpc2NyRXJyb3IuVGFnXG4gICAgICAgID8gYHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHN0cmluZ2BcbiAgICAgICAgOiBgdmFsdWUgb2YgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgaW4gb25lT2ZgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZywgdGFnTmFtZSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb25lT2YgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIGRpc2NyaW1pbmF0b3Igb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBzY2hlbWEucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIHByb3BlcnR5TmFtZVwiKTtcbiAgICAgICAgaWYgKHNjaGVtYS5tYXBwaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogbWFwcGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAoIW9uZU9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgb25lT2Yga2V5d29yZFwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkodGFnTmFtZSl9YCk7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHt0YWd9ID09IFwic3RyaW5nXCJgLCAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSwgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZSB9KSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKCk7XG4gICAgICAgICAgICBnZW4uaWYoZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke3RhZ30gPT09ICR7dGFnVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgYXBwbHlUYWdTY2hlbWEobWFwcGluZ1t0YWdWYWx1ZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZSB9KTtcbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJvbmVPZlwiLCBzY2hlbWFQcm9wIH0sIF92YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gX3ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcHBpbmcoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBvbmVPZk1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJlcXVpcmVkID0gaGFzUmVxdWlyZWQocGFyZW50U2NoZW1hKTtcbiAgICAgICAgICAgIGxldCB0YWdSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjaCA9IG9uZU9mW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLiRyZWYpICYmICEoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2gsIGl0LnNlbGYuUlVMRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNjaC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKGl0LnNlbGYsIGl0LnNjaGVtYUVudi5yb290LCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2ggaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoID0gc2NoLnNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCByZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wU2NoID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnByb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0YWdOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BTY2ggIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHN1YnNjaGVtYXMgKG9yIHJlZmVyZW5jZWQgc2NoZW1hcykgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFnUmVxdWlyZWQgPSB0YWdSZXF1aXJlZCAmJiAodG9wUmVxdWlyZWQgfHwgaGFzUmVxdWlyZWQoc2NoKSk7XG4gICAgICAgICAgICAgICAgYWRkTWFwcGluZ3MocHJvcFNjaCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhZ1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgbXVzdCBiZSByZXF1aXJlZGApO1xuICAgICAgICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhc1JlcXVpcmVkKHsgcmVxdWlyZWQgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVpcmVkKSAmJiByZXF1aXJlZC5pbmNsdWRlcyh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2guY29uc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyhzY2guY29uc3QsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWdWYWx1ZSAhPSBcInN0cmluZ1wiIHx8IHRhZ1ZhbHVlIGluIG9uZU9mTWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSBzdHJpbmdzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uZU9mTWFwcGluZ1t0YWdWYWx1ZV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWlzc2luZ1JlZkVycm9yID0gZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLkFqdiA9IHZvaWQgMDtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCBkcmFmdDdfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kcmFmdDdcIik7XG5jb25zdCBkaXNjcmltaW5hdG9yXzEgPSByZXF1aXJlKFwiLi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvclwiKTtcbmNvbnN0IGRyYWZ0N01ldGFTY2hlbWEgPSByZXF1aXJlKFwiLi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb25cIik7XG5jb25zdCBNRVRBX1NVUFBPUlRfREFUQSA9IFtcIi9wcm9wZXJ0aWVzXCJdO1xuY29uc3QgTUVUQV9TQ0hFTUFfSUQgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hXCI7XG5jbGFzcyBBanYgZXh0ZW5kcyBjb3JlXzEuZGVmYXVsdCB7XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgc3VwZXIuX2FkZFZvY2FidWxhcmllcygpO1xuICAgICAgICBkcmFmdDdfMS5kZWZhdWx0LmZvckVhY2goKHYpID0+IHRoaXMuYWRkVm9jYWJ1bGFyeSh2KSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGlzY3JpbWluYXRvcilcbiAgICAgICAgICAgIHRoaXMuYWRkS2V5d29yZChkaXNjcmltaW5hdG9yXzEuZGVmYXVsdCk7XG4gICAgfVxuICAgIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpIHtcbiAgICAgICAgc3VwZXIuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1ldGFTY2hlbWEgPSB0aGlzLm9wdHMuJGRhdGFcbiAgICAgICAgICAgID8gdGhpcy4kZGF0YU1ldGFTY2hlbWEoZHJhZnQ3TWV0YVNjaGVtYSwgTUVUQV9TVVBQT1JUX0RBVEEpXG4gICAgICAgICAgICA6IGRyYWZ0N01ldGFTY2hlbWE7XG4gICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnJlZnNbXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYVwiXSA9IE1FVEFfU0NIRU1BX0lEO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPVxuICAgICAgICAgICAgc3VwZXIuZGVmYXVsdE1ldGEoKSB8fCAodGhpcy5nZXRTY2hlbWEoTUVUQV9TQ0hFTUFfSUQpID8gTUVUQV9TQ0hFTUFfSUQgOiB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnRzLkFqdiA9IEFqdjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEFqdjtcbm1vZHVsZS5leHBvcnRzLkFqdiA9IEFqdjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG52YXIgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsaWRhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0aW9uX2Vycm9yXzEuZGVmYXVsdDsgfSB9KTtcbnZhciByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWlzc2luZ1JlZkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWZfZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWp2LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IGV4cG9ydHMuZmFzdEZvcm1hdHMgPSBleHBvcnRzLmZ1bGxGb3JtYXRzID0gdm9pZCAwO1xuZnVuY3Rpb24gZm10RGVmKHZhbGlkYXRlLCBjb21wYXJlKSB7XG4gICAgcmV0dXJuIHsgdmFsaWRhdGUsIGNvbXBhcmUgfTtcbn1cbmV4cG9ydHMuZnVsbEZvcm1hdHMgPSB7XG4gICAgLy8gZGF0ZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGRhdGU6IGZtdERlZihkYXRlLCBjb21wYXJlRGF0ZSksXG4gICAgLy8gZGF0ZS10aW1lOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgdGltZTogZm10RGVmKGdldFRpbWUodHJ1ZSksIGNvbXBhcmVUaW1lKSxcbiAgICBcImRhdGUtdGltZVwiOiBmbXREZWYoZ2V0RGF0ZVRpbWUodHJ1ZSksIGNvbXBhcmVEYXRlVGltZSksXG4gICAgXCJpc28tdGltZVwiOiBmbXREZWYoZ2V0VGltZSgpLCBjb21wYXJlSXNvVGltZSksXG4gICAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSgpLCBjb21wYXJlSXNvRGF0ZVRpbWUpLFxuICAgIC8vIGR1cmF0aW9uOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1BXG4gICAgZHVyYXRpb246IC9eUCg/ISQpKChcXGQrWSk/KFxcZCtNKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/fChcXGQrVyk/KSQvLFxuICAgIHVyaSxcbiAgICBcInVyaS1yZWZlcmVuY2VcIjogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaSxcbiAgICAvLyB1cmktdGVtcGxhdGU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NTcwXG4gICAgXCJ1cmktdGVtcGxhdGVcIjogL14oPzooPzpbXlxceDAwLVxceDIwXCInPD4lXFxcXF5ge3x9XXwlWzAtOWEtZl17Mn0pfFxce1srIy4vOz8mPSwhQHxdPyg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8oPzosKD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPykqXFx9KSokL2ksXG4gICAgLy8gRm9yIHRoZSBzb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG4gICAgLy8gRm9yIHRlc3QgY2FzZXM6IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleFxuICAgIHVybDogL14oPzpodHRwcz98ZnRwKTpcXC9cXC8oPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKy0pKlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSspKD86XFwuKD86W2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKy0pKlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSspKig/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9XXsyLH0pKSkoPzo6XFxkezIsNX0pPyg/OlxcL1teXFxzXSopPyQvaXUsXG4gICAgZW1haWw6IC9eW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkAoPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/JC9pLFxuICAgIGhvc3RuYW1lOiAvXig/PS57MSwyNTN9XFwuPyQpW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbLTAtOWEtel17MCw2MX1bMC05YS16XSk/KSpcXC4/JC9pLFxuICAgIC8vIG9wdGltaXplZCBodHRwczovL3d3dy5zYWZhcmlib29rc29ubGluZS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MDU5NjgwMjgzNy9jaDA3czE2Lmh0bWxcbiAgICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkkLyxcbiAgICBpcHY2OiAvXigoKFswLTlhLWZdezEsNH06KXs3fShbMC05YS1mXXsxLDR9fDopKXwoKFswLTlhLWZdezEsNH06KXs2fSg6WzAtOWEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezV9KCgoOlswLTlhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezR9KCgoOlswLTlhLWZdezEsNH0pezEsM30pfCgoOlswLTlhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXszfSgoKDpbMC05YS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05YS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezJ9KCgoOlswLTlhLWZdezEsNH0pezEsNX0pfCgoOlswLTlhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7MX0oKCg6WzAtOWEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05YS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05YS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSQvaSxcbiAgICByZWdleCxcbiAgICAvLyB1dWlkOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG4gICAgdXVpZDogL14oPzp1cm46dXVpZDopP1swLTlhLWZdezh9LSg/OlswLTlhLWZdezR9LSl7M31bMC05YS1mXXsxMn0kL2ksXG4gICAgLy8gSlNPTi1wb2ludGVyOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICAgIC8vIHVyaSBmcmFnbWVudDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQVxuICAgIFwianNvbi1wb2ludGVyXCI6IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC8sXG4gICAgXCJqc29uLXBvaW50ZXItdXJpLWZyYWdtZW50XCI6IC9eIyg/OlxcLyg/OlthLXowLTlfXFwtLiEkJicoKSorLDs6PUBdfCVbMC05YS1mXXsyfXx+MHx+MSkqKSokL2ksXG4gICAgLy8gcmVsYXRpdmUgSlNPTi1wb2ludGVyOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1sdWZmLXJlbGF0aXZlLWpzb24tcG9pbnRlci0wMFxuICAgIFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCI6IC9eKD86MHxbMS05XVswLTldKikoPzojfCg/OlxcLyg/Oltefi9dfH4wfH4xKSopKikkLyxcbiAgICAvLyB0aGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHVzZWQgYnkgdGhlIG9wZW5hcGkgc3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9zcGVjLm9wZW5hcGlzLm9yZy9vYXMvdjMuMC4wI2RhdGEtdHlwZXNcbiAgICAvLyBieXRlOiBodHRwczovL2dpdGh1Yi5jb20vbWlndWVsbW90YS9pcy1iYXNlNjRcbiAgICBieXRlLFxuICAgIC8vIHNpZ25lZCAzMiBiaXQgaW50ZWdlclxuICAgIGludDMyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDMyIH0sXG4gICAgLy8gc2lnbmVkIDY0IGJpdCBpbnRlZ2VyXG4gICAgaW50NjQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50NjQgfSxcbiAgICAvLyBDLXR5cGUgZmxvYXRcbiAgICBmbG9hdDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBDLXR5cGUgZG91YmxlXG4gICAgZG91YmxlOiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIGhpbnQgdG8gdGhlIFVJIHRvIGhpZGUgaW5wdXQgc3RyaW5nc1xuICAgIHBhc3N3b3JkOiB0cnVlLFxuICAgIC8vIHVuY2hlY2tlZCBzdHJpbmcgcGF5bG9hZFxuICAgIGJpbmFyeTogdHJ1ZSxcbn07XG5leHBvcnRzLmZhc3RGb3JtYXRzID0ge1xuICAgIC4uLmV4cG9ydHMuZnVsbEZvcm1hdHMsXG4gICAgZGF0ZTogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkJC8sIGNvbXBhcmVEYXRlKSxcbiAgICB0aW1lOiBmbXREZWYoL14oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KSQvaSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZHQoPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KSQvaSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICBcImlzby10aW1lXCI6IGZtdERlZigvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSwgY29tcGFyZUlzb1RpbWUpLFxuICAgIFwiaXNvLWRhdGUtdGltZVwiOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGRbdFxcc10oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2ksIGNvbXBhcmVJc29EYXRlVGltZSksXG4gICAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59O1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuZnVsbEZvcm1hdHMpO1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IERBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IGRheSA9ICttYXRjaGVzWzNdO1xuICAgIHJldHVybiAobW9udGggPj0gMSAmJlxuICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICBkYXkgPj0gMSAmJlxuICAgICAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMSwgZDIpIHtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGQxID4gZDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChkMSA8IGQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKD86XFwuXFxkKyk/KSh6fChbKy1dKShcXGRcXGQpKD86Oj8oXFxkXFxkKSk/KT8kL2k7XG5mdW5jdGlvbiBnZXRUaW1lKHN0cmljdFRpbWVab25lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRpbWUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBUSU1FLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBociA9ICttYXRjaGVzWzFdO1xuICAgICAgICBjb25zdCBtaW4gPSArbWF0Y2hlc1syXTtcbiAgICAgICAgY29uc3Qgc2VjID0gK21hdGNoZXNbM107XG4gICAgICAgIGNvbnN0IHR6ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgY29uc3QgdHpTaWduID0gbWF0Y2hlc1s1XSA9PT0gXCItXCIgPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHR6SCA9ICsobWF0Y2hlc1s2XSB8fCAwKTtcbiAgICAgICAgY29uc3QgdHpNID0gKyhtYXRjaGVzWzddIHx8IDApO1xuICAgICAgICBpZiAodHpIID4gMjMgfHwgdHpNID4gNTkgfHwgKHN0cmljdFRpbWVab25lICYmICF0eikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChociA8PSAyMyAmJiBtaW4gPD0gNTkgJiYgc2VjIDwgNjApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gbGVhcCBzZWNvbmRcbiAgICAgICAgY29uc3QgdXRjTWluID0gbWluIC0gdHpNICogdHpTaWduO1xuICAgICAgICBjb25zdCB1dGNIciA9IGhyIC0gdHpIICogdHpTaWduIC0gKHV0Y01pbiA8IDAgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiAodXRjSHIgPT09IDIzIHx8IHV0Y0hyID09PSAtMSkgJiYgKHV0Y01pbiA9PT0gNTkgfHwgdXRjTWluID09PSAtMSkgJiYgc2VjIDwgNjE7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVUaW1lKHMxLCBzMikge1xuICAgIGlmICghKHMxICYmIHMyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCB0MSA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMxKS52YWx1ZU9mKCk7XG4gICAgY29uc3QgdDIgPSBuZXcgRGF0ZShcIjIwMjAtMDEtMDFUXCIgKyBzMikudmFsdWVPZigpO1xuICAgIGlmICghKHQxICYmIHQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdDEgLSB0Mjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJc29UaW1lKHQxLCB0Mikge1xuICAgIGlmICghKHQxICYmIHQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBhMSA9IFRJTUUuZXhlYyh0MSk7XG4gICAgY29uc3QgYTIgPSBUSU1FLmV4ZWModDIpO1xuICAgIGlmICghKGExICYmIGEyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0MSA9IGExWzFdICsgYTFbMl0gKyBhMVszXTtcbiAgICB0MiA9IGEyWzFdICsgYTJbMl0gKyBhMlszXTtcbiAgICBpZiAodDEgPiB0MilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHQxIDwgdDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IERBVEVfVElNRV9TRVBBUkFUT1IgPSAvdHxcXHMvaTtcbmZ1bmN0aW9uIGdldERhdGVUaW1lKHN0cmljdFRpbWVab25lKSB7XG4gICAgY29uc3QgdGltZSA9IGdldFRpbWUoc3RyaWN0VGltZVpvbmUpO1xuICAgIHJldHVybiBmdW5jdGlvbiBkYXRlX3RpbWUoc3RyKSB7XG4gICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICAgICAgY29uc3QgZGF0ZVRpbWUgPSBzdHIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgICAgIHJldHVybiBkYXRlVGltZS5sZW5ndGggPT09IDIgJiYgZGF0ZShkYXRlVGltZVswXSkgJiYgdGltZShkYXRlVGltZVsxXSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlVGltZShkdDEsIGR0Mikge1xuICAgIGlmICghKGR0MSAmJiBkdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGQxID0gbmV3IERhdGUoZHQxKS52YWx1ZU9mKCk7XG4gICAgY29uc3QgZDIgPSBuZXcgRGF0ZShkdDIpLnZhbHVlT2YoKTtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGQxIC0gZDI7XG59XG5mdW5jdGlvbiBjb21wYXJlSXNvRGF0ZVRpbWUoZHQxLCBkdDIpIHtcbiAgICBpZiAoIShkdDEgJiYgZHQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBbZDEsIHQxXSA9IGR0MS5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICBjb25zdCBbZDIsIHQyXSA9IGR0Mi5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICBjb25zdCByZXMgPSBjb21wYXJlRGF0ZShkMSwgZDIpO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzIHx8IGNvbXBhcmVUaW1lKHQxLCB0Mik7XG59XG5jb25zdCBOT1RfVVJJX0ZSQUdNRU5UID0gL1xcL3w6LztcbmNvbnN0IFVSSSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5mdW5jdGlvbiB1cmkoc3RyKSB7XG4gICAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgICByZXR1cm4gTk9UX1VSSV9GUkFHTUVOVC50ZXN0KHN0cikgJiYgVVJJLnRlc3Qoc3RyKTtcbn1cbmNvbnN0IEJZVEUgPSAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC9nbTtcbmZ1bmN0aW9uIGJ5dGUoc3RyKSB7XG4gICAgQllURS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBCWVRFLnRlc3Qoc3RyKTtcbn1cbmNvbnN0IE1JTl9JTlQzMiA9IC0oMiAqKiAzMSk7XG5jb25zdCBNQVhfSU5UMzIgPSAyICoqIDMxIC0gMTtcbmZ1bmN0aW9uIHZhbGlkYXRlSW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPD0gTUFYX0lOVDMyICYmIHZhbHVlID49IE1JTl9JTlQzMjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSW50NjQodmFsdWUpIHtcbiAgICAvLyBKU09OIGFuZCBqYXZhc2NyaXB0IG1heCBJbnQgaXMgMioqNTMsIHNvIGFueSBpbnQgdGhhdCBwYXNzZXMgaXNJbnRlZ2VyIGlzIHZhbGlkIGZvciBJbnQ2NFxuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgWl9BTkNIT1IgPSAvW15cXFxcXVxcXFxaLztcbmZ1bmN0aW9uIHJlZ2V4KHN0cikge1xuICAgIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHN0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0gdm9pZCAwO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG9wcyA9IGNvZGVnZW5fMS5vcGVyYXRvcnM7XG5jb25zdCBLV0RzID0ge1xuICAgIGZvcm1hdE1heGltdW06IHsgb2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVCB9LFxuICAgIGZvcm1hdE1pbmltdW06IHsgb2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVCB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1heGltdW06IHsgb2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWluaW11bTogeyBva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEUgfSxcbn07XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgc2hvdWxkIGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZkN4dCA9IG5ldyBhanZfMS5LZXl3b3JkQ3h0KGl0LCBzZWxmLlJVTEVTLmFsbC5mb3JtYXQuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIik7XG4gICAgICAgIGlmIChmQ3h0LiRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdHN9WyR7ZkN4dC5zY2hlbWFDb2RlfV1gKTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5vcikoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9IGluc3RhbmNlb2YgUmVnRXhwYCwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7Zm10fS5jb21wYXJlICE9IFwiZnVuY3Rpb25cImAsIGNvbXBhcmVDb2RlKGZtdCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGZDeHQuc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgZm10RGVmID0gc2VsZi5mb3JtYXRzW2Zvcm1hdF07XG4gICAgICAgICAgICBpZiAoIWZtdERlZiB8fCBmbXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgIGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBmbXREZWYuY29tcGFyZSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl3b3JkfVwiOiBmb3JtYXQgXCIke2Zvcm1hdH1cIiBkb2VzIG5vdCBkZWZpbmUgXCJjb21wYXJlXCIgZnVuY3Rpb25gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAga2V5OiBmb3JtYXQsXG4gICAgICAgICAgICAgICAgcmVmOiBmbXREZWYsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMgPyAoMCwgY29kZWdlbl8xLl8pIGAke29wdHMuY29kZS5mb3JtYXRzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoZm9ybWF0KX1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvbXBhcmVDb2RlKGZtdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVDb2RlKGZtdCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10fS5jb21wYXJlKCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pICR7S1dEc1trZXl3b3JkXS5mYWlsfSAwYDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbXCJmb3JtYXRcIl0sXG59O1xuY29uc3QgZm9ybWF0TGltaXRQbHVnaW4gPSAoYWp2KSA9PiB7XG4gICAgYWp2LmFkZEtleXdvcmQoZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24pO1xuICAgIHJldHVybiBhanY7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0TGltaXRQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdHNfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHNcIik7XG5jb25zdCBsaW1pdF8xID0gcmVxdWlyZShcIi4vbGltaXRcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZnVsbE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmdWxsRm9ybWF0c1wiKTtcbmNvbnN0IGZhc3ROYW1lID0gbmV3IGNvZGVnZW5fMS5OYW1lKFwiZmFzdEZvcm1hdHNcIik7XG5jb25zdCBmb3JtYXRzUGx1Z2luID0gKGFqdiwgb3B0cyA9IHsga2V5d29yZHM6IHRydWUgfSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIGFkZEZvcm1hdHMoYWp2LCBvcHRzLCBmb3JtYXRzXzEuZnVsbEZvcm1hdHMsIGZ1bGxOYW1lKTtcbiAgICAgICAgcmV0dXJuIGFqdjtcbiAgICB9XG4gICAgY29uc3QgW2Zvcm1hdHMsIGV4cG9ydE5hbWVdID0gb3B0cy5tb2RlID09PSBcImZhc3RcIiA/IFtmb3JtYXRzXzEuZmFzdEZvcm1hdHMsIGZhc3ROYW1lXSA6IFtmb3JtYXRzXzEuZnVsbEZvcm1hdHMsIGZ1bGxOYW1lXTtcbiAgICBjb25zdCBsaXN0ID0gb3B0cy5mb3JtYXRzIHx8IGZvcm1hdHNfMS5mb3JtYXROYW1lcztcbiAgICBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZm9ybWF0cywgZXhwb3J0TmFtZSk7XG4gICAgaWYgKG9wdHMua2V5d29yZHMpXG4gICAgICAgICgwLCBsaW1pdF8xLmRlZmF1bHQpKGFqdik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5mb3JtYXRzUGx1Z2luLmdldCA9IChuYW1lLCBtb2RlID0gXCJmdWxsXCIpID0+IHtcbiAgICBjb25zdCBmb3JtYXRzID0gbW9kZSA9PT0gXCJmYXN0XCIgPyBmb3JtYXRzXzEuZmFzdEZvcm1hdHMgOiBmb3JtYXRzXzEuZnVsbEZvcm1hdHM7XG4gICAgY29uc3QgZiA9IGZvcm1hdHNbbmFtZV07XG4gICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZm9ybWF0IFwiJHtuYW1lfVwiYCk7XG4gICAgcmV0dXJuIGY7XG59O1xuZnVuY3Rpb24gYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZzLCBleHBvcnROYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICAoX2EgPSAoX2IgPSBhanYub3B0cy5jb2RlKS5mb3JtYXRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IuZm9ybWF0cyA9ICgwLCBjb2RlZ2VuXzEuXykgYHJlcXVpcmUoXCJhanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHNcIikuJHtleHBvcnROYW1lfWApO1xuICAgIGZvciAoY29uc3QgZiBvZiBsaXN0KVxuICAgICAgICBhanYuYWRkRm9ybWF0KGYsIGZzW2ZdKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZvcm1hdHNQbHVnaW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRzUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnNcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBrZXl3b3JkID0gXCJlcnJvck1lc3NhZ2VcIjtcbmNvbnN0IHVzZWQgPSBuZXcgYWp2XzEuTmFtZShcImVtVXNlZFwiKTtcbmNvbnN0IEtFWVdPUkRfUFJPUEVSVFlfUEFSQU1TID0ge1xuICAgIHJlcXVpcmVkOiBcIm1pc3NpbmdQcm9wZXJ0eVwiLFxuICAgIGRlcGVuZGVuY2llczogXCJwcm9wZXJ0eVwiLFxuICAgIGRlcGVuZGVudFJlcXVpcmVkOiBcInByb3BlcnR5XCIsXG59O1xuY29uc3QgSU5URVJQT0xBVElPTiA9IC9cXCRcXHtbXn1dK1xcfS87XG5jb25zdCBJTlRFUlBPTEFUSU9OX1JFUExBQ0UgPSAvXFwkXFx7KFtefV0rKVxcfS9nO1xuY29uc3QgRU1QVFlfU1RSID0gL15cIlwiXFxzKlxcK1xccyp8XFxzKlxcK1xccypcIlwiJC9nO1xuZnVuY3Rpb24gZXJyb3JNZXNzYWdlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJvYmplY3RcIl0sXG4gICAgICAgIHBvc3Q6IHRydWUsXG4gICAgICAgIGNvZGUoY3h0KSB7XG4gICAgICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlUGF0aCA9IGNvZGVnZW5fMS5zdHJDb25jYXQobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgaXQuZXJyb3JQYXRoKTtcbiAgICAgICAgICAgIGdlbi5pZihhanZfMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID4gMGAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrd2RQcm9wRXJyb3JzLCBrd2RFcnJvcnNdID0ga2V5d29yZEVycm9yc0NvbmZpZyhzY2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa3dkRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0tleXdvcmRFcnJvcnMoa3dkRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGt3ZFByb3BFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzS2V5d29yZFByb3BFcnJvcnMoa3dkUHJvcEVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDaGlsZEVycm9ycyhjaGlsZEVycm9yc0NvbmZpZyhzY2gpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoTWVzc2FnZSA9IHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIiA/IHNjaCA6IHNjaC5fO1xuICAgICAgICAgICAgICAgIGlmIChzY2hNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQWxsRXJyb3JzKHNjaE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVVc2VkRXJyb3JzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoaWxkRXJyb3JzQ29uZmlnKHsgcHJvcGVydGllcywgaXRlbXMgfSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgaW4gcHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wcm9wc1twXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLml0ZW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuaXRlbXNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGtleXdvcmRFcnJvcnNDb25maWcoZW1TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcEVycm9ycztcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JzO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBlbVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gXCJwcm9wZXJ0aWVzXCIgfHwgayA9PT0gXCJpdGVtc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGt3ZFNjaCA9IGVtU2NoZW1hW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGt3ZFNjaCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wRXJyb3JzIHx8IChwcm9wRXJyb3JzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTWFwID0gKHByb3BFcnJvcnNba10gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgaW4ga3dkU2NoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1hcFtwXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzIHx8IChlcnJvcnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnNba10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3Byb3BFcnJvcnMsIGVycm9yc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzS2V5d29yZEVycm9ycyhrd2RFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrd2RFcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJvcnNcIiwgYWp2XzEuc3RyaW5naWZ5KGt3ZEVycm9ycykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IGdlbi5jb25zdChcInRlbXBsYXRlc1wiLCBnZXRUZW1wbGF0ZXNDb2RlKGt3ZEVycm9ycywgc2NoZW1hKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtrd2RFcnJzfVske2Vycn0ua2V5d29yZF0ucHVzaCgke2Vycn0pYCkuYXNzaWduKGFqdl8xLl8gYCR7ZXJyfS4ke3VzZWR9YCwgdHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNpbmdsZUVycm9yIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2VuLmxldChcIm1lc3NhZ2VcIiwgYWp2XzEuXyBgXCJcImApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNFcnJvcnMgPSBnZW4ubGV0KFwicGFyYW1zRXJyb3JzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgICAgIGxvb3BFcnJvcnMoKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKG1lc3NhZ2UsICgpID0+IGdlbi5jb2RlKGFqdl8xLl8gYCR7bWVzc2FnZX0gKz0gJHt0eXBlb2Ygc2luZ2xlRXJyb3IgPT0gXCJzdHJpbmdcIiA/IHNpbmdsZUVycm9yIDogXCI7XCJ9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmNvZGUoYWp2XzEuXyBgJHttZXNzYWdlfSArPSAke2Vyck1lc3NhZ2Uoa2V5KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFyYW1zRXJyb3JzLCBhanZfMS5fIGAke3BhcmFtc0Vycm9yc30uY29uY2F0KCR7a3dkRXJyc31bJHtrZXl9XSlgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwgeyBtZXNzYWdlLCBwYXJhbXM6IGFqdl8xLl8gYHtlcnJvcnM6ICR7cGFyYW1zRXJyb3JzfX1gIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcEVycm9ycygoa2V5KSA9PiBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1lc3NhZ2Uoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtrd2RFcnJzfVske2tleX1dfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbG9vcEVycm9ycyhib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBrd2RFcnJzLCAoa2V5KSA9PiBnZW4uaWYoYWp2XzEuXyBgJHtrd2RFcnJzfVske2tleX1dLmxlbmd0aGAsICgpID0+IGJvZHkoa2V5KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlcnJNZXNzYWdlKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWp2XzEuXyBgJHtrZXl9IGluICR7dGVtcGxhdGVzfSA/ICR7dGVtcGxhdGVzfVske2tleX1dKCkgOiAke3NjaGVtYVZhbHVlfVske2tleX1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzS2V5d29yZFByb3BFcnJvcnMoa3dkUHJvcEVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZEVycnMgPSBnZW4uY29uc3QoXCJlbUVycm9yc1wiLCBhanZfMS5zdHJpbmdpZnkoa3dkUHJvcEVycm9ycykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlc0NvZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4ga3dkUHJvcEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNDb2RlLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFRlbXBsYXRlc0NvZGUoa3dkUHJvcEVycm9yc1trXSwgc2NoZW1hW2tdKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IGdlbi5jb25zdChcInRlbXBsYXRlc1wiLCBnZW4ub2JqZWN0KC4uLnRlbXBsYXRlc0NvZGUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrd2RQcm9wUGFyYW1zID0gZ2VuLnNjb3BlVmFsdWUoXCJvYmpcIiwge1xuICAgICAgICAgICAgICAgICAgICByZWY6IEtFWVdPUkRfUFJPUEVSVFlfUEFSQU1TLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBhanZfMS5zdHJpbmdpZnkoS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BQYXJhbSA9IGdlbi5sZXQoXCJlbVByb3BQYXJhbXNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zRXJyb3JzID0gZ2VuLmxldChcImVtUGFyYW1zRXJyb3JzXCIpO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JPZihcImVyclwiLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKGVycikgPT4gZ2VuLmlmKG1hdGNoS2V5d29yZEVycm9yKGVyciwga3dkRXJycyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwcm9wUGFyYW0sIGFqdl8xLl8gYCR7a3dkUHJvcFBhcmFtc31bJHtlcnJ9LmtleXdvcmRdYCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFyYW1zRXJyb3JzLCBhanZfMS5fIGAke2t3ZEVycnN9WyR7ZXJyfS5rZXl3b3JkXVske2Vycn0ucGFyYW1zWyR7cHJvcFBhcmFtfV1dYCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihwYXJhbXNFcnJvcnMsICgpID0+IGdlbi5jb2RlKGFqdl8xLl8gYCR7cGFyYW1zRXJyb3JzfS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBrd2RFcnJzLCAoa2V5KSA9PiBnZW4uZm9ySW4oXCJrZXlQcm9wXCIsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtrZXl9XWAsIChrZXlQcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFyYW1zRXJyb3JzLCBhanZfMS5fIGAke2t3ZEVycnN9WyR7a2V5fV1bJHtrZXlQcm9wfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7cGFyYW1zRXJyb3JzfS5sZW5ndGhgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXBsID0gZ2VuLmNvbnN0KFwidG1wbFwiLCBhanZfMS5fIGAke3RlbXBsYXRlc31bJHtrZXl9XSAmJiAke3RlbXBsYXRlc31bJHtrZXl9XVske2tleVByb3B9XWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWp2XzEuXyBgJHt0bXBsfSA/ICR7dG1wbH0oKSA6ICR7c2NoZW1hVmFsdWV9WyR7a2V5fV1bJHtrZXlQcm9wfV1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtwYXJhbXNFcnJvcnN9fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0NoaWxkRXJyb3JzKGNoaWxkRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgaXRlbXMgfSA9IGNoaWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMgJiYgIWl0ZW1zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPYmogPSBhanZfMS5fIGB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiYDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FyciA9IGFqdl8xLl8gYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkRXJycyA9IGdlbi5sZXQoXCJlbUVycm9yc1wiKTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRLd2Q7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkUHJvcDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZXMgPSBnZW4ubGV0KFwidGVtcGxhdGVzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcyAmJiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEt3ZCA9IGdlbi5sZXQoXCJlbUNoaWxkS3dkXCIpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoaXNPYmopO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoaXNBcnIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQoaXRlbXMsIHNjaGVtYS5pdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNoaWxkS3dkLCBhanZfMS5zdHIgYGl0ZW1zYCk7XG4gICAgICAgICAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQocHJvcHMsIHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRLd2QsIGFqdl8xLnN0ciBgcHJvcGVydGllc2ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgWyR7Y2hpbGRLd2R9XWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0Fycik7XG4gICAgICAgICAgICAgICAgICAgIGluaXQoaXRlbXMsIHNjaGVtYS5pdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcCA9IGFqdl8xLl8gYC5pdGVtc2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuYW5kKGlzT2JqLCBjb2RlZ2VuXzEubm90KGlzQXJyKSkpO1xuICAgICAgICAgICAgICAgICAgICBpbml0KHByb3BzLCBzY2hlbWEucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcCA9IGFqdl8xLl8gYC5wcm9wZXJ0aWVzYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBpZk1hdGNoZXNDaGlsZEVycm9yKGVyciwgY2hpbGRFcnJzLCAoY2hpbGQpID0+IGdlbi5jb2RlKGFqdl8xLl8gYCR7Y2hpbGRFcnJzfVske2NoaWxkfV0ucHVzaCgke2Vycn0pYCkuYXNzaWduKGFqdl8xLl8gYCR7ZXJyfS4ke3VzZWR9YCwgdHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgY2hpbGRFcnJzLCAoa2V5KSA9PiBnZW4uaWYoYWp2XzEuXyBgJHtjaGlsZEVycnN9WyR7a2V5fV0ubGVuZ3RoYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFqdl8xLl8gYCR7a2V5fSBpbiAke3RlbXBsYXRlc30gPyAke3RlbXBsYXRlc31bJHtrZXl9XSgpIDogJHtzY2hlbWFWYWx1ZX0ke2NoaWxkUHJvcH1bJHtrZXl9XWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGFqdl8xLl8gYHtlcnJvcnM6ICR7Y2hpbGRFcnJzfVske2tleX1dfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGFqdl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9WyR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30tMV0uaW5zdGFuY2VQYXRoYCwgYWp2XzEuXyBgJHtpbnN0YW5jZVBhdGh9ICsgXCIvXCIgKyAke2tleX0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5pdChjaGlsZHJlbiwgbXNncykge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNoaWxkRXJycywgYWp2XzEuc3RyaW5naWZ5KGNoaWxkcmVuKSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odGVtcGxhdGVzLCBnZXRUZW1wbGF0ZXNDb2RlKGNoaWxkcmVuLCBtc2dzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0FsbEVycm9ycyhzY2hNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJycyA9IGdlbi5jb25zdChcImVtRXJyc1wiLCBhanZfMS5fIGBbXWApO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JPZihcImVyclwiLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKGVycikgPT4gZ2VuLmlmKG1hdGNoQW55RXJyb3IoZXJyKSwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtlcnJzfS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5pZihhanZfMS5fIGAke2VycnN9Lmxlbmd0aGAsICgpID0+IGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0ZW1wbGF0ZUV4cHIoc2NoTWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtlcnJzfX1gLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZVVzZWRFcnJvcnMoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJycyA9IGdlbi5jb25zdChcImVtRXJyc1wiLCBhanZfMS5fIGBbXWApO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JPZihcImVyclwiLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKGVycikgPT4gZ2VuLmlmKGFqdl8xLl8gYCEke2Vycn0uJHt1c2VkfWAsICgpID0+IGdlbi5jb2RlKGFqdl8xLl8gYCR7ZXJyc30ucHVzaCgke2Vycn0pYCkpKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBlcnJzKS5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgYWp2XzEuXyBgJHtlcnJzfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZEVycm9yKGVyciwga3dkRXJycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuYW5kKGFqdl8xLl8gYCR7ZXJyfS5rZXl3b3JkICE9PSAke2tleXdvcmR9YCwgYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgYWp2XzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aCA9PT0gJHtpbnN0YW5jZVBhdGh9YCwgYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgaW4gJHtrd2RFcnJzfWAsIFxuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF0Y2ggdGhlIGVuZCBvZiB0aGUgc3RyaW5nP1xuICAgICAgICAgICAgICAgIGFqdl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoLmluZGV4T2YoJHtpdC5lcnJTY2hlbWFQYXRofSkgPT09IDBgLCBhanZfMS5fIGAvXlxcXFwvW15cXFxcL10qJC8udGVzdCgke2Vycn0uc2NoZW1hUGF0aC5zbGljZSgke2l0LmVyclNjaGVtYVBhdGgubGVuZ3RofSkpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpZk1hdGNoZXNDaGlsZEVycm9yKGVyciwgY2hpbGRFcnJzLCB0aGVuQm9keSkge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuYW5kKGFqdl8xLl8gYCR7ZXJyfS5rZXl3b3JkICE9PSAke2tleXdvcmR9YCwgYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgYWp2XzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aC5pbmRleE9mKCR7aW5zdGFuY2VQYXRofSkgPT09IDBgKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlZ2V4ID0gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogL15cXC8oW14vXSopKD86XFwvfCQpLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGFqdl8xLl8gYG5ldyBSZWdFeHAoXCJeXFxcXFxcLyhbXi9dKikoPzpcXFxcXFwvfCQpXCIpYCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBnZW4uY29uc3QoXCJlbU1hdGNoZXNcIiwgYWp2XzEuXyBgJHtjaGlsZFJlZ2V4fS5leGVjKCR7ZXJyfS5pbnN0YW5jZVBhdGguc2xpY2UoJHtpbnN0YW5jZVBhdGh9Lmxlbmd0aCkpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gZ2VuLmNvbnN0KFwiZW1DaGlsZFwiLCBhanZfMS5fIGAke21hdGNoZXN9ICYmICR7bWF0Y2hlc31bMV0ucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKWApO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoYWp2XzEuXyBgJHtjaGlsZH0gIT09IHVuZGVmaW5lZCAmJiAke2NoaWxkfSBpbiAke2NoaWxkRXJyc31gLCAoKSA9PiB0aGVuQm9keShjaGlsZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hBbnlFcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLmFuZChhanZfMS5fIGAke2Vycn0ua2V5d29yZCAhPT0gJHtrZXl3b3JkfWAsIGFqdl8xLl8gYCEke2Vycn0uJHt1c2VkfWAsIGNvZGVnZW5fMS5vcihhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSAke2luc3RhbmNlUGF0aH1gLCBjb2RlZ2VuXzEuYW5kKGFqdl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGguaW5kZXhPZigke2luc3RhbmNlUGF0aH0pID09PSAwYCwgYWp2XzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aFske2luc3RhbmNlUGF0aH0ubGVuZ3RoXSA9PT0gXCIvXCJgKSksIGFqdl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoLmluZGV4T2YoJHtpdC5lcnJTY2hlbWFQYXRofSkgPT09IDBgLCBhanZfMS5fIGAke2Vycn0uc2NoZW1hUGF0aFske2l0LmVyclNjaGVtYVBhdGh9Lmxlbmd0aF0gPT09IFwiL1wiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRUZW1wbGF0ZXNDb2RlKGtleXMsIG1zZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZXNDb2RlID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gbXNnc1trXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKElOVEVSUE9MQVRJT04udGVzdChtc2cpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzQ29kZS5wdXNoKFtrLCB0ZW1wbGF0ZUZ1bmMobXNnKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuLm9iamVjdCguLi50ZW1wbGF0ZXNDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRlbXBsYXRlRXhwcihtc2cpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUlOVEVSUE9MQVRJT04udGVzdChtc2cpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWp2XzEuc3RyaW5naWZ5KG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoY29kZV8xLnNhZmVTdHJpbmdpZnkobXNnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShJTlRFUlBPTEFUSU9OX1JFUExBQ0UsIChfcywgcHRyKSA9PiBgXCIgKyBKU09OLnN0cmluZ2lmeSgke3ZhbGlkYXRlXzEuZ2V0RGF0YShwdHIsIGl0KX0pICsgXCJgKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShFTVBUWV9TVFIsIFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRlbXBsYXRlRnVuYyhtc2cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWp2XzEuXyBgZnVuY3Rpb24oKXtyZXR1cm4gJHt0ZW1wbGF0ZUV4cHIobXNnKX19YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWV0YVNjaGVtYToge1xuICAgICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgJHJlZjogXCIjLyRkZWZzL3N0cmluZ01hcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTGlzdFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nT3JNYXBcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdPck1hcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICRkZWZzOiB7XG4gICAgICAgICAgICAgICAgc3RyaW5nTWFwOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cmluZ09yTWFwOiB7XG4gICAgICAgICAgICAgICAgICAgIGFueU9mOiBbeyB0eXBlOiBcInN0cmluZ1wiIH0sIHsgJHJlZjogXCIjLyRkZWZzL3N0cmluZ01hcFwiIH1dLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5nTGlzdDogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuY29uc3QgYWp2RXJyb3JzID0gKGFqdiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKCFhanYub3B0cy5hbGxFcnJvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi1lcnJvcnM6IEFqdiBvcHRpb24gYWxsRXJyb3JzIG11c3QgYmUgdHJ1ZVwiKTtcbiAgICBpZiAoYWp2Lm9wdHMuanNQcm9wZXJ0eVN5bnRheCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYtZXJyb3JzOiBhanYgb3B0aW9uIGpzUHJvcGVydHlTeW50YXggaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFqdi5hZGRLZXl3b3JkKGVycm9yTWVzc2FnZShvcHRpb25zKSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYWp2RXJyb3JzO1xubW9kdWxlLmV4cG9ydHMgPSBhanZFcnJvcnM7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYWp2RXJyb3JzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IEFqdiwge1xuICBPcHRpb25zLFxuICBFcnJvck9iamVjdCxcbiAgRXJyb3JzVGV4dE9wdGlvbnMsXG4gIEFueVNjaGVtYU9iamVjdCxcbn0gZnJvbSBcImFqdlwiO1xuaW1wb3J0IGFkZEZvcm1hdHMgZnJvbSBcImFqdi1mb3JtYXRzXCI7XG5pbXBvcnQgYWRkRXJyb3JzIGZyb20gXCJhanYtZXJyb3JzXCI7XG5pbXBvcnQgeyBNZXNzYWdlU2NoZW1hLCBUeXBlZElucHV0U2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hc1wiO1xuXG5jbGFzcyBWYWxpZGF0b3JTZXJ2aWNlIHtcbiAgYWp2OiBBanY7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IE9wdGlvbnMpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIklOU0lERSBDT05TVFJVQ1RPUiBPRiBWQUxJREFUT1IgU0VSVklDRVwiKTtcbiAgICB0aGlzLmFqdiA9IG5ldyBBanYoe1xuICAgICAgYWxsRXJyb3JzOiB0cnVlLFxuICAgICAgdXNlRGVmYXVsdHM6IFwiZW1wdHlcIixcbiAgICAgIHZlcmJvc2U6IHRydWUsXG4gICAgICB2YWxpZGF0ZUZvcm1hdHM6IHRydWUsXG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBjb2VyY2VUeXBlczogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZyh0aGlzLmFqdi5zY2hlbWFzKTtcblxuICAgIC8vIE5PVEU6IHRoaXMgcGx1Z2luIGVuYWJsZXMgdXNlcnMgdG8gdXNlIGZvcm1hdHMga2V5d29yZFxuICAgIGFkZEZvcm1hdHModGhpcy5hanYpO1xuXG4gICAgLy8gTk9URTsgdGhpcyBwbHVnaW4gZW5hYmxlcyB1c2VycyB0byBkZWNsYXJlIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICAgIGFkZEVycm9ycyh0aGlzLmFqdik7XG5cbiAgICB0aGlzLmFqdi5hZGRLZXl3b3JkKFwibm9kZVR5cGVcIik7XG4gIH1cblxuICBjcmVhdGVWYWxpZGF0b3Ioc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIklOU0lERSBDUkVBVEVWQUxJREFUT1JcIik7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5hanYuc2NoZW1hcyk7XG4gICAgcmV0dXJuIHRoaXMuYWp2LmNvbXBpbGUoc2NoZW1hKTtcbiAgfVxuXG4gIGVycm9ycyhcbiAgICBlcnJvcnM/OiBFcnJvck9iamVjdFtdIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zPzogRXJyb3JzVGV4dE9wdGlvbnNcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuYWp2LmVycm9yc1RleHQoZXJyb3JzLCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgeyBWYWxpZGF0b3JTZXJ2aWNlIH07XG4iLCJpbXBvcnQgeyBWYWxpZGF0b3JTZXJ2aWNlIH0gZnJvbSBcIi4uL3ZhbGlkYXRvci1zZXJ2aWNlXCI7XG4vLyBOT1RFOiBzaW5nbGV0b24gdG8gdXNlIGFqdiBjYWNoaW5nIGZlYXR1cmVzXG5jb25zdCB2YWxpZGF0b3JTZXJ2aWNlID0gbmV3IFZhbGlkYXRvclNlcnZpY2UoKTtcblxuZXhwb3J0IHsgdmFsaWRhdG9yU2VydmljZSB9O1xuIiwiaW1wb3J0ICQgZnJvbSBcImpxdWVyeVwiO1xuaW1wb3J0IHsgY3JlYXRlQXBwLCBDb21wb25lbnQsIEFwcCwgZGVmaW5lQ29tcG9uZW50IH0gZnJvbSBcInZ1ZVwiO1xuaW1wb3J0IHsgY2xvbmVEZWVwLCBpc0VxdWFsLCBtZXJnZSB9IGZyb20gXCJlcy10b29sa2l0XCI7XG5pbXBvcnQgeyBBbnlTY2hlbWEsIFZhbGlkYXRlRnVuY3Rpb24gfSBmcm9tIFwiYWp2XCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0c0Zyb21TY2hlbWEsIGdldENyZWRlbnRpYWxzRnJvbVNjaGVtYSB9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5pbXBvcnQgTm9kZVJlZFZ1ZUFwcCBmcm9tIFwiLi9BcHAudnVlXCI7XG5pbXBvcnQgTm9kZVJlZElucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZElucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRUeXBlZElucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZFR5cGVkSW5wdXQudnVlXCI7XG5pbXBvcnQgTm9kZVJlZENvbmZpZ0lucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZENvbmZpZ0lucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRTZWxlY3RJbnB1dCBmcm9tIFwiLi9jb21wb25lbnRzL05vZGVSZWRTZWxlY3RJbnB1dC52dWVcIjtcbmltcG9ydCBOb2RlUmVkRWRpdG9ySW5wdXQgZnJvbSBcIi4vY29tcG9uZW50cy9Ob2RlUmVkRWRpdG9ySW5wdXQudnVlXCI7XG5cbmltcG9ydCB7IHZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi92YWxpZGF0b3JcIjtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZVJlZFZ1ZUFwcChcbiAgbm9kZTogYW55LFxuICBmb3JtOiBJTm9kZUZvcm0sXG4gIHZhbGlkYXRvcjogVmFsaWRhdGVGdW5jdGlvbiB8ICgoKSA9PiBib29sZWFuKVxuKTogQXBwPEVsZW1lbnQ+IHtcbiAgY29uc3QgYXBwID0gY3JlYXRlQXBwKE5vZGVSZWRWdWVBcHAsIHtcbiAgICBub2RlLFxuICAgIHZhbGlkYXRvcixcbiAgICBkaXNhYmxlU2F2ZUJ1dHRvbk9uRXJyb3I6IGZvcm0uZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yLFxuICB9KTtcblxuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZElucHV0XCIsIE5vZGVSZWRJbnB1dCk7XG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkVHlwZWRJbnB1dFwiLCBOb2RlUmVkVHlwZWRJbnB1dCk7XG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkQ29uZmlnSW5wdXRcIiwgTm9kZVJlZENvbmZpZ0lucHV0KTtcbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRTZWxlY3RJbnB1dFwiLCBOb2RlUmVkU2VsZWN0SW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZEVkaXRvcklucHV0XCIsIE5vZGVSZWRFZGl0b3JJbnB1dCk7XG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkTm9kZUZvcm1cIiwgZm9ybS5jb21wb25lbnQpO1xuICByZXR1cm4gYXBwO1xufVxuXG5mdW5jdGlvbiBtb3VudEFwcChcbiAgbm9kZTogYW55LFxuICBmb3JtOiBJTm9kZUZvcm0sXG4gIHZhbGlkYXRvcjogVmFsaWRhdGVGdW5jdGlvbiB8ICgoKSA9PiBib29sZWFuKVxuKSB7XG4gICQoXCIjYXBwXCIpLmVtcHR5KCk7XG4gIG5vZGUuX25ld1N0YXRlID0gY2xvbmVEZWVwKG5vZGUpO1xuICBub2RlLl9hcHAgPSBjcmVhdGVOb2RlUmVkVnVlQXBwKG5vZGUuX25ld1N0YXRlLCBmb3JtLCB2YWxpZGF0b3IpO1xuICBub2RlLl9hcHAubW91bnQoXCIjYXBwXCIpO1xufVxuXG5mdW5jdGlvbiB1bm1vdW50QXBwKG5vZGU6IGFueSkge1xuICBpZiAobm9kZS5fYXBwKSB7XG4gICAgbm9kZS5fYXBwLnVubW91bnQoKTtcbiAgICBub2RlLl9hcHAgPSBudWxsO1xuICB9XG59XG5cbmludGVyZmFjZSBJQ3JlZGVudGlhbHMge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmludGVyZmFjZSBJTm9kZVN0YXRlIHtcbiAgY3JlZGVudGlhbHM6IElDcmVkZW50aWFscztcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5mdW5jdGlvbiBnZXROb2RlU3RhdGUobm9kZTogYW55KTogSU5vZGVTdGF0ZSB7XG4gIGNvbnN0IHN0YXRlOiBJTm9kZVN0YXRlID0ge1xuICAgIGNyZWRlbnRpYWxzOiB7fSxcbiAgfTtcbiAgT2JqZWN0LmtleXMobm9kZS5fZGVmLmRlZmF1bHRzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgc3RhdGVbcHJvcF0gPSBub2RlW3Byb3BdO1xuICB9KTtcbiAgT2JqZWN0LmtleXMobm9kZS5fZGVmLmNyZWRlbnRpYWxzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgc3RhdGUuY3JlZGVudGlhbHNbcHJvcF0gPSBub2RlLmNyZWRlbnRpYWxzW3Byb3BdO1xuXG4gICAgaWYgKG5vZGUuX2RlZi5jcmVkZW50aWFsc1twcm9wXS50eXBlID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgIHN0YXRlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdID1cbiAgICAgICAgbm9kZS5jcmVkZW50aWFsc1tgaGFzXyR7cHJvcH1gXSB8fCBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlcyhcbiAgbzogUmVjb3JkPGFueSwgYW55PixcbiAgbjogUmVjb3JkPGFueSwgYW55PlxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IGNoYW5nZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcblxuICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgY29uc3QgX28gPSBvW3Byb3BdO1xuICAgIGNvbnN0IF9uID0gbltwcm9wXTtcblxuICAgIGlmICh0eXBlb2YgX28gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IF9jaGFuZ2VzID0gZ2V0Q2hhbmdlcyhfbywgX24pO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKF9jaGFuZ2VzKS5sZW5ndGgpIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IF9jaGFuZ2VzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzRXF1YWwoX28sIF9uKSkge1xuICAgICAgY2hhbmdlc1twcm9wXSA9IF9vO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNoYW5nZXM7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgYnV0dG9uIGNvbmZpZ3VyYXRpb24gZm9yIGEgTm9kZS5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlQnV0dG9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG9nZ2xlIC0gVGV4dCB0byBkaXNwbGF5IHdoZW4gdG9nZ2xpbmcgdGhlIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gb25jbGljayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IGJvb2xlYW59IFtlbmFibGVkXSAtIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidXR0b24gc2hvdWxkIGJlXG4gKiAgIGVuYWJsZWQuIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnV0dG9uIHNob3VsZCBiZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IGJvb2xlYW59IFt2aXNpYmxlXSAtIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidXR0b24gc2hvdWxkIGJlXG4gKiAgIHZpc2libGUuIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnV0dG9uIHNob3VsZCBiZSB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmludGVyZmFjZSBJTm9kZUJ1dHRvbiB7XG4gIHRvZ2dsZTogc3RyaW5nO1xuICBvbmNsaWNrOiAoKSA9PiB2b2lkO1xuICBlbmFibGVkPzogKCkgPT4gYm9vbGVhbjtcbiAgdmlzaWJsZT86ICgpID0+IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgZm9ybSBjb25maWd1cmF0aW9uIGZvciBhIE5vZGUuXG4gKlxuICogQGludGVyZmFjZSBJTm9kZUZvcm1cbiAqIEBwcm9wZXJ0eSB7Q29tcG9uZW50fSBbY29tcG9uZW50XSAtIFZ1ZSAzIGNvbXBvbmVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVTYXZlQnV0dG9uT25FcnJvcl0gLSBXaGVuIHRoaXMgcHJvcGVydHkgaXMgdHJ1ZSwgdGhlIFNhdmUsIG9yIFVwZGF0ZSwgYnV0dG9ucyBhcmUgZGlzYWJsZWQgd2hlbiB0aGUgZm9ybSBoYXMgZXJyb3JzLiBJdCBkZWZhdWx0cyB0byBmYWxzZS5cbiAqL1xuaW50ZXJmYWNlIElOb2RlRm9ybSB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50O1xuICBkaXNhYmxlU2F2ZUJ1dHRvbk9uRXJyb3I/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSByZXByZXNlbnRpbmcgYSBOb2RlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGludGVyZmFjZSBJTm9kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgbm9kZSB0eXBlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdGVnb3J5IC0gVGhlIGNhdGVnb3J5IHRoaXMgbm9kZSBiZWxvbmdzIHRvIGluIHRoZSBwYWxldHRlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl0gLSBUaGUgY29sb3IgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaW4gaGV4IGZvcm1hdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvbl0gLSBUaGUgaWNvbiB0byBkaXNwbGF5IGZvciB0aGlzIG5vZGUuXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW2xhYmVsXSAtIFRoZSBsYWJlbCB0byBkaXNwbGF5IG9uIHRoZSBub2RlLiBDYW4gYmUgYSBzdGF0aWMgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtpbnB1dHNdIC0gTnVtYmVyIG9mIGlucHV0IHBvcnRzIHRoZSBub2RlIHNob3VsZCBoYXZlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvdXRwdXRzXSAtIE51bWJlciBvZiBvdXRwdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmUuXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW3BhbGV0dGVMYWJlbF0gLSBUaGUgbGFiZWwgdG8gc2hvdyBpbiB0aGUgcGFsZXR0ZS4gQ2FuIGJlIGEgc3RhdGljIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbGFiZWxTdHlsZV0gLSBDU1Mgc3R5bGUgdG8gYXBwbHkgdG8gdGhlIG5vZGUgbGFiZWwuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW2lucHV0TGFiZWxzXSAtIExhYmVscyBmb3IgdGhlIGlucHV0IHBvcnRzLiBDYW4gYmUgYSBzdGF0aWMgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtvdXRwdXRMYWJlbHNdIC0gTGFiZWxzIGZvciB0aGUgb3V0cHV0IHBvcnRzLiBDYW4gYmUgYSBzdGF0aWMgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHtcImxlZnRcInxcInJpZ2h0XCJ9IFthbGlnbl0gLSBBbGlnbm1lbnQgb2YgdGhlIG5vZGUgY29udGVudC5cbiAqIEBwcm9wZXJ0eSB7SU5vZGVCdXR0b259IFtidXR0b25dIC0gQ29uZmlndXJhdGlvbiBmb3IgYSBidXR0b24gb24gdGhlIG5vZGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IHZvaWR9IFtvblBhbGV0dGVBZGRdIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIG5vZGUgaXMgYWRkZWQgdG8gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IHZvaWR9IFtvblBhbGV0dGVSZW1vdmVdIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBwYWxldHRlLlxuICogQHByb3BlcnR5IHtJTm9kZUZvcm19IGZvcm0gLSBUaGUgZm9ybSBjb21wb25lbnQgdG8gdXNlIGZvciBjb25maWd1cmluZyB0aGUgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7QW55U2NoZW1hfSBbc2NoZW1hXSAtIFNjaGVtYSBkZWZpbml0aW9uIGZvciB2YWxpZGF0aW9uLlxuICovXG5pbnRlcmZhY2UgSU5vZGUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBpY29uPzogc3RyaW5nO1xuICBsYWJlbD86ICgoKSA9PiBzdHJpbmcpIHwgc3RyaW5nO1xuICBpbnB1dHM/OiBudW1iZXI7XG4gIG91dHB1dHM/OiBudW1iZXI7XG4gIHBhbGV0dGVMYWJlbD86ICgoKSA9PiBzdHJpbmcpIHwgc3RyaW5nO1xuICBsYWJlbFN0eWxlPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGlucHV0TGFiZWxzPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIG91dHB1dExhYmVscz86ICgoKSA9PiBzdHJpbmcpIHwgc3RyaW5nO1xuICBhbGlnbj86IFwibGVmdFwiIHwgXCJyaWdodFwiO1xuICBidXR0b24/OiBJTm9kZUJ1dHRvbjtcbiAgb25QYWxldHRlQWRkPzogKCkgPT4gdm9pZDtcbiAgb25QYWxldHRlUmVtb3ZlPzogKCkgPT4gdm9pZDtcbiAgZm9ybTogSU5vZGVGb3JtO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVOb2RlPFQgZXh0ZW5kcyBPbWl0PElOb2RlLCBcInR5cGVcIj4+KG9wdGlvbnM6IFQpOiBUIHtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogUHJlcGFyZXMgYSBub2RlIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoaXMgaXMgYSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHRvIHJlZ2lzdGVyIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyB0eXBlIGF0IHJ1bnRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVDb25maWcgLSBUaGUgc3RhdGljIGNvbmZpZ3VyYXRpb24gc2hhcmVkIGJ5IGFsbCBub2RlcyBvZiB0aGlzIGtpbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbm9kZUNvbmZpZy5jYXRlZ29yeT1cInVuZGVmaW5lZFwiXSAtIFRoZSBjYXRlZ29yeSB0aGlzIG5vZGUgYmVsb25ncyB0byBpbiB0aGUgcGFsZXR0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtub2RlQ29uZmlnLmNvbG9yPVwiI0ZGRkZGRlwiXSAtIFRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpbiBoZXggZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gW25vZGVDb25maWcuaWNvbl0gLSBUaGUgaWNvbiB0byBkaXNwbGF5IGZvciB0aGlzIG5vZGVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5sYWJlbF0gLSBUaGUgbGFiZWwgdG8gZGlzcGxheSBvbiB0aGUgbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtub2RlQ29uZmlnLmlucHV0cz0wXSAtIE51bWJlciBvZiBpbnB1dCBwb3J0cyB0aGUgbm9kZSBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtub2RlQ29uZmlnLm91dHB1dHM9MF0gLSBOdW1iZXIgb2Ygb3V0cHV0IHBvcnRzIHRoZSBub2RlIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0geyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW25vZGVDb25maWcucGFsZXR0ZUxhYmVsXSAtIFRoZSBsYWJlbCB0byBzaG93IGluIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0geyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW25vZGVDb25maWcubGFiZWxTdHlsZV0gLSBDU1Mgc3R5bGUgdG8gYXBwbHkgdG8gdGhlIG5vZGUgbGFiZWxcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5pbnB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBpbnB1dCBwb3J0c1xuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLm91dHB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBvdXRwdXQgcG9ydHNcbiAqIEBwYXJhbSB7XCJsZWZ0XCJ8XCJyaWdodFwifSBbbm9kZUNvbmZpZy5hbGlnbj1cImxlZnRcIl0gLSBBbGlnbm1lbnQgb2YgdGhlIG5vZGUgY29udGVudFxuICogQHBhcmFtIHtJTm9kZUJ1dHRvbn0gW25vZGVDb25maWcuYnV0dG9uXSAtIENvbmZpZ3VyYXRpb24gZm9yIGEgYnV0dG9uIG9uIHRoZSBub2RlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtub2RlQ29uZmlnLm9uUGFsZXR0ZUFkZF0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcGFsZXR0ZVxuICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbbm9kZUNvbmZpZy5vblBhbGV0dGVSZW1vdmVdIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gbm9kZUNvbmZpZy5mb3JtIC0gVGhlIGZvcm0gY29tcG9uZW50IHRvIHVzZSBmb3IgY29uZmlndXJpbmcgdGhlIG5vZGVcbiAqIEBwYXJhbSB7QW55U2NoZW1hfSBbbm9kZUNvbmZpZy5zY2hlbWFdIC0gU2NoZW1hIGRlZmluaXRpb24gZm9yIHZhbGlkYXRpb25cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24odHlwZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPn0gLSBBIGZ1bmN0aW9uIHRoYXQgcmVnaXN0ZXJzIHRoZSBub2RlIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShcbiAgdHlwZTogc3RyaW5nLFxuICBvcHRpb25zOiBPbWl0PElOb2RlLCBcInR5cGVcIj5cbik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9ucmcvbm9kZXMvJHt0eXBlfWApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHNjaGVtYSB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgY29uc3QgZGVmYXVsdHMgPSBnZXREZWZhdWx0c0Zyb21TY2hlbWEoc2NoZW1hKTtcbiAgICBpZiAoZGVmYXVsdHMuY3JlZGVudGlhbHMpIGRlbGV0ZSBkZWZhdWx0cy5jcmVkZW50aWFscztcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGdldENyZWRlbnRpYWxzRnJvbVNjaGVtYShzY2hlbWEucHJvcGVydGllcy5jcmVkZW50aWFscyk7XG5cbiAgICBjb25zb2xlLmxvZyhcImRlZmF1bHRzXCIsIGRlZmF1bHRzKTtcbiAgICBjb25zb2xlLmxvZyhcImNyZWRlbnRpYWxzXCIsIGNyZWRlbnRpYWxzKTtcblxuICAgIFJFRC5ub2Rlcy5yZWdpc3RlclR5cGUodHlwZSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICB0eXBlLFxuICAgICAgbGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgIH0sXG4gICAgICBvbmVkaXRwcmVwYXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib25lZGl0cHJlcGFyZVwiKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcyk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IHZhbGlkYXRvclNlcnZpY2UuY3JlYXRlVmFsaWRhdG9yKHNjaGVtYSk7XG4gICAgICAgIG1vdW50QXBwKHRoaXMsIG9wdGlvbnMuZm9ybSwgdmFsaWRhdG9yKTtcbiAgICAgIH0sXG4gICAgICBvbmVkaXRzYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzO1xuICAgICAgICB1bm1vdW50QXBwKG5vZGUpO1xuXG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gZ2V0Tm9kZVN0YXRlKG5vZGUuX25ld1N0YXRlKTtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGUgPSBnZXROb2RlU3RhdGUobm9kZSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VzKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhIU9iamVjdC5rZXlzKGNoYW5nZXMpPy5sZW5ndGg7XG4gICAgICAgIGlmICghY2hhbmdlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgIGlmIChub2RlLl9kZWYuZGVmYXVsdHM/Lltwcm9wXT8udHlwZSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkQ29uZmlnTm9kZUlkID0gbm9kZVtwcm9wXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbmZpZ05vZGVJZCA9IG5vZGUuX25ld1N0YXRlW3Byb3BdO1xuICAgICAgICAgICAgaWYgKG9sZENvbmZpZ05vZGVJZCAhPT0gbmV3Q29uZmlnTm9kZUlkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZENvbmZpZ05vZGUgPSBSRUQubm9kZXMubm9kZShvbGRDb25maWdOb2RlSWQpO1xuICAgICAgICAgICAgICBpZiAob2xkQ29uZmlnTm9kZSAmJiBvbGRDb25maWdOb2RlLl9kZWYuY2F0ZWdvcnkgPT09IFwiY29uZmlnXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlSW5kZXggPSBvbGRDb25maWdOb2RlLnVzZXJzLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAgIChfbm9kZSkgPT4gX25vZGUuaWQgPT09IG5vZGUuaWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBvbGRDb25maWdOb2RlLnVzZXJzLnNwbGljZShwYXJlbnROb2RlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMobm9kZS5fZGVmLmRlZmF1bHRzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuX2RlZi5kZWZhdWx0cz8uW3Byb3BdPy50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZUNvbmZpZ05vZGVJZCA9IG5vZGUuX25ld1N0YXRlW3Byb3BdO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGVDb25maWdOb2RlID0gUkVELm5vZGVzLm5vZGUobmV3U3RhdGVDb25maWdOb2RlSWQpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBuZXdTdGF0ZUNvbmZpZ05vZGUgJiZcbiAgICAgICAgICAgICAgbmV3U3RhdGVDb25maWdOb2RlLl9kZWYuY2F0ZWdvcnkgPT09IFwiY29uZmlnXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlSW5kZXggPSBuZXdTdGF0ZUNvbmZpZ05vZGUudXNlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgIChfbm9kZSkgPT4gX25vZGUuaWQgPT09IG5vZGUuaWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZUNvbmZpZ05vZGUudXNlcnMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVyZ2Uobm9kZSwgbmV3U3RhdGUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbmdlZCxcbiAgICAgICAgICBoaXN0b3J5OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHQ6IFwiZWRpdFwiLFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgICBsaW5rczogW10sXG4gICAgICAgICAgICAgIGRpcnR5OiBSRUQubm9kZXMuZGlydHkoKSxcbiAgICAgICAgICAgICAgY2hhbmdlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBvbmVkaXRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5tb3VudEFwcCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBvbmVkaXRkZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5tb3VudEFwcCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBvbnBhbGV0dGVhZGQ6IG9wdGlvbnMub25QYWxldHRlQWRkLFxuICAgICAgb25wYWx0dGVyZW1vdmU6IG9wdGlvbnMub25QYWxldHRlUmVtb3ZlLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIG5vZGUgdHlwZSAke3R5cGV9OmAsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgeyBkZWZpbmVOb2RlLCByZWdpc3RlclR5cGUsIElOb2RlLCBJTm9kZUJ1dHRvbiB9O1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBOYW1lPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUubmFtZVwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5uYW1lJ11cIlxuICAgICAgICBwbGFjZWhvbGRlcj1cIm5hbWVcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gSG9zdG5hbWU8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5ob3N0XCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmhvc3QnXVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiaG9zdG5hbWVcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIk5vZGVSZWROb2RlRm9ybVwiLFxuICBwcm9wczoge1xuICAgIG5vZGU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG4gICAgZXJyb3JzOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiAoKSA9PiAoe30pLFxuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCIvLyBOT1RFOiB0aGlzIGZpbGUgaXMgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbi8vIE5PVEU7IHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgbnJnXG5pbXBvcnQgeyBkZWZpbmVOb2RlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvY2xpZW50XCI7XG5pbXBvcnQgY29tcG9uZW50IGZyb20gXCIuL0Zvcm0udnVlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZU5vZGUoe1xuICBjYXRlZ29yeTogXCJjb25maWdcIixcbiAgY29sb3I6IFwiI2E2YmJjZlwiLFxuICBmb3JtOiB7XG4gICAgY29tcG9uZW50LFxuICAgIGRpc2FibGVTYXZlQnV0dG9uT25FcnJvcjogdHJ1ZSxcbiAgfSxcbn0pO1xuIiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVdnQUFBRU9DQUlBQUFBcktockZBQUFBQVhOU1IwSUFyczRjNlFBQUFFUmxXRWxtVFUwQUtnQUFBQWdBQVlkcEFBUUFBQUFCQUFBQUdnQUFBQUFBQTZBQkFBTUFBQUFCQUFFQUFLQUNBQVFBQUFBQkFBQUJhS0FEQUFRQUFBQUJBQUFCRGdBQUFBQk5MN3k0QUFBWlRVbEVRVlI0QWUxZFBhOGxSeEY5UmhzaEVrZkVHQUp5TEJBSkFSSVdrVE5FNk15V2tFaElJQ0lnY29CSWtGYnlaZzRSZndDeGlJQUVZUzA1Z2RjYmszZ1RpM1E1dTcxdnR1L2N1VDNkTTlYZGRiclBTOTU4OUZSWG42bzVVMTAxUGZldEZ5OWUzR1gvUFgvK2ZMUHQyMisvL2J0Ly91bkpWODgyei9vLytMOUhOSnIvNkZjLy91MFBmeDRiQXVEbkl4eGZ1SHRWTThsLytlTGZ2Ly8xbzExOW5EVDQrb2ZmY3FKSnFScnZmdU5iY0o1YlZ4WDV4dGR1U1NrNmppNS8rZDMzaWk1UjQyTUkvT01QZndmYVJiZjBzWTVhWGtYRUdpMWhNZS9MOENhMUlRNk1FSzc4aTIvL3hIeW9iUVJ5UFVNK2VQSkpHMWphOUlKWXRVMUhKcjF3dVVvOFpOeWVoczhiTStMQVkvQUhiNzhUSzZydFNnaGdZb1hZM3RBSkt1bVpJeFp1Z3hncXA2WGFuRVRncCs5ODc2U0UrSEl6NG9CUUJSMHhzbFczaDRudHVhSW42bkREMWlFdGlRTlBEN0FhRWpDMktqYVR4dVVXQXdRZEdBSlJXcHJMUGVLN0JyZWtiYmdCNFpiRUFYSGdEc01FVER4NGJhOFFRTkFCdEtrbkxNUEVUU3ZUZU51dGNVc2FFd2NnZ3lzcjZHampPbi84ejEvYmRGU2pGK1ZFYTZCNkxkTTJKN3JJdHljT0JSMEx1TFUza0ZaRXRGKzdGM1A1ZUxUQVNaUVROUWQyVTJDbGtvVTljVUI3WlVrM1RWamo0R2YvL2J5RzJOb3l1V0lsM3V4R3BYQUQ3bEdGT1BBOEFjOXB3bEw3OW9OOHVxQUREeFZFU1VUaEJpOXIxTWlKTGk1ZGhUaUM5Qm9wbVVWdmJTd0lQSHo2ZU5sMnZoRW1LVVFLTzhjenJkNzN2L21kZElNelp5c1NCN3hFUWNjWjIyUmVHOTRIeTJ6Y3ZkbS9ubitoRW13REsrRFdxNVRkQ01wWEpBNTBvS0NqZ1l1Z0M0cTZaZ2czS0ZSdFk3V3F2U0RjQU9EMXVxaExIRkJkQzFqcUdTK1dURkhkVkU0ME5sbTk3WkRkUUtxeFhoY1BpcVFYY1ZpUWpIanBZVDMxSmZrZUFhUWJuejk2THp6Vjc0OXQvRDlnd1EwcFc0ZDJKY01maUhLaVcwT2tPUmJXenU4Nncybzh1eGFNMjllTk9OQVR0RkhRRVNOZWI5djV1Zy9uNnEzc3dsdE1hWE83VlNjT1BHZW9TN01yZi9LODYzblZySmFsdFBHY3FpWFllQWpWaVFPZEllaW9XaG1LeDJPK3pmWGtjWnQ2ZEt1WXVjUDBGZGpzUm10QkhBZzZ0R3EybVQ4aFMxbzBXVzJnR0VYaWRzR0I2MUd4cUkyTlp1RUcrbXBCSE9nRzNLSFNiR3pqZXRzdnM2VE9WczBxSjFyUDNMSGt4UGRFNDJZbTI0MklJK2phSm0xamdzdEtDTmRUeUZYVlUrSEd5cGNxN1RhK3Vab1NSOVZYMlNyWmcxRXNudkJJUm5xWXNDRDJVYmpSeG9YTVA5V1RWcnNwY2FnMG16YUc0Vm1zbXNWTmF5andtQ2lWWUkvaFZucFY0M0FENmpVbERyZ3lkV21XYU1LQzV6eFdoZlFOT2xTQ0xiMy9qN1Z2bVJOZE5HeEtIT2dWcnR5c1lyUU1jczROVkVEN1prbFZnbTNqZUYzS0RxMkpBNjZzMG13YmYwSXZDRHFhOWJYcUNPSEc2b2puWGFKWWNnVWp3bzB1Y1dWcjRzQ3d3UjFkT0hLRitBeTd2WUlPbUZqaFJoc0g2M1VyZFNBT0FLb3NhUnV2UWk5ZFNyTmRPajBNS1crNGdaeG9sM0FEVVBjaERqeVJWSm85N09oRkY3WXZ6Y0s0UkNWWVh0Ym9raE5kZk84dGsxK3JYOFRGRzd0Y2lHa3c3MWZraUQ1akJhUDg3Yyt2ZjI0V2QzVnNvL1QycmdYank0TmtYUEwrNDQrSndPRWxEb1FiU0JlbURYckFnckZORTl0OUlvNmdrTEtrQ2NQWW5tcVRxb1NicWdScmE3aGIwa0s0a1dhTlc5ZWFITzlKSEJoQXI5U09DWFpFUXBxbEtwdDFSQVIrRFZXN3Y5UFFtVGp3akFKMzFrQzJnVXl1S0xmMm1oR1lzbllYdGpibE1sODg5dTdoQnBUcFRCelFvT1dTdmhqOTJiYVJzRVJrV3pUcExZSUl3b2x5b2tWRDg5WVljWHJIU1VwQW96OXhRSS8yYjlwYnVRTFhVNnRxbFZUTFVxeWNLaTJuWXdrMlZzd0ZjVFJlMkJlUC8vdzJFWGZVSzgxeTVVVFBHNzJqQkx6SDBEM2N3UEJkRUFmMDRBMDZPdnJRZ2E0ckpTKzV5dXBFWEw4eThhZnZmbFJ2c3JucUs3M3JoVGhVbWszYnlmQXNVcGkyenNjVmJ2Q3lCbktpTUp5SGNBUGU2SVU0QUlkS3M0YnNrQkJsbmlXdEZNVWtoakRuS1ZjM2lCZmlDSzdBTzJIaGVvNFpaa2xWZ20zRFlrNXlvc3RnZlJHSEZyQXNocW02WVJWMElFNVVDYmFxcFJiaDNnb0l2b2dEVXpnRkhZdXZWTjFBOWZUOGJOa3djcWs2MkNDY0t5cU1BWEY0VS9naURyaXl2aTBZZTB5OWJheERPL2x0UWE1d2c1YzF3bnVpOVR6aG1HUmZ4SUV4SU9qby9oNytNU2pwcmpxWjFQelpoNytoR3pLandqNXZoK3EvVnA5cHFyaEFpT2tjUHRMOTVLdG5tZGU2YW9Zbkc5R2ljbFJTRTVQblczTVpHQXNYdW9JOXJReDd1QkViSXI1VDBxUEcyZmpDM2NaRmt0MUZIR0Y0cmlwUHU0anpOamdXZE1BZGoxM0lDMVF2emQzZUNFNkpBK1RuTUNHVTZUMWN6N2ZTZWlwTW81eG9waWVjYk9icWphL1ZXSndTQjdSTWhOQ3JNV2ozREFLaE5Kc3BBYXlCU1lwS3NKbHduV3ptTnR6QXVQd1NCNVJUMEhIUzh6SXZMMXJZcW1VcG1haWViQWJuQjAwWEpTbE85bGgwdVd2aVFOQ0JhSzFvUEg0YUUwMVlrTTNOU1hhR2NJTW85VXRrZ3BYZmhoS3NXOWFBdHE2SkEvcDVqdFpXeHFiZTNVMTJocWZmYmpOcUVQd29EN2YzekJvQXlqdHh3RjhWZExSeDZOMHNxWEtpYlF3UmNxSnQranJjaTNmaXdNRDBiY0hEMWkyNk1KRWxEWk1VNVVTTDhEemMySCs0Z2FFUkVBZTBWSmIwc0JjV1haaUlLZkJLWHBHb3ZvMTVzeHNzcnM1QkhOUlowcjYzVUZIdmlDbXVzNlIwNFFZdmEyQ1NnclZhQUx6SWFsMGFjeEFIb1BINXhuNk96Ymo4K0RxeVFKYnUrbURPd05XbUZBRTRPVmpEZVZvMERJcUdPS2lERGlMdVdBVWQ4R01zb2lYS2JoQkJ2YUtWRUc1UXNBWTBweUVPNktyUzdNclZLdTB1TmRmdzlGdDJLM1Vuc1FHQkVHNndvTUZFSFBCamx0VFJ0Zm01bm9STGFUYVJMcjBlWS9jalhDREhjQ0hjUUV6TkVtNUE4d2U0RytNQnBMZUxCbFpETWxKSEQ5TXE2cXdGQXBpYlBILzBIaXhJTkVteEdIYzNHZUdkZzV4YnB2czlHREJpaWppZ01aQlYwTkhHdXhGckxIRkhteDVQOXNJYmJqQzZOQmx4Z0c3MWJjR1ROMWptNVlnMUZHNWtZbld5R1NZcEp5VzB2NXlNT0FBUWdnN2UwbXg3QTAvU284S054b2JtSXc0RUhTck5OdllTNTkzeHNrYklpVHFIZDFNOVB1SUl3MUJwZHRPY09zaUZBTVd5bEUxSVdZbERXZEpOYzA1NGtEcmN5Q21qK0xRcEszRUFUY2FVa2s4bmtGWmRFT0FOTndBWE1YRkFlOFk2VnZCUjN1ZGtsM3ZzVnFlOE1NSjFlY01ObUlPYk9KUWx2WFZIelhDY2x6VzRscVZzK2hJM2NXQkl5cEp1MmxVSFBTUEF0U3hsRTBsNjRrQzhCLzdlSEp2L2c3elB6TzdZOGtJM1FMZ0I2OU1UQjhhZ29LUDdiU3dGOGhHQXUxSm5OOEpJUnlBT21FRlowbnpISGFBbGI3Z1JjcUpGQzlWODJtc0U0Z0N5eXBMNmRDOXB0VUlBSzYwR1lBME15dU92MWErd3Z0NjloaDVCQnhKT3BEOXdmejFBSFVrZ3dCNXVYQS90MnArdjJ5eEhpcVk1OVNRUEVuRUFJSzJhWFh4cjRBMWUxdUJkbHJMcFRvTVFCOFlXZ283TlFlcWdFT2lPd0dBcC9IR0lBMEdITWgzZGI0K3FDbENIRzBWVGpLb3dtZ2dmaHpnQUI3aGpNRjQzc2JHRWRFZGd2RjhqSElvNDRCL2dkWlZtdTk4bk5SVGdEVGQ0SFRKaHg5R0lJMlJKRXdQV0tVWUVlRmtEYUErNWpIczA0b0NkRkhRd1VzT29Pbi82N2tkRERtMUE0bENXZERCUDVRMDNVSUlkTENlNnVOYUF4SUd4S1V1NkdGZ2JIUkVZT0ZVL0puSEFWOEQwV2pYYjhaNng2cG8zM0FqTFVxeHc4Q1puV09KUTBPSE4xV2JUWjhpYzZHTEVZWWtESTFTV2RERXo2UVoxdUVHS2VhYmFJeE5IS00xcXdwTHBDdDZhOGJMR1lNdFNOaDFqWk9JSUF4NDRRYlZwVVIzc2pzQU12elJJOW12MXdTZUtTbHlJTy9BRUlGMXhqNmZ1L3g0OTYzNG50RmVBUGR5QTErV0RWdXJQSGlTUEgzRUFaUVVkK2E2bWxpY1JtTVRacGlBT2xXWlAzZ3lOTCtjTk44WXV3Y1p1TUFWeHFEUWJtMXpiOVJBWXV3UWI0ellGY1dEQUtzM0dWdmU4VFIxdWVBYldWcmRaaUVPbFdWdS9xU1NObHpWbUtNSEdScCtGT0RCbUJCMHoxTWxpNjJxN0dRS1Q1RVFYUENjaURnUWQrcmJnWW5pSEc5VGhSbEZKMVNINHBTcE5SQnlBUmxuU1V2OVEreHdFeHZzeTRPNm81eUtPQUFmdnA5eDRuOG03anNnN05GNTMyalZLb3NGMHhJR1FFci9Ba2tERStTbmVHOHc1c0lmVm02Y0VHME0wSFhGZ3RrSmRtbzJOTjh3Mkx4dU8rbVhBWGRlYWpqaUFpRXF6dTI3UnNnRXZhNkFFTzF0T2RIR01HWWtqREg2Mit0bGljbTFZSVRDekM4MUxIUEFlUERHc2ZLaXhITjZuOUFvbzNvSE1zeXhsWmJLd084aXYxVytPTFJ4TUJKT29vcjMvK09QRXRUb2xCRzRoRUZMc21QWnVOa2g0M1hYN1cwS3VXK0tJRThsVFJ4d3dBMjh0amZkWnZkd1B2RU1JNFViUkRiK01lb3lOMlltRCtsMVNhaGZrWlEzTWNCRnV6TXdhY0x6WmlRTVE4QzVnNGIzM3FDa1BEbE0wWDZBZTdDM2xSUnd2ZjlwVFdkSmIvbEhwT0MvbHdWWGdNSk9IRy9BS0VjZkxXMlBtdWxvbGFoaFZMRzk4YW1zUkVjZExQQkY1S3Vpd2RheUVOSVViQ1hCWVRvazRYbHRxd2dXT0xEN3FSMDlFcHBxa0JIT0lPTjY0cFVxemI3Q290c1ViYmt6K3h0ZktJMFFjYndCUmx2UU5GblcyZUZsREpkaVZSNGc0TGdCUjZ1c0NEdTNjSTRCSmlrcXc5MkM4L0MvaWlORlFhZllDRGRzZDZuQURyS0hzUnV3UElvNFlEWDFiOEFJTjdRUUVsRGkvOWdRUnh6VW1Xc0N5Z2NuSlE3emhCbS9LL0tUSjBwZUxPRGJ3b2Y2MjRNWjRlaC9pWlEwZ2g1UjViL3c4OWovRnI5WG5BNzhrd1BDY2VmajBjZjZGZmxyaUxwM3pCKzVybUNDRUd5RzdzZmhHVGtkRkNSRkd5WW80dHQxQXBkbHRYTXFQOG9ZYktzRW1yQzNpdUFtT0ZyRGNoR2FPRTFvRm03Q3ppT01tT0FnZ3RZRGxKanA1SjZqRERhMkNUUmhaeEpFQTUwNTF1QlE2UTU5VHZKazJyNGdqalk5S3N6djRKRTd6aGh0aFdVcFJnak9CdzVDblJCdzdabFUxYmdlZ0VVL3J5NEM3VmhWeDdFS2tvR01mb3VzVzdPSEc5WWgwSkVaQXhCR2pzYjJ0MHV3MkxyZVA4cklHMHVIS2lkNDI3SnN6SW80M1dDUzJsQ3BMZ0RQU0tSaGFxWTBjZzRvNGNsQjYrVzFCM2pVTGpaLy9qYnZMc2w5ZUk0UWJSUzl4NWtrZHM1V0lJOWV1eXBMbUlrWGJUdUZHdnVsRUhQbFlLVXU2anhWdnVCRktzUHNqVkl0WENJZzRDaHhCV2RJMFdMeXNvV1VwYWN0ZW54VnhYR09TT3FJc2FRb2Qybk5hbGxKcXVxbC9yZjRhckp5TU9wNU9UNzU2ZG4ydC95T0lDT3F0dUtjT04wSUNLNTBaemZHTnhRZlNvcFptWVlOUnNpS09sUkYzZHVFUUNqcDJNR0k3TFlNZXNKaUlvd3kwOEhCUWFYYUZHbSs0b1p6b3lwU1p1eUtPVEtBdW11bmJnaGR3TU8rb3luN01laUtPSTdoaHdxS2dZd0dPT3R4WVJxR05JZ1JFSEVWd3ZXNk1DUXVDRG1SSmoxenM0QnJEVzkxUVZHTmdZRDZGRzRjeEYzRWNoRTVaMG9QQXVibE12OXAzeGhRaWpvUG9JZWdBZDB3ZWRDamNPT2c5L0plSk9FN1pVTjhXUEFWZnY0dTFMT1VrOWlLT2t3RE91NENGTjl4UUNmYXMwK3RIcDg4anFBVGJlUXdiUzlDWEFjOERyb2pqUElZekJoM1U0WWFCeWFjWEllSXdjQUVFSFZObFNYbFpBMmJTeTNzR0hxK3BpZ21JRUtMMURsWklWcFdqVmJCVzhDcmlzRUZ5bm5kSmVjTU41RVNWM2JCeDk3czcvVnI5QlpLNC95LzJrenVyMWRCd3lvZko5anJaRndFWWFHWGZsUVhUNnEydVRUY2VYcklpanJRRGxKMGRmZ0VMZGJoUmRPZVhHWDYrMWlJT001dkRML0ZNR3poTHlzc2FNSXFxNW1hTy9rcVFpTU1Nei9BU3VsWkFtQUZxSjBoR3NjUHl0U1FSaHlXazRJNVJndzZGRzVhT3dpOUx4R0ZzUTB4WTlId3p4dlNjT0ZYS3orRzNmYldJWXh1WHcwY1JkSXozUGhoMXVLR2M2R0ZuVGx3bzRraUFjL0FVdUVOUHVZUFlXVittNWN2V2lMNldKK0tvQWl5ZWNzT1Vabm5ERFY0VFZIRktVNkVpRGxNNDc0V0ZMT245SHZGL1h0WlFDYmFxMjRrNGFzRTdVdEJSQzZPYWNqVmJySW51M1lPcTBtY1dIcktrbi8zM2M5NmZmZU0xSDhJTjVVU3JtazhSUjBWNGxTV3RDRzVTdEhLaVNYZ01Ub280REVCTWkxQ0tMbzJQK1ZrQmJnN3B0VUFSeHpVbXhrZndMcW14UklsTElxQmxLVWw0YkU3cTErb3ZjTVRrNG1JL3VaTS9pOFl6OE9IVHgwbGhPbW1EUUFnM011MlliMEVvbHlrekRHTjR5WW80YlB3MUxZWDZYZEwwMEZ5ZFJVNFU4VjNSSGU1S2Z5SmxSQnlOaktVRkxBMkFSZ20yNkZIZlFLVlJ1eEJ4TkxLc2dvN2FRSWNTck1LTjJqZ0grU0tPTmppL25DSHJsYVNxV0F2ZXF2Q3VoSXM0Vm9CVTNFVVVyVXBoSlh3QnJDWXBsYkRkRkN2aTJJU2x5a0VFSFNyTlZrSDI3azRsMkVyQTNoSXI0cmlGVEpYakNqcHF3S280cmdhcWFaa2lqalEreG1jUmRDaExhb3VwVnNIYTRwa3BUY1NSQ1pSWk0yVkp6YUI4SlVnNVVWczhNNldKT0RLQnNteUdDUXVlazVZU1o1VVZTckN6anI3bnVFVWNIZEJYMEdFRnVsYkJXaUZaS2tmRVVZcVlUWHRsU2MvanFKem9lUXdQU3hCeEhJYnUxSVdoTktzSnkyRVFsUk05REozSmhTSU9FeGlQQ0VIUW9RVXNSNEI3ZFkxeW9vZWhNN2xRdjFaL0FTTnU1b3Y5NUE2aWh1VDVpNU9ia2xHYTVmMjI0TVh3MnU2RVNHMFQvMDJjYjJtM0tlRldZMG1Pa1ZIRUVhUFJZVnRQemdPZ0E3U2kyL2hBRjdva2pZQ0lJNDFQOWJPNEFaVGtLMEk1RVc0VXlWSGpNd2lJT002Z1ozTXQ5ZTlVMjBCUUlrWGhSZ2xhdGRxS09Hb2hteThYUVlleXBKbHdoVld3UmJtSlRNbHFWb1NBaUtNSXJscU50WUFsQjFsTVV2Umx3QnlnR3JRUmNUUUFPYXNMQlIyN01BRWk1VVIzVVdyVFFNVFJCdWY5WGhSMHBERUtiM3hwa3BKR3FkbFpFVWN6cVBjN1VtazJnUkhBRVdzazhHbDhTc1RSR1BCVWR5ck4za0lINFlZbUtiZkE2WEpjeE5FRjlwdWRZc0p5ODl6RUp4U0xlVE8raU1PYlJlNzBQdGpLSkNyQnJnRHhzQ3ZpOEdDRkN4MlVKWTNoVUU0MFJzUFB0b2pEankzZWFLTFM3SUtGY3FJTEZLNDJSQnl1elBGYUdRVWRBUWpsUkQxNjV5dWQzdnJ5eXkvemxTdktiQmNWenlRNXRnTFFBSG9mUFBra1Bqamg5cWZ2Zm9SUnl6ZGkwenRCUXhGSGJCUkgyL0NQeWJPa0lTZnF5Q1JTSlVKQXhCR0I0V3h6NWdrTEppbGFsdUxNSHkvVUVYRmN3T0Z0Wjlvc3FaYWxlSFBGbFQ0aWpoVWd2bmJuRERvVWJ2anl3aTF0UkJ4YnFIZzZOdUZMa3dvM1BEbmd0aTRpam0xYy9CeEZsaFJQWUQvNjFOWUVnMFdjVlZTU3E2MlM1RjhqSU9LNHhzVGRrYWwrcjB4dmZMbnp2eTJGUkJ4YnFQZzdOa2xwVmlWWWY2NjNyWkdJWXhzWGIwY255WktxQk92TjhXN3BJK0s0aFl5NzQ4T1haaFZ1dVBPNTJ3cUpPRzVqNCt6TTJFR0hjcUxPM0cxSEhSSEhEa0N1VGc5Y21sVk8xSlduN1NvajR0aUZ5RkdEVVJld0lOd29XcnZseUNTenFpTGlJTE04Sml4a0dtZW9xM0FqQXlSZlRkNTY4ZUpGdmtaRnIrVVVQVU1rT2JaQ0dvMS9QZi9pNGRQSGNYdnFiZVJFMDJ5WVJtTTFkbmxkREVnOU5CUnh4RGdUYk1NVlJ2cXQyWkFUSmNCZEtsNGlJT0s0eE1QOVhuajhEbE9hSFRqZDY5NlZUaWtvNGpnRlg2K0x4eWpOS2lmYXkzL085eXZpT0k5aEh3a0RQS3NIR0VJZjJ6dm9WY1Rod0FqbEtvUUpDL1VDRnIwbldtNTJSMWVJT0J3Wm8xUVZaRWxMTC9IVFBsMUo4YU9uTk5sRVFNU3hDUXZIUVZSWVNJTU9VclU1M0tLSmxpS09KakRYNlFRVEZzYlNyRXF3ZGR5aHFWUVJSMU80elR0RDBFR1hZaHltbG14dVRTS0JJZzRpWTIyb2lxQUQzSUZuK01ZNWw0Y1VicmcwUzdGU0lvNWl5QnhlUVBSdFFjUkhvU1RrRUVhcGxJK0FpQ01mSzljdEtkS05Lc0c2OXFFUzVVUWNKV2c1Ymt0UjNkU1hBUjE3VUpscUlvNHl2RHkzRGovUjdGWkRoUnR1VFhOQXNRZEZFMDdrNGZMN2tPUVlxelpvSVBYNDVLdG5jYjlPdHBlY2FIQ2hObWpzamwzK0hFTlVoSVlpamhnNjdtMFkzbTFwMXExaTNDYnZwNzJJb3gvMjFqMkh4N2pEMHF3bUtkYW03aTlQeE5IZkJvWWErQXc2cU5mVUdGcG5KRkVpanBHc2VZZWdBOXpocWpTcmNHTW9EN3NmaklqakhvbFIvb003L0N4Z1dYS2lvNkNyY2J4R1FNUXhvQ3NnNkhDeUhzU0pHZ1BhdVBlUVJCeTlMVkNoZndRZEhyNHRxSENqZ20yOWlCUnhlTEdFclI3Z2p1NFYwTzRLMkVJcWFURUNJbzRZamFHMk1XSHBXSnBGMTFCZ0tFQTFtQWdCRVVjRXhsaWJmWU1Pb2dXN1k1bTkwV2hFSEkyQTd0Sk5yOUtzcTNwd0YrU0g3MVRFTWJLSnU1Um1sUk1kMmFYdXh5Yml1RWRpMFAvdFM3UEtpUTdxU2hmREVuRmN3REhlVHVQU3JIS2k0N25RNW9qMGEvVVhzQlFWQW5CUFhseWMzT2t1K2YzSEh5Y1Z0RG1aK1UyUTdtaUUwWEpaMEpYT2lqaHNiaGovVWhva0xMVXN4YjhiV0drbzRyQkMwcnVjQnUrUzZzdUEzcDNBVGo4Umh4Mlc3aVZWWFRtaWNNTzkvUzBWRkhGWW91bGNWcjJnQXpsUmhSdk9yVytybm9qREZrL3YwaW9GSFNqQkZ1VTd2Y01rL2ZZUUVISHNJVFRXK1JwQlJ5akJGbFVveGdKMXh0R0lPS2F6dXZrTFd1WUNwek1KNFlCRkhJUkdPNkV5NGdMTUtReExzOHFKbnJBRzhhVWlEbUxqSFZNZDNHSDE5V0F0U3psbWdnR3VFbkVNWU1UaUlWZ0ZIWlZTcmNYajBRWE5FUkJ4TklmY1FZY0lPczVuU1JWdU9MQmtOeFZFSE4yZzc5c3h1T05rVXZQazVYMkhyOTVQSWlEaU9Ba2c4ZVdZc0NCcU9EWUE1VVNQNFRiTVZTS09ZVXhaUEpBelFRZG1Pc1g5NllLQkVOQ3YxVjhZRS9mU3hYNXlwK2hkU2JlU0VUczhmUG80T2REMXlWRE5YWTFvRERUV1E0MzJWK09Oem14c0RvK0dJbzROcTA5MTZFQ1dWTXRTcHZLUXpjR0tPRFpobWV0Z1Vab3o4MU05Y3lFNDMyaEZIUFBaL0dyRStWblN3OG5VcXo1MWdCc0JFUWUzL2F5MHp3dzYwS3hvOW02bG51UjRRMERFNGMwaWZmUUJIWVNVWjZMN1VJSXR5aEVtcE9rVU5RSWlEbXJ6V1NxUGxHZDZKcUtjcUNYYzVMSkVIT1FHdEZNZlFVZGk3VWtJTit4Nmt5UnVCRVFjM1BhejFmNVdhUmFSaU1JTlc2alpwWWs0MkMxb3JQOW1saFNSaUhLaXhrQ1RpeE54a0J2UVduMFF4Q3JUZ1YxRUlzcUpXaVBOTFUvRXdXMi9HdHIvOW9jL2o4VWlCaEZyeElCb0d3aUlPT1FHR3dnc3BWbmxSRGZRMFNFUmgzeGdFNEZsOGF0eW9wdjQ2T0FEUVNBRU5oRUlRUWRTSHBxbmJPSXorY0gvQStucEVXL0dJZkNuQUFBQUFFbEZUa1N1UW1DQ1wiIiwiZXhwb3J0IGRlZmF1bHQgXCJfX1ZJVEVfUFVCTElDX0FTU0VUX19iZjhjY2EyZV9fXCIiLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IFVzZXJuYW1lPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY3JlZGVudGlhbHMudXNlcm5hbWVcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3JlZGVudGlhbHMudXNlcm5hbWUnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IFBhc3N3b3JkPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY3JlZGVudGlhbHMucGFzc3dvcmRcIlxuICAgICAgICB0eXBlPVwicGFzc3dvcmRcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3JlZGVudGlhbHMucGFzc3dvcmQnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IFBhc3N3b3JkIDI8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jcmVkZW50aWFscy5wYXNzd29yZDJcIlxuICAgICAgICB0eXBlPVwicGFzc3dvcmRcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3JlZGVudGlhbHMucGFzc3dvcmQyJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlR5cGVkIElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkVHlwZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5teVByb3BlcnR5XCJcbiAgICAgICAgOnR5cGVzPVwidHlwZXNcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUubXlQcm9wZXJ0eSddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5UeXBlZCBJbnB1dCAyPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkVHlwZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5teVByb3BlcnR5MlwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5teVByb3BlcnR5MiddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5Db25maWcgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRDb25maWdJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5yZW1vdGVTZXJ2ZXJcIlxuICAgICAgICB0eXBlPVwicmVtb3RlLXNlcnZlclwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5yZW1vdGVTZXJ2ZXInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+Q29uZmlnIElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkQ29uZmlnSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuYW5vdGhlclJlbW90ZVNlcnZlclwiXG4gICAgICAgIHR5cGU9XCJyZW1vdGUtc2VydmVyXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmFub3RoZXJSZW1vdGVTZXJ2ZXInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+U2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY291bnRyeVwiXG4gICAgICAgIDpvcHRpb25zPVwiY291bnRyaWVzXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmNvdW50cnknXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+TXVsdGlTZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5mcnVpdFwiXG4gICAgICAgIDpvcHRpb25zPVwiZnJ1aXRzXCJcbiAgICAgICAgbXVsdGlwbGVcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmZydWl0J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLm51bWJlclwiXG4gICAgICAgIDpvcHRpb25zPVwibnVtYmVyc1wiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5udW1iZXInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+U2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUub2JqZWN0XCJcbiAgICAgICAgOm9wdGlvbnM9XCJvYmplY3RzXCJcbiAgICAgICAgbXVsdGlwbGVcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm9iamVjdCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5TZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5hcnJheVwiXG4gICAgICAgIDpvcHRpb25zPVwiYXJyYXlzXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmFycmF5J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPkVkaXRvciB3aXRoIGRlZmF1bHQgaGVpZ2h0IDIwMHB4IGFuZCBKU09OPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkRWRpdG9ySW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuanNvbnRlc3RcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuanNvbnRlc3QnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+RWRpdG9yIHdpdGggY3VzdG9tIGhlaWdodCBhbmQgQ1NTPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkRWRpdG9ySW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY3NzdGVzdFwiXG4gICAgICAgIGxhbmd1YWdlPVwiY3NzXCJcbiAgICAgICAgc3R5bGU9XCJoZWlnaHQ6IDEwMHB4XCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmNzc3Rlc3QnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBOT1RFOiB0aGlzIGlzIGxvYWRlZCBmcm9tIHRoZSByZXNvdXJjZXMve3BrZy5uYW1lfSBmb2xkZXIgLS0+XG4gICAgPGltZyBzcmM9XCIvdnVlLnBuZ1wiIC8+XG5cbiAgICA8IS0tIE5PVEU6IHRoaXMgaXMgYWRkZWQgdG8gdGhlIGJ1bmRsZWQgLmpzIC0tPlxuICAgIDxpbWcgOnNyYz1cImxvZ29cIiBhbHQ9XCJMb2dvXCIgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGxvZ28gZnJvbSBcIi4uLy4uLy4uL2Fzc2V0cy92dWUucG5nXCI7XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiTm9kZVJlZE5vZGVGb3JtXCIsXG4gIHByb3BzOiB7XG4gICAgbm9kZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBlcnJvcnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nbyxcbiAgICAgIHR5cGVzOiBbXCJzdHJcIiwgXCJtc2dcIiwgXCJub2RlXCJdLFxuICAgICAgY291bnRyaWVzOiBbXG4gICAgICAgIHsgdmFsdWU6IFwidXNhXCIsIGxhYmVsOiBcInVzYVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwiYXJnZW50aW5hXCIsIGxhYmVsOiBcImFyZ2VudGluYVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwiYnJhc2lsXCIsIGxhYmVsOiBcImJyYXNpbFwiIH0sXG4gICAgICBdLFxuICAgICAgZnJ1aXRzOiBbXG4gICAgICAgIHsgdmFsdWU6IFwiYXBwbGVcIiwgbGFiZWw6IFwiYXBwbGVcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcIm1lbG9uXCIsIGxhYmVsOiBcIm1lbG9uXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJyYXNwYmVycnlcIiwgbGFiZWw6IFwicmFzcGJlcnJ5XCIgfSxcbiAgICAgIF0sXG4gICAgICBudW1iZXJzOiBbXG4gICAgICAgIHsgdmFsdWU6IFwiMVwiLCBsYWJlbDogXCIxXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCIyXCIsIGxhYmVsOiBcIjJcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcIjNcIiwgbGFiZWw6IFwiM1wiIH0sXG4gICAgICBdLFxuICAgICAgb2JqZWN0czogW1xuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeSh7IHRlc3Q6IFwiYVwiIH0pLCBsYWJlbDogXCJhXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoeyB0ZXN0OiBcImJcIiB9KSwgbGFiZWw6IFwiYlwiIH0sXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KHsgdGVzdDogXCJjXCIgfSksIGxhYmVsOiBcImNcIiB9LFxuICAgICAgXSxcbiAgICAgIGFycmF5czogW1xuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeShbXCJhXCJdKSwgbGFiZWw6IFwiYVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KFtcImJcIl0pLCBsYWJlbDogXCJiXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoW1wiY1wiXSksIGxhYmVsOiBcImNcIiB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGNvbnNvbGUubG9nKFwiTU9VTlRFRFwiKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmxvZ28pO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiLy8gTk9URTogdGhpcyBmaWxlIGlzIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4vLyBOT1RFOyB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IG5yZ1xuaW1wb3J0IHsgZGVmaW5lTm9kZSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL2NsaWVudFwiO1xuaW1wb3J0IGNvbXBvbmVudCBmcm9tIFwiLi9Gb3JtLnZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVOb2RlKHtcbiAgY2F0ZWdvcnk6IFwiZnVuY3Rpb25cIixcbiAgY29sb3I6IFwiI0ZGRkZGRlwiLFxuICBpbnB1dHM6IDEsXG4gIG91dHB1dHM6IDEsXG4gIGljb246IFwidnVlLnBuZ1wiLFxuICBmb3JtOiB7XG4gICAgY29tcG9uZW50LFxuICAgIGRpc2FibGVTYXZlQnV0dG9uT25FcnJvcjogdHJ1ZSxcbiAgfSxcbiAgb25QYWxldHRlQWRkOiAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJOT0RFIFRZUEUgUkVHSVNURVJFRCBPTiBUSEUgUEFMRVRURVwiKTtcbiAgfSxcbn0pO1xuIiwiLy8gTk9URTogdGhpcyBtb2R1bGUgaXMgb3B0aW9uYWwgYW5kIGl0IGlzIGdlbmVyYXRlZCBieSBucmcgd2hlbiBjbGllbnQuYnVpbGQuZW50cnlQb2ludCBpc24ndCBwcm92aWRlZC4gVXNlIHRoaXMgaWYgeW91IG5lZWQgdG8gY29udHJvbCB0aGUgb3JkZXIgbm9kZXMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIGVkaXRvci5cbmltcG9ydCByZW1vdGVTZXJ2ZXIgZnJvbSBcIi4vbm9kZXMvcmVtb3RlLXNlcnZlci9jbGllbnRcIjtcbmltcG9ydCB5b3VyTm9kZSBmcm9tIFwiLi9ub2Rlcy95b3VyLW5vZGUvY2xpZW50XCI7XG5pbXBvcnQgeyByZWdpc3RlclR5cGUgfSBmcm9tIFwiLi9jb3JlL2NsaWVudFwiO1xuXG4vLyBUT0RPOiBpcyB0aGVyZSBhIHVzZSBjYXNlIGZvciBjb250cm9sbGluZyB0aGUgb3JkZXIgbm9kZXMgaW4gdGhlIGVkaXRvciBhcmUgcmVnaXN0ZXJlZD9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICByZWdpc3RlclR5cGUoXCJyZW1vdGUtc2VydmVyXCIsIHJlbW90ZVNlcnZlciksXG4gICAgICByZWdpc3RlclR5cGUoXCJ5b3VyLW5vZGVcIiwgeW91ck5vZGUpLFxuICAgIF0pO1xuICAgIGNvbnNvbGUubG9nKFwiQWxsIG5vZGUgdHlwZXMgcmVnaXN0ZXJlZCBpbiBwYXJhbGxlbFwiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVnaXN0ZXJpbmcgbm9kZSB0eXBlczpcIiwgZXJyb3IpO1xuICB9XG59XG4iLCIvLyBOT1RFOiB0aGlzIG1vZHVsZSBpcyBnZW5lcmF0ZWQgYnkgbnJnXG5pbXBvcnQgaW5pdCBmcm9tIFwiLi9pbmRleC5jbGllbnRcIjtcblxuKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIlJ1bm5pbmcgcHJvdmlkZWQgaW5pdFwiKTtcbiAgICBhd2FpdCBpbml0KCk7XG4gICAgY29uc29sZS5sb2coXCJGaW5pc2hlZCBydW5uaW5nIHByb3ZpZGVkIGluaXRcIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIHJ1bm5pbmcgcHJvdmlkZWQgaW5pdDpcIiwgZXJyb3IpO1xuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbIm1hcCIsImhhc093blByb3BlcnR5IiwiaXNQbGFpbk9iamVjdCIsImlzUmVmIiwid2FybiIsImNvbXB1dGVkIiwidHlwZSIsInNlbGYiLCJyZWFkb25seSIsIndhdGNoIiwiZWZmZWN0Iiwic2NvcGUiLCJwIiwiaWQiLCJjb21wb25lbnQiLCJ2ZXJzaW9uIiwicmVmIiwicmVzb2x2ZSIsImgiLCJjcmVhdGVBcHAiLCJyZXF1aXJlZCIsInR5cGVzIiwicmVtb3ZlMiIsInJlbW92ZSIsImlzTW9kZWxMaXN0ZW5lciIsImVtaXQiLCJuYW1lcyIsImlzQm9vbGVhbiIsImNhbWVsaXplJDEiLCJzdGFjayIsImNvbXBpbGUiLCJqc29ucG9pbnRlciIsImVycm9ycyIsIl9vcGVuQmxvY2siLCJfY3JlYXRlRWxlbWVudEJsb2NrIiwiX2hvaXN0ZWRfMSIsIl9jcmVhdGVWTm9kZSIsIl9zZmNfbWFpbiIsIl9ob2lzdGVkXzIiLCJfY3JlYXRlRWxlbWVudFZOb2RlIiwiX2hvaXN0ZWRfMyIsIl90b0Rpc3BsYXlTdHJpbmciLCJfY3JlYXRlQ29tbWVudFZOb2RlIiwiaXNPYmplY3QiLCJfd2l0aERpcmVjdGl2ZXMiLCJjb2RlIiwicmVxdWlyZSQkMCIsIlVzZWRWYWx1ZVN0YXRlIiwicHJlZml4ZXMiLCJkZWYiLCJyZXF1aXJlJCQxIiwibm90IiwiaXRlbXMiLCJydWxlcyIsImtleXdvcmQiLCJUeXBlIiwibmFtZXNfMSIsInJlcXVpcmUkJDIiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkNCIsIkRhdGFUeXBlIiwiZGF0YVR5cGUiLCJwcm9wZXJ0aWVzIiwicGF0dGVybiIsInZhbGlkYXRlIiwiX2EiLCJzdWJzY2hlbWEiLCJlcXVhbCIsInRyYXZlcnNlIiwianNvblNjaGVtYVRyYXZlcnNlTW9kdWxlIiwibGltaXQiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsInJlcXVpcmUkJDEwIiwiYnVmZmVyIiwidXJpIiwiZmFzdFVyaSIsImZhc3RVcmlNb2R1bGUiLCJ1cmlfMSIsIkFqdiIsIiRzY2hlbWEiLCJkZWZpbml0aW9ucyIsImZvcm1hdCIsImNvcmVfMSIsImNvcmUiLCJ1Y3MybGVuZ3RoXzEiLCJ1Y3MybGVuZ3RoIiwiZXF1YWxfMSIsInZhbGlkYXRpb25fMSIsInZhbGlkYXRpb24iLCJwcmVmaXhJdGVtcyIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJhcHBsaWNhdG9yIiwiZm9ybWF0XzIiLCJEaXNjckVycm9yIiwib25lT2YiLCJhanYiLCJhZGRGb3JtYXRzIiwiZm9ybWF0cyIsImluaXQiLCIkIiwiZGVmYXVsdHMiLCJfY3JlYXRlVGV4dFZOb2RlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBO0FBQUE7QUFFQSxXQUFTLFFBQVEsS0FBSztBQUNkLFVBQUFBLE9BQTZCLHVCQUFBLE9BQU8sSUFBSTtBQUM5QyxlQUFXLE9BQU8sSUFBSSxNQUFNLEdBQUcsRUFBRyxDQUFBQSxLQUFJLEdBQUcsSUFBSTtBQUN0QyxXQUFBLENBQUMsUUFBUSxPQUFPQTtBQUFBLEVBQ3pCO0FBRUEsUUFBTSxZQUF3RCxPQUFPLE9BQU8sQ0FBQSxDQUFFO0FBQzlFLFFBQU0sWUFBd0QsT0FBTyxPQUFPLENBQUEsQ0FBRTtBQUM5RSxRQUFNLE9BQU8sTUFBTTtBQUFBLEVBQ25CO0FBQ0EsUUFBTSxLQUFLLE1BQU07QUFDakIsUUFBTSxPQUFPLENBQUMsUUFBUSxJQUFJLFdBQVcsQ0FBQyxNQUFNLE9BQU8sSUFBSSxXQUFXLENBQUMsTUFBTTtBQUFBLEdBQ3hFLElBQUksV0FBVyxDQUFDLElBQUksT0FBTyxJQUFJLFdBQVcsQ0FBQyxJQUFJO0FBQ2hELFFBQU0sa0JBQWtCLENBQUMsUUFBUSxJQUFJLFdBQVcsV0FBVztBQUMzRCxRQUFNLFNBQVMsT0FBTztBQUN0QixRQUFNLFNBQVMsQ0FBQyxLQUFLLE9BQU87QUFDcEIsVUFBQSxJQUFJLElBQUksUUFBUSxFQUFFO0FBQ3hCLFFBQUksSUFBSSxJQUFJO0FBQ04sVUFBQSxPQUFPLEdBQUcsQ0FBQztBQUFBLElBQUE7QUFBQSxFQUVuQjtBQUNBLFFBQU1DLG1CQUFpQixPQUFPLFVBQVU7QUFDeEMsUUFBTSxTQUFTLENBQUMsS0FBSyxRQUFRQSxpQkFBZSxLQUFL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dUNBQXVDO0FBQUEsYUFDNUMsT0FBTztBQUNOLGNBQUEsTUFBTSxpQ0FBaUMsS0FBSztBQUFBLElBQUE7QUFBQSxFQUV4RDtBQ2ZpQixHQUVoQixpQkFBa0I7QUFDYixRQUFBO0FBQ0YsY0FBUSxJQUFJLHVCQUF1QjtBQUNuQyxZQUFNLEtBQUs7QUFDWCxjQUFRLElBQUksZ0NBQWdDO0FBQUEsYUFDckMsT0FBTztBQUNOLGNBQUEsTUFBTSxzQ0FBc0MsS0FBSztBQUFBLElBQUE7QUFBQSxFQUU3RCxHQUFHOzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOSwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5N119

//# sourceURL=src/client.js
