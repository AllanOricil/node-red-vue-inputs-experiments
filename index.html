<script type="text/html" data-template-name="remote-server">
  <div class="form-row">
    <label for="node-config-input-name"><i class="fa"></i> Name</label>
    <input type="text" id="node-config-input-name" />
  </div>
  <div class="form-row">
    <label for="node-config-input-host"
      ><i class="fa fa-bookmark"></i> Host</label
    >
    <input type="text" id="node-config-input-host" />
  </div>
</script>

<script type="text/javascript">
  RED.nodes.registerType("remote-server", {
    category: "config",
    color: "#a6bbcf",
    defaults: {
      name: { value: "", required: true },
      host: { value: "localhost", required: true },
    },
    label: function () {
      return this.name;
    },
  });
</script>

<script type="text/html" data-template-name="your-node">
  <div id="app"></div>
</script>

<script type="text/javascript">
  // RED.events.on("editor:open", function () {
  //   alert("OPENED");
  // });

  RED.events.on("deploy", () => {
    RED.nodes.eachNode(function (node) {
      console.log("RESET INITIAL STATE");
      node._initial_state = null;
    });
  });

  function mountApp(node) {
    $("#app").empty();

    const NodeRedCredentialInput = {
      template: `
    <div style="display: flex; flex-direction: column; width: 100%;">
      <input ref="inputField" :type="type" :value="internalValue" @input="onInput" style="flex: 1; width: 100%;" />
      <div v-if="error" class="error-text" >
        {{ error }}
      </div>
    </div>
  `,
      props: {
        value: String,
        type: {
          type: String,
          default: "text",
          validator: function (value) {
            return ["text", "password"].includes(value);
          },
        },
        hasPassword: {
          type: Boolean,
          default: false,
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value", "update:has-password", "input"],
      data() {
        return {
          internalValue: "",
        };
      },
      mounted() {
        if (this.type === "text") {
          this.hasPassword = false;
        }

        if (this.hasPassword) {
          this.internalValue = "*************";
        } else {
          this.internalValue = this.value;
        }
      },
      computed: {
        showError() {
          return this.error ? true : false;
        },
      },
      watch: {
        error(newVal) {
          const input = this.$refs.inputField;
          if (newVal) {
            input.setCustomValidity(newVal);
          } else {
            input.setCustomValidity("");
          }
          input.reportValidity();
        },
      },
      methods: {
        onInput(event) {
          this.internalValue = event.target.value;
          this.$emit("update:value", this.internalValue);
          this.$emit("update:has-password", !!this.internalValue);
          this.$emit("input", this.internalValue);
        },
      },
    };

    const NodeRedTypedInput = {
      template: `<input type="text" ref="typedInput" class="node-red-typed-input" style="flex: 1; width: 100%;"/>`,
      props: {
        value: {
          type: Object,
          required: true,
          validator: function (obj) {
            if (!typeof obj === "object") {
              console.warn("Prop 'value' must be an object.");
              return false;
            }
            const isValid =
              obj.hasOwnProperty("value") &&
              obj.hasOwnProperty("type") &&
              typeof obj.value === "string" &&
              typeof obj.type === "string";
            if (!isValid) {
              console.warn(
                "Validation failed for prop 'value': It must be an object with 'value' and 'type' properties being strings.",
                obj
              );
            }
            return isValid;
          },
        },
        types: {
          type: Array,
          default: () => [
            "msg",
            "flow",
            "global",
            "str",
            "num",
            "bool",
            "json",
            "bin",
            "re",
            "jsonata",
            "date",
            "env",
            "node",
            "cred",
          ],
        },
      },
      emits: ["update:value"],
      mounted() {
        const inputElement = this.$refs.typedInput;
        this.$input = $(inputElement).typedInput({
          default: this.value.type || this.types[0],
          types: this.types,
        });

        this.$input.typedInput("value", this.value.value || "");
        this.$input.typedInput("type", this.value.type || this.types[0]);

        // NOTE: when typed input is just an text input, it isn't emiting change while typing because it is updating the value in a hidden input
        this.$nextTick(() => {
          const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.attributeName === "value") {
                this.onChange();
              }
            }
          });

          observer.observe(inputElement, {
            attributes: true,
            attributeFilter: ["value"],
          });

          this._observer = observer;
        });

        // NOTE: this emits changes to all types that lose focus when choosing a value, but text inputs
        this.$input.on("change", () => {
          this.onChange();
        });
      },
      methods: {
        onChange() {
          const newValue = this.$input.typedInput("value");
          const newType = this.$input.typedInput("type");
          if (this.value.value !== newValue || this.value.type !== newType) {
            this.$emit("update:value", {
              value: newValue,
              type: newType,
            });
          }
        },
      },
    };

    const NodeRedConfigInput = {
      template: `<input type="text" :id="inputId" style="width: 100%"/>`,
      props: {
        value: String,
        type: String,
      },
      emits: ["update:value"],
      data() {
        return {
          inputId: "node-input-" + this.value,
        };
      },
      mounted() {
        console.log(this);
        RED.editor.prepareConfigNodeSelect(
          this,
          this.value,
          this.type,
          "node-input"
        );

        const input = $("#" + this.inputId);
        input.on("change", () => {
          this.$emit("update:value", input.val());
        });

        input.val(this.value || "_ADD_");
      },
    };

    const NodeRedSelectInput = {
      template: `<input type="text" ref="selectInput" class="node-input-select" style="width: 100%"/>`,
      props: {
        value: String,
        options: {
          type: Array,
          required: true,
          validator: function (value) {
            if (!Array.isArray(value)) {
              console.warn("Prop 'options' must be an array.");
              return false;
            }
            const isValid = value.every((item) => {
              const isObject = typeof item === "object" && item !== null;
              if (!isObject) return false;
              return (
                item.hasOwnProperty("value") &&
                item.hasOwnProperty("label") &&
                typeof item.value === "string" &&
                typeof item.label === "string"
              );
            });

            if (!isValid) {
              console.warn(
                "Validation failed for prop 'options': Each item must be an object with 'value' and 'label' properties being strings.",
                value
              );
            }
            return isValid;
          },
        },
        multiple: {
          type: Boolean,
          default: false,
        },
      },
      emits: ["update:value"],
      mounted() {
        const inputElement = this.$refs.selectInput;
        const $selectInput = $(inputElement);
        $selectInput.typedInput({
          types: [
            {
              multiple: this.multiple,
              options: this.options,
            },
          ],
        });

        $selectInput.typedInput("value", this.value);
        $selectInput.on("change", () => {
          const newValue = this.multiple
            ? $selectInput.typedInput("value")?.split(",")
            : $selectInput.typedInput("value");
          this.$emit("update:value", newValue);
        });
      },
    };

    const NodeRedEditorInput = {
      template: `<div class="node-text-editor-container" ref="containerDiv" style="height: 200px"><div ref="editorDiv" :id="editorId" class="node-text-editor"></div></div>`,
      props: {
        value: String,
        language: {
          type: String,
          default: "json",
          validator: function (value) {
            const allowedLanguages = [
              "text",
              "json",
              "javascript",
              "html",
              "css",
              "markdown",
              "sql",
              "yaml",
            ];
            const isValid = allowedLanguages.includes(value);
            if (!isValid) {
              console.warn(
                `[NodeRedEditorComponent] Invalid ACE editor mode prop: "${value}". ` +
                  `Expected one of: ${allowedLanguages.join(", ")}`
              );
            }
            return isValid;
          },
        },
      },
      emits: ["update:value"],
      editor: null,
      data() {
        return {
          editorId:
            "node-red-editor-" + Math.random().toString(36).substring(2, 9),
        };
      },
      mounted() {
        this.mountEditor();
      },
      methods: {
        mountEditor() {
          this.$nextTick(() => {
            const containerEl = this.$refs.containerDiv;
            const editorEl = this.$refs.editorDiv;

            if (containerEl && editorEl) {
              try {
                const inlineHeight = containerEl.style.height;
                const inlineWidth = containerEl.style.width;
                if (inlineHeight) {
                  editorEl.style.height = inlineHeight;
                } else {
                  editorEl.style.height = "200px";
                }

                if (inlineWidth) {
                  editorEl.style.width = inlineWidth;
                } else {
                  editorEl.style.width = "100%";
                }

                this.createEditorInstance();
              } catch (e) {
                console.error(
                  "[NodeRedEditorInput] Error setting initial editor style:",
                  e
                );
                this.createEditorInstance();
              }
            } else {
              console.error(
                "[NodeRedEditorInput] Container or Editor div refs not found on mount."
              );
            }
          });
        },
        createEditorInstance() {
          this.editorInstance = RED.editor.createEditor({
            id: this.editorId,
            mode: this.language,
            value: this.value,
          });
          this.editorInstance.getSession().on("change", () => {
            const currentValue = this.editorInstance.getValue();
            if (currentValue !== this.value) {
              this.$emit("update:value", currentValue);
            }
          });
        },
      },
      beforeUnmount() {
        if (this.editorInstance) {
          try {
            this.editorInstance.destroy();
          } catch (err) {
            console.error(
              `Error destroying editor for ID ${this.editorId}:`,
              err
            );
          }
          this.editorInstance = null;
        }
      },
    };

    node._app = Vue.createApp({
      data() {
        return {
          node,
          error: false,
          errors: [],
          usernameError: "",
          countries: [
            { value: "usa", label: "usa" },
            { value: "argentina", label: "argentina" },
            { value: "brasil", label: "brasil" },
          ],
          fruits: [
            { value: "apple", label: "apple" },
            { value: "melon", label: "melon" },
            { value: "raspberry", label: "raspberry" },
          ],
          numbers: [
            { value: "1", label: "1" },
            { value: "2", label: "2" },
            { value: "3", label: "3" },
          ],
          objects: [
            { value: JSON.stringify({ test: "a" }), label: "a" },
            { value: JSON.stringify({ test: "b" }), label: "b" },
            { value: JSON.stringify({ test: "c" }), label: "c" },
          ],
          arrays: [
            { value: JSON.stringify(["a"]), label: "a" },
            { value: JSON.stringify(["b"]), label: "b" },
            { value: JSON.stringify(["c"]), label: "c" },
          ],
        };
      },
      components: {
        NodeRedCredentialInput,
        NodeRedTypedInput,
        NodeRedConfigInput,
        NodeRedSelectInput,
        NodeRedEditorInput,
      },
      beforeMount() {
        console.log("BEFORE MOUNTING");
        console.log(this.node._def);

        // Object.keys(this.node._def.defaults).forEach((prop) => {
        //   console.log("Add validation");
        //   this.node._def.defaults[prop].validate =
        //     this.createValidateFunction(prop);
        // });

        // Object.keys(this.node._def.credentials).forEach((prop) => {
        //   console.log("Add validation");
        //   this.node._def.credentials[prop].validate =
        //     this.createValidateFunction(prop);
        // });
        // this.node._def.credentials.username.validate = this.validateUsername;
        // this.node._def._creds = this.node.credentials;

        Object.keys(this.node._def.defaults).forEach((prop) => {
          this.$watch(
            () => this.node[prop],
            (newVal) => {
              console.log(`changed prop: ${prop}`);
              console.log(newVal);
              this.validate();
            },
            { deep: true }
          );
        });

        Object.keys(this.node._def.credentials).forEach((prop) => {
          this.$watch(
            () => this.node.credentials[prop],
            (newVal) => {
              console.log(`changed credentials: ${prop}`);
              console.log(newVal);
              this.validate();
            },
            { deep: true }
          );
        });
      },
      methods: {
        toggleDoneButton() {
          console.log("TOGGLING DONE BUTTON");
          if (Object.keys(this.errors).length) {
            $("#node-dialog-ok").prop("disabled", true).addClass("disabled");
          } else {
            $("#node-dialog-ok")
              .prop("disabled", false)
              .removeClass("disabled");
          }
        },
        validate() {
          if (this.node) {
            const ajv = new ajv7({
              allErrors: true,
            });

            const schema = {
              type: "object",
              properties: {
                credentials: {
                  type: "object",
                  properties: {
                    username: { type: "string", minLength: 5, maxLength: 10 },
                    password: {
                      type: "string",
                      minLength: 8,
                      maxLength: 20,
                      pattern: "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]+$",
                    },
                  },
                  required: ["password", "username"],
                },
                myProperty: {
                  type: "object",
                  properties: {
                    value: {
                      type: "string",
                      default: "",
                    },
                    type: {
                      type: "string",
                      enum: [
                        "msg",
                        "flow",
                        "global",
                        "str",
                        "num",
                        "bool",
                        "json",
                        "bin",
                        "re",
                        "jsonata",
                        "date",
                        "env",
                        "node",
                        "cred",
                      ],
                      default: "str",
                    },
                  },
                  required: ["value", "type"],
                },
              },
              required: ["credentials", "myProperty"],
            };

            const data = {
              credentials: {},
            };
            Object.keys(this.node._def.credentials).forEach((prop) => {
              return (data.credentials[prop] = this.node.credentials[prop]);
            });

            Object.keys(this.node._def.defaults).forEach((prop) => {
              return (data[prop] = this.node[prop]);
            });

            const validate = ajv.compile(schema);

            const valid = validate(data);
            if (!valid) {
              console.log("errors");
              console.log(validate.errors);
              const errors = validate.errors;
              this.errors = errors.reduce((acc, error) => {
                const key = error.instancePath;
                acc[key] = error.message;
                return acc;
              }, {});
            } else {
              this.errors = {};
            }

            this.toggleDoneButton();
          }
        },
      },
      template: `
    	<div style="width: 100%;">
    		<div class="form-row">
    			<label><i class="fa fa-tag"></i> Username</label>
    			<NodeRedCredentialInput
            v-model:value="node.credentials.username"
            type="text"
            :error="errors['/credentials/username']"
          />
    		</div>
    		<div class="form-row">
    			<label><i class="fa fa-tag"></i> Password</label>
    			<NodeRedCredentialInput
            v-model:value="node.credentials.password"
            v-model:has-password="node.credentials.has_password"
            type="password"
            :error="errors['/credentials/password']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Typed Input</label>
    			<NodeRedTypedInput v-model:value="node.myProperty"/>
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Config Input</label>
    			<NodeRedConfigInput v-model:value="node.remoteServer" type="remote-server"/>
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput v-model:value="node.country" :options="countries"/>
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">MultiSelect Input</label>
    			<NodeRedSelectInput v-model:value="node.fruit" :options="fruits" multiple/>
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput v-model:value="node.number" :options="numbers"/>
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput v-model:value="node.object" :options="objects"/>
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput v-model:value="node.array" :options="arrays"/>
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Editor with default height 200px and JSON</label>
    			<NodeRedEditorInput v-model:value="node.jsontest" />
    		</div>
    		<div class="form-row">
    		  <label style="width: 100%">Editor with custom height and CSS</label>
    		  <NodeRedEditorInput v-model:value="node.csstest" language="css" style="height: 500px;"/>
    		</div>
    	</div>
     `,
    });
    node._app.config.performance = true;
    node._app.mount("#app");
  }

  function unmountApp(node) {
    node._app.unmount();
    node._app = null;
  }

  // TODO: find a better way to compare node states
  function strigifyNode(node) {
    const infoEditor = node.infoEditor;
    const app = node._app;
    const initialState = node._initial_state;
    const old = node._old;
    const highlighted = node.highlighted;
    delete node.infoEditor;
    delete node._app;
    delete node._initial_state;
    delete node._old;
    delete node.highlighted;
    const val = JSON.stringify(node);
    node.infoEditor = infoEditor;
    node._app = app;
    node._initial_state = initialState;
    node._old = old;
    node.highlighted = highlighted;
    return val;
  }

  function loadScriptsAndMount(urls, callback) {
    const scriptsLoaded = new Array(urls.length).fill(false); // To track the loading state of each script

    const checkIfAllLoaded = () => {
      if (scriptsLoaded.every((status) => status)) {
        callback();
      }
    };

    const onScriptLoad = (index) => {
      scriptsLoaded[index] = true;
      checkIfAllLoaded();
    };

    // Create and append each script
    urls.forEach((url, index) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = () => onScriptLoad(index);
      document.head.appendChild(script);
    });
  }

  $.getJSON("your-node", function (nodeProperties) {
    RED.nodes.registerType("your-node", {
      ...nodeProperties,
      label: function () {
        return this.name || "Your Node";
      },
      oneditprepare: function (abc) {
        const node = this;

        // document.getElementById("node-dialog-ok")?.addEventListener(
        //   "click",
        //   function (event) {
        //     event.preventDefault();
        //     event.stopImmediatePropagation();

        //     // Your custom logic
        //     console.log("Doing validation or async logic...");

        //     // Simulate original action AFTER you're done
        //     setTimeout(() => {
        //       console.log("Triggering original Node-RED save...");

        //       // Option 1: Trigger the click again (this time skipping your own listener)
        //       $("#node-dialog-ok")[0].click();

        //       // Option 2 (better): Call whatever function Node-RED uses to close the dialog or save
        //       // RED.nodes.registerType(...) gives access to oneditsave/oneditsubmit/etc
        //     }, 100); // Can also await a promise if you're async
        //   },
        //   true
        // );

        $("#node-dialog-ok").on("click", (event) => {
          event.stopImmediatePropagation();
        });
        console.log(node);

        node._old = {
          credentials: {},
        };
        Object.keys(nodeProperties.defaults).forEach((value) => {
          node._old[value] = node[value];
        });

        Object.keys(nodeProperties.credentials).forEach((value) => {
          node._old.credentials[value] = node.credentials[value];
        });

        if (!node._initial_state) {
          console.log("STORING NEW INITIAL STATE");
          node._initial_state = JSON.parse(strigifyNode(node));
        }

        if (typeof Vue !== "undefined") {
          console.log("Vue is already loaded:", Vue.version);
          mountApp(node);
          return;
        }

        const urls = [
          "https://unpkg.com/vue@3/dist/vue.global.js",
          "https://cdnjs.cloudflare.com/ajax/libs/ajv/8.17.1/ajv7.min.js",
        ];

        loadScriptsAndMount(urls, () => {
          mountApp(node);
        });
      },
      oneditsave: function () {
        const node = this;

        node.changed = strigifyNode(node._initial_state) !== strigifyNode(node);
        if (node.changed) {
          console.log("THERE ARE CHANGES");
          if (node._old["remoteServer"]) {
            const oldRemoteServer = RED.nodes.node(node._old["remoteServer"]);
            const parentIndex = oldRemoteServer.users.findIndex(
              (_node) => _node.id === node.id
            );
            if (parentIndex !== -1) {
              oldRemoteServer.users.splice(parentIndex, 1);
            }
          }

          RED.nodes.updateConfigNodeUsers(node, {
            action: "add",
            emitEvent: true,
          });

          RED.nodes.dirty(node);
        }

        node.validationErrors = ["'myField' is required"];
        node.valid = false;
        RED.view.redraw(true);
        console.log("SAVED");
        console.log(node);
        unmountApp(node);
      },
      oneditcancel: function () {
        const node = this;

        Object.keys(nodeProperties.defaults).forEach((value) => {
          node[value] = node._old[value];
        });

        Object.keys(nodeProperties.credentials).forEach((value) => {
          node.credentials[value] = node._old.credentials[value];
        });

        node.changed = strigifyNode(node._initial_state) !== strigifyNode(node);
        if (node.changed) {
          RED.nodes.dirty(node);
        }

        unmountApp(node);
      },
      oneditdelete: function () {
        const node = this;
        unmountApp(node);
      },
      oneditresize: function () {
        console.log("hello world");
      },
    });
  });
</script>
