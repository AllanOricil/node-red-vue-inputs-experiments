<script type="text/html" data-template-name="remote-server">
  <div class="form-row">
    <label for="node-config-input-name"><i class="fa"></i> Name</label>
    <input type="text" id="node-config-input-name" />
  </div>
  <div class="form-row">
    <label for="node-config-input-host"
      ><i class="fa fa-bookmark"></i> Host</label
    >
    <input type="text" id="node-config-input-host" />
  </div>
</script>

<script type="text/javascript">
  RED.nodes.registerType("remote-server", {
    category: "config",
    color: "#a6bbcf",
    defaults: {
      name: { value: "", required: true },
      host: { value: "localhost", required: true },
    },
    label: function () {
      return this.name;
    },
  });
</script>

<script type="text/html" data-template-name="your-node">
  <div id="app"></div>
</script>

<style>
  .node-red-vue-input-error-message {
    color: var(--red-ui-form-input-border-error-color);
  }
</style>
<script type="text/javascript">
  // RED.events.on("editor:open", function () {
  //   alert("OPENED");
  // });

  RED.events.on("deploy", () => {
    RED.nodes.eachNode(function (node) {
      console.log("RESET INITIAL STATE");
      node._initial_state = null;
    });
  });

  function getChanges(old, current) {
    const changes = {};

    console.log(old);
    console.log(current);

    Object.keys(old).forEach((prop) => {
      const o = old[prop];
      const c = current[prop];

      if (typeof o === "object") {
        const _changes = getChanges(o, c);
        if (Object.keys(_changes).length) {
          changes[prop] = _changes;
        }
      } else if (o !== c) {
        changes[prop] = o;
      }
    });

    return changes;
  }

  function createValidator(schema) {
    const ajv = new ajv7({
      allErrors: true,
      useDefaults: "empty",
    });

    return ajv.compile(schema);
  }

  function createApp(node, NodeRedNodeForm, validator) {
    const NodeRedCredentialInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input ref="inputField" :type="type" :value="internalValue" @input="onInput" style="flex: 1; width: 100%;" />
        <div v-if="error" class="node-red-vue-input-error-message " >
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String,
        type: {
          type: String,
          default: "text",
          validator: function (value) {
            return ["text", "password"].includes(value);
          },
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value", "input"],
      data() {
        return {
          internalValue: "",
        };
      },
      beforeMount() {
        this.internalValue = this.value;
        if (this.type === "password" && !this.value) {
          this.internalValue = "*************";
        }
      },
      methods: {
        onInput(event) {
          this.internalValue = event.target.value;
          this.$emit("update:value", this.internalValue);
          this.$emit("input", this.internalValue);
        },
      },
    };

    const NodeRedTypedInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input type="text" ref="typedInput" class="node-red-typed-input" style="flex: 1; width: 100%;"/>
        <div v-if="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: {
          type: Object,
          required: true,
          validator: function (obj) {
            if (!typeof obj === "object") {
              console.warn("Prop 'value' must be an object.");
              return false;
            }
            const isValid =
              obj.hasOwnProperty("value") &&
              obj.hasOwnProperty("type") &&
              typeof obj.value === "string" &&
              typeof obj.type === "string";
            if (!isValid) {
              console.warn(
                "Validation failed for prop 'value': It must be an object with 'value' and 'type' properties being strings.",
                obj
              );
            }
            return isValid;
          },
        },
        types: {
          type: Array,
          default: () => [
            "msg",
            "flow",
            "global",
            "str",
            "num",
            "bool",
            "json",
            "bin",
            "re",
            "jsonata",
            "date",
            "env",
            "node",
            "cred",
          ],
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      mounted() {
        const inputElement = this.$refs.typedInput;
        this.$input = $(inputElement).typedInput({
          default: this.value.type || this.types[0],
          types: this.types,
        });

        this.$input.typedInput("value", this.value.value || "");
        this.$input.typedInput("type", this.value.type || this.types[0]);

        // NOTE: when typed input is just a text input, it isn't emiting change while typing because it is updating the value in a hidden input
        this.$nextTick(() => {
          const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.attributeName === "value") {
                this.onChange();
              }
            }
          });

          observer.observe(inputElement, {
            attributes: true,
            attributeFilter: ["value"],
          });

          this._observer = observer;
        });

        // NOTE: this emits changes to all types that lose focus when choosing a value, but text inputs
        this.$input.on("change", () => {
          this.onChange();
        });
      },
      watch: {
        error(newVal) {
          this.$nextTick(() => {
            const targetDiv = this.$el.querySelector(
              ".red-ui-typedInput-container"
            );
            if (newVal) {
              targetDiv.classList.add("input-error");
            } else {
              targetDiv.classList.remove("input-error");
            }
          });
        },
      },
      methods: {
        onChange() {
          const newValue = this.$input.typedInput("value");
          const newType = this.$input.typedInput("type");
          if (this.value.value !== newValue || this.value.type !== newType) {
            this.$emit("update:value", {
              value: newValue,
              type: newType,
            });
          }
        },
      },
    };

    const NodeRedConfigInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input type="text" :id="inputId" style="width: 100%"/>
        <div v-if="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String,
        type: String,
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      data() {
        return {
          inputId: "node-input-" + this.value,
        };
      },
      mounted() {
        console.log(this);
        RED.editor.prepareConfigNodeSelect(
          this,
          this.value,
          this.type,
          "node-input"
        );

        const input = $("#" + this.inputId);
        input.on("change", () => {
          this.$emit("update:value", input.val());
        });

        input.val(this.value || "_ADD_");
      },
    };

    const NodeRedSelectInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input type="text" ref="selectInput" class="node-input-select" style="width: 100%"/>
        <div v-if="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String | Array,
        options: {
          type: Array,
          required: true,
          validator: function (value) {
            if (!Array.isArray(value)) {
              console.warn("Prop 'options' must be an array.");
              return false;
            }
            const isValid = value.every((item) => {
              const isObject = typeof item === "object" && item !== null;
              if (!isObject) return false;
              return (
                item.hasOwnProperty("value") &&
                item.hasOwnProperty("label") &&
                typeof item.value === "string" &&
                typeof item.label === "string"
              );
            });

            if (!isValid) {
              console.warn(
                "Validation failed for prop 'options': Each item must be an object with 'value' and 'label' properties being strings.",
                value
              );
            }
            return isValid;
          },
        },
        multiple: {
          type: Boolean,
          default: false,
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      mounted() {
        const inputElement = this.$refs.selectInput;
        const $selectInput = $(inputElement);
        $selectInput.typedInput({
          types: [
            {
              multiple: this.multiple,
              options: this.options,
            },
          ],
        });

        $selectInput.typedInput(
          "value",
          Array.isArray(this.value) ? this.value.join(",") : this.value
        );
        $selectInput.on("change", () => {
          const newValue = this.multiple
            ? $selectInput.typedInput("value")?.split(",")
            : $selectInput.typedInput("value");
          this.$emit("update:value", newValue);
        });
      },
    };

    const NodeRedEditorInput = {
      template: `
      <div ref="containerDiv" class="node-text-editor-container">
        <div ref="editorDiv" :id="editorId" class="node-text-editor"></div>
        <div v-show="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String,
        language: {
          type: String,
          default: "json",
          validator: function (value) {
            const allowedLanguages = [
              "text",
              "json",
              "javascript",
              "html",
              "css",
              "markdown",
              "sql",
              "yaml",
            ];
            const isValid = allowedLanguages.includes(value);
            if (!isValid) {
              console.warn(
                `[NodeRedEditorComponent] Invalid ACE editor mode prop: "${value}". ` +
                  `Expected one of: ${allowedLanguages.join(", ")}`
              );
            }
            return isValid;
          },
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      editor: null,
      data() {
        return {
          editorId:
            "node-red-editor-" + Math.random().toString(36).substring(2, 9),
        };
      },
      mounted() {
        this.mountEditor();
      },
      methods: {
        mountEditor() {
          this.$nextTick(() => {
            const containerEl = this.$refs.containerDiv;
            const editorEl = this.$refs.editorDiv;

            if (containerEl && editorEl) {
              try {
                const inlineHeight = containerEl.style.height;
                const inlineWidth = containerEl.style.width;
                if (inlineHeight) {
                  editorEl.style.height = inlineHeight;
                } else {
                  editorEl.style.height = "200px";
                }

                if (inlineWidth) {
                  editorEl.style.width = inlineWidth;
                } else {
                  editorEl.style.width = "100%";
                }

                this.createEditorInstance();
              } catch (e) {
                console.error(
                  "[NodeRedEditorInput] Error setting initial editor style:",
                  e
                );
                this.createEditorInstance();
              }
            } else {
              console.error(
                "[NodeRedEditorInput] Container or Editor div refs not found on mount."
              );
            }
          });
        },
        createEditorInstance() {
          this.editorInstance = RED.editor.createEditor({
            id: this.editorId,
            mode: this.language,
            value: this.value,
          });
          this.editorInstance.getSession().on("change", () => {
            const currentValue = this.editorInstance.getValue();
            if (currentValue !== this.value) {
              this.$emit("update:value", currentValue);
            }
          });
        },
      },
      beforeUnmount() {
        if (this.editorInstance) {
          try {
            this.editorInstance.destroy();
          } catch (err) {
            console.error(
              `Error destroying editor for ID ${this.editorId}:`,
              err
            );
          }
          this.editorInstance = null;
        }
      },
    };

    const app = Vue.createApp({
      data() {
        return {
          node,
          errors: {},
        };
      },
      validator,
      components: {
        NodeRedNodeForm,
      },
      beforeMount() {
        this.validate();

        Object.keys(this.node._def.defaults).forEach((prop) => {
          this.$watch(
            () => this.node[prop],
            (newVal) => {
              this.validate();
            },
            { deep: true }
          );
        });

        Object.keys(this.node._def.credentials).forEach((prop) => {
          this.$watch(
            () => this.node.credentials[prop],
            (newVal, oldVal) => {
              this.validate();

              if (
                this.node._def.credentials[prop].type === "password" &&
                newVal !== oldVal
              ) {
                this.node.credentials[`has_${prop}`] = true;
              }
            },
            { deep: true }
          );
        });
      },
      beforeUnmount() {
        $("#node-dialog-ok").prop("disabled", false).removeClass("disabled");
        $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
        $("#red-ui-workspace-chart svg")
          .get(0)
          .style.setProperty("pointer-events", "all");
      },
      methods: {
        validate() {
          const valid = validator(this.node);
          if (!valid) {
            const errors = validator.errors;
            this.errors = errors.reduce((acc, error) => {
              const key = `node${error.instancePath.replaceAll("/", ".")}`;
              acc[key] = error.message;
              return acc;
            }, {});
          } else {
            this.errors = {};
          }
          if (Object.keys(this.errors).length) {
            $("#node-dialog-ok").prop("disabled", true).addClass("disabled");
            $("#red-ui-workspace")
              .get(0)
              .style.setProperty("pointer-events", "none", "important");
            $("#red-ui-workspace-chart svg")
              .get(0)
              .style.setProperty("pointer-events", "none", "important");
          } else {
            $("#node-dialog-ok")
              .prop("disabled", false)
              .removeClass("disabled");
            $("#red-ui-workspace")
              .get(0)
              .style.setProperty("pointer-events", "");
            $("#red-ui-workspace-chart svg")
              .get(0)
              .style.setProperty("pointer-events", "all");
          }
        },
      },
      template: `
    	<div style="width: 100%;">
    		<NodeRedNodeForm
          :node="node"
          :errors="errors"
          style="width: 100%;"
        />
    	</div>`,
    });
    app.config.performance = true;
    app.component("NodeRedCredentialInput", NodeRedCredentialInput);
    app.component("NodeRedTypedInput", NodeRedTypedInput);
    app.component("NodeRedConfigInput", NodeRedConfigInput);
    app.component("NodeRedSelectInput", NodeRedSelectInput);
    app.component("NodeRedEditorInput", NodeRedEditorInput);
    return app;
  }

  function mountApp(node, formComponent, schema) {
    $("#app").empty();
    const validator = createValidator(schema);
    node._app = createApp(node, formComponent, validator);
    node._app.mount("#app");
  }

  function unmountApp(node) {
    if (node._app) {
      node._app.unmount();
      node._app = null;
    }
  }

  function getNodeState(node) {
    const state = {
      credentials: {},
    };
    Object.keys(node._def.defaults).forEach((prop) => {
      state[prop] = node[prop];
    });
    Object.keys(node._def.credentials).forEach((prop) => {
      state.credentials[prop] = node.credentials[prop];

      if (node._def.credentials[prop].type === "password") {
        state.credentials[`has_${prop}`] =
          node.credentials[`has_${prop}`] || false;
      }
    });

    return state;
  }

  function loadExternalScripts(urls, callback) {
    const scriptsLoaded = new Array(urls.length).fill(false); // To track the loading state of each script

    const checkIfAllLoaded = () => {
      if (scriptsLoaded.every((status) => status)) {
        callback();
      }
    };

    const onScriptLoad = (index) => {
      scriptsLoaded[index] = true;
      checkIfAllLoaded();
    };

    // Create and append each script
    urls.forEach((url, index) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = () => onScriptLoad(index);
      document.head.appendChild(script);
    });
  }

  $.getJSON("your-node", function (nodeProperties) {
    RED.nodes.registerType("your-node", {
      ...nodeProperties,
      label: function () {
        return this.name || "Your Node";
      },
      oneditprepare: function (abc) {
        const node = this;

        console.log(node);
        // NOTE: provided by the User
        const formComponent = {
          template: `
    	<div>
    		<div class="form-row">
    			<label style="width: 100%"><i class="fa fa-tag"></i> Username</label>
    			<NodeRedCredentialInput
            v-model:value="node.credentials.username"
            :error="errors['node.credentials.username']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%"><i class="fa fa-tag"></i> Password</label>
    			<NodeRedCredentialInput
            v-model:value="node.credentials.password"
            type="password"
            :error="errors['node.credentials.password']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Typed Input</label>
    			<NodeRedTypedInput
            v-model:value="node.myProperty"
            :error="errors['node.myProperty']"
          />
    		</div>
        <div class="form-row">
    			<label style="width: 100%">Typed Input 2</label>
    			<NodeRedTypedInput
            v-model:value="node.myProperty2"
            :error="errors['node.myProperty2']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Config Input</label>
    			<NodeRedConfigInput
            v-model:value="node.remoteServer"
            type="remote-server"
            :error="errors['node.remoteServer']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.country"
            :options="countries"
            :error="errors['node.country']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">MultiSelect Input</label>
    			<NodeRedSelectInput
            v-model:value="node.fruit"
            :options="fruits"
            multiple
            :error="errors['node.fruit']"
          />
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.number"
            :options="numbers"
            :error="errors['node.number']"
          />
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.object"
            :options="objects"
            multiple
            :error="errors['node.object']"
          />
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.array"
            :options="arrays"
            :error="errors['node.array']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Editor with default height 200px and JSON</label>
    			<NodeRedEditorInput
            v-model:value="node.jsontest"
            :error="errors['node.jsontest']"
          />
    		</div>
    		<div class="form-row">
    		  <label style="width: 100%">Editor with custom height and CSS</label>
    		  <NodeRedEditorInput
            v-model:value="node.csstest"
            language="css"
            style="height: 100px;"
            :error="errors['node.csstest']"
          />
    		</div>
    	</div>`,
          props: {
            node: {
              type: Object,
            },
            errors: {
              type: Object,
            },
          },
          data() {
            return {
              countries: [
                { value: "usa", label: "usa" },
                { value: "argentina", label: "argentina" },
                { value: "brasil", label: "brasil" },
              ],
              fruits: [
                { value: "apple", label: "apple" },
                { value: "melon", label: "melon" },
                { value: "raspberry", label: "raspberry" },
              ],
              numbers: [
                { value: "1", label: "1" },
                { value: "2", label: "2" },
                { value: "3", label: "3" },
              ],
              objects: [
                { value: JSON.stringify({ test: "a" }), label: "a" },
                { value: JSON.stringify({ test: "b" }), label: "b" },
                { value: JSON.stringify({ test: "c" }), label: "c" },
              ],
              arrays: [
                { value: JSON.stringify(["a"]), label: "a" },
                { value: JSON.stringify(["b"]), label: "b" },
                { value: JSON.stringify(["c"]), label: "c" },
              ],
            };
          },
        };

        // NOTE: provided by the User
        const schema = {
          type: "object",
          properties: {
            credentials: {
              type: "object",
              properties: {
                username: {
                  type: "string",
                  minLength: 5,
                  maxLength: 10,
                  default: "",
                },
                password: {
                  type: "string",
                  minLength: 8,
                  maxLength: 20,
                  pattern: "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]+$",
                  default: "",
                },
              },
              default: {},
              required: ["password", "username"],
            },
            myProperty: {
              type: "object",
              properties: {
                value: {
                  type: "string",
                  default: "",
                },
                type: {
                  type: "string",
                  enum: [
                    "msg",
                    "flow",
                    "global",
                    "str",
                    "num",
                    "bool",
                    "json",
                    "bin",
                    "re",
                    "jsonata",
                    "date",
                    "env",
                    "node",
                    "cred",
                  ],
                  default: "str",
                },
              },
              required: ["value", "type"],
              default: {},
              oneOf: [
                {
                  properties: {
                    type: { const: "str" },
                    value: { type: "string", minLength: 10 },
                  },
                },
              ],
            },
            myProperty2: {
              type: "object",
              properties: {
                value: {
                  type: "string",
                  default: "",
                },
                type: {
                  type: "string",
                  enum: [
                    "msg",
                    "flow",
                    "global",
                    "str",
                    "num",
                    "bool",
                    "json",
                    "bin",
                    "re",
                    "jsonata",
                    "date",
                    "env",
                    "node",
                    "cred",
                  ],
                  default: "str",
                },
              },
              required: ["value", "type"],
              default: {},
            },
            country: {
              type: "string",
              default: "brasil",
            },
          },
        };

        node._old = getNodeState(node);
        if (!node._initial_state) {
          console.log("STORING NEW INITIAL STATE");
          node._initial_state = JSON.parse(JSON.stringify(node._old));
        }

        if (typeof Vue !== "undefined") {
          console.log("Vue is already loaded:", Vue.version);
          mountApp(node, formComponent, schema);
          return;
        }

        const urls = [
          "https://unpkg.com/vue@3/dist/vue.global.js",
          "https://cdnjs.cloudflare.com/ajax/libs/ajv/8.17.1/ajv7.min.js",
        ];

        loadExternalScripts(urls, () => {
          mountApp(node, formComponent, schema);
        });
      },
      oneditsave: function () {
        const node = this;
        const current_state = getNodeState(node);
        const changed =
          JSON.stringify(node._initial_state) !== JSON.stringify(current_state);
        if (changed) {
          console.log("THERE ARE CHANGES");

          // NOTE: updating config node users
          Object.keys(node._def.defaults).forEach((prop) => {
            if (node._def.defaults?.[prop]?.type) {
              console.log(node._def.defaults?.[prop]?.type);
              const oldPropState = node._old[prop];
              const currentPropState = node[prop];
              console.log(`prop: ${prop}`);
              console.log(`oldPropState: ${oldPropState}`);
              console.log(`currentPropState: ${currentPropState}`);
              if (oldPropState !== currentPropState) {
                console.log("CHANGED");

                const oldConfigNode = RED.nodes.node(oldPropState);
                console.log(`oldConfigNode`);
                console.log(oldConfigNode);
                if (oldConfigNode) {
                  const parentNodeIndex = oldConfigNode.users.findIndex(
                    (_node) => _node.id === node.id
                  );
                  if (parentNodeIndex !== -1) {
                    oldConfigNode.users.splice(parentNodeIndex, 1);
                  }
                }

                const currentConfigNode = RED.nodes.node(currentPropState);
                console.log(`currentConfigNode`);
                console.log(currentConfigNode);
                if (currentConfigNode) {
                  const parentNodeIndex = currentConfigNode.users.findIndex(
                    (_node) => _node.id === node.id
                  );
                  if (parentNodeIndex === -1) {
                    currentConfigNode.users.push(node);
                  }
                }
              }
            }
          });

          const changes = getChanges(node._old, current_state);
          return {
            changed,
            history: [
              {
                t: "edit",
                node,
                changes,
                links: [],
                dirty: RED.nodes.dirty(),
                changed,
              },
            ],
          };
        }

        unmountApp(node);
        return false;
      },
      oneditcancel: function () {
        console.log("ONEDITCANCEL");
        const node = this;

        Object.keys(node._def.defaults).forEach((prop) => {
          node[prop] = node._old[prop];
        });
        Object.keys(node._def.credentials).forEach((prop) => {
          node.credentials[prop] = node._old.credentials[prop];

          if (node._def.credentials[prop].type === "password") {
            node.credentials[`has_${prop}`] =
              node._old.credentials[`has_${prop}`];
          }
        });

        unmountApp(node);
      },
      oneditdelete: function () {
        console.log("ONEDITDELETE");
        const node = this;
        unmountApp(node);
      },
      oneditresize: function () {
        console.log("hello world");
      },
    });
  });
</script>
