<script type="text/html" data-template-name="remote-server">
  <div id="app"></div>
</script>

<script type="text/html" data-template-name="your-node">
  <div id="app"></div>
</script>

<style>
.node-red-vue-input-error-message{
  color:var(--red-ui-form-input-border-error-color)
}

.form-row label{
  width: 100% !important
}
</style>

<!-- TODO: create a /core/client lib and change to ts -->
<script type="text/javascript">var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  (function($$1) {
    "use strict";
    /**
    * @vue/shared v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str) {
      const map2 = /* @__PURE__ */ Object.create(null);
      for (const key of str.split(",")) map2[key] = 1;
      return (val) => val in map2;
    }
    const EMPTY_OBJ = Object.freeze({});
    const EMPTY_ARR = Object.freeze([]);
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
    const isArray = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isFunction = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isSymbol = (val) => typeof val === "symbol";
    const isObject = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
    };
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const isBuiltInDirective = /* @__PURE__ */ makeMap(
      "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
    );
    const cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction(
      (str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      }
    );
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction(
      (str) => {
        const s = str ? `on${capitalize(str)}` : ``;
        return s;
      }
    );
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
      }
    };
    const def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value) || isObject(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
    const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
    const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
    const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    const isRef$1 = (val) => {
      return !!(val && val["__v_isRef"] === true);
    };
    const toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol(val)) {
        return stringifySymbol(val);
      } else if (isObject(val) && !isArray(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
      );
    };
    /**
    * @vue/reactivity v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function warn$2(msg, ...args) {
      console.warn(`[Vue warn] ${msg}`, ...args);
    }
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this._isPaused = false;
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      pause() {
        if (this._active) {
          this._isPaused = true;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].pause();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].pause();
          }
        }
      }
      /**
       * Resumes the effect scope, including all child scopes and effects.
       */
      resume() {
        if (this._active) {
          if (this._isPaused) {
            this._isPaused = false;
            let i, l;
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].resume();
              }
            }
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].resume();
            }
          }
        }
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        } else {
          warn$2(`cannot run an inactive effect scope.`);
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          this._active = false;
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          this.effects.length = 0;
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          this.cleanups.length = 0;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
            this.scopes.length = 0;
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
        }
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    let activeSub;
    const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
    class ReactiveEffect {
      constructor(fn) {
        this.fn = fn;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 1 | 4;
        this.next = void 0;
        this.cleanup = void 0;
        this.scheduler = void 0;
        if (activeEffectScope && activeEffectScope.active) {
          activeEffectScope.effects.push(this);
        }
      }
      pause() {
        this.flags |= 64;
      }
      resume() {
        if (this.flags & 64) {
          this.flags &= -65;
          if (pausedQueueEffects.has(this)) {
            pausedQueueEffects.delete(this);
            this.trigger();
          }
        }
      }
      /**
       * @internal
       */
      notify() {
        if (this.flags & 2 && !(this.flags & 32)) {
          return;
        }
        if (!(this.flags & 8)) {
          batch(this);
        }
      }
      run() {
        if (!(this.flags & 1)) {
          return this.fn();
        }
        this.flags |= 2;
        cleanupEffect(this);
        prepareDeps(this);
        const prevEffect = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = this;
        shouldTrack = true;
        try {
          return this.fn();
        } finally {
          if (activeSub !== this) {
            warn$2(
              "Active effect was not restored correctly - this is likely a Vue internal bug."
            );
          }
          cleanupDeps(this);
          activeSub = prevEffect;
          shouldTrack = prevShouldTrack;
          this.flags &= -3;
        }
      }
      stop() {
        if (this.flags & 1) {
          for (let link = this.deps; link; link = link.nextDep) {
            removeSub(link);
          }
          this.deps = this.depsTail = void 0;
          cleanupEffect(this);
          this.onStop && this.onStop();
          this.flags &= -2;
        }
      }
      trigger() {
        if (this.flags & 64) {
          pausedQueueEffects.add(this);
        } else if (this.scheduler) {
          this.scheduler();
        } else {
          this.runIfDirty();
        }
      }
      /**
       * @internal
       */
      runIfDirty() {
        if (isDirty(this)) {
          this.run();
        }
      }
      get dirty() {
        return isDirty(this);
      }
    }
    let batchDepth = 0;
    let batchedSub;
    let batchedComputed;
    function batch(sub, isComputed = false) {
      sub.flags |= 8;
      if (isComputed) {
        sub.next = batchedComputed;
        batchedComputed = sub;
        return;
      }
      sub.next = batchedSub;
      batchedSub = sub;
    }
    function startBatch() {
      batchDepth++;
    }
    function endBatch() {
      if (--batchDepth > 0) {
        return;
      }
      if (batchedComputed) {
        let e = batchedComputed;
        batchedComputed = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          e = next;
        }
      }
      let error;
      while (batchedSub) {
        let e = batchedSub;
        batchedSub = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          if (e.flags & 1) {
            try {
              ;
              e.trigger();
            } catch (err) {
              if (!error) error = err;
            }
          }
          e = next;
        }
      }
      if (error) throw error;
    }
    function prepareDeps(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        link.version = -1;
        link.prevActiveLink = link.dep.activeLink;
        link.dep.activeLink = link;
      }
    }
    function cleanupDeps(sub) {
      let head;
      let tail = sub.depsTail;
      let link = tail;
      while (link) {
        const prev = link.prevDep;
        if (link.version === -1) {
          if (link === tail) tail = prev;
          removeSub(link);
          removeDep(link);
        } else {
          head = link;
        }
        link.dep.activeLink = link.prevActiveLink;
        link.prevActiveLink = void 0;
        link = prev;
      }
      sub.deps = head;
      sub.depsTail = tail;
    }
    function isDirty(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
          return true;
        }
      }
      if (sub._dirty) {
        return true;
      }
      return false;
    }
    function refreshComputed(computed2) {
      if (computed2.flags & 4 && !(computed2.flags & 16)) {
        return;
      }
      computed2.flags &= -17;
      if (computed2.globalVersion === globalVersion) {
        return;
      }
      computed2.globalVersion = globalVersion;
      const dep = computed2.dep;
      computed2.flags |= 2;
      if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
        computed2.flags &= -3;
        return;
      }
      const prevSub = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = computed2;
      shouldTrack = true;
      try {
        prepareDeps(computed2);
        const value = computed2.fn(computed2._value);
        if (dep.version === 0 || hasChanged(value, computed2._value)) {
          computed2._value = value;
          dep.version++;
        }
      } catch (err) {
        dep.version++;
        throw err;
      } finally {
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDeps(computed2);
        computed2.flags &= -3;
      }
    }
    function removeSub(link, soft = false) {
      const { dep, prevSub, nextSub } = link;
      if (prevSub) {
        prevSub.nextSub = nextSub;
        link.prevSub = void 0;
      }
      if (nextSub) {
        nextSub.prevSub = prevSub;
        link.nextSub = void 0;
      }
      if (dep.subsHead === link) {
        dep.subsHead = nextSub;
      }
      if (dep.subs === link) {
        dep.subs = prevSub;
        if (!prevSub && dep.computed) {
          dep.computed.flags &= -5;
          for (let l = dep.computed.deps; l; l = l.nextDep) {
            removeSub(l, true);
          }
        }
      }
      if (!soft && !--dep.sc && dep.map) {
        dep.map.delete(dep.key);
      }
    }
    function removeDep(link) {
      const { prevDep, nextDep } = link;
      if (prevDep) {
        prevDep.nextDep = nextDep;
        link.prevDep = void 0;
      }
      if (nextDep) {
        nextDep.prevDep = prevDep;
        link.nextDep = void 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function cleanupEffect(e) {
      const { cleanup } = e;
      e.cleanup = void 0;
      if (cleanup) {
        const prevSub = activeSub;
        activeSub = void 0;
        try {
          cleanup();
        } finally {
          activeSub = prevSub;
        }
      }
    }
    let globalVersion = 0;
    class Link {
      constructor(sub, dep) {
        this.sub = sub;
        this.dep = dep;
        this.version = dep.version;
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
      }
    }
    class Dep {
      constructor(computed2) {
        this.computed = computed2;
        this.version = 0;
        this.activeLink = void 0;
        this.subs = void 0;
        this.map = void 0;
        this.key = void 0;
        this.sc = 0;
        {
          this.subsHead = void 0;
        }
      }
      track(debugInfo) {
        if (!activeSub || !shouldTrack || activeSub === this.computed) {
          return;
        }
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
          link = this.activeLink = new Link(activeSub, this);
          if (!activeSub.deps) {
            activeSub.deps = activeSub.depsTail = link;
          } else {
            link.prevDep = activeSub.depsTail;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
          }
          addSub(link);
        } else if (link.version === -1) {
          link.version = this.version;
          if (link.nextDep) {
            const next = link.nextDep;
            next.prevDep = link.prevDep;
            if (link.prevDep) {
              link.prevDep.nextDep = next;
            }
            link.prevDep = activeSub.depsTail;
            link.nextDep = void 0;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
            if (activeSub.deps === link) {
              activeSub.deps = next;
            }
          }
        }
        if (activeSub.onTrack) {
          activeSub.onTrack(
            extend(
              {
                effect: activeSub
              },
              debugInfo
            )
          );
        }
        return link;
      }
      trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
      }
      notify(debugInfo) {
        startBatch();
        try {
          if (true) {
            for (let head = this.subsHead; head; head = head.nextSub) {
              if (head.sub.onTrigger && !(head.sub.flags & 8)) {
                head.sub.onTrigger(
                  extend(
                    {
                      effect: head.sub
                    },
                    debugInfo
                  )
                );
              }
            }
          }
          for (let link = this.subs; link; link = link.prevSub) {
            if (link.sub.notify()) {
              ;
              link.sub.dep.notify();
            }
          }
        } finally {
          endBatch();
        }
      }
    }
    function addSub(link) {
      link.dep.sc++;
      if (link.sub.flags & 4) {
        const computed2 = link.dep.computed;
        if (computed2 && !link.dep.subs) {
          computed2.flags |= 4 | 16;
          for (let l = computed2.deps; l; l = l.nextDep) {
            addSub(l);
          }
        }
        const currentTail = link.dep.subs;
        if (currentTail !== link) {
          link.prevSub = currentTail;
          if (currentTail) currentTail.nextSub = link;
        }
        if (link.dep.subsHead === void 0) {
          link.dep.subsHead = link;
        }
        link.dep.subs = link;
      }
    }
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol(
      "Object iterate"
    );
    const MAP_KEY_ITERATE_KEY = Symbol(
      "Map keys iterate"
    );
    const ARRAY_ITERATE_KEY = Symbol(
      "Array iterate"
    );
    function track(target, type2, key) {
      if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = new Dep());
          dep.map = depsMap;
          dep.key = key;
        }
        {
          dep.track({
            target,
            type: type2,
            key
          });
        }
      }
    }
    function trigger(target, type2, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        globalVersion++;
        return;
      }
      const run = (dep) => {
        if (dep) {
          {
            dep.trigger({
              target,
              type: type2,
              key,
              newValue,
              oldValue,
              oldTarget
            });
          }
        }
      };
      startBatch();
      if (type2 === "clear") {
        depsMap.forEach(run);
      } else {
        const targetIsArray = isArray(target);
        const isArrayIndex = targetIsArray && isIntegerKey(key);
        if (targetIsArray && key === "length") {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
              run(dep);
            }
          });
        } else {
          if (key !== void 0 || depsMap.has(void 0)) {
            run(depsMap.get(key));
          }
          if (isArrayIndex) {
            run(depsMap.get(ARRAY_ITERATE_KEY));
          }
          switch (type2) {
            case "add":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isArrayIndex) {
                run(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap(target)) {
                run(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
      }
      endBatch();
    }
    function reactiveReadArray(array) {
      const raw = toRaw(array);
      if (raw === array) return raw;
      track(raw, "iterate", ARRAY_ITERATE_KEY);
      return isShallow(array) ? raw : raw.map(toReactive);
    }
    function shallowReadArray(arr) {
      track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
      return arr;
    }
    const arrayInstrumentations = {
      __proto__: null,
      [Symbol.iterator]() {
        return iterator(this, Symbol.iterator, toReactive);
      },
      concat(...args) {
        return reactiveReadArray(this).concat(
          ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
        );
      },
      entries() {
        return iterator(this, "entries", (value) => {
          value[1] = toReactive(value[1]);
          return value;
        });
      },
      every(fn, thisArg) {
        return apply(this, "every", fn, thisArg, void 0, arguments);
      },
      filter(fn, thisArg) {
        return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
      },
      find(fn, thisArg) {
        return apply(this, "find", fn, thisArg, toReactive, arguments);
      },
      findIndex(fn, thisArg) {
        return apply(this, "findIndex", fn, thisArg, void 0, arguments);
      },
      findLast(fn, thisArg) {
        return apply(this, "findLast", fn, thisArg, toReactive, arguments);
      },
      findLastIndex(fn, thisArg) {
        return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
      },
      // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
      forEach(fn, thisArg) {
        return apply(this, "forEach", fn, thisArg, void 0, arguments);
      },
      includes(...args) {
        return searchProxy(this, "includes", args);
      },
      indexOf(...args) {
        return searchProxy(this, "indexOf", args);
      },
      join(separator) {
        return reactiveReadArray(this).join(separator);
      },
      // keys() iterator only reads `length`, no optimisation required
      lastIndexOf(...args) {
        return searchProxy(this, "lastIndexOf", args);
      },
      map(fn, thisArg) {
        return apply(this, "map", fn, thisArg, void 0, arguments);
      },
      pop() {
        return noTracking(this, "pop");
      },
      push(...args) {
        return noTracking(this, "push", args);
      },
      reduce(fn, ...args) {
        return reduce(this, "reduce", fn, args);
      },
      reduceRight(fn, ...args) {
        return reduce(this, "reduceRight", fn, args);
      },
      shift() {
        return noTracking(this, "shift");
      },
      // slice could use ARRAY_ITERATE but also seems to beg for range tracking
      some(fn, thisArg) {
        return apply(this, "some", fn, thisArg, void 0, arguments);
      },
      splice(...args) {
        return noTracking(this, "splice", args);
      },
      toReversed() {
        return reactiveReadArray(this).toReversed();
      },
      toSorted(comparer) {
        return reactiveReadArray(this).toSorted(comparer);
      },
      toSpliced(...args) {
        return reactiveReadArray(this).toSpliced(...args);
      },
      unshift(...args) {
        return noTracking(this, "unshift", args);
      },
      values() {
        return iterator(this, "values", toReactive);
      }
    };
    function iterator(self2, method, wrapValue) {
      const arr = shallowReadArray(self2);
      const iter = arr[method]();
      if (arr !== self2 && !isShallow(self2)) {
        iter._next = iter.next;
        iter.next = () => {
          const result = iter._next();
          if (result.value) {
            result.value = wrapValue(result.value);
          }
          return result;
        };
      }
      return iter;
    }
    const arrayProto = Array.prototype;
    function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
      const arr = shallowReadArray(self2);
      const needsWrap = arr !== self2 && !isShallow(self2);
      const methodFn = arr[method];
      if (methodFn !== arrayProto[method]) {
        const result2 = methodFn.apply(self2, args);
        return needsWrap ? toReactive(result2) : result2;
      }
      let wrappedFn = fn;
      if (arr !== self2) {
        if (needsWrap) {
          wrappedFn = function(item, index) {
            return fn.call(this, toReactive(item), index, self2);
          };
        } else if (fn.length > 2) {
          wrappedFn = function(item, index) {
            return fn.call(this, item, index, self2);
          };
        }
      }
      const result = methodFn.call(arr, wrappedFn, thisArg);
      return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
    }
    function reduce(self2, method, fn, args) {
      const arr = shallowReadArray(self2);
      let wrappedFn = fn;
      if (arr !== self2) {
        if (!isShallow(self2)) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, toReactive(item), index, self2);
          };
        } else if (fn.length > 3) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, item, index, self2);
          };
        }
      }
      return arr[method](wrappedFn, ...args);
    }
    function searchProxy(self2, method, args) {
      const arr = toRaw(self2);
      track(arr, "iterate", ARRAY_ITERATE_KEY);
      const res = arr[method](...args);
      if ((res === -1 || res === false) && isProxy(args[0])) {
        args[0] = toRaw(args[0]);
        return arr[method](...args);
      }
      return res;
    }
    function noTracking(self2, method, args = []) {
      pauseTracking();
      startBatch();
      const res = toRaw(self2)[method].apply(self2, args);
      endBatch();
      resetTracking();
      return res;
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
    );
    function hasOwnProperty(key) {
      if (!isSymbol(key)) key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        if (key === "__v_skip") return target["__v_skip"];
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray(target);
        if (!isReadonly2) {
          let fn;
          if (targetIsArray && (fn = arrayInstrumentations[key])) {
            return fn;
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty;
          }
        }
        const res = Reflect.get(
          target,
          key,
          // if this is a proxy wrapping a ref, return methods using the raw ref
          // as receiver so that we don't have to call `toRaw` on the ref in all
          // its class methods
          isRef(target) ? target : receiver
        );
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(
          target,
          key,
          value,
          isRef(target) ? target : receiver
        );
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        {
          warn$2(
            `Set operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
      deleteProperty(target, key) {
        {
          warn$2(
            `Delete operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type2) {
      return function(...args) {
        {
          const key = args[0] ? `on key "${args[0]}" ` : ``;
          warn$2(
            `${capitalize(type2)} operation ${key}failed: target is readonly.`,
            toRaw(this)
          );
        }
        return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations(readonly2, shallow) {
      const instrumentations = {
        get(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "get", key);
            }
            track(rawTarget, "get", rawKey);
          }
          const { has } = getProto(rawTarget);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          if (has.call(rawTarget, key)) {
            return wrap(target.get(key));
          } else if (has.call(rawTarget, rawKey)) {
            return wrap(target.get(rawKey));
          } else if (target !== rawTarget) {
            target.get(key);
          }
        },
        get size() {
          const target = this["__v_raw"];
          !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
          return Reflect.get(target, "size", target);
        },
        has(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "has", key);
            }
            track(rawTarget, "has", rawKey);
          }
          return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
        },
        forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        }
      };
      extend(
        instrumentations,
        readonly2 ? {
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear")
        } : {
          add(value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const proto = getProto(target);
            const hadKey = proto.has.call(target, value);
            if (!hadKey) {
              target.add(value);
              trigger(target, "add", value, value);
            }
            return this;
          },
          set(key, value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const { has, get } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            } else {
              checkIdentityKeys(target, has, key);
            }
            const oldValue = get.call(target, key);
            target.set(key, value);
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value, oldValue);
            }
            return this;
          },
          delete(key) {
            const target = toRaw(this);
            const { has, get } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            } else {
              checkIdentityKeys(target, has, key);
            }
            const oldValue = get ? get.call(target, key) : void 0;
            const result = target.delete(key);
            if (hadKey) {
              trigger(target, "delete", key, void 0, oldValue);
            }
            return result;
          },
          clear() {
            const target = toRaw(this);
            const hadItems = target.size !== 0;
            const oldTarget = isMap(target) ? new Map(target) : new Set(target);
            const result = target.clear();
            if (hadItems) {
              trigger(
                target,
                "clear",
                void 0,
                void 0,
                oldTarget
              );
            }
            return result;
          }
        }
      );
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        instrumentations[method] = createIterableMethod(method, readonly2, shallow);
      });
      return instrumentations;
    }
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = createInstrumentations(isReadonly2, shallow);
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    function checkIdentityKeys(target, has, key) {
      const rawKey = toRaw(key);
      if (rawKey !== key && has.call(target, rawKey)) {
        const type2 = toRawType(target);
        warn$2(
          `Reactive ${type2} contains both the raw and reactive versions of the same object${type2 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
        );
      }
    }
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject(target)) {
        {
          warn$2(
            `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
              target
            )}`
          );
        }
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject(value) ? readonly(value) : value;
    function isRef(r) {
      return r ? r["__v_isRef"] === true : false;
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class ComputedRefImpl {
      constructor(fn, setter, isSSR) {
        this.fn = fn;
        this.setter = setter;
        this._value = void 0;
        this.dep = new Dep(this);
        this.__v_isRef = true;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 16;
        this.globalVersion = globalVersion - 1;
        this.next = void 0;
        this.effect = this;
        this["__v_isReadonly"] = !setter;
        this.isSSR = isSSR;
      }
      /**
       * @internal
       */
      notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
          batch(this, true);
          return true;
        }
      }
      get value() {
        const link = this.dep.track({
          target: this,
          type: "get",
          key: "value"
        });
        refreshComputed(this);
        if (link) {
          link.version = this.dep.version;
        }
        return this._value;
      }
      set value(newValue) {
        if (this.setter) {
          this.setter(newValue);
        } else {
          warn$2("Write operation failed: computed value is readonly");
        }
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      if (isFunction(getterOrOptions)) {
        getter = getterOrOptions;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, isSSR);
      return cRef;
    }
    const INITIAL_WATCHER_VALUE = {};
    const cleanupMap = /* @__PURE__ */ new WeakMap();
    let activeWatcher = void 0;
    function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
      if (owner) {
        let cleanups = cleanupMap.get(owner);
        if (!cleanups) cleanupMap.set(owner, cleanups = []);
        cleanups.push(cleanupFn);
      } else if (!failSilently) {
        warn$2(
          `onWatcherCleanup() was called when there was no active watcher to associate with.`
        );
      }
    }
    function watch$1(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, once, scheduler, augmentJob, call } = options;
      const warnInvalidSource = (s) => {
        (options.onWarn || warn$2)(
          `Invalid watch source: `,
          s,
          `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
        );
      };
      const reactiveGetter = (source2) => {
        if (deep) return source2;
        if (isShallow(source2) || deep === false || deep === 0)
          return traverse(source2, 1);
        return traverse(source2);
      };
      let effect2;
      let getter;
      let cleanup;
      let boundCleanup;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction(s)) {
            return call ? call(s, 2) : s();
          } else {
            warnInvalidSource(s);
          }
        });
      } else if (isFunction(source)) {
        if (cb) {
          getter = call ? () => call(source, 2) : source;
        } else {
          getter = () => {
            if (cleanup) {
              pauseTracking();
              try {
                cleanup();
              } finally {
                resetTracking();
              }
            }
            const currentEffect = activeWatcher;
            activeWatcher = effect2;
            try {
              return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
            } finally {
              activeWatcher = currentEffect;
            }
          };
        }
      } else {
        getter = NOOP;
        warnInvalidSource(source);
      }
      if (cb && deep) {
        const baseGetter = getter;
        const depth = deep === true ? Infinity : deep;
        getter = () => traverse(baseGetter(), depth);
      }
      const scope2 = getCurrentScope();
      const watchHandle = () => {
        effect2.stop();
        if (scope2 && scope2.active) {
          remove(scope2.effects, effect2);
        }
      };
      if (once && cb) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          watchHandle();
        };
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = (immediateFirstRun) => {
        if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            const currentWatcher = activeWatcher;
            activeWatcher = effect2;
            try {
              const args = [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                boundCleanup
              ];
              call ? call(cb, 3, args) : (
                // @ts-expect-error
                cb(...args)
              );
              oldValue = newValue;
            } finally {
              activeWatcher = currentWatcher;
            }
          }
        } else {
          effect2.run();
        }
      };
      if (augmentJob) {
        augmentJob(job);
      }
      effect2 = new ReactiveEffect(getter);
      effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
      boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
      cleanup = effect2.onStop = () => {
        const cleanups = cleanupMap.get(effect2);
        if (cleanups) {
          if (call) {
            call(cleanups, 4);
          } else {
            for (const cleanup2 of cleanups) cleanup2();
          }
          cleanupMap.delete(effect2);
        }
      };
      {
        effect2.onTrack = options.onTrack;
        effect2.onTrigger = options.onTrigger;
      }
      if (cb) {
        if (immediate) {
          job(true);
        } else {
          oldValue = effect2.run();
        }
      } else if (scheduler) {
        scheduler(job.bind(null, true), true);
      } else {
        effect2.run();
      }
      watchHandle.pause = effect2.pause.bind(effect2);
      watchHandle.resume = effect2.resume.bind(effect2);
      watchHandle.stop = watchHandle;
      return watchHandle;
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    /**
    * @vue/runtime-core v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function pushWarningContext(vnode) {
      stack.push(vnode);
    }
    function popWarningContext() {
      stack.pop();
    }
    let isWarning = false;
    function warn$1(msg, ...args) {
      if (isWarning) return;
      isWarning = true;
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg + args.map((a) => {
              var _a, _b;
              return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
  `, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
  `], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    const ErrorTypeStrings$1 = {
      ["sp"]: "serverPrefetch hook",
      ["bc"]: "beforeCreate hook",
      ["c"]: "created hook",
      ["bm"]: "beforeMount hook",
      ["m"]: "mounted hook",
      ["bu"]: "beforeUpdate hook",
      ["u"]: "updated",
      ["bum"]: "beforeUnmount hook",
      ["um"]: "unmounted hook",
      ["a"]: "activated hook",
      ["da"]: "deactivated hook",
      ["ec"]: "errorCaptured hook",
      ["rtc"]: "renderTracked hook",
      ["rtg"]: "renderTriggered hook",
      [0]: "setup function",
      [1]: "render function",
      [2]: "watcher getter",
      [3]: "watcher callback",
      [4]: "watcher cleanup function",
      [5]: "native event handler",
      [6]: "component event handler",
      [7]: "vnode hook",
      [8]: "directive hook",
      [9]: "transition hook",
      [10]: "app errorHandler",
      [11]: "app warnHandler",
      [12]: "ref function",
      [13]: "async component loader",
      [14]: "scheduler flush",
      [15]: "component update",
      [16]: "app unmount cleanup function"
    };
    function callWithErrorHandling(fn, instance, type2, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type2);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type2, args) {
      if (isFunction(fn)) {
        const res = callWithErrorHandling(fn, instance, type2, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type2);
          });
        }
        return res;
      }
      if (isArray(fn)) {
        const values = [];
        for (let i = 0; i < fn.length; i++) {
          values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
        }
        return values;
      } else {
        warn$1(
          `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
        );
      }
    }
    function handleError(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = ErrorTypeStrings$1[type2];
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        if (errorHandler) {
          pauseTracking();
          callWithErrorHandling(errorHandler, null, 10, [
            err,
            exposedInstance,
            errorInfo
          ]);
          resetTracking();
          return;
        }
      }
      logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
    }
    function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
      {
        const info = ErrorTypeStrings$1[type2];
        if (contextVNode) {
          pushWarningContext(contextVNode);
        }
        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
          popWarningContext();
        }
        if (throwInDev) {
          throw err;
        } else {
          console.error(err);
        }
      }
    }
    const queue = [];
    let flushIndex = -1;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    const RECURSION_LIMIT = 100;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id2) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!(job.flags & 1)) {
        const jobId = getId(job);
        const lastJob = queue[queue.length - 1];
        if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(jobId), 0, job);
        }
        job.flags |= 1;
        queueFlush();
      }
    }
    function queueFlush() {
      if (!currentFlushPromise) {
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray(cb)) {
        if (activePostFlushCbs && cb.id === -1) {
          activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
        } else if (!(cb.flags & 1)) {
          pendingPostFlushCbs.push(cb);
          cb.flags |= 1;
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.flags & 2) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          if (checkRecursiveUpdates(seen, cb)) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          if (cb.flags & 4) {
            cb.flags &= -2;
          }
          cb();
          if (!(cb.flags & 4)) {
            cb.flags &= -2;
          }
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        {
          seen = seen || /* @__PURE__ */ new Map();
        }
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb = activePostFlushCbs[postFlushIndex];
          if (checkRecursiveUpdates(seen, cb)) {
            continue;
          }
          if (cb.flags & 4) {
            cb.flags &= -2;
          }
          if (!(cb.flags & 8)) cb();
          cb.flags &= -2;
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
    function flushJobs(seen) {
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      const check = (job) => checkRecursiveUpdates(seen, job);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && !(job.flags & 8)) {
            if (check(job)) {
              continue;
            }
            if (job.flags & 4) {
              job.flags &= ~1;
            }
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
            if (!(job.flags & 4)) {
              job.flags &= ~1;
            }
          }
        }
      } finally {
        for (; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job) {
            job.flags &= -2;
          }
        }
        flushIndex = -1;
        queue.length = 0;
        flushPostFlushCbs(seen);
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs(seen);
        }
      }
    }
    function checkRecursiveUpdates(seen, fn) {
      const count = seen.get(fn) || 0;
      if (count > RECURSION_LIMIT) {
        const instance = fn.i;
        const componentName = instance && getComponentName(instance.type);
        handleError(
          `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
          null,
          10
        );
        return true;
      }
      seen.set(fn, count + 1);
      return false;
    }
    let isHmrUpdating = false;
    const hmrDirtyComponents = /* @__PURE__ */ new Map();
    {
      getGlobalThis().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
      };
    }
    const map = /* @__PURE__ */ new Map();
    function registerHMR(instance) {
      const id2 = instance.type.__hmrId;
      let record = map.get(id2);
      if (!record) {
        createRecord(id2, instance.type);
        record = map.get(id2);
      }
      record.instances.add(instance);
    }
    function unregisterHMR(instance) {
      map.get(instance.type.__hmrId).instances.delete(instance);
    }
    function createRecord(id2, initialDef) {
      if (map.has(id2)) {
        return false;
      }
      map.set(id2, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
      });
      return true;
    }
    function normalizeClassComponent(component) {
      return isClassComponent(component) ? component.__vccOpts : component;
    }
    function rerender(id2, newRender) {
      const record = map.get(id2);
      if (!record) {
        return;
      }
      record.initialDef.render = newRender;
      [...record.instances].forEach((instance) => {
        if (newRender) {
          instance.render = newRender;
          normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
      });
    }
    function reload(id2, newComp) {
      const record = map.get(id2);
      if (!record) return;
      newComp = normalizeClassComponent(newComp);
      updateComponentDef(record.initialDef, newComp);
      const instances = [...record.instances];
      for (let i = 0; i < instances.length; i++) {
        const instance = instances[i];
        const oldComp = normalizeClassComponent(instance.type);
        let dirtyInstances = hmrDirtyComponents.get(oldComp);
        if (!dirtyInstances) {
          if (oldComp !== record.initialDef) {
            updateComponentDef(oldComp, newComp);
          }
          hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
        }
        dirtyInstances.add(instance);
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
          dirtyInstances.add(instance);
          instance.ceReload(newComp.styles);
          dirtyInstances.delete(instance);
        } else if (instance.parent) {
          queueJob(() => {
            isHmrUpdating = true;
            instance.parent.update();
            isHmrUpdating = false;
            dirtyInstances.delete(instance);
          });
        } else if (instance.appContext.reload) {
          instance.appContext.reload();
        } else if (typeof window !== "undefined") {
          window.location.reload();
        } else {
          console.warn(
            "[HMR] Root or manually mounted instance modified. Full reload required."
          );
        }
        if (instance.root.ce && instance !== instance.root) {
          instance.root.ce._removeChildStyle(oldComp);
        }
      }
      queuePostFlushCb(() => {
        hmrDirtyComponents.clear();
      });
    }
    function updateComponentDef(oldComp, newComp) {
      extend(oldComp, newComp);
      for (const key in oldComp) {
        if (key !== "__file" && !(key in newComp)) {
          delete oldComp[key];
        }
      }
    }
    function tryWrap(fn) {
      return (id2, arg) => {
        try {
          return fn(id2, arg);
        } catch (e) {
          console.error(e);
          console.warn(
            `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
          );
        }
      };
    }
    let devtools$1;
    let buffer = [];
    let devtoolsNotInstalled = false;
    function emit$1(event, ...args) {
      if (devtools$1) {
        devtools$1.emit(event, ...args);
      } else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
      }
    }
    function setDevtoolsHook$1(hook, target) {
      var _a, _b;
      devtools$1 = hook;
      if (devtools$1) {
        devtools$1.enabled = true;
        buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
        buffer = [];
      } else if (
        // handle late devtools injection - only do this if we are in an actual
        // browser environment to avoid the timer handle stalling test runner exit
        // (#4815)
        typeof window !== "undefined" && // some envs mock window but not fully
        window.HTMLElement && // also exclude jsdom
        // eslint-disable-next-line no-restricted-syntax
        !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
      ) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook) => {
          setDevtoolsHook$1(newHook, target);
        });
        setTimeout(() => {
          if (!devtools$1) {
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
            devtoolsNotInstalled = true;
            buffer = [];
          }
        }, 3e3);
      } else {
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }
    function devtoolsInitApp(app, version2) {
      emit$1("app:init", app, version2, {
        Fragment,
        Text,
        Comment,
        Static
      });
    }
    function devtoolsUnmountApp(app) {
      emit$1("app:unmount", app);
    }
    const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:added"
      /* COMPONENT_ADDED */
    );
    const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:updated"
      /* COMPONENT_UPDATED */
    );
    const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:removed"
      /* COMPONENT_REMOVED */
    );
    const devtoolsComponentRemoved = (component) => {
      if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
      !devtools$1.cleanupBuffer(component)) {
        _devtoolsComponentRemoved(component);
      }
    };
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function createDevtoolsComponentHook(hook) {
      return (component) => {
        emit$1(
          hook,
          component.appContext.app,
          component.uid,
          component.parent ? component.parent.uid : void 0,
          component
        );
      };
    }
    const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
      "perf:start"
      /* PERFORMANCE_START */
    );
    const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
      "perf:end"
      /* PERFORMANCE_END */
    );
    function createDevtoolsPerformanceHook(hook) {
      return (component, type2, time) => {
        emit$1(hook, component.appContext.app, component.uid, component, type2, time);
      };
    }
    function devtoolsComponentEmit(component, event, params) {
      emit$1(
        "component:emit",
        component.appContext.app,
        component,
        event,
        params
      );
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx) return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        {
          devtoolsComponentUpdated(ctx);
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function validateDirectiveName(name) {
      if (isBuiltInDirective(name)) {
        warn$1("Do not use built-in directive ids as custom directive id: " + name);
      }
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        warn$1(`withDirectives can only be used inside render functions.`);
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type2) => type2.__isTeleport;
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        vnode.transition = hooks;
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function markAsyncBoundary(instance) {
      instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
    }
    const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
          setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
        }
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      if (!owner) {
        warn$1(
          `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
        );
        return;
      }
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      const rawSetupState = toRaw(setupState);
      const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
        {
          if (hasOwn(rawSetupState, key) && !isRef(rawSetupState[key])) {
            warn$1(
              `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
            );
          }
          if (knownTemplateRefs.has(rawSetupState[key])) {
            return false;
          }
        }
        return hasOwn(rawSetupState, key);
      };
      if (oldRef != null && oldRef !== ref3) {
        if (isString(oldRef)) {
          refs[oldRef] = null;
          if (canSetSetupRef(oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray(existing) && remove(existing, refValue);
              } else {
                if (!isArray(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (canSetSetupRef(ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k) refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (canSetSetupRef(ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k) refs[rawRef.k] = value;
            } else {
              warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
            }
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        } else {
          warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
        }
      }
    }
    getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
    getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type2, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type2, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type2, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
      const injected = injectHook(
        type2,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type2], injected);
      }, target);
    }
    function injectHook(type2, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type2] || (target[type2] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type2, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      } else {
        const apiName = toHandlerKey(ErrorTypeStrings$1[type2].replace(/ hook$/, ""));
        warn$1(
          `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
        );
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook(
      "bu"
    );
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook(
      "bum"
    );
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook(
      "sp"
    );
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve$1(instance[type2] || Component[type2], name) || // global registration
          resolve$1(instance.appContext[type2], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        if (warnMissing && !res) {
          const extra = `
  If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.`;
          warn$1(`Failed to resolve ${type2.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
      } else {
        warn$1(
          `resolve${capitalize(type2.slice(0, -1))} can only be used in render() or setup().`
        );
      }
    }
    function resolve$1(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    const getPublicInstance = (i) => {
      if (!i) return null;
      if (isStatefulComponent(i)) return getComponentPublicInstance(i);
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => shallowReadonly(i.props),
        $attrs: (i) => shallowReadonly(i.attrs),
        $slots: (i) => shallowReadonly(i.slots),
        $refs: (i) => shallowReadonly(i.refs),
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $host: (i) => i.ce,
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const isReservedPrefix = (key) => key === "_" || key === "$";
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
        if (key === "__isVue") {
          return true;
        }
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
            markAttrsAccessed();
          } else if (key === "$slots") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else if (currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
          if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
            warn$1(
              `Property ${JSON.stringify(
                key
              )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
            );
          } else if (instance === currentRenderingInstance) {
            warn$1(
              `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
            );
          }
        }
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
          warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
          return false;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          warn$1(
            `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
          );
          return false;
        } else {
          if (key in instance.appContext.config.globalProperties) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              value
            });
          } else {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    {
      PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn$1(
          `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
        );
        return Reflect.ownKeys(target);
      };
    }
    function createDevRenderContext(instance) {
      const target = {};
      Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
      });
      Object.keys(publicPropertiesMap).forEach((key) => {
        Object.defineProperty(target, key, {
          configurable: true,
          enumerable: false,
          get: () => publicPropertiesMap[key](instance),
          // intercepted by the proxy so no need for implementation,
          // but needed to prevent set errors
          set: NOOP
        });
      });
      return target;
    }
    function exposePropsOnRenderContext(instance) {
      const {
        ctx,
        propsOptions: [propsOptions]
      } = instance;
      if (propsOptions) {
        Object.keys(propsOptions).forEach((key) => {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => instance.props[key],
            set: NOOP
          });
        });
      }
    }
    function exposeSetupStateOnRenderContext(instance) {
      const { ctx, setupState } = instance;
      Object.keys(toRaw(setupState)).forEach((key) => {
        if (!setupState.__isScriptSetup) {
          if (isReservedPrefix(key[0])) {
            warn$1(
              `setup() return property ${JSON.stringify(
                key
              )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
            );
            return;
          }
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: NOOP
          });
        }
      });
    }
    function normalizePropsOrEmits(props) {
      return isArray(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    function createDuplicateChecker() {
      const cache = /* @__PURE__ */ Object.create(null);
      return (type2, key) => {
        if (cache[key]) {
          warn$1(`${type2} property "${key}" is already defined in ${cache[key]}.`);
        } else {
          cache[key] = type2;
        }
      };
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = createDuplicateChecker();
      {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
          for (const key in propsOptions) {
            checkDuplicateProperties("Props", key);
          }
        }
      }
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction(methodHandler)) {
            {
              Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
              });
            }
            {
              checkDuplicateProperties("Methods", key);
            }
          } else {
            warn$1(
              `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
            );
          }
        }
      }
      if (dataOptions) {
        if (!isFunction(dataOptions)) {
          warn$1(
            `The data option must be a function. Plain object usage is no longer supported.`
          );
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (isPromise(data)) {
          warn$1(
            `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
          );
        }
        if (!isObject(data)) {
          warn$1(`data() should return an object.`);
        } else {
          instance.data = reactive(data);
          {
            for (const key in data) {
              checkDuplicateProperties("Data", key);
              if (!isReservedPrefix(key[0])) {
                Object.defineProperty(ctx, key, {
                  configurable: true,
                  enumerable: true,
                  get: () => data[key],
                  set: NOOP
                });
              }
            }
          }
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          if (get === NOOP) {
            warn$1(`Computed property "${key}" has no getter.`);
          }
          const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
            warn$1(
              `Write operation failed: computed property "${key}" is readonly.`
            );
          };
          const c = computed({
            get,
            set
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
          {
            checkDuplicateProperties("Computed", key);
          }
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components) instance.components = components;
      if (directives) instance.directives = directives;
      if (serverPrefetch) {
        markAsyncBoundary(instance);
      }
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
        {
          checkDuplicateProperties("Inject", key);
        }
      }
    }
    function callHook(hook, instance, type2) {
      callWithAsyncErrorHandling(
        isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type2
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString(raw)) {
        const handler = ctx[raw];
        if (isFunction(handler)) {
          {
            watch(getter, handler);
          }
        } else {
          warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
        }
      } else if (isFunction(raw)) {
        {
          watch(getter, raw.bind(publicThis));
        }
      } else if (isObject(raw)) {
        if (isArray(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction(handler)) {
            watch(getter, handler, raw);
          } else {
            warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
          }
        }
      } else {
        warn$1(`Invalid watch option: "${key}"`, raw);
      }
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      if (isObject(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") {
          warn$1(
            `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
          );
        } else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction(to) ? to.call(this, this) : to,
          isFunction(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray(to) && isArray(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to) return from;
      if (!from) return to;
      const merged = extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject(rootProps)) {
          warn$1(`root props passed to app.mount() must be an object.`);
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        const pluginCleanupFns = [];
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
            {
              warn$1(
                `app.config cannot be replaced. Modify individual options instead.`
              );
            }
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin)) {
              warn$1(`Plugin has already been applied to target app.`);
            } else if (plugin && isFunction(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else {
              warn$1(
                `A plugin must either be a function or an object with an "install" function.`
              );
            }
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              } else {
                warn$1(
                  "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
                );
              }
            }
            return app;
          },
          component(name, component) {
            {
              validateComponentName(name, context.config);
            }
            if (!component) {
              return context.components[name];
            }
            if (context.components[name]) {
              warn$1(`Component "${name}" has already been registered in target app.`);
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            {
              validateDirectiveName(name);
            }
            if (!directive) {
              return context.directives[name];
            }
            if (context.directives[name]) {
              warn$1(`Directive "${name}" has already been registered in target app.`);
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              if (rootContainer.__vue_app__) {
                warn$1(
                  `There is already an app instance mounted on the host container.
   If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
                );
              }
              const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              {
                context.reload = () => {
                  render(
                    cloneVNode(vnode),
                    rootContainer,
                    namespace
                  );
                };
              }
              {
                render(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              {
                app._instance = vnode.component;
                devtoolsInitApp(app, version);
              }
              return getComponentPublicInstance(vnode.component);
            } else {
              warn$1(
                `App has already been mounted.
  If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
              );
            }
          },
          onUnmount(cleanupFn) {
            if (typeof cleanupFn !== "function") {
              warn$1(
                `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
              );
            }
            pluginCleanupFns.push(cleanupFn);
          },
          unmount() {
            if (isMounted) {
              callWithAsyncErrorHandling(
                pluginCleanupFns,
                app._instance,
                16
              );
              render(null, app._container);
              {
                app._instance = null;
                devtoolsUnmountApp(app);
              }
              delete app._container.__vue_app__;
            } else {
              warn$1(`Cannot unmount an app that is not mounted.`);
            }
          },
          provide(key, value) {
            if (key in context.provides) {
              warn$1(
                `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
              );
            }
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) {
        {
          warn$1(`provide() can only be used inside setup().`);
        }
      } else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else {
          warn$1(`injection "${String(key)}" not found.`);
        }
      } else {
        warn$1(`inject() can only be used inside setup() or functional components.`);
      }
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      {
        validateProps(rawProps || {}, props, instance);
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function isInHmrContext(instance) {
      while (instance) {
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
      }
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance.attrs, "set", "");
      }
      {
        validateProps(rawProps || {}, props, instance);
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
          if (instance.ce) {
            instance.ce._setProp(key, value);
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray(raw)) {
        for (let i = 0; i < raw.length; i++) {
          if (!isString(raw[i])) {
            warn$1(`props must be strings when using array syntax.`, raw[i]);
          }
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        if (!isObject(raw)) {
          warn$1(`invalid props options`, raw);
        }
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
            const propType = prop.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray(propType)) {
              for (let index = 0; index < propType.length; ++index) {
                const type2 = propType[index];
                const typeName = isFunction(type2) && type2.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction(propType) && propType.name === "Boolean";
            }
            prop[
              0
              /* shouldCast */
            ] = shouldCast;
            prop[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      } else {
        warn$1(`Invalid prop name: "${key}" is a reserved property.`);
      }
      return false;
    }
    function getType(ctor) {
      if (ctor === null) {
        return "null";
      }
      if (typeof ctor === "function") {
        return ctor.name || "";
      } else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
      }
      return "";
    }
    function validateProps(rawProps, props, instance) {
      const resolvedValues = toRaw(props);
      const options = instance.propsOptions[0];
      const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
      for (const key in options) {
        let opt = options[key];
        if (opt == null) continue;
        validateProp(
          key,
          resolvedValues[key],
          opt,
          shallowReadonly(resolvedValues),
          !camelizePropsKey.includes(key)
        );
      }
    }
    function validateProp(name, value, prop, props, isAbsent) {
      const { type: type2, required: required2, validator, skipCheck } = prop;
      if (required2 && isAbsent) {
        warn$1('Missing required prop: "' + name + '"');
        return;
      }
      if (value == null && !required2) {
        return;
      }
      if (type2 != null && type2 !== true && !skipCheck) {
        let isValid = false;
        const types2 = isArray(type2) ? type2 : [type2];
        const expectedTypes = [];
        for (let i = 0; i < types2.length && !isValid; i++) {
          const { valid, expectedType } = assertType(value, types2[i]);
          expectedTypes.push(expectedType || "");
          isValid = valid;
        }
        if (!isValid) {
          warn$1(getInvalidTypeMessage(name, value, expectedTypes));
          return;
        }
      }
      if (validator && !validator(value, props)) {
        warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
      }
    }
    const isSimpleType = /* @__PURE__ */ makeMap(
      "String,Number,Boolean,Function,Symbol,BigInt"
    );
    function assertType(value, type2) {
      let valid;
      const expectedType = getType(type2);
      if (expectedType === "null") {
        valid = value === null;
      } else if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") {
          valid = value instanceof type2;
        }
      } else if (expectedType === "Object") {
        valid = isObject(value);
      } else if (expectedType === "Array") {
        valid = isArray(value);
      } else {
        valid = value instanceof type2;
      }
      return {
        valid,
        expectedType
      };
    }
    function getInvalidTypeMessage(name, value, expectedTypes) {
      if (expectedTypes.length === 0) {
        return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
      }
      let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType(value);
      const expectedValue = styleValue(value, expectedType);
      const receivedValue = styleValue(value, receivedType);
      if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
      }
      message += `, got ${receivedType} `;
      if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
      }
      return message;
    }
    function styleValue(value, type2) {
      if (type2 === "String") {
        return `"${value}"`;
      } else if (type2 === "Number") {
        return `${Number(value)}`;
      } else {
        return `${value}`;
      }
    }
    function isExplicable(type2) {
      const explicitTypes = ["string", "number", "boolean"];
      return explicitTypes.some((elem) => type2.toLowerCase() === elem);
    }
    function isBoolean(...args) {
      return args.some((elem) => elem.toLowerCase() === "boolean");
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
          warn$1(
            `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
          );
        }
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          {
            warn$1(
              `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
            );
          }
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      if (!isKeepAlive(instance.vnode) && true) {
        warn$1(
          `Non-function value encountered for default slot. Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def(slots, "_", type2, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          if (isHmrUpdating) {
            assignSlots(slots, children, optimized);
            trigger(instance, "set", "$slots");
          } else if (optimized && type2 === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    let supported;
    let perf;
    function startMeasure(instance, type2) {
      if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type2}-${instance.uid}`);
      }
      {
        devtoolsPerfStart(instance, type2, isSupported() ? perf.now() : Date.now());
      }
    }
    function endMeasure(instance, type2) {
      if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type2}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(
          `<${formatComponentName(instance, instance.type)}> ${type2}`,
          startTag,
          endTag
        );
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
      }
      {
        devtoolsPerfEnd(instance, type2, isSupported() ? perf.now() : Date.now());
      }
    }
    function isSupported() {
      if (supported !== void 0) {
        return supported;
      }
      if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
      } else {
        supported = false;
      }
      return supported;
    }
    function initFeatureFlags() {
      const needWarn = [];
      if (needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(
          `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.
  
  For more details, see https://link.vuejs.org/feature-flags.`
        );
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      {
        initFeatureFlags();
      }
      const target = getGlobalThis();
      target.__VUE__ = true;
      {
        setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
      }
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type: type2, ref: ref3, shapeFlag } = n2;
        switch (type2) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            } else {
              patchStaticNode(n1, n2, container, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else {
              warn$1("Invalid VNode type:", type2, `(${typeof type2})`);
            }
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const patchStaticNode = (n1, n2, container, namespace) => {
        if (n2.children !== n1.children) {
          const anchor = hostNextSibling(n1.anchor);
          removeStaticNode(n1);
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace
          );
        } else {
          n2.el = n1.el;
          n2.anchor = n1.anchor;
        }
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], namespace, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        {
          def(el, "__vnode", vnode, true);
          def(el, "__vueParentComponent", parentComponent, true);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
            subTree = filterSingleRoot(subTree.children) || subTree;
          }
          if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        {
          el.__vnode = n2;
        }
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, oldProps, newProps, parentComponent, namespace);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, namespace, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key)) continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (
          // #5523 dev root fragment may inherit directives
          isHmrUpdating || patchFlag & 2048
        ) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            {
              traverseStaticChildren(n1, n2);
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (instance.type.__hmrId) {
          registerHMR(instance);
        }
        {
          pushWarningContext(initialVNode);
          startMeasure(instance, `mount`);
        }
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          {
            startMeasure(instance, `init`);
          }
          setupComponent(instance, false, optimized);
          {
            endMeasure(instance, `init`);
          }
        }
        if (instance.asyncDep) {
          if (isHmrUpdating) initialVNode.el = null;
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
        {
          popWarningContext();
          endMeasure(instance, `mount`);
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            {
              pushWarningContext(n2);
            }
            updateComponentPreRender(instance, n2, optimized);
            {
              popWarningContext();
            }
            return;
          } else {
            instance.next = n2;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent, root, type: type2 } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            {
              if (root.ce) {
                root.ce._injectChildStyle(type2);
              }
              {
                startMeasure(instance, `render`);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              {
                endMeasure(instance, `render`);
              }
              {
                startMeasure(instance, `patch`);
              }
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              {
                endMeasure(instance, `patch`);
              }
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            {
              devtoolsComponentAdded(instance);
            }
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            {
              pushWarningContext(next || instance.vnode);
            }
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            {
              startMeasure(instance, `render`);
            }
            const nextTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            {
              startMeasure(instance, `patch`);
            }
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
            {
              devtoolsComponentUpdated(instance);
            }
            {
              popWarningContext();
            }
          }
        };
        instance.scope.on();
        const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
        instance.scope.off();
        const update = instance.update = effect2.run.bind(effect2);
        const job = instance.job = effect2.runIfDirty.bind(effect2);
        job.i = instance;
        job.id = instance.uid;
        effect2.scheduler = () => queueJob(job);
        toggleRecurse(instance, true);
        {
          effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
          effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
        }
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              if (keyToNewIndexMap.has(nextChild.key)) {
                warn$1(
                  `Duplicate keys found during update:`,
                  JSON.stringify(nextChild.key),
                  `Make sure keys are unique.`
                );
              }
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type: type2, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type2.move(vnode, container, anchor, internals);
          return;
        }
        if (type2 === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type2 === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type: type2,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type: type2, el, anchor, transition } = vnode;
        if (type2 === Fragment) {
          if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
            vnode.children.forEach((child) => {
              if (child.type === Comment) {
                hostRemove(child.el);
              } else {
                remove2(child);
              }
            });
          } else {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type2 === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (instance.type.__hmrId) {
          unregisterHMR(instance);
        }
        const { bum, scope: scope2, job, subTree, um, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope2.stop();
        if (job) {
          job.flags |= 8;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
        {
          devtoolsComponentRemoved(instance);
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el && el[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el;
      };
      let isFlushing = false;
      const render = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        container._vnode = vnode;
        if (!isFlushing) {
          isFlushing = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing = false;
        }
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      return {
        render,
        hydrate,
        createApp: createAppAPI(render)
      };
    }
    function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
      return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, job }, allowed) {
      if (allowed) {
        effect2.flags |= 32;
        job.flags |= 4;
      } else {
        effect2.flags &= -33;
        job.flags &= -5;
      }
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray(ch1) && isArray(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
          if (c2.type === Comment && !c2.el) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i = 0; i < hooks.length; i++)
          hooks[i].flags |= 8;
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
          warn$1(
            `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
          );
        }
        return ctx;
      }
    };
    function watch(source, cb, options) {
      if (!isFunction(cb)) {
        warn$1(
          `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
        );
      }
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, flush, once } = options;
      if (!cb) {
        if (immediate !== void 0) {
          warn$1(
            `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (deep !== void 0) {
          warn$1(
            `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (once !== void 0) {
          warn$1(
            `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
      }
      const baseWatchOptions = extend({}, options);
      baseWatchOptions.onWarn = warn$1;
      const runsImmediately = cb && immediate || !cb && flush !== "post";
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else if (!runsImmediately) {
          const watchStopHandle = () => {
          };
          watchStopHandle.stop = NOOP;
          watchStopHandle.resume = NOOP;
          watchStopHandle.pause = NOOP;
          return watchStopHandle;
        }
      }
      const instance = currentInstance;
      baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance, type2, args);
      let isPre = false;
      if (flush === "post") {
        baseWatchOptions.scheduler = (job) => {
          queuePostRenderEffect(job, instance && instance.suspense);
        };
      } else if (flush !== "sync") {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
          if (isFirstRun) {
            job();
          } else {
            queueJob(job);
          }
        };
      }
      baseWatchOptions.augmentJob = (job) => {
        if (cb) {
          job.flags |= 4;
        }
        if (isPre) {
          job.flags |= 2;
          if (instance) {
            job.id = instance.uid;
            job.i = instance;
          }
        }
      };
      const watchHandle = watch$1(source, cb, baseWatchOptions);
      if (isInSSRComponentSetup) {
        if (ssrCleanup) {
          ssrCleanup.push(watchHandle);
        } else if (runsImmediately) {
          watchHandle();
        }
      }
      return watchHandle;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted) return;
      const props = instance.vnode.props || EMPTY_OBJ;
      {
        const {
          emitsOptions,
          propsOptions: [propsOptions]
        } = instance;
        if (emitsOptions) {
          if (!(event in emitsOptions) && true) {
            if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
              warn$1(
                `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event))}" prop.`
              );
            }
          } else {
            const validator = emitsOptions[event];
            if (isFunction(validator)) {
              const isValid = validator(...rawArgs);
              if (!isValid) {
                warn$1(
                  `Invalid event arguments: event validation failed for event "${event}".`
                );
              }
            }
          }
        }
      }
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers) {
        if (modifiers.trim) {
          args = rawArgs.map((a) => isString(a) ? a.trim() : a);
        }
        if (modifiers.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      {
        devtoolsComponentEmit(instance, event, args);
      }
      {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
          warn$1(
            `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
              instance,
              instance.type
            )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
              event
            )}" instead of "${event}".`
          );
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let accessedAttrs = false;
    function markAttrsAccessed() {
      accessedAttrs = true;
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      {
        accessedAttrs = false;
      }
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              true ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (attrs === props) {
            markAttrsAccessed();
          }
          result = normalizeVNode(
            render2.length > 1 ? render2(
              true ? shallowReadonly(props) : props,
              true ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              true ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root = result;
      let setRoot = void 0;
      if (result.patchFlag > 0 && result.patchFlag & 2048) {
        [root, setRoot] = getChildRoot(result);
      }
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root = cloneVNode(root, fallthroughAttrs, false, true);
          } else if (!accessedAttrs && root.type !== Comment) {
            const allAttrs = Object.keys(attrs);
            const eventAttrs = [];
            const extraAttrs = [];
            for (let i = 0, l = allAttrs.length; i < l; i++) {
              const key = allAttrs[i];
              if (isOn(key)) {
                if (!isModelListener(key)) {
                  eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                }
              } else {
                extraAttrs.push(key);
              }
            }
            if (extraAttrs.length) {
              warn$1(
                `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
              );
            }
            if (eventAttrs.length) {
              warn$1(
                `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
              );
            }
          }
        }
      }
      if (vnode.dirs) {
        if (!isElementRoot(root)) {
          warn$1(
            `Runtime directive used on component with non-element root node. The directives will not function as intended.`
          );
        }
        root = cloneVNode(root, null, false, true);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        if (!isElementRoot(root)) {
          warn$1(
            `Component inside <Transition> renders non-element root node that cannot be animated.`
          );
        }
        setTransitionHooks(root, vnode.transition);
      }
      if (setRoot) {
        setRoot(root);
      } else {
        result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getChildRoot = (vnode) => {
      const rawChildren = vnode.children;
      const dynamicChildren = vnode.dynamicChildren;
      const childRoot = filterSingleRoot(rawChildren, false);
      if (!childRoot) {
        return [vnode, void 0];
      } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
        return getChildRoot(childRoot);
      }
      const index = rawChildren.indexOf(childRoot);
      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
      const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
          if (dynamicIndex > -1) {
            dynamicChildren[dynamicIndex] = updatedRoot;
          } else if (updatedRoot.patchFlag > 0) {
            vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
          }
        }
      };
      return [normalizeVNode(childRoot), setRoot];
    };
    function filterSingleRoot(children, recurse = true) {
      let singleRoot;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
          if (child.type !== Comment || child.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child;
              if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
                return filterSingleRoot(singleRoot.children);
              }
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    const isElementRoot = (vnode) => {
      return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if ((prevChildren || nextChildren) && isHmrUpdating) {
        return true;
      }
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) {
          root.el = vnode.el;
        }
        if (root === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type2) => type2.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value, inVOnce = false) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock && inVOnce) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type2, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      if (n2.shapeFlag & 6 && n1.component) {
        const dirtyInstances = hmrDirtyComponents.get(n2.type);
        if (dirtyInstances && dirtyInstances.has(n1.component)) {
          n1.shapeFlag &= -257;
          n2.shapeFlag &= -513;
          return false;
        }
      }
      return n1.type === n2.type && n1.key === n2.key;
    }
    const createVNodeWithArgsTransform = (...args) => {
      return _createVNode(
        ...args
      );
    };
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type: type2,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type2.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString(children) ? 8 : 16;
      }
      if (vnode.key !== vnode.key) {
        warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = createVNodeWithArgsTransform;
    function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
        if (!type2) {
          warn$1(`Invalid vnode type when creating vnode: ${type2}.`);
        }
        type2 = Comment;
      }
      if (isVNode(type2)) {
        const cloned = cloneVNode(
          type2,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type2)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type2)) {
        type2 = type2.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject(style)) {
          if (isProxy(style) && !isArray(style)) {
            style = extend({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction(type2) ? 2 : 0;
      if (shapeFlag & 4 && isProxy(type2)) {
        type2 = toRaw(type2);
        warn$1(
          `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
          `
  Component that was made reactive: `,
          type2
        );
      }
      return createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props) return null;
      return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function deepCloneVNode(vnode) {
      const cloned = cloneVNode(vnode);
      if (isArray(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (isVNode(child)) {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type2 = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray(children)) {
        type2 = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type2 = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type2 = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type2 = 16;
          children = [createTextVNode(children)];
        } else {
          type2 = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type2;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type2 = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type: type2,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        job: null,
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        ids: parent ? parent.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type2, appContext),
        emitsOptions: normalizeEmitsOptions(type2, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type2.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = createDevRenderContext(instance);
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1) setters.forEach((set) => set(v));
          else setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
    function validateComponentName(name, { isNativeTag }) {
      if (isBuiltInTag(name) || isNativeTag(name)) {
        warn$1(
          "Do not use built-in or reserved HTML elements as component id: " + name
        );
      }
    }
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      var _a;
      const Component = instance.type;
      {
        if (Component.name) {
          validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
          const names2 = Object.keys(Component.components);
          for (let i = 0; i < names2.length; i++) {
            validateComponentName(names2[i], instance.appContext.config);
          }
        }
        if (Component.directives) {
          const names2 = Object.keys(Component.directives);
          for (let i = 0; i < names2.length; i++) {
            validateDirectiveName(names2[i]);
          }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
          warn$1(
            `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
          );
        }
      }
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      {
        exposePropsOnRenderContext(instance);
      }
      const { setup } = Component;
      if (setup) {
        pauseTracking();
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            shallowReadonly(instance.props),
            setupContext
          ]
        );
        const isAsyncSetup = isPromise(setupResult);
        resetTracking();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
          markAsyncBoundary(instance);
        }
        if (isAsyncSetup) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
            if (!instance.suspense) {
              const name = (_a = Component.name) != null ? _a : "Anonymous";
              warn$1(
                `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
              );
            }
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject(setupResult)) {
        if (isVNode(setupResult)) {
          warn$1(
            `setup() should not return VNodes directly - return a render function instead.`
          );
        }
        {
          instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = proxyRefs(setupResult);
        {
          exposeSetupStateOnRenderContext(instance);
        }
      } else if (setupResult !== void 0) {
        warn$1(
          `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
        );
      }
      finishComponentSetup(instance, isSSR);
    }
    const isRuntimeOnly = () => true;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
      if (!Component.render && instance.render === NOOP && !isSSR) {
        if (Component.template) {
          warn$1(
            `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
          );
        } else {
          warn$1(`Component is missing template or render function: `, Component);
        }
      }
    }
    const attrsProxyHandlers = {
      get(target, key) {
        markAttrsAccessed();
        track(target, "get", "");
        return target[key];
      },
      set() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      }
    };
    function getSlotsProxy(instance) {
      return new Proxy(instance.slots, {
        get(target, key) {
          track(instance, "get", "$slots");
          return target[key];
        }
      });
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        {
          if (instance.exposed) {
            warn$1(`expose() should be called only once per setup().`);
          }
          if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
              if (isArray(exposed)) {
                exposedType = "array";
              } else if (isRef(exposed)) {
                exposedType = "ref";
              }
            }
            if (exposedType !== "object") {
              warn$1(
                `expose() should be passed a plain object, received ${exposedType}.`
              );
            }
          }
        }
        instance.exposed = exposed || {};
      };
      {
        let attrsProxy;
        let slotsProxy;
        return Object.freeze({
          get attrs() {
            return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
          },
          get slots() {
            return slotsProxy || (slotsProxy = getSlotsProxy(instance));
          },
          get emit() {
            return (event, ...args) => instance.emit(event, ...args);
          },
          expose
        });
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      {
        const i = getCurrentInstance();
        if (i && i.appContext.config.warnRecursiveComputed) {
          c._warnRecursive = true;
        }
      }
      return c;
    };
    function initCustomFormatter() {
      if (typeof window === "undefined") {
        return;
      }
      const vueStyle = { style: "color:#3ba776" };
      const numberStyle = { style: "color:#1677ff" };
      const stringStyle = { style: "color:#f5222d" };
      const keywordStyle = { style: "color:#eb2f96" };
      const formatter = {
        __vue_custom_formatter: true,
        header(obj) {
          if (!isObject(obj)) {
            return null;
          }
          if (obj.__isVue) {
            return ["div", vueStyle, `VueInstance`];
          } else if (isRef(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, genRefFlag(obj)],
              "<",
              // avoid debugger accessing value affecting behavior
              formatValue("_value" in obj ? obj._value : obj),
              `>`
            ];
          } else if (isReactive(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
              "<",
              formatValue(obj),
              `>${isReadonly(obj) ? ` (readonly)` : ``}`
            ];
          } else if (isReadonly(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
              "<",
              formatValue(obj),
              ">"
            ];
          }
          return null;
        },
        hasBody(obj) {
          return obj && obj.__isVue;
        },
        body(obj) {
          if (obj && obj.__isVue) {
            return [
              "div",
              {},
              ...formatInstance(obj.$)
            ];
          }
        }
      };
      function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
          blocks.push(createInstanceBlock("props", toRaw(instance.props)));
        }
        if (instance.setupState !== EMPTY_OBJ) {
          blocks.push(createInstanceBlock("setup", instance.setupState));
        }
        if (instance.data !== EMPTY_OBJ) {
          blocks.push(createInstanceBlock("data", toRaw(instance.data)));
        }
        const computed2 = extractKeys(instance, "computed");
        if (computed2) {
          blocks.push(createInstanceBlock("computed", computed2));
        }
        const injected = extractKeys(instance, "inject");
        if (injected) {
          blocks.push(createInstanceBlock("injected", injected));
        }
        blocks.push([
          "div",
          {},
          [
            "span",
            {
              style: keywordStyle.style + ";opacity:0.66"
            },
            "$ (internal): "
          ],
          ["object", { object: instance }]
        ]);
        return blocks;
      }
      function createInstanceBlock(type2, target) {
        target = extend({}, target);
        if (!Object.keys(target).length) {
          return ["span", {}];
        }
        return [
          "div",
          { style: "line-height:1.25em;margin-bottom:0.6em" },
          [
            "div",
            {
              style: "color:#476582"
            },
            type2
          ],
          [
            "div",
            {
              style: "padding-left:1.25em"
            },
            ...Object.keys(target).map((key) => {
              return [
                "div",
                {},
                ["span", keywordStyle, key + ": "],
                formatValue(target[key], false)
              ];
            })
          ]
        ];
      }
      function formatValue(v, asRaw = true) {
        if (typeof v === "number") {
          return ["span", numberStyle, v];
        } else if (typeof v === "string") {
          return ["span", stringStyle, JSON.stringify(v)];
        } else if (typeof v === "boolean") {
          return ["span", keywordStyle, v];
        } else if (isObject(v)) {
          return ["object", { object: asRaw ? toRaw(v) : v }];
        } else {
          return ["span", stringStyle, String(v)];
        }
      }
      function extractKeys(instance, type2) {
        const Comp = instance.type;
        if (isFunction(Comp)) {
          return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
          if (isKeyOfType(Comp, key, type2)) {
            extracted[key] = instance.ctx[key];
          }
        }
        return extracted;
      }
      function isKeyOfType(Comp, key, type2) {
        const opts = Comp[type2];
        if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
          return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type2)) {
          return true;
        }
        if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type2))) {
          return true;
        }
      }
      function genRefFlag(v) {
        if (isShallow(v)) {
          return `ShallowRef`;
        }
        if (v.effect) {
          return `ComputedRef`;
        }
        return `Ref`;
      }
      if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
      } else {
        window.devtoolsFormatters = [formatter];
      }
    }
    const version = "3.5.13";
    const warn = warn$1;
    /**
    * @vue/runtime-dom v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let policy = void 0;
    const tt = typeof window !== "undefined" && window.trustedTypes;
    if (tt) {
      try {
        policy = /* @__PURE__ */ tt.createPolicy("vue", {
          createHTML: (val) => val
        });
      } catch (e) {
        warn(`Error creating trusted types policy: ${e}`);
      }
    }
    const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id2) {
        el.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
          }
        } else {
          templateContainer.innerHTML = unsafeToTrustedHTML(
            namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
          );
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const vtcKey = Symbol("_vtc");
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    {
      vShow.name = "show";
    }
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOriginalDisplay] : "none";
      el[vShowHidden] = !value;
    }
    const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) {
          style.display = "none";
        }
      }
    }
    const semicolonRE = /[^\\];\s*$/;
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null) val = "";
        {
          if (semicolonRE.test(val)) {
            warn(
              `Unexpected semicolon at the end of '${name}' style value: '${val}'`
            );
          }
        }
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(
            key,
            isBoolean2 ? "" : isSymbol(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el, key, value, parentComponent, attrName) {
      if (key === "innerHTML" || key === "textContent") {
        if (value != null) {
          el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
        }
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? (
          // #11647: value should be set as empty string for null and undefined,
          // but <input type="checkbox"> should be set as 'on'.
          el.type === "checkbox" ? "on" : ""
        ) : String(value);
        if (oldValue !== newValue || !("_value" in el)) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        el._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type2 = typeof el[key];
        if (type2 === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type2 === "string") {
          value = "";
          needRemove = true;
        } else if (type2 === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
        if (!needRemove) {
          warn(
            `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
            e
          );
        }
      }
      needRemove && el.removeAttribute(attrName || key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = sanitizeEventValue(nextValue, rawName);
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            sanitizeEventValue(nextValue, rawName),
            instance
          );
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function sanitizeEventValue(value, propName) {
      if (isFunction(value) || isArray(value)) {
        return value;
      }
      warn(
        `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
  Expected function or array of functions, received type ${typeof value}.`
      );
      return NOOP;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn) => (e2) => !e2._stopped && fn && fn(e2)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue);
        if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
        }
      } else if (
        // #11081 force set props for possible async custom element
        el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
      ) {
        patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString(value)) {
        return false;
      }
      return key in el;
    }
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!isFunction(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        if (container.nodeType === 1) {
          container.textContent = "";
        }
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function injectNativeTagCheck(app) {
      Object.defineProperty(app.config, "isNativeTag", {
        value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
        writable: false
      });
    }
    function injectCompilerOptionsCheck(app) {
      {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
          get() {
            return isCustomElement;
          },
          set() {
            warn(
              `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
            );
          }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
  - For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
  - For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
  - For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
          get() {
            warn(msg);
            return compilerOptions;
          },
          set() {
            warn(msg);
          }
        });
      }
    }
    function normalizeContainer(container) {
      if (isString(container)) {
        const res = document.querySelector(container);
        if (!res) {
          warn(
            `Failed to mount app: mount target selector "${container}" returned null.`
          );
        }
        return res;
      }
      if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
        warn(
          `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
        );
      }
      return container;
    }
    /**
    * vue v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function initDev() {
      {
        initCustomFormatter();
      }
    }
    {
      initDev();
    }
    function noop() {
    }
    function isPrimitive(value) {
      return value == null || typeof value !== "object" && typeof value !== "function";
    }
    function isTypedArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }
    function getSymbols(object) {
      return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
    }
    function getTag(value) {
      if (value == null) {
        return value === void 0 ? "[object Undefined]" : "[object Null]";
      }
      return Object.prototype.toString.call(value);
    }
    const regexpTag = "[object RegExp]";
    const stringTag = "[object String]";
    const numberTag = "[object Number]";
    const booleanTag = "[object Boolean]";
    const argumentsTag = "[object Arguments]";
    const symbolTag = "[object Symbol]";
    const dateTag = "[object Date]";
    const mapTag = "[object Map]";
    const setTag = "[object Set]";
    const arrayTag = "[object Array]";
    const functionTag = "[object Function]";
    const arrayBufferTag = "[object ArrayBuffer]";
    const objectTag = "[object Object]";
    const errorTag = "[object Error]";
    const dataViewTag = "[object DataView]";
    const uint8ArrayTag = "[object Uint8Array]";
    const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
    const uint16ArrayTag = "[object Uint16Array]";
    const uint32ArrayTag = "[object Uint32Array]";
    const bigUint64ArrayTag = "[object BigUint64Array]";
    const int8ArrayTag = "[object Int8Array]";
    const int16ArrayTag = "[object Int16Array]";
    const int32ArrayTag = "[object Int32Array]";
    const bigInt64ArrayTag = "[object BigInt64Array]";
    const float32ArrayTag = "[object Float32Array]";
    const float64ArrayTag = "[object Float64Array]";
    function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack2 = /* @__PURE__ */ new Map(), cloneValue = void 0) {
      const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack2);
      if (cloned != null) {
        return cloned;
      }
      if (isPrimitive(valueToClone)) {
        return valueToClone;
      }
      if (stack2.has(valueToClone)) {
        return stack2.get(valueToClone);
      }
      if (Array.isArray(valueToClone)) {
        const result = new Array(valueToClone.length);
        stack2.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
        }
        if (Object.hasOwn(valueToClone, "index")) {
          result.index = valueToClone.index;
        }
        if (Object.hasOwn(valueToClone, "input")) {
          result.input = valueToClone.input;
        }
        return result;
      }
      if (valueToClone instanceof Date) {
        return new Date(valueToClone.getTime());
      }
      if (valueToClone instanceof RegExp) {
        const result = new RegExp(valueToClone.source, valueToClone.flags);
        result.lastIndex = valueToClone.lastIndex;
        return result;
      }
      if (valueToClone instanceof Map) {
        const result = /* @__PURE__ */ new Map();
        stack2.set(valueToClone, result);
        for (const [key, value] of valueToClone) {
          result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack2, cloneValue));
        }
        return result;
      }
      if (valueToClone instanceof Set) {
        const result = /* @__PURE__ */ new Set();
        stack2.set(valueToClone, result);
        for (const value of valueToClone) {
          result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack2, cloneValue));
        }
        return result;
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
        return valueToClone.subarray();
      }
      if (isTypedArray(valueToClone)) {
        const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
        stack2.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
        }
        return result;
      }
      if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
        return valueToClone.slice(0);
      }
      if (valueToClone instanceof DataView) {
        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (typeof File !== "undefined" && valueToClone instanceof File) {
        const result = new File([valueToClone], valueToClone.name, {
          type: valueToClone.type
        });
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (valueToClone instanceof Blob) {
        const result = new Blob([valueToClone], { type: valueToClone.type });
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (valueToClone instanceof Error) {
        const result = new valueToClone.constructor();
        stack2.set(valueToClone, result);
        result.message = valueToClone.message;
        result.name = valueToClone.name;
        result.stack = valueToClone.stack;
        result.cause = valueToClone.cause;
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
        const result = Object.create(Object.getPrototypeOf(valueToClone));
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      return valueToClone;
    }
    function copyProperties(target, source, objectToClone = target, stack2, cloneValue) {
      const keys = [...Object.keys(source), ...getSymbols(source)];
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor == null || descriptor.writable) {
          target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack2, cloneValue);
        }
      }
    }
    function isCloneableObject(object) {
      switch (getTag(object)) {
        case argumentsTag:
        case arrayTag:
        case arrayBufferTag:
        case dataViewTag:
        case booleanTag:
        case dateTag:
        case float32ArrayTag:
        case float64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case mapTag:
        case numberTag:
        case objectTag:
        case regexpTag:
        case setTag:
        case stringTag:
        case symbolTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag: {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    function cloneDeep(obj) {
      return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
    }
    function isPlainObject(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
      if (!hasObjectPrototype) {
        return false;
      }
      return Object.prototype.toString.call(value) === "[object Object]";
    }
    function merge(target, source) {
      const sourceKeys = Object.keys(source);
      for (let i = 0; i < sourceKeys.length; i++) {
        const key = sourceKeys[i];
        const sourceValue = source[key];
        const targetValue = target[key];
        if (Array.isArray(sourceValue)) {
          if (Array.isArray(targetValue)) {
            target[key] = merge(targetValue, sourceValue);
          } else {
            target[key] = merge([], sourceValue);
          }
        } else if (isPlainObject(sourceValue)) {
          if (isPlainObject(targetValue)) {
            target[key] = merge(targetValue, sourceValue);
          } else {
            target[key] = merge({}, sourceValue);
          }
        } else if (targetValue === void 0 || sourceValue !== void 0) {
          target[key] = sourceValue;
        }
      }
      return target;
    }
    function eq(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    function isEqualWith(a, b, areValuesEqual) {
      return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
    }
    function isEqualWithImpl(a, b, property, aParent, bParent, stack2, areValuesEqual) {
      const result = areValuesEqual(a, b, property, aParent, bParent, stack2);
      if (result !== void 0) {
        return result;
      }
      if (typeof a === typeof b) {
        switch (typeof a) {
          case "bigint":
          case "string":
          case "boolean":
          case "symbol":
          case "undefined": {
            return a === b;
          }
          case "number": {
            return a === b || Object.is(a, b);
          }
          case "function": {
            return a === b;
          }
          case "object": {
            return areObjectsEqual(a, b, stack2, areValuesEqual);
          }
        }
      }
      return areObjectsEqual(a, b, stack2, areValuesEqual);
    }
    function areObjectsEqual(a, b, stack2, areValuesEqual) {
      if (Object.is(a, b)) {
        return true;
      }
      let aTag = getTag(a);
      let bTag = getTag(b);
      if (aTag === argumentsTag) {
        aTag = objectTag;
      }
      if (bTag === argumentsTag) {
        bTag = objectTag;
      }
      if (aTag !== bTag) {
        return false;
      }
      switch (aTag) {
        case stringTag:
          return a.toString() === b.toString();
        case numberTag: {
          const x = a.valueOf();
          const y = b.valueOf();
          return eq(x, y);
        }
        case booleanTag:
        case dateTag:
        case symbolTag:
          return Object.is(a.valueOf(), b.valueOf());
        case regexpTag: {
          return a.source === b.source && a.flags === b.flags;
        }
        case functionTag: {
          return a === b;
        }
      }
      stack2 = stack2 ?? /* @__PURE__ */ new Map();
      const aStack = stack2.get(a);
      const bStack = stack2.get(b);
      if (aStack != null && bStack != null) {
        return aStack === b;
      }
      stack2.set(a, b);
      stack2.set(b, a);
      try {
        switch (aTag) {
          case mapTag: {
            if (a.size !== b.size) {
              return false;
            }
            for (const [key, value] of a.entries()) {
              if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack2, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          case setTag: {
            if (a.size !== b.size) {
              return false;
            }
            const aValues = Array.from(a.values());
            const bValues = Array.from(b.values());
            for (let i = 0; i < aValues.length; i++) {
              const aValue = aValues[i];
              const index = bValues.findIndex((bValue) => {
                return isEqualWithImpl(aValue, bValue, void 0, a, b, stack2, areValuesEqual);
              });
              if (index === -1) {
                return false;
              }
              bValues.splice(index, 1);
            }
            return true;
          }
          case arrayTag:
          case uint8ArrayTag:
          case uint8ClampedArrayTag:
          case uint16ArrayTag:
          case uint32ArrayTag:
          case bigUint64ArrayTag:
          case int8ArrayTag:
          case int16ArrayTag:
          case int32ArrayTag:
          case bigInt64ArrayTag:
          case float32ArrayTag:
          case float64ArrayTag: {
            if (typeof Buffer !== "undefined" && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {
              return false;
            }
            if (a.length !== b.length) {
              return false;
            }
            for (let i = 0; i < a.length; i++) {
              if (!isEqualWithImpl(a[i], b[i], i, a, b, stack2, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          case arrayBufferTag: {
            if (a.byteLength !== b.byteLength) {
              return false;
            }
            return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
          }
          case dataViewTag: {
            if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
              return false;
            }
            return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
          }
          case errorTag: {
            return a.name === b.name && a.message === b.message;
          }
          case objectTag: {
            const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack2, areValuesEqual) || isPlainObject(a) && isPlainObject(b);
            if (!areEqualInstances) {
              return false;
            }
            const aKeys = [...Object.keys(a), ...getSymbols(a)];
            const bKeys = [...Object.keys(b), ...getSymbols(b)];
            if (aKeys.length !== bKeys.length) {
              return false;
            }
            for (let i = 0; i < aKeys.length; i++) {
              const propKey = aKeys[i];
              const aProp = a[propKey];
              if (!Object.hasOwn(b, propKey)) {
                return false;
              }
              const bProp = b[propKey];
              if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack2, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          default: {
            return false;
          }
        }
      } finally {
        stack2.delete(a);
        stack2.delete(b);
      }
    }
    function isEqual(a, b) {
      return isEqualWith(a, b, noop);
    }
    function getDefaultsFromSchema(schema) {
      const result = {};
      const properties2 = schema.properties || {};
      const requiredProps = Array.isArray(schema.required) ? schema.required : [];
      console.log("getDefaultsFromSchema");
      for (const [key, value] of Object.entries(properties2)) {
        console.log(key);
        console.log(value);
        result[key] = {
          required: requiredProps.includes(key),
          value: value.default ?? ""
        };
        if ("nodeType" in value) {
          result[key].type = value.nodeType;
        }
      }
      return result;
    }
    function getCredentialsFromSchema(schema) {
      const result = {};
      const properties2 = schema.properties || {};
      const requiredProps = Array.isArray(schema.required) ? schema.required : [];
      for (const [key, value] of Object.entries(properties2)) {
        console.log(value);
        const isPassword = value.format === "password";
        result[key] = {
          type: isPassword ? "password" : "text",
          required: requiredProps.includes(key),
          value: value.default ?? ""
        };
      }
      return result;
    }
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var ajv = { exports: {} };
    var core$1 = {};
    var validate = {};
    var boolSchema = {};
    var errors = {};
    var codegen = {};
    var code$1 = {};
    var hasRequiredCode$1;
    function requireCode$1() {
      if (hasRequiredCode$1) return code$1;
      hasRequiredCode$1 = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
        class _CodeOrName {
        }
        exports._CodeOrName = _CodeOrName;
        exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class Name extends _CodeOrName {
          constructor(s) {
            super();
            if (!exports.IDENTIFIER.test(s))
              throw new Error("CodeGen: name must be a valid identifier");
            this.str = s;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            return false;
          }
          get names() {
            return { [this.str]: 1 };
          }
        }
        exports.Name = Name;
        class _Code extends _CodeOrName {
          constructor(code2) {
            super();
            this._items = typeof code2 === "string" ? [code2] : code2;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            if (this._items.length > 1)
              return false;
            const item = this._items[0];
            return item === "" || item === '""';
          }
          get str() {
            var _a;
            return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
          }
          get names() {
            var _a;
            return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
              if (c instanceof Name)
                names2[c.str] = (names2[c.str] || 0) + 1;
              return names2;
            }, {});
          }
        }
        exports._Code = _Code;
        exports.nil = new _Code("");
        function _(strs, ...args) {
          const code2 = [strs[0]];
          let i = 0;
          while (i < args.length) {
            addCodeArg(code2, args[i]);
            code2.push(strs[++i]);
          }
          return new _Code(code2);
        }
        exports._ = _;
        const plus = new _Code("+");
        function str(strs, ...args) {
          const expr = [safeStringify(strs[0])];
          let i = 0;
          while (i < args.length) {
            expr.push(plus);
            addCodeArg(expr, args[i]);
            expr.push(plus, safeStringify(strs[++i]));
          }
          optimize(expr);
          return new _Code(expr);
        }
        exports.str = str;
        function addCodeArg(code2, arg) {
          if (arg instanceof _Code)
            code2.push(...arg._items);
          else if (arg instanceof Name)
            code2.push(arg);
          else
            code2.push(interpolate(arg));
        }
        exports.addCodeArg = addCodeArg;
        function optimize(expr) {
          let i = 1;
          while (i < expr.length - 1) {
            if (expr[i] === plus) {
              const res = mergeExprItems(expr[i - 1], expr[i + 1]);
              if (res !== void 0) {
                expr.splice(i - 1, 3, res);
                continue;
              }
              expr[i++] = "+";
            }
            i++;
          }
        }
        function mergeExprItems(a, b) {
          if (b === '""')
            return a;
          if (a === '""')
            return b;
          if (typeof a == "string") {
            if (b instanceof Name || a[a.length - 1] !== '"')
              return;
            if (typeof b != "string")
              return `${a.slice(0, -1)}${b}"`;
            if (b[0] === '"')
              return a.slice(0, -1) + b.slice(1);
            return;
          }
          if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
            return `"${a}${b.slice(1)}`;
          return;
        }
        function strConcat(c1, c2) {
          return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
        }
        exports.strConcat = strConcat;
        function interpolate(x) {
          return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
        }
        function stringify(x) {
          return new _Code(safeStringify(x));
        }
        exports.stringify = stringify;
        function safeStringify(x) {
          return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        exports.safeStringify = safeStringify;
        function getProperty(key) {
          return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
        }
        exports.getProperty = getProperty;
        function getEsmExportName(key) {
          if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
            return new _Code(`${key}`);
          }
          throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
        }
        exports.getEsmExportName = getEsmExportName;
        function regexpCode(rx) {
          return new _Code(rx.toString());
        }
        exports.regexpCode = regexpCode;
      })(code$1);
      return code$1;
    }
    var scope = {};
    var hasRequiredScope;
    function requireScope() {
      if (hasRequiredScope) return scope;
      hasRequiredScope = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
        const code_1 = requireCode$1();
        class ValueError extends Error {
          constructor(name) {
            super(`CodeGen: "code" for ${name} not defined`);
            this.value = name.value;
          }
        }
        var UsedValueState;
        (function(UsedValueState2) {
          UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
          UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
        })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
        exports.varKinds = {
          const: new code_1.Name("const"),
          let: new code_1.Name("let"),
          var: new code_1.Name("var")
        };
        class Scope {
          constructor({ prefixes: prefixes2, parent } = {}) {
            this._names = {};
            this._prefixes = prefixes2;
            this._parent = parent;
          }
          toName(nameOrPrefix) {
            return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
          }
          name(prefix) {
            return new code_1.Name(this._newName(prefix));
          }
          _newName(prefix) {
            const ng = this._names[prefix] || this._nameGroup(prefix);
            return `${prefix}${ng.index++}`;
          }
          _nameGroup(prefix) {
            var _a, _b;
            if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
              throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
            }
            return this._names[prefix] = { prefix, index: 0 };
          }
        }
        exports.Scope = Scope;
        class ValueScopeName extends code_1.Name {
          constructor(prefix, nameStr) {
            super(nameStr);
            this.prefix = prefix;
          }
          setValue(value, { property, itemIndex }) {
            this.value = value;
            this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
          }
        }
        exports.ValueScopeName = ValueScopeName;
        const line = (0, code_1._)`\n`;
        class ValueScope extends Scope {
          constructor(opts) {
            super(opts);
            this._values = {};
            this._scope = opts.scope;
            this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
          }
          get() {
            return this._scope;
          }
          name(prefix) {
            return new ValueScopeName(prefix, this._newName(prefix));
          }
          value(nameOrPrefix, value) {
            var _a;
            if (value.ref === void 0)
              throw new Error("CodeGen: ref must be passed in value");
            const name = this.toName(nameOrPrefix);
            const { prefix } = name;
            const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
            let vs = this._values[prefix];
            if (vs) {
              const _name = vs.get(valueKey);
              if (_name)
                return _name;
            } else {
              vs = this._values[prefix] = /* @__PURE__ */ new Map();
            }
            vs.set(valueKey, name);
            const s = this._scope[prefix] || (this._scope[prefix] = []);
            const itemIndex = s.length;
            s[itemIndex] = value.ref;
            name.setValue(value, { property: prefix, itemIndex });
            return name;
          }
          getValue(prefix, keyOrRef) {
            const vs = this._values[prefix];
            if (!vs)
              return;
            return vs.get(keyOrRef);
          }
          scopeRefs(scopeName, values = this._values) {
            return this._reduceValues(values, (name) => {
              if (name.scopePath === void 0)
                throw new Error(`CodeGen: name "${name}" has no value`);
              return (0, code_1._)`${scopeName}${name.scopePath}`;
            });
          }
          scopeCode(values = this._values, usedValues, getCode) {
            return this._reduceValues(values, (name) => {
              if (name.value === void 0)
                throw new Error(`CodeGen: name "${name}" has no value`);
              return name.value.code;
            }, usedValues, getCode);
          }
          _reduceValues(values, valueCode, usedValues = {}, getCode) {
            let code2 = code_1.nil;
            for (const prefix in values) {
              const vs = values[prefix];
              if (!vs)
                continue;
              const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
              vs.forEach((name) => {
                if (nameSet.has(name))
                  return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                  const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                  code2 = (0, code_1._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
                } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                  code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
                } else {
                  throw new ValueError(name);
                }
                nameSet.set(name, UsedValueState.Completed);
              });
            }
            return code2;
          }
        }
        exports.ValueScope = ValueScope;
      })(scope);
      return scope;
    }
    var hasRequiredCodegen;
    function requireCodegen() {
      if (hasRequiredCodegen) return codegen;
      hasRequiredCodegen = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
        const code_1 = requireCode$1();
        const scope_1 = requireScope();
        var code_2 = requireCode$1();
        Object.defineProperty(exports, "_", { enumerable: true, get: function() {
          return code_2._;
        } });
        Object.defineProperty(exports, "str", { enumerable: true, get: function() {
          return code_2.str;
        } });
        Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
          return code_2.strConcat;
        } });
        Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
          return code_2.nil;
        } });
        Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
          return code_2.getProperty;
        } });
        Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
          return code_2.stringify;
        } });
        Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
          return code_2.regexpCode;
        } });
        Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
          return code_2.Name;
        } });
        var scope_2 = requireScope();
        Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
          return scope_2.Scope;
        } });
        Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
          return scope_2.ValueScope;
        } });
        Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
          return scope_2.ValueScopeName;
        } });
        Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
          return scope_2.varKinds;
        } });
        exports.operators = {
          GT: new code_1._Code(">"),
          GTE: new code_1._Code(">="),
          LT: new code_1._Code("<"),
          LTE: new code_1._Code("<="),
          EQ: new code_1._Code("==="),
          NEQ: new code_1._Code("!=="),
          NOT: new code_1._Code("!"),
          OR: new code_1._Code("||"),
          AND: new code_1._Code("&&"),
          ADD: new code_1._Code("+")
        };
        class Node {
          optimizeNodes() {
            return this;
          }
          optimizeNames(_names, _constants) {
            return this;
          }
        }
        class Def extends Node {
          constructor(varKind, name, rhs) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.rhs = rhs;
          }
          render({ es5, _n }) {
            const varKind = es5 ? scope_1.varKinds.var : this.varKind;
            const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
            return `${varKind} ${this.name}${rhs};` + _n;
          }
          optimizeNames(names2, constants) {
            if (!names2[this.name.str])
              return;
            if (this.rhs)
              this.rhs = optimizeExpr(this.rhs, names2, constants);
            return this;
          }
          get names() {
            return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
          }
        }
        class Assign extends Node {
          constructor(lhs, rhs, sideEffects) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.sideEffects = sideEffects;
          }
          render({ _n }) {
            return `${this.lhs} = ${this.rhs};` + _n;
          }
          optimizeNames(names2, constants) {
            if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
              return;
            this.rhs = optimizeExpr(this.rhs, names2, constants);
            return this;
          }
          get names() {
            const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
            return addExprNames(names2, this.rhs);
          }
        }
        class AssignOp extends Assign {
          constructor(lhs, op, rhs, sideEffects) {
            super(lhs, rhs, sideEffects);
            this.op = op;
          }
          render({ _n }) {
            return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
          }
        }
        class Label extends Node {
          constructor(label) {
            super();
            this.label = label;
            this.names = {};
          }
          render({ _n }) {
            return `${this.label}:` + _n;
          }
        }
        class Break extends Node {
          constructor(label) {
            super();
            this.label = label;
            this.names = {};
          }
          render({ _n }) {
            const label = this.label ? ` ${this.label}` : "";
            return `break${label};` + _n;
          }
        }
        class Throw extends Node {
          constructor(error) {
            super();
            this.error = error;
          }
          render({ _n }) {
            return `throw ${this.error};` + _n;
          }
          get names() {
            return this.error.names;
          }
        }
        class AnyCode extends Node {
          constructor(code2) {
            super();
            this.code = code2;
          }
          render({ _n }) {
            return `${this.code};` + _n;
          }
          optimizeNodes() {
            return `${this.code}` ? this : void 0;
          }
          optimizeNames(names2, constants) {
            this.code = optimizeExpr(this.code, names2, constants);
            return this;
          }
          get names() {
            return this.code instanceof code_1._CodeOrName ? this.code.names : {};
          }
        }
        class ParentNode extends Node {
          constructor(nodes = []) {
            super();
            this.nodes = nodes;
          }
          render(opts) {
            return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
          }
          optimizeNodes() {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
              const n = nodes[i].optimizeNodes();
              if (Array.isArray(n))
                nodes.splice(i, 1, ...n);
              else if (n)
                nodes[i] = n;
              else
                nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : void 0;
          }
          optimizeNames(names2, constants) {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
              const n = nodes[i];
              if (n.optimizeNames(names2, constants))
                continue;
              subtractNames(names2, n.names);
              nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : void 0;
          }
          get names() {
            return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
          }
        }
        class BlockNode extends ParentNode {
          render(opts) {
            return "{" + opts._n + super.render(opts) + "}" + opts._n;
          }
        }
        class Root extends ParentNode {
        }
        class Else extends BlockNode {
        }
        Else.kind = "else";
        class If extends BlockNode {
          constructor(condition, nodes) {
            super(nodes);
            this.condition = condition;
          }
          render(opts) {
            let code2 = `if(${this.condition})` + super.render(opts);
            if (this.else)
              code2 += "else " + this.else.render(opts);
            return code2;
          }
          optimizeNodes() {
            super.optimizeNodes();
            const cond = this.condition;
            if (cond === true)
              return this.nodes;
            let e = this.else;
            if (e) {
              const ns = e.optimizeNodes();
              e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
            }
            if (e) {
              if (cond === false)
                return e instanceof If ? e : e.nodes;
              if (this.nodes.length)
                return this;
              return new If(not2(cond), e instanceof If ? [e] : e.nodes);
            }
            if (cond === false || !this.nodes.length)
              return void 0;
            return this;
          }
          optimizeNames(names2, constants) {
            var _a;
            this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
            if (!(super.optimizeNames(names2, constants) || this.else))
              return;
            this.condition = optimizeExpr(this.condition, names2, constants);
            return this;
          }
          get names() {
            const names2 = super.names;
            addExprNames(names2, this.condition);
            if (this.else)
              addNames(names2, this.else.names);
            return names2;
          }
        }
        If.kind = "if";
        class For extends BlockNode {
        }
        For.kind = "for";
        class ForLoop extends For {
          constructor(iteration) {
            super();
            this.iteration = iteration;
          }
          render(opts) {
            return `for(${this.iteration})` + super.render(opts);
          }
          optimizeNames(names2, constants) {
            if (!super.optimizeNames(names2, constants))
              return;
            this.iteration = optimizeExpr(this.iteration, names2, constants);
            return this;
          }
          get names() {
            return addNames(super.names, this.iteration.names);
          }
        }
        class ForRange extends For {
          constructor(varKind, name, from, to) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.from = from;
            this.to = to;
          }
          render(opts) {
            const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
            const { name, from, to } = this;
            return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
          }
          get names() {
            const names2 = addExprNames(super.names, this.from);
            return addExprNames(names2, this.to);
          }
        }
        class ForIter extends For {
          constructor(loop, varKind, name, iterable) {
            super();
            this.loop = loop;
            this.varKind = varKind;
            this.name = name;
            this.iterable = iterable;
          }
          render(opts) {
            return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
          }
          optimizeNames(names2, constants) {
            if (!super.optimizeNames(names2, constants))
              return;
            this.iterable = optimizeExpr(this.iterable, names2, constants);
            return this;
          }
          get names() {
            return addNames(super.names, this.iterable.names);
          }
        }
        class Func extends BlockNode {
          constructor(name, args, async) {
            super();
            this.name = name;
            this.args = args;
            this.async = async;
          }
          render(opts) {
            const _async = this.async ? "async " : "";
            return `${_async}function ${this.name}(${this.args})` + super.render(opts);
          }
        }
        Func.kind = "func";
        class Return extends ParentNode {
          render(opts) {
            return "return " + super.render(opts);
          }
        }
        Return.kind = "return";
        class Try extends BlockNode {
          render(opts) {
            let code2 = "try" + super.render(opts);
            if (this.catch)
              code2 += this.catch.render(opts);
            if (this.finally)
              code2 += this.finally.render(opts);
            return code2;
          }
          optimizeNodes() {
            var _a, _b;
            super.optimizeNodes();
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
            return this;
          }
          optimizeNames(names2, constants) {
            var _a, _b;
            super.optimizeNames(names2, constants);
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
            return this;
          }
          get names() {
            const names2 = super.names;
            if (this.catch)
              addNames(names2, this.catch.names);
            if (this.finally)
              addNames(names2, this.finally.names);
            return names2;
          }
        }
        class Catch extends BlockNode {
          constructor(error) {
            super();
            this.error = error;
          }
          render(opts) {
            return `catch(${this.error})` + super.render(opts);
          }
        }
        Catch.kind = "catch";
        class Finally extends BlockNode {
          render(opts) {
            return "finally" + super.render(opts);
          }
        }
        Finally.kind = "finally";
        class CodeGen {
          constructor(extScope, opts = {}) {
            this._values = {};
            this._blockStarts = [];
            this._constants = {};
            this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
            this._extScope = extScope;
            this._scope = new scope_1.Scope({ parent: extScope });
            this._nodes = [new Root()];
          }
          toString() {
            return this._root.render(this.opts);
          }
          // returns unique name in the internal scope
          name(prefix) {
            return this._scope.name(prefix);
          }
          // reserves unique name in the external scope
          scopeName(prefix) {
            return this._extScope.name(prefix);
          }
          // reserves unique name in the external scope and assigns value to it
          scopeValue(prefixOrName, value) {
            const name = this._extScope.value(prefixOrName, value);
            const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
            vs.add(name);
            return name;
          }
          getScopeValue(prefix, keyOrRef) {
            return this._extScope.getValue(prefix, keyOrRef);
          }
          // return code that assigns values in the external scope to the names that are used internally
          // (same names that were returned by gen.scopeName or gen.scopeValue)
          scopeRefs(scopeName) {
            return this._extScope.scopeRefs(scopeName, this._values);
          }
          scopeCode() {
            return this._extScope.scopeCode(this._values);
          }
          _def(varKind, nameOrPrefix, rhs, constant) {
            const name = this._scope.toName(nameOrPrefix);
            if (rhs !== void 0 && constant)
              this._constants[name.str] = rhs;
            this._leafNode(new Def(varKind, name, rhs));
            return name;
          }
          // `const` declaration (`var` in es5 mode)
          const(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
          }
          // `let` declaration with optional assignment (`var` in es5 mode)
          let(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
          }
          // `var` declaration with optional assignment
          var(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
          }
          // assignment code
          assign(lhs, rhs, sideEffects) {
            return this._leafNode(new Assign(lhs, rhs, sideEffects));
          }
          // `+=` code
          add(lhs, rhs) {
            return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
          }
          // appends passed SafeExpr to code or executes Block
          code(c) {
            if (typeof c == "function")
              c();
            else if (c !== code_1.nil)
              this._leafNode(new AnyCode(c));
            return this;
          }
          // returns code for object literal for the passed argument list of key-value pairs
          object(...keyValues) {
            const code2 = ["{"];
            for (const [key, value] of keyValues) {
              if (code2.length > 1)
                code2.push(",");
              code2.push(key);
              if (key !== value || this.opts.es5) {
                code2.push(":");
                (0, code_1.addCodeArg)(code2, value);
              }
            }
            code2.push("}");
            return new code_1._Code(code2);
          }
          // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
          if(condition, thenBody, elseBody) {
            this._blockNode(new If(condition));
            if (thenBody && elseBody) {
              this.code(thenBody).else().code(elseBody).endIf();
            } else if (thenBody) {
              this.code(thenBody).endIf();
            } else if (elseBody) {
              throw new Error('CodeGen: "else" body without "then" body');
            }
            return this;
          }
          // `else if` clause - invalid without `if` or after `else` clauses
          elseIf(condition) {
            return this._elseNode(new If(condition));
          }
          // `else` clause - only valid after `if` or `else if` clauses
          else() {
            return this._elseNode(new Else());
          }
          // end `if` statement (needed if gen.if was used only with condition)
          endIf() {
            return this._endBlockNode(If, Else);
          }
          _for(node, forBody) {
            this._blockNode(node);
            if (forBody)
              this.code(forBody).endFor();
            return this;
          }
          // a generic `for` clause (or statement if `forBody` is passed)
          for(iteration, forBody) {
            return this._for(new ForLoop(iteration), forBody);
          }
          // `for` statement for a range of values
          forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
          }
          // `for-of` statement (in es5 mode replace with a normal for loop)
          forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
            const name = this._scope.toName(nameOrPrefix);
            if (this.opts.es5) {
              const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
              return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
                this.var(name, (0, code_1._)`${arr}[${i}]`);
                forBody(name);
              });
            }
            return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
          }
          // `for-in` statement.
          // With option `ownProperties` replaced with a `for-of` loop for object keys
          forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
            if (this.opts.ownProperties) {
              return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
            }
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
          }
          // end `for` loop
          endFor() {
            return this._endBlockNode(For);
          }
          // `label` statement
          label(label) {
            return this._leafNode(new Label(label));
          }
          // `break` statement
          break(label) {
            return this._leafNode(new Break(label));
          }
          // `return` statement
          return(value) {
            const node = new Return();
            this._blockNode(node);
            this.code(value);
            if (node.nodes.length !== 1)
              throw new Error('CodeGen: "return" should have one node');
            return this._endBlockNode(Return);
          }
          // `try` statement
          try(tryBody, catchCode, finallyCode) {
            if (!catchCode && !finallyCode)
              throw new Error('CodeGen: "try" without "catch" and "finally"');
            const node = new Try();
            this._blockNode(node);
            this.code(tryBody);
            if (catchCode) {
              const error = this.name("e");
              this._currNode = node.catch = new Catch(error);
              catchCode(error);
            }
            if (finallyCode) {
              this._currNode = node.finally = new Finally();
              this.code(finallyCode);
            }
            return this._endBlockNode(Catch, Finally);
          }
          // `throw` statement
          throw(error) {
            return this._leafNode(new Throw(error));
          }
          // start self-balancing block
          block(body, nodeCount) {
            this._blockStarts.push(this._nodes.length);
            if (body)
              this.code(body).endBlock(nodeCount);
            return this;
          }
          // end the current self-balancing block
          endBlock(nodeCount) {
            const len = this._blockStarts.pop();
            if (len === void 0)
              throw new Error("CodeGen: not in self-balancing block");
            const toClose = this._nodes.length - len;
            if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
              throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
            }
            this._nodes.length = len;
            return this;
          }
          // `function` heading (or definition if funcBody is passed)
          func(name, args = code_1.nil, async, funcBody) {
            this._blockNode(new Func(name, args, async));
            if (funcBody)
              this.code(funcBody).endFunc();
            return this;
          }
          // end function definition
          endFunc() {
            return this._endBlockNode(Func);
          }
          optimize(n = 1) {
            while (n-- > 0) {
              this._root.optimizeNodes();
              this._root.optimizeNames(this._root.names, this._constants);
            }
          }
          _leafNode(node) {
            this._currNode.nodes.push(node);
            return this;
          }
          _blockNode(node) {
            this._currNode.nodes.push(node);
            this._nodes.push(node);
          }
          _endBlockNode(N1, N2) {
            const n = this._currNode;
            if (n instanceof N1 || N2 && n instanceof N2) {
              this._nodes.pop();
              return this;
            }
            throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
          }
          _elseNode(node) {
            const n = this._currNode;
            if (!(n instanceof If)) {
              throw new Error('CodeGen: "else" without "if"');
            }
            this._currNode = n.else = node;
            return this;
          }
          get _root() {
            return this._nodes[0];
          }
          get _currNode() {
            const ns = this._nodes;
            return ns[ns.length - 1];
          }
          set _currNode(node) {
            const ns = this._nodes;
            ns[ns.length - 1] = node;
          }
        }
        exports.CodeGen = CodeGen;
        function addNames(names2, from) {
          for (const n in from)
            names2[n] = (names2[n] || 0) + (from[n] || 0);
          return names2;
        }
        function addExprNames(names2, from) {
          return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
        }
        function optimizeExpr(expr, names2, constants) {
          if (expr instanceof code_1.Name)
            return replaceName(expr);
          if (!canOptimize(expr))
            return expr;
          return new code_1._Code(expr._items.reduce((items2, c) => {
            if (c instanceof code_1.Name)
              c = replaceName(c);
            if (c instanceof code_1._Code)
              items2.push(...c._items);
            else
              items2.push(c);
            return items2;
          }, []));
          function replaceName(n) {
            const c = constants[n.str];
            if (c === void 0 || names2[n.str] !== 1)
              return n;
            delete names2[n.str];
            return c;
          }
          function canOptimize(e) {
            return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
          }
        }
        function subtractNames(names2, from) {
          for (const n in from)
            names2[n] = (names2[n] || 0) - (from[n] || 0);
        }
        function not2(x) {
          return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
        }
        exports.not = not2;
        const andCode = mappend(exports.operators.AND);
        function and(...args) {
          return args.reduce(andCode);
        }
        exports.and = and;
        const orCode = mappend(exports.operators.OR);
        function or(...args) {
          return args.reduce(orCode);
        }
        exports.or = or;
        function mappend(op) {
          return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
        }
        function par(x) {
          return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
        }
      })(codegen);
      return codegen;
    }
    var util = {};
    var hasRequiredUtil;
    function requireUtil() {
      if (hasRequiredUtil) return util;
      hasRequiredUtil = 1;
      Object.defineProperty(util, "__esModule", { value: true });
      util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
      const codegen_1 = requireCodegen();
      const code_1 = requireCode$1();
      function toHash(arr) {
        const hash = {};
        for (const item of arr)
          hash[item] = true;
        return hash;
      }
      util.toHash = toHash;
      function alwaysValidSchema(it, schema) {
        if (typeof schema == "boolean")
          return schema;
        if (Object.keys(schema).length === 0)
          return true;
        checkUnknownRules(it, schema);
        return !schemaHasRules(schema, it.self.RULES.all);
      }
      util.alwaysValidSchema = alwaysValidSchema;
      function checkUnknownRules(it, schema = it.schema) {
        const { opts, self: self2 } = it;
        if (!opts.strictSchema)
          return;
        if (typeof schema === "boolean")
          return;
        const rules2 = self2.RULES.keywords;
        for (const key in schema) {
          if (!rules2[key])
            checkStrictMode(it, `unknown keyword: "${key}"`);
        }
      }
      util.checkUnknownRules = checkUnknownRules;
      function schemaHasRules(schema, rules2) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (rules2[key])
            return true;
        return false;
      }
      util.schemaHasRules = schemaHasRules;
      function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (key !== "$ref" && RULES.all[key])
            return true;
        return false;
      }
      util.schemaHasRulesButRef = schemaHasRulesButRef;
      function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
        if (!$data) {
          if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
          if (typeof schema == "string")
            return (0, codegen_1._)`${schema}`;
        }
        return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
      }
      util.schemaRefOrVal = schemaRefOrVal;
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
      }
      util.unescapeFragment = unescapeFragment;
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
      }
      util.escapeFragment = escapeFragment;
      function escapeJsonPointer(str) {
        if (typeof str == "number")
          return `${str}`;
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      util.escapeJsonPointer = escapeJsonPointer;
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      util.unescapeJsonPointer = unescapeJsonPointer;
      function eachItem(xs, f) {
        if (Array.isArray(xs)) {
          for (const x of xs)
            f(x);
        } else {
          f(xs);
        }
      }
      util.eachItem = eachItem;
      function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
        return (gen, from, to, toName) => {
          const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
          return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
        };
      }
      util.mergeEvaluated = {
        props: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
            gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
          }),
          mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
            if (from === true) {
              gen.assign(to, true);
            } else {
              gen.assign(to, (0, codegen_1._)`${to} || {}`);
              setEvaluated(gen, to, from);
            }
          }),
          mergeValues: (from, to) => from === true ? true : { ...from, ...to },
          resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
          mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
          mergeValues: (from, to) => from === true ? true : Math.max(from, to),
          resultToName: (gen, items2) => gen.var("items", items2)
        })
      };
      function evaluatedPropsToName(gen, ps) {
        if (ps === true)
          return gen.var("props", true);
        const props = gen.var("props", (0, codegen_1._)`{}`);
        if (ps !== void 0)
          setEvaluated(gen, props, ps);
        return props;
      }
      util.evaluatedPropsToName = evaluatedPropsToName;
      function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
      }
      util.setEvaluated = setEvaluated;
      const snippets = {};
      function useFunc(gen, f) {
        return gen.scopeValue("func", {
          ref: f,
          code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
        });
      }
      util.useFunc = useFunc;
      var Type;
      (function(Type2) {
        Type2[Type2["Num"] = 0] = "Num";
        Type2[Type2["Str"] = 1] = "Str";
      })(Type || (util.Type = Type = {}));
      function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        if (dataProp instanceof codegen_1.Name) {
          const isNumber = dataPropType === Type.Num;
          return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
        }
        return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
      }
      util.getErrorPath = getErrorPath;
      function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode)
          return;
        msg = `strict mode: ${msg}`;
        if (mode === true)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
      util.checkStrictMode = checkStrictMode;
      return util;
    }
    var names = {};
    var hasRequiredNames;
    function requireNames() {
      if (hasRequiredNames) return names;
      hasRequiredNames = 1;
      Object.defineProperty(names, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const names$1 = {
        // validation function arguments
        data: new codegen_1.Name("data"),
        // data passed to validation function
        // args passed from referencing schema
        valCxt: new codegen_1.Name("valCxt"),
        // validation/data context - should not be used directly, it is destructured to the names below
        instancePath: new codegen_1.Name("instancePath"),
        parentData: new codegen_1.Name("parentData"),
        parentDataProperty: new codegen_1.Name("parentDataProperty"),
        rootData: new codegen_1.Name("rootData"),
        // root data - same as the data passed to the first/top validation function
        dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
        // used to support recursiveRef and dynamicRef
        // function scoped variables
        vErrors: new codegen_1.Name("vErrors"),
        // null or array of validation errors
        errors: new codegen_1.Name("errors"),
        // counter of validation errors
        this: new codegen_1.Name("this"),
        // "globals"
        self: new codegen_1.Name("self"),
        scope: new codegen_1.Name("scope"),
        // JTD serialize/parse name for JSON string and position
        json: new codegen_1.Name("json"),
        jsonPos: new codegen_1.Name("jsonPos"),
        jsonLen: new codegen_1.Name("jsonLen"),
        jsonPart: new codegen_1.Name("jsonPart")
      };
      names.default = names$1;
      return names;
    }
    var hasRequiredErrors;
    function requireErrors() {
      if (hasRequiredErrors) return errors;
      hasRequiredErrors = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
        const codegen_1 = requireCodegen();
        const util_1 = requireUtil();
        const names_1 = requireNames();
        exports.keywordError = {
          message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
        };
        exports.keyword$DataError = {
          message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
        };
        function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
          const { it } = cxt;
          const { gen, compositeRule, allErrors } = it;
          const errObj = errorObjectCode(cxt, error, errorPaths);
          if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
            addError(gen, errObj);
          } else {
            returnErrors(it, (0, codegen_1._)`[${errObj}]`);
          }
        }
        exports.reportError = reportError;
        function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
          const { it } = cxt;
          const { gen, compositeRule, allErrors } = it;
          const errObj = errorObjectCode(cxt, error, errorPaths);
          addError(gen, errObj);
          if (!(compositeRule || allErrors)) {
            returnErrors(it, names_1.default.vErrors);
          }
        }
        exports.reportExtraError = reportExtraError;
        function resetErrorsCount(gen, errsCount) {
          gen.assign(names_1.default.errors, errsCount);
          gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
        }
        exports.resetErrorsCount = resetErrorsCount;
        function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
          if (errsCount === void 0)
            throw new Error("ajv implementation error");
          const err = gen.name("err");
          gen.forRange("i", errsCount, names_1.default.errors, (i) => {
            gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
            gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
            gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
            if (it.opts.verbose) {
              gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
              gen.assign((0, codegen_1._)`${err}.data`, data);
            }
          });
        }
        exports.extendErrors = extendErrors;
        function addError(gen, errObj) {
          const err = gen.const("err", errObj);
          gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
          gen.code((0, codegen_1._)`${names_1.default.errors}++`);
        }
        function returnErrors(it, errs) {
          const { gen, validateName, schemaEnv } = it;
          if (schemaEnv.$async) {
            gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
          } else {
            gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
            gen.return(false);
          }
        }
        const E = {
          keyword: new codegen_1.Name("keyword"),
          schemaPath: new codegen_1.Name("schemaPath"),
          // also used in JTD errors
          params: new codegen_1.Name("params"),
          propertyName: new codegen_1.Name("propertyName"),
          message: new codegen_1.Name("message"),
          schema: new codegen_1.Name("schema"),
          parentSchema: new codegen_1.Name("parentSchema")
        };
        function errorObjectCode(cxt, error, errorPaths) {
          const { createErrors } = cxt.it;
          if (createErrors === false)
            return (0, codegen_1._)`{}`;
          return errorObject(cxt, error, errorPaths);
        }
        function errorObject(cxt, error, errorPaths = {}) {
          const { gen, it } = cxt;
          const keyValues = [
            errorInstancePath(it, errorPaths),
            errorSchemaPath(cxt, errorPaths)
          ];
          extraErrorProps(cxt, error, keyValues);
          return gen.object(...keyValues);
        }
        function errorInstancePath({ errorPath }, { instancePath }) {
          const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
          return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
        }
        function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
          let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
          if (schemaPath) {
            schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
          }
          return [E.schemaPath, schPath];
        }
        function extraErrorProps(cxt, { params, message }, keyValues) {
          const { keyword: keyword2, data, schemaValue, it } = cxt;
          const { opts, propertyName, topSchemaRef, schemaPath } = it;
          keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
          if (opts.messages) {
            keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
          }
          if (opts.verbose) {
            keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
          }
          if (propertyName)
            keyValues.push([E.propertyName, propertyName]);
        }
      })(errors);
      return errors;
    }
    var hasRequiredBoolSchema;
    function requireBoolSchema() {
      if (hasRequiredBoolSchema) return boolSchema;
      hasRequiredBoolSchema = 1;
      Object.defineProperty(boolSchema, "__esModule", { value: true });
      boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
      const errors_1 = requireErrors();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const boolError = {
        message: "boolean schema is false"
      };
      function topBoolOrEmptySchema(it) {
        const { gen, schema, validateName } = it;
        if (schema === false) {
          falseSchemaError(it, false);
        } else if (typeof schema == "object" && schema.$async === true) {
          gen.return(names_1.default.data);
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, null);
          gen.return(true);
        }
      }
      boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
      function boolOrEmptySchema(it, valid) {
        const { gen, schema } = it;
        if (schema === false) {
          gen.var(valid, false);
          falseSchemaError(it);
        } else {
          gen.var(valid, true);
        }
      }
      boolSchema.boolOrEmptySchema = boolOrEmptySchema;
      function falseSchemaError(it, overrideAllErrors) {
        const { gen, data } = it;
        const cxt = {
          gen,
          keyword: "false schema",
          data,
          schema: false,
          schemaCode: false,
          schemaValue: false,
          params: {},
          it
        };
        (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
      }
      return boolSchema;
    }
    var dataType = {};
    var rules = {};
    var hasRequiredRules;
    function requireRules() {
      if (hasRequiredRules) return rules;
      hasRequiredRules = 1;
      Object.defineProperty(rules, "__esModule", { value: true });
      rules.getRules = rules.isJSONType = void 0;
      const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
      const jsonTypes = new Set(_jsonTypes);
      function isJSONType(x) {
        return typeof x == "string" && jsonTypes.has(x);
      }
      rules.isJSONType = isJSONType;
      function getRules() {
        const groups = {
          number: { type: "number", rules: [] },
          string: { type: "string", rules: [] },
          array: { type: "array", rules: [] },
          object: { type: "object", rules: [] }
        };
        return {
          types: { ...groups, integer: true, boolean: true, null: true },
          rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
          post: { rules: [] },
          all: {},
          keywords: {}
        };
      }
      rules.getRules = getRules;
      return rules;
    }
    var applicability = {};
    var hasRequiredApplicability;
    function requireApplicability() {
      if (hasRequiredApplicability) return applicability;
      hasRequiredApplicability = 1;
      Object.defineProperty(applicability, "__esModule", { value: true });
      applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
      function schemaHasRulesForType({ schema, self: self2 }, type2) {
        const group = self2.RULES.types[type2];
        return group && group !== true && shouldUseGroup(schema, group);
      }
      applicability.schemaHasRulesForType = schemaHasRulesForType;
      function shouldUseGroup(schema, group) {
        return group.rules.some((rule) => shouldUseRule(schema, rule));
      }
      applicability.shouldUseGroup = shouldUseGroup;
      function shouldUseRule(schema, rule) {
        var _a;
        return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
      }
      applicability.shouldUseRule = shouldUseRule;
      return applicability;
    }
    var hasRequiredDataType;
    function requireDataType() {
      if (hasRequiredDataType) return dataType;
      hasRequiredDataType = 1;
      Object.defineProperty(dataType, "__esModule", { value: true });
      dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
      const rules_1 = requireRules();
      const applicability_1 = requireApplicability();
      const errors_1 = requireErrors();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      var DataType;
      (function(DataType2) {
        DataType2[DataType2["Correct"] = 0] = "Correct";
        DataType2[DataType2["Wrong"] = 1] = "Wrong";
      })(DataType || (dataType.DataType = DataType = {}));
      function getSchemaTypes(schema) {
        const types2 = getJSONTypes(schema.type);
        const hasNull = types2.includes("null");
        if (hasNull) {
          if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
        } else {
          if (!types2.length && schema.nullable !== void 0) {
            throw new Error('"nullable" cannot be used without "type"');
          }
          if (schema.nullable === true)
            types2.push("null");
        }
        return types2;
      }
      dataType.getSchemaTypes = getSchemaTypes;
      function getJSONTypes(ts) {
        const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
        if (types2.every(rules_1.isJSONType))
          return types2;
        throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
      }
      dataType.getJSONTypes = getJSONTypes;
      function coerceAndCheckDataType(it, types2) {
        const { gen, data, opts } = it;
        const coerceTo = coerceToTypes(types2, opts.coerceTypes);
        const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
        if (checkTypes) {
          const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
          gen.if(wrongType, () => {
            if (coerceTo.length)
              coerceData(it, types2, coerceTo);
            else
              reportTypeError(it);
          });
        }
        return checkTypes;
      }
      dataType.coerceAndCheckDataType = coerceAndCheckDataType;
      const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(types2, coerceTypes) {
        return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
      }
      function coerceData(it, types2, coerceTo) {
        const { gen, data, opts } = it;
        const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
        const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
        if (opts.coerceTypes === "array") {
          gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
        }
        gen.if((0, codegen_1._)`${coerced} !== undefined`);
        for (const t of coerceTo) {
          if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
            coerceSpecificType(t);
          }
        }
        gen.else();
        reportTypeError(it);
        gen.endIf();
        gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
          gen.assign(data, coerced);
          assignParentData(it, coerced);
        });
        function coerceSpecificType(t) {
          switch (t) {
            case "string":
              gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
              return;
            case "number":
              gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data} === null
                || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
              return;
            case "integer":
              gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data} === null
                || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
              return;
            case "boolean":
              gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
              return;
            case "null":
              gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
              gen.assign(coerced, null);
              return;
            case "array":
              gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
                || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
          }
        }
      }
      function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
      }
      function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
        const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
        let cond;
        switch (dataType2) {
          case "null":
            return (0, codegen_1._)`${data} ${EQ} null`;
          case "array":
            cond = (0, codegen_1._)`Array.isArray(${data})`;
            break;
          case "object":
            cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
          case "integer":
            cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
            break;
          case "number":
            cond = numCond();
            break;
          default:
            return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType2}`;
        }
        return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
        function numCond(_cond = codegen_1.nil) {
          return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
        }
      }
      dataType.checkDataType = checkDataType;
      function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
          return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        let cond;
        const types2 = (0, util_1.toHash)(dataTypes);
        if (types2.array && types2.object) {
          const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
          cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
          delete types2.null;
          delete types2.array;
          delete types2.object;
        } else {
          cond = codegen_1.nil;
        }
        if (types2.number)
          delete types2.integer;
        for (const t in types2)
          cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
        return cond;
      }
      dataType.checkDataTypes = checkDataTypes;
      const typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
      };
      function reportTypeError(it) {
        const cxt = getTypeErrorContext(it);
        (0, errors_1.reportError)(cxt, typeError);
      }
      dataType.reportTypeError = reportTypeError;
      function getTypeErrorContext(it) {
        const { gen, data, schema } = it;
        const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
        return {
          gen,
          keyword: "type",
          data,
          schema: schema.type,
          schemaCode,
          schemaValue: schemaCode,
          parentSchema: schema,
          params: {},
          it
        };
      }
      return dataType;
    }
    var defaults = {};
    var hasRequiredDefaults;
    function requireDefaults() {
      if (hasRequiredDefaults) return defaults;
      hasRequiredDefaults = 1;
      Object.defineProperty(defaults, "__esModule", { value: true });
      defaults.assignDefaults = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      function assignDefaults(it, ty) {
        const { properties: properties2, items: items2 } = it.schema;
        if (ty === "object" && properties2) {
          for (const key in properties2) {
            assignDefault(it, key, properties2[key].default);
          }
        } else if (ty === "array" && Array.isArray(items2)) {
          items2.forEach((sch, i) => assignDefault(it, i, sch.default));
        }
      }
      defaults.assignDefaults = assignDefaults;
      function assignDefault(it, prop, defaultValue) {
        const { gen, compositeRule, data, opts } = it;
        if (defaultValue === void 0)
          return;
        const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
        if (compositeRule) {
          (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
          return;
        }
        let condition = (0, codegen_1._)`${childData} === undefined`;
        if (opts.useDefaults === "empty") {
          condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
        }
        gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
      }
      return defaults;
    }
    var keyword = {};
    var code = {};
    var hasRequiredCode;
    function requireCode() {
      if (hasRequiredCode) return code;
      hasRequiredCode = 1;
      Object.defineProperty(code, "__esModule", { value: true });
      code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const names_1 = requireNames();
      const util_2 = requireUtil();
      function checkReportMissingProp(cxt, prop) {
        const { gen, data, it } = cxt;
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
          cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
          cxt.error();
        });
      }
      code.checkReportMissingProp = checkReportMissingProp;
      function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
        return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
      }
      code.checkMissingProp = checkMissingProp;
      function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true);
        cxt.error();
      }
      code.reportMissingProp = reportMissingProp;
      function hasPropFunc(gen) {
        return gen.scopeValue("func", {
          // eslint-disable-next-line @typescript-eslint/unbound-method
          ref: Object.prototype.hasOwnProperty,
          code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
        });
      }
      code.hasPropFunc = hasPropFunc;
      function isOwnProperty(gen, data, property) {
        return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
      }
      code.isOwnProperty = isOwnProperty;
      function propertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
        return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
      }
      code.propertyInData = propertyInData;
      function noPropertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
        return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
      }
      code.noPropertyInData = noPropertyInData;
      function allSchemaProperties(schemaMap) {
        return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
      }
      code.allSchemaProperties = allSchemaProperties;
      function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p2]));
      }
      code.schemaProperties = schemaProperties;
      function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
        const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
        const valCxt = [
          [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
          [names_1.default.parentData, it.parentData],
          [names_1.default.parentDataProperty, it.parentDataProperty],
          [names_1.default.rootData, names_1.default.rootData]
        ];
        if (it.opts.dynamicRef)
          valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
        const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
        return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
      }
      code.callValidateCode = callValidateCode;
      const newRegExp = (0, codegen_1._)`new RegExp`;
      function usePattern({ gen, it: { opts } }, pattern2) {
        const u = opts.unicodeRegExp ? "u" : "";
        const { regExp } = opts.code;
        const rx = regExp(pattern2, u);
        return gen.scopeValue("pattern", {
          key: rx.toString(),
          ref: rx,
          code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
        });
      }
      code.usePattern = usePattern;
      function validateArray(cxt) {
        const { gen, data, keyword: keyword2, it } = cxt;
        const valid = gen.name("valid");
        if (it.allErrors) {
          const validArr = gen.let("valid", true);
          validateItems(() => gen.assign(validArr, false));
          return validArr;
        }
        gen.var(valid, true);
        validateItems(() => gen.break());
        return valid;
        function validateItems(notValid) {
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: keyword2,
              dataProp: i,
              dataPropType: util_1.Type.Num
            }, valid);
            gen.if((0, codegen_1.not)(valid), notValid);
          });
        }
      }
      code.validateArray = validateArray;
      function validateUnion(cxt) {
        const { gen, schema, keyword: keyword2, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
        if (alwaysValid && !it.opts.unevaluated)
          return;
        const valid = gen.let("valid", false);
        const schValid = gen.name("_valid");
        gen.block(() => schema.forEach((_sch, i) => {
          const schCxt = cxt.subschema({
            keyword: keyword2,
            schemaProp: i,
            compositeRule: true
          }, schValid);
          gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
          const merged = cxt.mergeValidEvaluated(schCxt, schValid);
          if (!merged)
            gen.if((0, codegen_1.not)(valid));
        }));
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      }
      code.validateUnion = validateUnion;
      return code;
    }
    var hasRequiredKeyword;
    function requireKeyword() {
      if (hasRequiredKeyword) return keyword;
      hasRequiredKeyword = 1;
      Object.defineProperty(keyword, "__esModule", { value: true });
      keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const code_1 = requireCode();
      const errors_1 = requireErrors();
      function macroKeywordCode(cxt, def2) {
        const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
        const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
        const schemaRef = useKeyword(gen, keyword2, macroSchema);
        if (it.opts.validateSchema !== false)
          it.self.validateSchema(macroSchema, true);
        const valid = gen.name("valid");
        cxt.subschema({
          schema: macroSchema,
          schemaPath: codegen_1.nil,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
          topSchemaRef: schemaRef,
          compositeRule: true
        }, valid);
        cxt.pass(valid, () => cxt.error(true));
      }
      keyword.macroKeywordCode = macroKeywordCode;
      function funcKeywordCode(cxt, def2) {
        var _a;
        const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
        checkAsyncKeyword(it, def2);
        const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
        const validateRef = useKeyword(gen, keyword2, validate2);
        const valid = gen.let("valid");
        cxt.block$data(valid, validateKeyword);
        cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid);
        function validateKeyword() {
          if (def2.errors === false) {
            assignValid();
            if (def2.modifying)
              modifyData(cxt);
            reportErrs(() => cxt.error());
          } else {
            const ruleErrs = def2.async ? validateAsync() : validateSync();
            if (def2.modifying)
              modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
          }
        }
        function validateAsync() {
          const ruleErrs = gen.let("ruleErrs", null);
          gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
          return ruleErrs;
        }
        function validateSync() {
          const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
          gen.assign(validateErrs, null);
          assignValid(codegen_1.nil);
          return validateErrs;
        }
        function assignValid(_await = def2.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
          const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
          const passSchema = !("compile" in def2 && !$data || def2.schema === false);
          gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
        }
        function reportErrs(errors2) {
          var _a2;
          gen.if((0, codegen_1.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
        }
      }
      keyword.funcKeywordCode = funcKeywordCode;
      function modifyData(cxt) {
        const { gen, data, it } = cxt;
        gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
      }
      function addErrs(cxt, errs) {
        const { gen } = cxt;
        gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
          gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
          (0, errors_1.extendErrors)(cxt);
        }, () => cxt.error());
      }
      function checkAsyncKeyword({ schemaEnv }, def2) {
        if (def2.async && !schemaEnv.$async)
          throw new Error("async keyword in sync schema");
      }
      function useKeyword(gen, keyword2, result) {
        if (result === void 0)
          throw new Error(`keyword "${keyword2}" failed to compile`);
        return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
      }
      function validSchemaType(schema, schemaType, allowUndefined = false) {
        return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
      }
      keyword.validSchemaType = validSchemaType;
      function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
        if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
          throw new Error("ajv implementation error");
        }
        const deps = def2.dependencies;
        if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
          throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
        }
        if (def2.validateSchema) {
          const valid = def2.validateSchema(schema[keyword2]);
          if (!valid) {
            const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
            if (opts.validateSchema === "log")
              self2.logger.error(msg);
            else
              throw new Error(msg);
          }
        }
      }
      keyword.validateKeywordUsage = validateKeywordUsage;
      return keyword;
    }
    var subschema = {};
    var hasRequiredSubschema;
    function requireSubschema() {
      if (hasRequiredSubschema) return subschema;
      hasRequiredSubschema = 1;
      Object.defineProperty(subschema, "__esModule", { value: true });
      subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
        if (keyword2 !== void 0 && schema !== void 0) {
          throw new Error('both "keyword" and "schema" passed, only one allowed');
        }
        if (keyword2 !== void 0) {
          const sch = it.schema[keyword2];
          return schemaProp === void 0 ? {
            schema: sch,
            schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword2}`
          } : {
            schema: sch[schemaProp],
            schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
          };
        }
        if (schema !== void 0) {
          if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
          }
          return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath
          };
        }
        throw new Error('either "keyword" or "schema" must be passed');
      }
      subschema.getSubschema = getSubschema;
      function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
        if (data !== void 0 && dataProp !== void 0) {
          throw new Error('both "data" and "dataProp" passed, only one allowed');
        }
        const { gen } = it;
        if (dataProp !== void 0) {
          const { errorPath, dataPathArr, opts } = it;
          const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
          dataContextProps(nextData);
          subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
          subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
          subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
        }
        if (data !== void 0) {
          const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
          dataContextProps(nextData);
          if (propertyName !== void 0)
            subschema2.propertyName = propertyName;
        }
        if (dataTypes)
          subschema2.dataTypes = dataTypes;
        function dataContextProps(_nextData) {
          subschema2.data = _nextData;
          subschema2.dataLevel = it.dataLevel + 1;
          subschema2.dataTypes = [];
          it.definedProperties = /* @__PURE__ */ new Set();
          subschema2.parentData = it.data;
          subschema2.dataNames = [...it.dataNames, _nextData];
        }
      }
      subschema.extendSubschemaData = extendSubschemaData;
      function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
        if (compositeRule !== void 0)
          subschema2.compositeRule = compositeRule;
        if (createErrors !== void 0)
          subschema2.createErrors = createErrors;
        if (allErrors !== void 0)
          subschema2.allErrors = allErrors;
        subschema2.jtdDiscriminator = jtdDiscriminator;
        subschema2.jtdMetadata = jtdMetadata;
      }
      subschema.extendSubschemaMode = extendSubschemaMode;
      return subschema;
    }
    var resolve = {};
    var fastDeepEqual;
    var hasRequiredFastDeepEqual;
    function requireFastDeepEqual() {
      if (hasRequiredFastDeepEqual) return fastDeepEqual;
      hasRequiredFastDeepEqual = 1;
      fastDeepEqual = function equal2(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) return false;
          var length, i, keys;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for (i = length; i-- !== 0; )
              if (!equal2(a[i], b[i])) return false;
            return true;
          }
          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length) return false;
          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
          for (i = length; i-- !== 0; ) {
            var key = keys[i];
            if (!equal2(a[key], b[key])) return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
      return fastDeepEqual;
    }
    var jsonSchemaTraverse = { exports: {} };
    var hasRequiredJsonSchemaTraverse;
    function requireJsonSchemaTraverse() {
      if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
      hasRequiredJsonSchemaTraverse = 1;
      var traverse2 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
          cb = opts;
          opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {
        };
        var post = cb.post || function() {
        };
        _traverse(opts, pre, post, schema, "", schema);
      };
      traverse2.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
        if: true,
        then: true,
        else: true
      };
      traverse2.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      };
      traverse2.propsKeywords = {
        $defs: true,
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      };
      traverse2.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      };
      function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
          pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          for (var key in schema) {
            var sch = schema[key];
            if (Array.isArray(sch)) {
              if (key in traverse2.arrayKeywords) {
                for (var i = 0; i < sch.length; i++)
                  _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
              }
            } else if (key in traverse2.propsKeywords) {
              if (sch && typeof sch == "object") {
                for (var prop in sch)
                  _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
              }
            } else if (key in traverse2.keywords || opts.allKeys && !(key in traverse2.skipKeywords)) {
              _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
          }
          post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
      }
      function escapeJsonPtr(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      return jsonSchemaTraverse.exports;
    }
    var hasRequiredResolve;
    function requireResolve() {
      if (hasRequiredResolve) return resolve;
      hasRequiredResolve = 1;
      Object.defineProperty(resolve, "__esModule", { value: true });
      resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
      const util_1 = requireUtil();
      const equal2 = requireFastDeepEqual();
      const traverse2 = requireJsonSchemaTraverse();
      const SIMPLE_INLINED = /* @__PURE__ */ new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const"
      ]);
      function inlineRef(schema, limit2 = true) {
        if (typeof schema == "boolean")
          return true;
        if (limit2 === true)
          return !hasRef(schema);
        if (!limit2)
          return false;
        return countKeys(schema) <= limit2;
      }
      resolve.inlineRef = inlineRef;
      const REF_KEYWORDS = /* @__PURE__ */ new Set([
        "$ref",
        "$recursiveRef",
        "$recursiveAnchor",
        "$dynamicRef",
        "$dynamicAnchor"
      ]);
      function hasRef(schema) {
        for (const key in schema) {
          if (REF_KEYWORDS.has(key))
            return true;
          const sch = schema[key];
          if (Array.isArray(sch) && sch.some(hasRef))
            return true;
          if (typeof sch == "object" && hasRef(sch))
            return true;
        }
        return false;
      }
      function countKeys(schema) {
        let count = 0;
        for (const key in schema) {
          if (key === "$ref")
            return Infinity;
          count++;
          if (SIMPLE_INLINED.has(key))
            continue;
          if (typeof schema[key] == "object") {
            (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
          }
          if (count === Infinity)
            return Infinity;
        }
        return count;
      }
      function getFullPath(resolver, id2 = "", normalize) {
        if (normalize !== false)
          id2 = normalizeId(id2);
        const p2 = resolver.parse(id2);
        return _getFullPath(resolver, p2);
      }
      resolve.getFullPath = getFullPath;
      function _getFullPath(resolver, p2) {
        const serialized = resolver.serialize(p2);
        return serialized.split("#")[0] + "#";
      }
      resolve._getFullPath = _getFullPath;
      const TRAILING_SLASH_HASH = /#\/?$/;
      function normalizeId(id2) {
        return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
      }
      resolve.normalizeId = normalizeId;
      function resolveUrl(resolver, baseId, id2) {
        id2 = normalizeId(id2);
        return resolver.resolve(baseId, id2);
      }
      resolve.resolveUrl = resolveUrl;
      const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
      function getSchemaRefs(schema, baseId) {
        if (typeof schema == "boolean")
          return {};
        const { schemaId, uriResolver } = this.opts;
        const schId = normalizeId(schema[schemaId] || baseId);
        const baseIds = { "": schId };
        const pathPrefix = getFullPath(uriResolver, schId, false);
        const localRefs = {};
        const schemaRefs = /* @__PURE__ */ new Set();
        traverse2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
          if (parentJsonPtr === void 0)
            return;
          const fullPath = pathPrefix + jsonPtr;
          let innerBaseId = baseIds[parentJsonPtr];
          if (typeof sch[schemaId] == "string")
            innerBaseId = addRef.call(this, sch[schemaId]);
          addAnchor.call(this, sch.$anchor);
          addAnchor.call(this, sch.$dynamicAnchor);
          baseIds[jsonPtr] = innerBaseId;
          function addRef(ref2) {
            const _resolve = this.opts.uriResolver.resolve;
            ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
            if (schemaRefs.has(ref2))
              throw ambiguos(ref2);
            schemaRefs.add(ref2);
            let schOrRef = this.refs[ref2];
            if (typeof schOrRef == "string")
              schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
              checkAmbiguosRef(sch, schOrRef.schema, ref2);
            } else if (ref2 !== normalizeId(fullPath)) {
              if (ref2[0] === "#") {
                checkAmbiguosRef(sch, localRefs[ref2], ref2);
                localRefs[ref2] = sch;
              } else {
                this.refs[ref2] = fullPath;
              }
            }
            return ref2;
          }
          function addAnchor(anchor) {
            if (typeof anchor == "string") {
              if (!ANCHOR.test(anchor))
                throw new Error(`invalid anchor "${anchor}"`);
              addRef.call(this, `#${anchor}`);
            }
          }
        });
        return localRefs;
        function checkAmbiguosRef(sch1, sch2, ref2) {
          if (sch2 !== void 0 && !equal2(sch1, sch2))
            throw ambiguos(ref2);
        }
        function ambiguos(ref2) {
          return new Error(`reference "${ref2}" resolves to more than one schema`);
        }
      }
      resolve.getSchemaRefs = getSchemaRefs;
      return resolve;
    }
    var hasRequiredValidate;
    function requireValidate() {
      if (hasRequiredValidate) return validate;
      hasRequiredValidate = 1;
      Object.defineProperty(validate, "__esModule", { value: true });
      validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
      const boolSchema_1 = requireBoolSchema();
      const dataType_1 = requireDataType();
      const applicability_1 = requireApplicability();
      const dataType_2 = requireDataType();
      const defaults_1 = requireDefaults();
      const keyword_1 = requireKeyword();
      const subschema_1 = requireSubschema();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const resolve_1 = requireResolve();
      const util_1 = requireUtil();
      const errors_1 = requireErrors();
      function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
          }
        }
        validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
      }
      validate.validateFunctionCode = validateFunctionCode;
      function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
        if (opts.code.es5) {
          gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
          });
        } else {
          gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
        }
      }
      function destructureValCxt(opts) {
        return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
      }
      function destructureValCxtES5(gen, opts) {
        gen.if(names_1.default.valCxt, () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
          gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
          gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
        }, () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
          gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
          gen.var(names_1.default.rootData, names_1.default.data);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
        });
      }
      function topSchemaObjCode(it) {
        const { schema, opts, gen } = it;
        validateFunction(it, () => {
          if (opts.$comment && schema.$comment)
            commentKeyword(it);
          checkNoDefault(it);
          gen.let(names_1.default.vErrors, null);
          gen.let(names_1.default.errors, 0);
          if (opts.unevaluated)
            resetEvaluated(it);
          typeAndKeywords(it);
          returnResults(it);
        });
        return;
      }
      function resetEvaluated(it) {
        const { gen, validateName } = it;
        it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
      }
      function funcSourceUrl(schema, opts) {
        const schId = typeof schema == "object" && schema[opts.schemaId];
        return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
      }
      function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
          }
        }
        (0, boolSchema_1.boolOrEmptySchema)(it, valid);
      }
      function schemaCxtHasRules({ schema, self: self2 }) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (self2.RULES.all[key])
            return true;
        return false;
      }
      function isSchemaObj(it) {
        return typeof it.schema != "boolean";
      }
      function subSchemaObjCode(it, valid) {
        const { schema, gen, opts } = it;
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        updateContext(it);
        checkAsyncSchema(it);
        const errsCount = gen.const("_errs", names_1.default.errors);
        typeAndKeywords(it, errsCount);
        gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      }
      function checkKeywords(it) {
        (0, util_1.checkUnknownRules)(it);
        checkRefsAndKeywords(it);
      }
      function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd)
          return schemaKeywords(it, [], false, errsCount);
        const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
        const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
        schemaKeywords(it, types2, !checkedTypes, errsCount);
      }
      function checkRefsAndKeywords(it) {
        const { schema, errSchemaPath, opts, self: self2 } = it;
        if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
          self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
        }
      }
      function checkNoDefault(it) {
        const { schema, opts } = it;
        if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
          (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
        }
      }
      function updateContext(it) {
        const schId = it.schema[it.opts.schemaId];
        if (schId)
          it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
      }
      function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
          throw new Error("async schema in sync schema");
      }
      function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
        const msg = schema.$comment;
        if (opts.$comment === true) {
          gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
        } else if (typeof opts.$comment == "function") {
          const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
          const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
          gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
        }
      }
      function returnResults(it) {
        const { gen, schemaEnv, validateName, ValidationError, opts } = it;
        if (schemaEnv.$async) {
          gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
          if (opts.unevaluated)
            assignEvaluated(it);
          gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
        }
      }
      function assignEvaluated({ gen, evaluated, props, items: items2 }) {
        if (props instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.props`, props);
        if (items2 instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
      }
      function schemaKeywords(it, types2, typeErrors, errsCount) {
        const { gen, schema, data, allErrors, opts, self: self2 } = it;
        const { RULES } = self2;
        if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
          gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
          return;
        }
        if (!opts.jtd)
          checkStrictTypes(it, types2);
        gen.block(() => {
          for (const group of RULES.rules)
            groupKeywords(group);
          groupKeywords(RULES.post);
        });
        function groupKeywords(group) {
          if (!(0, applicability_1.shouldUseGroup)(schema, group))
            return;
          if (group.type) {
            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types2.length === 1 && types2[0] === group.type && typeErrors) {
              gen.else();
              (0, dataType_2.reportTypeError)(it);
            }
            gen.endIf();
          } else {
            iterateKeywords(it, group);
          }
          if (!allErrors)
            gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
        }
      }
      function iterateKeywords(it, group) {
        const { gen, schema, opts: { useDefaults } } = it;
        if (useDefaults)
          (0, defaults_1.assignDefaults)(it, group.type);
        gen.block(() => {
          for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
              keywordCode(it, rule.keyword, rule.definition, group.type);
            }
          }
        });
      }
      function checkStrictTypes(it, types2) {
        if (it.schemaEnv.meta || !it.opts.strictTypes)
          return;
        checkContextTypes(it, types2);
        if (!it.opts.allowUnionTypes)
          checkMultipleTypes(it, types2);
        checkKeywordTypes(it, it.dataTypes);
      }
      function checkContextTypes(it, types2) {
        if (!types2.length)
          return;
        if (!it.dataTypes.length) {
          it.dataTypes = types2;
          return;
        }
        types2.forEach((t) => {
          if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
          }
        });
        narrowSchemaTypes(it, types2);
      }
      function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
          strictTypesError(it, "use allowUnionTypes to allow union type keyword");
        }
      }
      function checkKeywordTypes(it, ts) {
        const rules2 = it.self.RULES.all;
        for (const keyword2 in rules2) {
          const rule = rules2[keyword2];
          if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
            const { type: type2 } = rule.definition;
            if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
              strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
            }
          }
        }
      }
      function hasApplicableType(schTs, kwdT) {
        return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
      }
      function includesType(ts, t) {
        return ts.includes(t) || t === "integer" && ts.includes("number");
      }
      function narrowSchemaTypes(it, withTypes) {
        const ts = [];
        for (const t of it.dataTypes) {
          if (includesType(withTypes, t))
            ts.push(t);
          else if (withTypes.includes("integer") && t === "number")
            ts.push("integer");
        }
        it.dataTypes = ts;
      }
      function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
        msg += ` at "${schemaPath}" (strictTypes)`;
        (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
      }
      class KeywordCxt {
        constructor(it, def2, keyword2) {
          (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
          this.gen = it.gen;
          this.allErrors = it.allErrors;
          this.keyword = keyword2;
          this.data = it.data;
          this.schema = it.schema[keyword2];
          this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
          this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
          this.schemaType = def2.schemaType;
          this.parentSchema = it.schema;
          this.params = {};
          this.it = it;
          this.def = def2;
          if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
          } else {
            this.schemaCode = this.schemaValue;
            if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
              throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
            }
          }
          if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
          }
        }
        result(condition, successAction, failAction) {
          this.failResult((0, codegen_1.not)(condition), successAction, failAction);
        }
        failResult(condition, successAction, failAction) {
          this.gen.if(condition);
          if (failAction)
            failAction();
          else
            this.error();
          if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
              this.gen.endIf();
          } else {
            if (this.allErrors)
              this.gen.endIf();
            else
              this.gen.else();
          }
        }
        pass(condition, failAction) {
          this.failResult((0, codegen_1.not)(condition), void 0, failAction);
        }
        fail(condition) {
          if (condition === void 0) {
            this.error();
            if (!this.allErrors)
              this.gen.if(false);
            return;
          }
          this.gen.if(condition);
          this.error();
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
        fail$data(condition) {
          if (!this.$data)
            return this.fail(condition);
          const { schemaCode } = this;
          this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
        }
        error(append, errorParams, errorPaths) {
          if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
          }
          this._error(append, errorPaths);
        }
        _error(append, errorPaths) {
          (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
        }
        $dataError() {
          (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
        }
        reset() {
          if (this.errsCount === void 0)
            throw new Error('add "trackErrors" to keyword definition');
          (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
        }
        ok(cond) {
          if (!this.allErrors)
            this.gen.if(cond);
        }
        setParams(obj, assign) {
          if (assign)
            Object.assign(this.params, obj);
          else
            this.params = obj;
        }
        block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
          this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
          });
        }
        check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
          if (!this.$data)
            return;
          const { gen, schemaCode, schemaType, def: def2 } = this;
          gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
          if (valid !== codegen_1.nil)
            gen.assign(valid, true);
          if (schemaType.length || def2.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
              gen.assign(valid, false);
          }
          gen.else();
        }
        invalid$data() {
          const { gen, schemaCode, schemaType, def: def2, it } = this;
          return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
          function wrong$DataType() {
            if (schemaType.length) {
              if (!(schemaCode instanceof codegen_1.Name))
                throw new Error("ajv implementation error");
              const st = Array.isArray(schemaType) ? schemaType : [schemaType];
              return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
            }
            return codegen_1.nil;
          }
          function invalid$DataSchema() {
            if (def2.validateSchema) {
              const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
              return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1.nil;
          }
        }
        subschema(appl, valid) {
          const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
          (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
          (0, subschema_1.extendSubschemaMode)(subschema2, appl);
          const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
          subschemaCode(nextContext, valid);
          return nextContext;
        }
        mergeEvaluated(schemaCxt, toName) {
          const { it, gen } = this;
          if (!it.opts.unevaluated)
            return;
          if (it.props !== true && schemaCxt.props !== void 0) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
          }
          if (it.items !== true && schemaCxt.items !== void 0) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
          }
        }
        mergeValidEvaluated(schemaCxt, valid) {
          const { it, gen } = this;
          if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
          }
        }
      }
      validate.KeywordCxt = KeywordCxt;
      function keywordCode(it, keyword2, def2, ruleType) {
        const cxt = new KeywordCxt(it, def2, keyword2);
        if ("code" in def2) {
          def2.code(cxt, ruleType);
        } else if (cxt.$data && def2.validate) {
          (0, keyword_1.funcKeywordCode)(cxt, def2);
        } else if ("macro" in def2) {
          (0, keyword_1.macroKeywordCode)(cxt, def2);
        } else if (def2.compile || def2.validate) {
          (0, keyword_1.funcKeywordCode)(cxt, def2);
        }
      }
      const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
      const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function getData($data, { dataLevel, dataNames, dataPathArr }) {
        let jsonPointer;
        let data;
        if ($data === "")
          return names_1.default.rootData;
        if ($data[0] === "/") {
          if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          jsonPointer = $data;
          data = names_1.default.rootData;
        } else {
          const matches = RELATIVE_JSON_POINTER.exec($data);
          if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          const up = +matches[1];
          jsonPointer = matches[2];
          if (jsonPointer === "#") {
            if (up >= dataLevel)
              throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
          }
          if (up > dataLevel)
            throw new Error(errorMsg("data", up));
          data = dataNames[dataLevel - up];
          if (!jsonPointer)
            return data;
        }
        let expr = data;
        const segments = jsonPointer.split("/");
        for (const segment of segments) {
          if (segment) {
            data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
            expr = (0, codegen_1._)`${expr} && ${data}`;
          }
        }
        return expr;
        function errorMsg(pointerType, up) {
          return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
        }
      }
      validate.getData = getData;
      return validate;
    }
    var validation_error = {};
    var hasRequiredValidation_error;
    function requireValidation_error() {
      if (hasRequiredValidation_error) return validation_error;
      hasRequiredValidation_error = 1;
      Object.defineProperty(validation_error, "__esModule", { value: true });
      class ValidationError extends Error {
        constructor(errors2) {
          super("validation failed");
          this.errors = errors2;
          this.ajv = this.validation = true;
        }
      }
      validation_error.default = ValidationError;
      return validation_error;
    }
    var ref_error = {};
    var hasRequiredRef_error;
    function requireRef_error() {
      if (hasRequiredRef_error) return ref_error;
      hasRequiredRef_error = 1;
      Object.defineProperty(ref_error, "__esModule", { value: true });
      const resolve_1 = requireResolve();
      class MissingRefError extends Error {
        constructor(resolver, baseId, ref2, msg) {
          super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
          this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
          this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
        }
      }
      ref_error.default = MissingRefError;
      return ref_error;
    }
    var compile = {};
    var hasRequiredCompile;
    function requireCompile() {
      if (hasRequiredCompile) return compile;
      hasRequiredCompile = 1;
      Object.defineProperty(compile, "__esModule", { value: true });
      compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
      const codegen_1 = requireCodegen();
      const validation_error_1 = requireValidation_error();
      const names_1 = requireNames();
      const resolve_1 = requireResolve();
      const util_1 = requireUtil();
      const validate_1 = requireValidate();
      class SchemaEnv {
        constructor(env) {
          var _a;
          this.refs = {};
          this.dynamicAnchors = {};
          let schema;
          if (typeof env.schema == "object")
            schema = env.schema;
          this.schema = env.schema;
          this.schemaId = env.schemaId;
          this.root = env.root || this;
          this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
          this.schemaPath = env.schemaPath;
          this.localRefs = env.localRefs;
          this.meta = env.meta;
          this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
          this.refs = {};
        }
      }
      compile.SchemaEnv = SchemaEnv;
      function compileSchema(sch) {
        const _sch = getCompilingSchema.call(this, sch);
        if (_sch)
          return _sch;
        const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
        const { es5, lines } = this.opts.code;
        const { ownProperties } = this.opts;
        const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
        let _ValidationError;
        if (sch.$async) {
          _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
          });
        }
        const validateName = gen.scopeName("validate");
        sch.validateName = validateName;
        const schemaCxt = {
          gen,
          allErrors: this.opts.allErrors,
          data: names_1.default.data,
          parentData: names_1.default.parentData,
          parentDataProperty: names_1.default.parentDataProperty,
          dataNames: [names_1.default.data],
          dataPathArr: [codegen_1.nil],
          // TODO can its length be used as dataLevel if nil is removed?
          dataLevel: 0,
          dataTypes: [],
          definedProperties: /* @__PURE__ */ new Set(),
          topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
          validateName,
          ValidationError: _ValidationError,
          schema: sch.schema,
          schemaEnv: sch,
          rootId,
          baseId: sch.baseId || rootId,
          schemaPath: codegen_1.nil,
          errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
          errorPath: (0, codegen_1._)`""`,
          opts: this.opts,
          self: this
        };
        let sourceCode;
        try {
          this._compilations.add(sch);
          (0, validate_1.validateFunctionCode)(schemaCxt);
          gen.optimize(this.opts.code.optimize);
          const validateCode = gen.toString();
          sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
          if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
          const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
          const validate2 = makeValidate(this, this.scope.get());
          this.scope.value(validateName, { ref: validate2 });
          validate2.errors = null;
          validate2.schema = sch.schema;
          validate2.schemaEnv = sch;
          if (sch.$async)
            validate2.$async = true;
          if (this.opts.code.source === true) {
            validate2.source = { validateName, validateCode, scopeValues: gen._values };
          }
          if (this.opts.unevaluated) {
            const { props, items: items2 } = schemaCxt;
            validate2.evaluated = {
              props: props instanceof codegen_1.Name ? void 0 : props,
              items: items2 instanceof codegen_1.Name ? void 0 : items2,
              dynamicProps: props instanceof codegen_1.Name,
              dynamicItems: items2 instanceof codegen_1.Name
            };
            if (validate2.source)
              validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
          }
          sch.validate = validate2;
          return sch;
        } catch (e) {
          delete sch.validate;
          delete sch.validateName;
          if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        } finally {
          this._compilations.delete(sch);
        }
      }
      compile.compileSchema = compileSchema;
      function resolveRef(root, baseId, ref2) {
        var _a;
        ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
        const schOrFunc = root.refs[ref2];
        if (schOrFunc)
          return schOrFunc;
        let _sch = resolve2.call(this, root, ref2);
        if (_sch === void 0) {
          const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
          const { schemaId } = this.opts;
          if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
        }
        if (_sch === void 0)
          return;
        return root.refs[ref2] = inlineOrCompile.call(this, _sch);
      }
      compile.resolveRef = resolveRef;
      function inlineOrCompile(sch) {
        if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
          return sch.schema;
        return sch.validate ? sch : compileSchema.call(this, sch);
      }
      function getCompilingSchema(schEnv) {
        for (const sch of this._compilations) {
          if (sameSchemaEnv(sch, schEnv))
            return sch;
        }
      }
      compile.getCompilingSchema = getCompilingSchema;
      function sameSchemaEnv(s1, s2) {
        return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
      }
      function resolve2(root, ref2) {
        let sch;
        while (typeof (sch = this.refs[ref2]) == "string")
          ref2 = sch;
        return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
      }
      function resolveSchema(root, ref2) {
        const p2 = this.opts.uriResolver.parse(ref2);
        const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
        let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
          return getJsonPointer.call(this, p2, root);
        }
        const id2 = (0, resolve_1.normalizeId)(refPath);
        const schOrRef = this.refs[id2] || this.schemas[id2];
        if (typeof schOrRef == "string") {
          const sch = resolveSchema.call(this, root, schOrRef);
          if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
          return getJsonPointer.call(this, p2, sch);
        }
        if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
          return;
        if (!schOrRef.validate)
          compileSchema.call(this, schOrRef);
        if (id2 === (0, resolve_1.normalizeId)(ref2)) {
          const { schema } = schOrRef;
          const { schemaId } = this.opts;
          const schId = schema[schemaId];
          if (schId)
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
          return new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p2, schOrRef);
      }
      compile.resolveSchema = resolveSchema;
      const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
        "properties",
        "patternProperties",
        "enum",
        "dependencies",
        "definitions"
      ]);
      function getJsonPointer(parsedRef, { baseId, schema, root }) {
        var _a;
        if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
          return;
        for (const part of parsedRef.fragment.slice(1).split("/")) {
          if (typeof schema === "boolean")
            return;
          const partSchema = schema[(0, util_1.unescapeFragment)(part)];
          if (partSchema === void 0)
            return;
          schema = partSchema;
          const schId = typeof schema === "object" && schema[this.opts.schemaId];
          if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
          }
        }
        let env;
        if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
          const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
          env = resolveSchema.call(this, root, $ref);
        }
        const { schemaId } = this.opts;
        env = env || new SchemaEnv({ schema, schemaId, root, baseId });
        if (env.schema !== env.root.schema)
          return env;
        return void 0;
      }
      return compile;
    }
    const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
    const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
    const type$1 = "object";
    const required$1 = ["$data"];
    const properties$2 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
    const additionalProperties$1 = false;
    const require$$9 = {
      $id: $id$1,
      description,
      type: type$1,
      required: required$1,
      properties: properties$2,
      additionalProperties: additionalProperties$1
    };
    var uri = {};
    var fastUri = { exports: {} };
    var scopedChars;
    var hasRequiredScopedChars;
    function requireScopedChars() {
      if (hasRequiredScopedChars) return scopedChars;
      hasRequiredScopedChars = 1;
      const HEX = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      };
      scopedChars = {
        HEX
      };
      return scopedChars;
    }
    var utils;
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils) return utils;
      hasRequiredUtils = 1;
      const { HEX } = requireScopedChars();
      const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
      function normalizeIPv4(host) {
        if (findToken(host, ".") < 3) {
          return { host, isIPV4: false };
        }
        const matches = host.match(IPV4_REG) || [];
        const [address] = matches;
        if (address) {
          return { host: stripLeadingZeros(address, "."), isIPV4: true };
        } else {
          return { host, isIPV4: false };
        }
      }
      function stringArrayToHexStripped(input, keepZero = false) {
        let acc = "";
        let strip = true;
        for (const c of input) {
          if (HEX[c] === void 0) return void 0;
          if (c !== "0" && strip === true) strip = false;
          if (!strip) acc += c;
        }
        if (keepZero && acc.length === 0) acc = "0";
        return acc;
      }
      function getIPV6(input) {
        let tokenCount = 0;
        const output = { error: false, address: "", zone: "" };
        const address = [];
        const buffer2 = [];
        let isZone = false;
        let endipv6Encountered = false;
        let endIpv6 = false;
        function consume() {
          if (buffer2.length) {
            if (isZone === false) {
              const hex = stringArrayToHexStripped(buffer2);
              if (hex !== void 0) {
                address.push(hex);
              } else {
                output.error = true;
                return false;
              }
            }
            buffer2.length = 0;
          }
          return true;
        }
        for (let i = 0; i < input.length; i++) {
          const cursor = input[i];
          if (cursor === "[" || cursor === "]") {
            continue;
          }
          if (cursor === ":") {
            if (endipv6Encountered === true) {
              endIpv6 = true;
            }
            if (!consume()) {
              break;
            }
            tokenCount++;
            address.push(":");
            if (tokenCount > 7) {
              output.error = true;
              break;
            }
            if (i - 1 >= 0 && input[i - 1] === ":") {
              endipv6Encountered = true;
            }
            continue;
          } else if (cursor === "%") {
            if (!consume()) {
              break;
            }
            isZone = true;
          } else {
            buffer2.push(cursor);
            continue;
          }
        }
        if (buffer2.length) {
          if (isZone) {
            output.zone = buffer2.join("");
          } else if (endIpv6) {
            address.push(buffer2.join(""));
          } else {
            address.push(stringArrayToHexStripped(buffer2));
          }
        }
        output.address = address.join("");
        return output;
      }
      function normalizeIPv6(host) {
        if (findToken(host, ":") < 2) {
          return { host, isIPV6: false };
        }
        const ipv6 = getIPV6(host);
        if (!ipv6.error) {
          let newHost = ipv6.address;
          let escapedHost = ipv6.address;
          if (ipv6.zone) {
            newHost += "%" + ipv6.zone;
            escapedHost += "%25" + ipv6.zone;
          }
          return { host: newHost, escapedHost, isIPV6: true };
        } else {
          return { host, isIPV6: false };
        }
      }
      function stripLeadingZeros(str, token) {
        let out = "";
        let skip = true;
        const l = str.length;
        for (let i = 0; i < l; i++) {
          const c = str[i];
          if (c === "0" && skip) {
            if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
              out += c;
              skip = false;
            }
          } else {
            if (c === token) {
              skip = true;
            } else {
              skip = false;
            }
            out += c;
          }
        }
        return out;
      }
      function findToken(str, token) {
        let ind = 0;
        for (let i = 0; i < str.length; i++) {
          if (str[i] === token) ind++;
        }
        return ind;
      }
      const RDS1 = /^\.\.?\//u;
      const RDS2 = /^\/\.(?:\/|$)/u;
      const RDS3 = /^\/\.\.(?:\/|$)/u;
      const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
      function removeDotSegments(input) {
        const output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            const im = input.match(RDS5);
            if (im) {
              const s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function normalizeComponentEncoding(components, esc) {
        const func = esc !== true ? escape : unescape;
        if (components.scheme !== void 0) {
          components.scheme = func(components.scheme);
        }
        if (components.userinfo !== void 0) {
          components.userinfo = func(components.userinfo);
        }
        if (components.host !== void 0) {
          components.host = func(components.host);
        }
        if (components.path !== void 0) {
          components.path = func(components.path);
        }
        if (components.query !== void 0) {
          components.query = func(components.query);
        }
        if (components.fragment !== void 0) {
          components.fragment = func(components.fragment);
        }
        return components;
      }
      function recomposeAuthority(components) {
        const uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          let host = unescape(components.host);
          const ipV4res = normalizeIPv4(host);
          if (ipV4res.isIPV4) {
            host = ipV4res.host;
          } else {
            const ipV6res = normalizeIPv6(ipV4res.host);
            if (ipV6res.isIPV6 === true) {
              host = `[${ipV6res.escapedHost}]`;
            } else {
              host = components.host;
            }
          }
          uriTokens.push(host);
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      utils = {
        recomposeAuthority,
        normalizeComponentEncoding,
        removeDotSegments,
        normalizeIPv4,
        normalizeIPv6,
        stringArrayToHexStripped
      };
      return utils;
    }
    var schemes;
    var hasRequiredSchemes;
    function requireSchemes() {
      if (hasRequiredSchemes) return schemes;
      hasRequiredSchemes = 1;
      const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
      const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      function httpParse(components) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      }
      function httpSerialize(components) {
        const secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
      function wsParse(wsComponents) {
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      }
      function wsSerialize(wsComponents) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          const [path, query] = wsComponents.resourceName.split("?");
          wsComponents.path = path && path !== "/" ? path : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
      function urnParse(urnComponents, options) {
        if (!urnComponents.path) {
          urnComponents.error = "URN can not be parsed";
          return urnComponents;
        }
        const matches = urnComponents.path.match(URN_REG);
        if (matches) {
          const scheme = options.scheme || urnComponents.scheme || "urn";
          urnComponents.nid = matches[1].toLowerCase();
          urnComponents.nss = matches[2];
          const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
          const schemeHandler = SCHEMES[urnScheme];
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      }
      function urnSerialize(urnComponents, options) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        const nid = urnComponents.nid.toLowerCase();
        const urnScheme = `${scheme}:${options.nid || nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        const uriComponents = urnComponents;
        const nss = urnComponents.nss;
        uriComponents.path = `${nid || options.nid}:${nss}`;
        options.skipEscape = true;
        return uriComponents;
      }
      function urnuuidParse(urnComponents, options) {
        const uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      }
      function urnuuidSerialize(uuidComponents) {
        const urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
      const http = {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      };
      const https = {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      };
      const ws = {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      };
      const wss = {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      };
      const urn = {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      };
      const urnuuid = {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      };
      const SCHEMES = {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      };
      schemes = SCHEMES;
      return schemes;
    }
    var hasRequiredFastUri;
    function requireFastUri() {
      if (hasRequiredFastUri) return fastUri.exports;
      hasRequiredFastUri = 1;
      const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils();
      const SCHEMES = requireSchemes();
      function normalize(uri2, options) {
        if (typeof uri2 === "string") {
          uri2 = serialize(parse(uri2, options), options);
        } else if (typeof uri2 === "object") {
          uri2 = parse(serialize(uri2, options), options);
        }
        return uri2;
      }
      function resolve2(baseURI, relativeURI, options) {
        const schemelessOptions = Object.assign({ scheme: "null" }, options);
        const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
        return serialize(resolved, { ...schemelessOptions, skipEscape: true });
      }
      function resolveComponents(base, relative, options, skipNormalization) {
        const target = {};
        if (!skipNormalization) {
          base = parse(serialize(base, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                  target.path = "/" + relative.path;
                } else if (!base.path) {
                  target.path = relative.path;
                } else {
                  target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
          }
          target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function equal2(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = unescape(uriA);
          uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
        } else if (typeof uriA === "object") {
          uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
        }
        if (typeof uriB === "string") {
          uriB = unescape(uriB);
          uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
        } else if (typeof uriB === "object") {
          uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
        }
        return uriA.toLowerCase() === uriB.toLowerCase();
      }
      function serialize(cmpts, opts) {
        const components = {
          host: cmpts.host,
          scheme: cmpts.scheme,
          userinfo: cmpts.userinfo,
          port: cmpts.port,
          path: cmpts.path,
          query: cmpts.query,
          nid: cmpts.nid,
          nss: cmpts.nss,
          uuid: cmpts.uuid,
          fragment: cmpts.fragment,
          reference: cmpts.reference,
          resourceName: cmpts.resourceName,
          secure: cmpts.secure,
          error: ""
        };
        const options = Object.assign({}, opts);
        const uriTokens = [];
        const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.path !== void 0) {
          if (!options.skipEscape) {
            components.path = escape(components.path);
            if (components.scheme !== void 0) {
              components.path = components.path.split("%3A").join(":");
            }
          } else {
            components.path = unescape(components.path);
          }
        }
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme, ":");
        }
        const authority = recomposeAuthority(components);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          let s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//u, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?", components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#", components.fragment);
        }
        return uriTokens.join("");
      }
      const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
      function nonSimpleDomain(value) {
        let code2 = 0;
        for (let i = 0, len = value.length; i < len; ++i) {
          code2 = value.charCodeAt(i);
          if (code2 > 126 || hexLookUp[code2]) {
            return true;
          }
        }
        return false;
      }
      const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
      function parse(uri2, opts) {
        const options = Object.assign({}, opts);
        const parsed = {
          scheme: void 0,
          userinfo: void 0,
          host: "",
          port: void 0,
          path: "",
          query: void 0,
          fragment: void 0
        };
        const gotEncoding = uri2.indexOf("%") !== -1;
        let isIP = false;
        if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
        const matches = uri2.match(URI_PARSE);
        if (matches) {
          parsed.scheme = matches[1];
          parsed.userinfo = matches[3];
          parsed.host = matches[4];
          parsed.port = parseInt(matches[5], 10);
          parsed.path = matches[6] || "";
          parsed.query = matches[7];
          parsed.fragment = matches[8];
          if (isNaN(parsed.port)) {
            parsed.port = matches[5];
          }
          if (parsed.host) {
            const ipv4result = normalizeIPv4(parsed.host);
            if (ipv4result.isIPV4 === false) {
              const ipv6result = normalizeIPv6(ipv4result.host);
              parsed.host = ipv6result.host.toLowerCase();
              isIP = ipv6result.isIPV6;
            } else {
              parsed.host = ipv4result.host;
              isIP = true;
            }
          }
          if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
            parsed.reference = "same-document";
          } else if (parsed.scheme === void 0) {
            parsed.reference = "relative";
          } else if (parsed.fragment === void 0) {
            parsed.reference = "absolute";
          } else {
            parsed.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
            parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
          }
          const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
              try {
                parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
              } catch (e) {
                parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
              }
            }
          }
          if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
            if (gotEncoding && parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (gotEncoding && parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
            if (parsed.path) {
              parsed.path = escape(unescape(parsed.path));
            }
            if (parsed.fragment) {
              parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
            }
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(parsed, options);
          }
        } else {
          parsed.error = parsed.error || "URI can not be parsed.";
        }
        return parsed;
      }
      const fastUri$1 = {
        SCHEMES,
        normalize,
        resolve: resolve2,
        resolveComponents,
        equal: equal2,
        serialize,
        parse
      };
      fastUri.exports = fastUri$1;
      fastUri.exports.default = fastUri$1;
      fastUri.exports.fastUri = fastUri$1;
      return fastUri.exports;
    }
    var hasRequiredUri;
    function requireUri() {
      if (hasRequiredUri) return uri;
      hasRequiredUri = 1;
      Object.defineProperty(uri, "__esModule", { value: true });
      const uri$1 = requireFastUri();
      uri$1.code = 'require("ajv/dist/runtime/uri").default';
      uri.default = uri$1;
      return uri;
    }
    var hasRequiredCore$1;
    function requireCore$1() {
      if (hasRequiredCore$1) return core$1;
      hasRequiredCore$1 = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
        var validate_1 = requireValidate();
        Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
          return validate_1.KeywordCxt;
        } });
        var codegen_1 = requireCodegen();
        Object.defineProperty(exports, "_", { enumerable: true, get: function() {
          return codegen_1._;
        } });
        Object.defineProperty(exports, "str", { enumerable: true, get: function() {
          return codegen_1.str;
        } });
        Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
          return codegen_1.stringify;
        } });
        Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
          return codegen_1.nil;
        } });
        Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
          return codegen_1.Name;
        } });
        Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
          return codegen_1.CodeGen;
        } });
        const validation_error_1 = requireValidation_error();
        const ref_error_1 = requireRef_error();
        const rules_1 = requireRules();
        const compile_1 = requireCompile();
        const codegen_2 = requireCodegen();
        const resolve_1 = requireResolve();
        const dataType_1 = requireDataType();
        const util_1 = requireUtil();
        const $dataRefSchema = require$$9;
        const uri_1 = requireUri();
        const defaultRegExp = (str, flags) => new RegExp(str, flags);
        defaultRegExp.code = "new RegExp";
        const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
        const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
          "validate",
          "serialize",
          "parse",
          "wrapper",
          "root",
          "schema",
          "keyword",
          "pattern",
          "formats",
          "validate$data",
          "func",
          "obj",
          "Error"
        ]);
        const removedOptions = {
          errorDataPath: "",
          format: "`validateFormats: false` can be used instead.",
          nullable: '"nullable" keyword is supported by default.',
          jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
          extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
          missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
          processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
          sourceCode: "Use option `code: {source: true}`",
          strictDefaults: "It is default now, see option `strict`.",
          strictKeywords: "It is default now, see option `strict`.",
          uniqueItems: '"uniqueItems" keyword is always validated.',
          unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
          cache: "Map is used as cache, schema object as key.",
          serialize: "Map is used as cache, schema object as key.",
          ajvErrors: "It is default now."
        };
        const deprecatedOptions = {
          ignoreKeywordsWithRef: "",
          jsPropertySyntax: "",
          unicode: '"minLength"/"maxLength" account for unicode characters by default.'
        };
        const MAX_EXPRESSION = 200;
        function requiredOptions(o) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
          const s = o.strict;
          const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
          const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
          const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
          const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
          return {
            strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
            strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
            strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
            strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
            strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
            code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
            loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
            loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
            meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
            messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
            inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
            schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
            addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
            validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
            validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
            unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
            int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
            uriResolver
          };
        }
        class Ajv2 {
          constructor(opts = {}) {
            this.schemas = {};
            this.refs = {};
            this.formats = {};
            this._compilations = /* @__PURE__ */ new Set();
            this._loading = {};
            this._cache = /* @__PURE__ */ new Map();
            opts = this.opts = { ...opts, ...requiredOptions(opts) };
            const { es5, lines } = this.opts.code;
            this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
            this.logger = getLogger(opts.logger);
            const formatOpt = opts.validateFormats;
            opts.validateFormats = false;
            this.RULES = (0, rules_1.getRules)();
            checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
            checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
            this._metaOpts = getMetaSchemaOptions.call(this);
            if (opts.formats)
              addInitialFormats.call(this);
            this._addVocabularies();
            this._addDefaultMetaSchema();
            if (opts.keywords)
              addInitialKeywords.call(this, opts.keywords);
            if (typeof opts.meta == "object")
              this.addMetaSchema(opts.meta);
            addInitialSchemas.call(this);
            opts.validateFormats = formatOpt;
          }
          _addVocabularies() {
            this.addKeyword("$async");
          }
          _addDefaultMetaSchema() {
            const { $data, meta, schemaId } = this.opts;
            let _dataRefSchema = $dataRefSchema;
            if (schemaId === "id") {
              _dataRefSchema = { ...$dataRefSchema };
              _dataRefSchema.id = _dataRefSchema.$id;
              delete _dataRefSchema.$id;
            }
            if (meta && $data)
              this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
          }
          defaultMeta() {
            const { meta, schemaId } = this.opts;
            return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
          }
          validate(schemaKeyRef, data) {
            let v;
            if (typeof schemaKeyRef == "string") {
              v = this.getSchema(schemaKeyRef);
              if (!v)
                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
            } else {
              v = this.compile(schemaKeyRef);
            }
            const valid = v(data);
            if (!("$async" in v))
              this.errors = v.errors;
            return valid;
          }
          compile(schema, _meta) {
            const sch = this._addSchema(schema, _meta);
            return sch.validate || this._compileSchemaEnv(sch);
          }
          compileAsync(schema, meta) {
            if (typeof this.opts.loadSchema != "function") {
              throw new Error("options.loadSchema should be a function");
            }
            const { loadSchema } = this.opts;
            return runCompileAsync.call(this, schema, meta);
            async function runCompileAsync(_schema, _meta) {
              await loadMetaSchema.call(this, _schema.$schema);
              const sch = this._addSchema(_schema, _meta);
              return sch.validate || _compileAsync.call(this, sch);
            }
            async function loadMetaSchema($ref) {
              if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
              }
            }
            async function _compileAsync(sch) {
              try {
                return this._compileSchemaEnv(sch);
              } catch (e) {
                if (!(e instanceof ref_error_1.default))
                  throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
              }
            }
            function checkLoaded({ missingSchema: ref2, missingRef }) {
              if (this.refs[ref2]) {
                throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
              }
            }
            async function loadMissingSchema(ref2) {
              const _schema = await _loadSchema.call(this, ref2);
              if (!this.refs[ref2])
                await loadMetaSchema.call(this, _schema.$schema);
              if (!this.refs[ref2])
                this.addSchema(_schema, ref2, meta);
            }
            async function _loadSchema(ref2) {
              const p2 = this._loading[ref2];
              if (p2)
                return p2;
              try {
                return await (this._loading[ref2] = loadSchema(ref2));
              } finally {
                delete this._loading[ref2];
              }
            }
          }
          // Adds schema to the instance
          addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
            if (Array.isArray(schema)) {
              for (const sch of schema)
                this.addSchema(sch, void 0, _meta, _validateSchema);
              return this;
            }
            let id2;
            if (typeof schema === "object") {
              const { schemaId } = this.opts;
              id2 = schema[schemaId];
              if (id2 !== void 0 && typeof id2 != "string") {
                throw new Error(`schema ${schemaId} must be string`);
              }
            }
            key = (0, resolve_1.normalizeId)(key || id2);
            this._checkUnique(key);
            this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
            return this;
          }
          // Add schema that will be used to validate other schemas
          // options in META_IGNORE_OPTIONS are alway set to false
          addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
            this.addSchema(schema, key, true, _validateSchema);
            return this;
          }
          //  Validate schema against its meta-schema
          validateSchema(schema, throwOrLogError) {
            if (typeof schema == "boolean")
              return true;
            let $schema2;
            $schema2 = schema.$schema;
            if ($schema2 !== void 0 && typeof $schema2 != "string") {
              throw new Error("$schema must be a string");
            }
            $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
            if (!$schema2) {
              this.logger.warn("meta-schema not available");
              this.errors = null;
              return true;
            }
            const valid = this.validate($schema2, schema);
            if (!valid && throwOrLogError) {
              const message = "schema is invalid: " + this.errorsText();
              if (this.opts.validateSchema === "log")
                this.logger.error(message);
              else
                throw new Error(message);
            }
            return valid;
          }
          // Get compiled schema by `key` or `ref`.
          // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
          getSchema(keyRef) {
            let sch;
            while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
              keyRef = sch;
            if (sch === void 0) {
              const { schemaId } = this.opts;
              const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
              sch = compile_1.resolveSchema.call(this, root, keyRef);
              if (!sch)
                return;
              this.refs[keyRef] = sch;
            }
            return sch.validate || this._compileSchemaEnv(sch);
          }
          // Remove cached schema(s).
          // If no parameter is passed all schemas but meta-schemas are removed.
          // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
          // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
          removeSchema(schemaKeyRef) {
            if (schemaKeyRef instanceof RegExp) {
              this._removeAllSchemas(this.schemas, schemaKeyRef);
              this._removeAllSchemas(this.refs, schemaKeyRef);
              return this;
            }
            switch (typeof schemaKeyRef) {
              case "undefined":
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
              case "string": {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == "object")
                  this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
              }
              case "object": {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id2 = schemaKeyRef[this.opts.schemaId];
                if (id2) {
                  id2 = (0, resolve_1.normalizeId)(id2);
                  delete this.schemas[id2];
                  delete this.refs[id2];
                }
                return this;
              }
              default:
                throw new Error("ajv.removeSchema: invalid parameter");
            }
          }
          // add "vocabulary" - a collection of keywords
          addVocabulary(definitions2) {
            for (const def2 of definitions2)
              this.addKeyword(def2);
            return this;
          }
          addKeyword(kwdOrDef, def2) {
            let keyword2;
            if (typeof kwdOrDef == "string") {
              keyword2 = kwdOrDef;
              if (typeof def2 == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def2.keyword = keyword2;
              }
            } else if (typeof kwdOrDef == "object" && def2 === void 0) {
              def2 = kwdOrDef;
              keyword2 = def2.keyword;
              if (Array.isArray(keyword2) && !keyword2.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
              }
            } else {
              throw new Error("invalid addKeywords parameters");
            }
            checkKeyword.call(this, keyword2, def2);
            if (!def2) {
              (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
              return this;
            }
            keywordMetaschema.call(this, def2);
            const definition = {
              ...def2,
              type: (0, dataType_1.getJSONTypes)(def2.type),
              schemaType: (0, dataType_1.getJSONTypes)(def2.schemaType)
            };
            (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
            return this;
          }
          getKeyword(keyword2) {
            const rule = this.RULES.all[keyword2];
            return typeof rule == "object" ? rule.definition : !!rule;
          }
          // Remove keyword
          removeKeyword(keyword2) {
            const { RULES } = this;
            delete RULES.keywords[keyword2];
            delete RULES.all[keyword2];
            for (const group of RULES.rules) {
              const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
              if (i >= 0)
                group.rules.splice(i, 1);
            }
            return this;
          }
          // Add format
          addFormat(name, format2) {
            if (typeof format2 == "string")
              format2 = new RegExp(format2);
            this.formats[name] = format2;
            return this;
          }
          errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
            if (!errors2 || errors2.length === 0)
              return "No errors";
            return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
          }
          $dataMetaSchema(metaSchema, keywordsJsonPointers) {
            const rules2 = this.RULES.all;
            metaSchema = JSON.parse(JSON.stringify(metaSchema));
            for (const jsonPointer of keywordsJsonPointers) {
              const segments = jsonPointer.split("/").slice(1);
              let keywords = metaSchema;
              for (const seg of segments)
                keywords = keywords[seg];
              for (const key in rules2) {
                const rule = rules2[key];
                if (typeof rule != "object")
                  continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema)
                  keywords[key] = schemaOrData(schema);
              }
            }
            return metaSchema;
          }
          _removeAllSchemas(schemas, regex) {
            for (const keyRef in schemas) {
              const sch = schemas[keyRef];
              if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                  delete schemas[keyRef];
                } else if (sch && !sch.meta) {
                  this._cache.delete(sch.schema);
                  delete schemas[keyRef];
                }
              }
            }
          }
          _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
            let id2;
            const { schemaId } = this.opts;
            if (typeof schema == "object") {
              id2 = schema[schemaId];
            } else {
              if (this.opts.jtd)
                throw new Error("schema must be object");
              else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
            }
            let sch = this._cache.get(schema);
            if (sch !== void 0)
              return sch;
            baseId = (0, resolve_1.normalizeId)(id2 || baseId);
            const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
            sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
            this._cache.set(sch.schema, sch);
            if (addSchema && !baseId.startsWith("#")) {
              if (baseId)
                this._checkUnique(baseId);
              this.refs[baseId] = sch;
            }
            if (validateSchema)
              this.validateSchema(schema, true);
            return sch;
          }
          _checkUnique(id2) {
            if (this.schemas[id2] || this.refs[id2]) {
              throw new Error(`schema with key or id "${id2}" already exists`);
            }
          }
          _compileSchemaEnv(sch) {
            if (sch.meta)
              this._compileMetaSchema(sch);
            else
              compile_1.compileSchema.call(this, sch);
            if (!sch.validate)
              throw new Error("ajv implementation error");
            return sch.validate;
          }
          _compileMetaSchema(sch) {
            const currentOpts = this.opts;
            this.opts = this._metaOpts;
            try {
              compile_1.compileSchema.call(this, sch);
            } finally {
              this.opts = currentOpts;
            }
          }
        }
        Ajv2.ValidationError = validation_error_1.default;
        Ajv2.MissingRefError = ref_error_1.default;
        exports.default = Ajv2;
        function checkOptions(checkOpts, options, msg, log = "error") {
          for (const key in checkOpts) {
            const opt = key;
            if (opt in options)
              this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
          }
        }
        function getSchEnv(keyRef) {
          keyRef = (0, resolve_1.normalizeId)(keyRef);
          return this.schemas[keyRef] || this.refs[keyRef];
        }
        function addInitialSchemas() {
          const optsSchemas = this.opts.schemas;
          if (!optsSchemas)
            return;
          if (Array.isArray(optsSchemas))
            this.addSchema(optsSchemas);
          else
            for (const key in optsSchemas)
              this.addSchema(optsSchemas[key], key);
        }
        function addInitialFormats() {
          for (const name in this.opts.formats) {
            const format2 = this.opts.formats[name];
            if (format2)
              this.addFormat(name, format2);
          }
        }
        function addInitialKeywords(defs) {
          if (Array.isArray(defs)) {
            this.addVocabulary(defs);
            return;
          }
          this.logger.warn("keywords option as map is deprecated, pass array");
          for (const keyword2 in defs) {
            const def2 = defs[keyword2];
            if (!def2.keyword)
              def2.keyword = keyword2;
            this.addKeyword(def2);
          }
        }
        function getMetaSchemaOptions() {
          const metaOpts = { ...this.opts };
          for (const opt of META_IGNORE_OPTIONS)
            delete metaOpts[opt];
          return metaOpts;
        }
        const noLogs = { log() {
        }, warn() {
        }, error() {
        } };
        function getLogger(logger) {
          if (logger === false)
            return noLogs;
          if (logger === void 0)
            return console;
          if (logger.log && logger.warn && logger.error)
            return logger;
          throw new Error("logger must implement log, warn and error methods");
        }
        const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
        function checkKeyword(keyword2, def2) {
          const { RULES } = this;
          (0, util_1.eachItem)(keyword2, (kwd) => {
            if (RULES.keywords[kwd])
              throw new Error(`Keyword ${kwd} is already defined`);
            if (!KEYWORD_NAME.test(kwd))
              throw new Error(`Keyword ${kwd} has invalid name`);
          });
          if (!def2)
            return;
          if (def2.$data && !("code" in def2 || "validate" in def2)) {
            throw new Error('$data keyword must have "code" or "validate" function');
          }
        }
        function addRule(keyword2, definition, dataType2) {
          var _a;
          const post = definition === null || definition === void 0 ? void 0 : definition.post;
          if (dataType2 && post)
            throw new Error('keyword with "post" flag cannot have "type"');
          const { RULES } = this;
          let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
          if (!ruleGroup) {
            ruleGroup = { type: dataType2, rules: [] };
            RULES.rules.push(ruleGroup);
          }
          RULES.keywords[keyword2] = true;
          if (!definition)
            return;
          const rule = {
            keyword: keyword2,
            definition: {
              ...definition,
              type: (0, dataType_1.getJSONTypes)(definition.type),
              schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
            }
          };
          if (definition.before)
            addBeforeRule.call(this, ruleGroup, rule, definition.before);
          else
            ruleGroup.rules.push(rule);
          RULES.all[keyword2] = rule;
          (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
        }
        function addBeforeRule(ruleGroup, rule, before) {
          const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
          if (i >= 0) {
            ruleGroup.rules.splice(i, 0, rule);
          } else {
            ruleGroup.rules.push(rule);
            this.logger.warn(`rule ${before} is not defined`);
          }
        }
        function keywordMetaschema(def2) {
          let { metaSchema } = def2;
          if (metaSchema === void 0)
            return;
          if (def2.$data && this.opts.$data)
            metaSchema = schemaOrData(metaSchema);
          def2.validateSchema = this.compile(metaSchema, true);
        }
        const $dataRef = {
          $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
        };
        function schemaOrData(schema) {
          return { anyOf: [schema, $dataRef] };
        }
      })(core$1);
      return core$1;
    }
    var draft7 = {};
    var core = {};
    var id = {};
    var hasRequiredId;
    function requireId() {
      if (hasRequiredId) return id;
      hasRequiredId = 1;
      Object.defineProperty(id, "__esModule", { value: true });
      const def2 = {
        keyword: "id",
        code() {
          throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
        }
      };
      id.default = def2;
      return id;
    }
    var ref = {};
    var hasRequiredRef;
    function requireRef() {
      if (hasRequiredRef) return ref;
      hasRequiredRef = 1;
      Object.defineProperty(ref, "__esModule", { value: true });
      ref.callRef = ref.getValidate = void 0;
      const ref_error_1 = requireRef_error();
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const compile_1 = requireCompile();
      const util_1 = requireUtil();
      const def2 = {
        keyword: "$ref",
        schemaType: "string",
        code(cxt) {
          const { gen, schema: $ref, it } = cxt;
          const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
          const { root } = env;
          if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
          const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
          if (schOrEnv === void 0)
            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
          if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
          return inlineRefSchema(schOrEnv);
          function callRootRef() {
            if (env === root)
              return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
          }
          function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
          }
          function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
              schema: sch,
              dataTypes: [],
              schemaPath: codegen_1.nil,
              topSchemaRef: schName,
              errSchemaPath: $ref
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
          }
        }
      };
      function getValidate(cxt, sch) {
        const { gen } = cxt;
        return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
      }
      ref.getValidate = getValidate;
      function callRef(cxt, v, sch, $async) {
        const { gen, it } = cxt;
        const { allErrors, schemaEnv: env, opts } = it;
        const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
        if ($async)
          callAsyncRef();
        else
          callSyncRef();
        function callAsyncRef() {
          if (!env.$async)
            throw new Error("async schema referenced by sync schema");
          const valid = gen.let("valid");
          gen.try(() => {
            gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v);
            if (!allErrors)
              gen.assign(valid, true);
          }, (e) => {
            gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
              gen.assign(valid, false);
          });
          cxt.ok(valid);
        }
        function callSyncRef() {
          cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
        }
        function addErrorsFrom(source) {
          const errs = (0, codegen_1._)`${source}.errors`;
          gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
          gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        }
        function addEvaluatedFrom(source) {
          var _a;
          if (!it.opts.unevaluated)
            return;
          const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
          if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
              if (schEvaluated.props !== void 0) {
                it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
              }
            } else {
              const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
              it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
          }
          if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
              if (schEvaluated.items !== void 0) {
                it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
              }
            } else {
              const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
              it.items = util_1.mergeEvaluated.items(gen, items2, it.items, codegen_1.Name);
            }
          }
        }
      }
      ref.callRef = callRef;
      ref.default = def2;
      return ref;
    }
    var hasRequiredCore;
    function requireCore() {
      if (hasRequiredCore) return core;
      hasRequiredCore = 1;
      Object.defineProperty(core, "__esModule", { value: true });
      const id_1 = requireId();
      const ref_1 = requireRef();
      const core$12 = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        id_1.default,
        ref_1.default
      ];
      core.default = core$12;
      return core;
    }
    var validation = {};
    var limitNumber = {};
    var hasRequiredLimitNumber;
    function requireLimitNumber() {
      if (hasRequiredLimitNumber) return limitNumber;
      hasRequiredLimitNumber = 1;
      Object.defineProperty(limitNumber, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const ops = codegen_1.operators;
      const KWDs = {
        maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      const error = {
        message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: Object.keys(KWDs),
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode } = cxt;
          cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
        }
      };
      limitNumber.default = def2;
      return limitNumber;
    }
    var multipleOf = {};
    var hasRequiredMultipleOf;
    function requireMultipleOf() {
      if (hasRequiredMultipleOf) return multipleOf;
      hasRequiredMultipleOf = 1;
      Object.defineProperty(multipleOf, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
        params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
      };
      const def2 = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, it } = cxt;
          const prec = it.opts.multipleOfPrecision;
          const res = gen.let("res");
          const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
          cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
        }
      };
      multipleOf.default = def2;
      return multipleOf;
    }
    var limitLength = {};
    var ucs2length = {};
    var hasRequiredUcs2length;
    function requireUcs2length() {
      if (hasRequiredUcs2length) return ucs2length;
      hasRequiredUcs2length = 1;
      Object.defineProperty(ucs2length, "__esModule", { value: true });
      function ucs2length$1(str) {
        const len = str.length;
        let length = 0;
        let pos = 0;
        let value;
        while (pos < len) {
          length++;
          value = str.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319 && pos < len) {
            value = str.charCodeAt(pos);
            if ((value & 64512) === 56320)
              pos++;
          }
        }
        return length;
      }
      ucs2length.default = ucs2length$1;
      ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
      return ucs2length;
    }
    var hasRequiredLimitLength;
    function requireLimitLength() {
      if (hasRequiredLimitLength) return limitLength;
      hasRequiredLimitLength = 1;
      Object.defineProperty(limitLength, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const ucs2length_1 = requireUcs2length();
      const error = {
        message({ keyword: keyword2, schemaCode }) {
          const comp = keyword2 === "maxLength" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode, it } = cxt;
          const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
          const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
          cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
        }
      };
      limitLength.default = def2;
      return limitLength;
    }
    var pattern = {};
    var hasRequiredPattern;
    function requirePattern() {
      if (hasRequiredPattern) return pattern;
      hasRequiredPattern = 1;
      Object.defineProperty(pattern, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
      };
      const def2 = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { data, $data, schema, schemaCode, it } = cxt;
          const u = it.opts.unicodeRegExp ? "u" : "";
          const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
          cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
        }
      };
      pattern.default = def2;
      return pattern;
    }
    var limitProperties = {};
    var hasRequiredLimitProperties;
    function requireLimitProperties() {
      if (hasRequiredLimitProperties) return limitProperties;
      hasRequiredLimitProperties = 1;
      Object.defineProperty(limitProperties, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message({ keyword: keyword2, schemaCode }) {
          const comp = keyword2 === "maxProperties" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode } = cxt;
          const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
        }
      };
      limitProperties.default = def2;
      return limitProperties;
    }
    var required = {};
    var hasRequiredRequired;
    function requireRequired() {
      if (hasRequiredRequired) return required;
      hasRequiredRequired = 1;
      Object.defineProperty(required, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
      };
      const def2 = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, schema, schemaCode, data, $data, it } = cxt;
          const { opts } = it;
          if (!$data && schema.length === 0)
            return;
          const useLoop = schema.length >= opts.loopRequired;
          if (it.allErrors)
            allErrorsMode();
          else
            exitOnErrorMode();
          if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
              if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
                const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
              }
            }
          }
          function allErrorsMode() {
            if (useLoop || $data) {
              cxt.block$data(codegen_1.nil, loopAllRequired);
            } else {
              for (const prop of schema) {
                (0, code_1.checkReportMissingProp)(cxt, prop);
              }
            }
          }
          function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
              const valid = gen.let("valid", true);
              cxt.block$data(valid, () => loopUntilMissing(missing, valid));
              cxt.ok(valid);
            } else {
              gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
              (0, code_1.reportMissingProp)(cxt, missing);
              gen.else();
            }
          }
          function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
              cxt.setParams({ missingProperty: prop });
              gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
          }
          function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
              gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.error();
                gen.break();
              });
            }, codegen_1.nil);
          }
        }
      };
      required.default = def2;
      return required;
    }
    var limitItems = {};
    var hasRequiredLimitItems;
    function requireLimitItems() {
      if (hasRequiredLimitItems) return limitItems;
      hasRequiredLimitItems = 1;
      Object.defineProperty(limitItems, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message({ keyword: keyword2, schemaCode }) {
          const comp = keyword2 === "maxItems" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode } = cxt;
          const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
        }
      };
      limitItems.default = def2;
      return limitItems;
    }
    var uniqueItems = {};
    var equal = {};
    var hasRequiredEqual;
    function requireEqual() {
      if (hasRequiredEqual) return equal;
      hasRequiredEqual = 1;
      Object.defineProperty(equal, "__esModule", { value: true });
      const equal$1 = requireFastDeepEqual();
      equal$1.code = 'require("ajv/dist/runtime/equal").default';
      equal.default = equal$1;
      return equal;
    }
    var hasRequiredUniqueItems;
    function requireUniqueItems() {
      if (hasRequiredUniqueItems) return uniqueItems;
      hasRequiredUniqueItems = 1;
      Object.defineProperty(uniqueItems, "__esModule", { value: true });
      const dataType_1 = requireDataType();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const equal_1 = requireEqual();
      const error = {
        message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
        params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
      };
      const def2 = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
          if (!$data && !schema)
            return;
          const valid = gen.let("valid");
          const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
          cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
          cxt.ok(valid);
          function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1._)`${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
          }
          function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
          }
          function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1._)`{}`);
            gen.for((0, codegen_1._)`;${i}--;`, () => {
              gen.let(item, (0, codegen_1._)`${data}[${i}]`);
              gen.if(wrongType, (0, codegen_1._)`continue`);
              if (itemTypes.length > 1)
                gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
              gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
                gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
                cxt.error();
                gen.assign(valid, false).break();
              }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
            });
          }
          function loopN2(i, j) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
              cxt.error();
              gen.assign(valid, false).break(outer);
            })));
          }
        }
      };
      uniqueItems.default = def2;
      return uniqueItems;
    }
    var _const = {};
    var hasRequired_const;
    function require_const() {
      if (hasRequired_const) return _const;
      hasRequired_const = 1;
      Object.defineProperty(_const, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const equal_1 = requireEqual();
      const error = {
        message: "must be equal to constant",
        params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
      };
      const def2 = {
        keyword: "const",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schemaCode, schema } = cxt;
          if ($data || schema && typeof schema == "object") {
            cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
          } else {
            cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
          }
        }
      };
      _const.default = def2;
      return _const;
    }
    var _enum = {};
    var hasRequired_enum;
    function require_enum() {
      if (hasRequired_enum) return _enum;
      hasRequired_enum = 1;
      Object.defineProperty(_enum, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const equal_1 = requireEqual();
      const error = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
      };
      const def2 = {
        keyword: "enum",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
          const useLoop = schema.length >= it.opts.loopEnum;
          let eql;
          const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
          let valid;
          if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
          } else {
            if (!Array.isArray(schema))
              throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
          }
          cxt.pass(valid);
          function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
          }
          function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
          }
        }
      };
      _enum.default = def2;
      return _enum;
    }
    var hasRequiredValidation;
    function requireValidation() {
      if (hasRequiredValidation) return validation;
      hasRequiredValidation = 1;
      Object.defineProperty(validation, "__esModule", { value: true });
      const limitNumber_1 = requireLimitNumber();
      const multipleOf_1 = requireMultipleOf();
      const limitLength_1 = requireLimitLength();
      const pattern_1 = requirePattern();
      const limitProperties_1 = requireLimitProperties();
      const required_1 = requireRequired();
      const limitItems_1 = requireLimitItems();
      const uniqueItems_1 = requireUniqueItems();
      const const_1 = require_const();
      const enum_1 = require_enum();
      const validation$1 = [
        // number
        limitNumber_1.default,
        multipleOf_1.default,
        // string
        limitLength_1.default,
        pattern_1.default,
        // object
        limitProperties_1.default,
        required_1.default,
        // array
        limitItems_1.default,
        uniqueItems_1.default,
        // any
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        const_1.default,
        enum_1.default
      ];
      validation.default = validation$1;
      return validation;
    }
    var applicator = {};
    var additionalItems = {};
    var hasRequiredAdditionalItems;
    function requireAdditionalItems() {
      if (hasRequiredAdditionalItems) return additionalItems;
      hasRequiredAdditionalItems = 1;
      Object.defineProperty(additionalItems, "__esModule", { value: true });
      additionalItems.validateAdditionalItems = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      };
      const def2 = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { parentSchema, it } = cxt;
          const { items: items2 } = parentSchema;
          if (!Array.isArray(items2)) {
            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
          }
          validateAdditionalItems(cxt, items2);
        }
      };
      function validateAdditionalItems(cxt, items2) {
        const { gen, schema, data, keyword: keyword2, it } = cxt;
        it.items = true;
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (schema === false) {
          cxt.setParams({ len: items2.length });
          cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
        } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
          cxt.ok(valid);
        }
        function validateItems(valid) {
          gen.forRange("i", items2.length, len, (i) => {
            cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          });
        }
      }
      additionalItems.validateAdditionalItems = validateAdditionalItems;
      additionalItems.default = def2;
      return additionalItems;
    }
    var prefixItems = {};
    var items = {};
    var hasRequiredItems;
    function requireItems() {
      if (hasRequiredItems) return items;
      hasRequiredItems = 1;
      Object.defineProperty(items, "__esModule", { value: true });
      items.validateTuple = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const code_1 = requireCode();
      const def2 = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code(cxt) {
          const { schema, it } = cxt;
          if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
          it.items = true;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          cxt.ok((0, code_1.validateArray)(cxt));
        }
      };
      function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
        checkStrictTuple(parentSchema);
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
          it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
        }
        const valid = gen.name("valid");
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        schArr.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
            keyword: keyword2,
            schemaProp: i,
            dataProp: i
          }, valid));
          cxt.ok(valid);
        });
        function checkStrictTuple(sch) {
          const { opts, errSchemaPath } = it;
          const l = schArr.length;
          const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
          if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
          }
        }
      }
      items.validateTuple = validateTuple;
      items.default = def2;
      return items;
    }
    var hasRequiredPrefixItems;
    function requirePrefixItems() {
      if (hasRequiredPrefixItems) return prefixItems;
      hasRequiredPrefixItems = 1;
      Object.defineProperty(prefixItems, "__esModule", { value: true });
      const items_1 = requireItems();
      const def2 = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
      };
      prefixItems.default = def2;
      return prefixItems;
    }
    var items2020 = {};
    var hasRequiredItems2020;
    function requireItems2020() {
      if (hasRequiredItems2020) return items2020;
      hasRequiredItems2020 = 1;
      Object.defineProperty(items2020, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const code_1 = requireCode();
      const additionalItems_1 = requireAdditionalItems();
      const error = {
        message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      };
      const def2 = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { schema, parentSchema, it } = cxt;
          const { prefixItems: prefixItems2 } = parentSchema;
          it.items = true;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          if (prefixItems2)
            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
          else
            cxt.ok((0, code_1.validateArray)(cxt));
        }
      };
      items2020.default = def2;
      return items2020;
    }
    var contains = {};
    var hasRequiredContains;
    function requireContains() {
      if (hasRequiredContains) return contains;
      hasRequiredContains = 1;
      Object.defineProperty(contains, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
      };
      const def2 = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          let min;
          let max;
          const { minContains, maxContains } = parentSchema;
          if (it.opts.next) {
            min = minContains === void 0 ? 1 : minContains;
            max = maxContains;
          } else {
            min = 1;
          }
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          cxt.setParams({ min, max });
          if (max === void 0 && min === 0) {
            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
          }
          if (max !== void 0 && min > max) {
            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
          }
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1._)`${len} >= ${min}`;
            if (max !== void 0)
              cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
          }
          it.items = true;
          const valid = gen.name("valid");
          if (max === void 0 && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
          } else if (min === 0) {
            gen.let(valid, true);
            if (max !== void 0)
              gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
          } else {
            gen.let(valid, false);
            validateItemsWithCount();
          }
          cxt.result(valid, () => cxt.reset());
          function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
          }
          function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
              cxt.subschema({
                keyword: "contains",
                dataProp: i,
                dataPropType: util_1.Type.Num,
                compositeRule: true
              }, _valid);
              block();
            });
          }
          function checkLimits(count) {
            gen.code((0, codegen_1._)`${count}++`);
            if (max === void 0) {
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
            } else {
              gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
              if (min === 1)
                gen.assign(valid, true);
              else
                gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
            }
          }
        }
      };
      contains.default = def2;
      return contains;
    }
    var dependencies = {};
    var hasRequiredDependencies;
    function requireDependencies() {
      if (hasRequiredDependencies) return dependencies;
      hasRequiredDependencies = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
        const codegen_1 = requireCodegen();
        const util_1 = requireUtil();
        const code_1 = requireCode();
        exports.error = {
          message: ({ params: { property, depsCount, deps } }) => {
            const property_ies = depsCount === 1 ? "property" : "properties";
            return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
          },
          params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
      missingProperty: ${missingProperty},
      depsCount: ${depsCount},
      deps: ${deps}}`
          // TODO change to reference
        };
        const def2 = {
          keyword: "dependencies",
          type: "object",
          schemaType: "object",
          error: exports.error,
          code(cxt) {
            const [propDeps, schDeps] = splitDependencies(cxt);
            validatePropertyDeps(cxt, propDeps);
            validateSchemaDeps(cxt, schDeps);
          }
        };
        function splitDependencies({ schema }) {
          const propertyDeps = {};
          const schemaDeps = {};
          for (const key in schema) {
            if (key === "__proto__")
              continue;
            const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
            deps[key] = schema[key];
          }
          return [propertyDeps, schemaDeps];
        }
        function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
          const { gen, data, it } = cxt;
          if (Object.keys(propertyDeps).length === 0)
            return;
          const missing = gen.let("missing");
          for (const prop in propertyDeps) {
            const deps = propertyDeps[prop];
            if (deps.length === 0)
              continue;
            const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
            cxt.setParams({
              property: prop,
              depsCount: deps.length,
              deps: deps.join(", ")
            });
            if (it.allErrors) {
              gen.if(hasProperty, () => {
                for (const depProp of deps) {
                  (0, code_1.checkReportMissingProp)(cxt, depProp);
                }
              });
            } else {
              gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
              (0, code_1.reportMissingProp)(cxt, missing);
              gen.else();
            }
          }
        }
        exports.validatePropertyDeps = validatePropertyDeps;
        function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
          const { gen, data, keyword: keyword2, it } = cxt;
          const valid = gen.name("valid");
          for (const prop in schemaDeps) {
            if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
              continue;
            gen.if(
              (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
              () => {
                const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
                cxt.mergeValidEvaluated(schCxt, valid);
              },
              () => gen.var(valid, true)
              // TODO var
            );
            cxt.ok(valid);
          }
        }
        exports.validateSchemaDeps = validateSchemaDeps;
        exports.default = def2;
      })(dependencies);
      return dependencies;
    }
    var propertyNames = {};
    var hasRequiredPropertyNames;
    function requirePropertyNames() {
      if (hasRequiredPropertyNames) return propertyNames;
      hasRequiredPropertyNames = 1;
      Object.defineProperty(propertyNames, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: "property name must be valid",
        params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
      };
      const def2 = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error,
        code(cxt) {
          const { gen, schema, data, it } = cxt;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          const valid = gen.name("valid");
          gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
              keyword: "propertyNames",
              data: key,
              dataTypes: ["string"],
              propertyName: key,
              compositeRule: true
            }, valid);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(true);
              if (!it.allErrors)
                gen.break();
            });
          });
          cxt.ok(valid);
        }
      };
      propertyNames.default = def2;
      return propertyNames;
    }
    var additionalProperties = {};
    var hasRequiredAdditionalProperties;
    function requireAdditionalProperties() {
      if (hasRequiredAdditionalProperties) return additionalProperties;
      hasRequiredAdditionalProperties = 1;
      Object.defineProperty(additionalProperties, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const util_1 = requireUtil();
      const error = {
        message: "must NOT have additional properties",
        params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
      };
      const def2 = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: true,
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, errsCount, it } = cxt;
          if (!errsCount)
            throw new Error("ajv implementation error");
          const { allErrors, opts } = it;
          it.props = true;
          if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
            return;
          const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
          const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
          checkAdditionalProperties();
          cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
          function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
              if (!props.length && !patProps.length)
                additionalPropertyCode(key);
              else
                gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
          }
          function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
              const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
              definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
            } else if (props.length) {
              definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
            } else {
              definedProp = codegen_1.nil;
            }
            if (patProps.length) {
              definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
            }
            return (0, codegen_1.not)(definedProp);
          }
          function deleteAdditional(key) {
            gen.code((0, codegen_1._)`delete ${data}[${key}]`);
          }
          function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
              deleteAdditional(key);
              return;
            }
            if (schema === false) {
              cxt.setParams({ additionalProperty: key });
              cxt.error();
              if (!allErrors)
                gen.break();
              return;
            }
            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
              const valid = gen.name("valid");
              if (opts.removeAdditional === "failing") {
                applyAdditionalSchema(key, valid, false);
                gen.if((0, codegen_1.not)(valid), () => {
                  cxt.reset();
                  deleteAdditional(key);
                });
              } else {
                applyAdditionalSchema(key, valid);
                if (!allErrors)
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            }
          }
          function applyAdditionalSchema(key, valid, errors2) {
            const subschema2 = {
              keyword: "additionalProperties",
              dataProp: key,
              dataPropType: util_1.Type.Str
            };
            if (errors2 === false) {
              Object.assign(subschema2, {
                compositeRule: true,
                createErrors: false,
                allErrors: false
              });
            }
            cxt.subschema(subschema2, valid);
          }
        }
      };
      additionalProperties.default = def2;
      return additionalProperties;
    }
    var properties$1 = {};
    var hasRequiredProperties;
    function requireProperties() {
      if (hasRequiredProperties) return properties$1;
      hasRequiredProperties = 1;
      Object.defineProperty(properties$1, "__esModule", { value: true });
      const validate_1 = requireValidate();
      const code_1 = requireCode();
      const util_1 = requireUtil();
      const additionalProperties_1 = requireAdditionalProperties();
      const def2 = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
          }
          const allProps = (0, code_1.allSchemaProperties)(schema);
          for (const prop of allProps) {
            it.definedProperties.add(prop);
          }
          if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
          }
          const properties2 = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it, schema[p2]));
          if (properties2.length === 0)
            return;
          const valid = gen.name("valid");
          for (const prop of properties2) {
            if (hasDefault(prop)) {
              applyPropertySchema(prop);
            } else {
              gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
              applyPropertySchema(prop);
              if (!it.allErrors)
                gen.else().var(valid, true);
              gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
          }
          function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
          }
          function applyPropertySchema(prop) {
            cxt.subschema({
              keyword: "properties",
              schemaProp: prop,
              dataProp: prop
            }, valid);
          }
        }
      };
      properties$1.default = def2;
      return properties$1;
    }
    var patternProperties = {};
    var hasRequiredPatternProperties;
    function requirePatternProperties() {
      if (hasRequiredPatternProperties) return patternProperties;
      hasRequiredPatternProperties = 1;
      Object.defineProperty(patternProperties, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const util_2 = requireUtil();
      const def2 = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, data, parentSchema, it } = cxt;
          const { opts } = it;
          const patterns = (0, code_1.allSchemaProperties)(schema);
          const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it, schema[p2]));
          if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
            return;
          }
          const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
          const valid = gen.name("valid");
          if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
          }
          const { props } = it;
          validatePatternProperties();
          function validatePatternProperties() {
            for (const pat of patterns) {
              if (checkProperties)
                checkMatchingProperties(pat);
              if (it.allErrors) {
                validateProperties(pat);
              } else {
                gen.var(valid, true);
                validateProperties(pat);
                gen.if(valid);
              }
            }
          }
          function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
              if (new RegExp(pat).test(prop)) {
                (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
              }
            }
          }
          function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
              gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
                const alwaysValid = alwaysValidPatterns.includes(pat);
                if (!alwaysValid) {
                  cxt.subschema({
                    keyword: "patternProperties",
                    schemaProp: pat,
                    dataProp: key,
                    dataPropType: util_2.Type.Str
                  }, valid);
                }
                if (it.opts.unevaluated && props !== true) {
                  gen.assign((0, codegen_1._)`${props}[${key}]`, true);
                } else if (!alwaysValid && !it.allErrors) {
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
              });
            });
          }
        }
      };
      patternProperties.default = def2;
      return patternProperties;
    }
    var not = {};
    var hasRequiredNot;
    function requireNot() {
      if (hasRequiredNot) return not;
      hasRequiredNot = 1;
      Object.defineProperty(not, "__esModule", { value: true });
      const util_1 = requireUtil();
      const def2 = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        code(cxt) {
          const { gen, schema, it } = cxt;
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
          }
          const valid = gen.name("valid");
          cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, valid);
          cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
        },
        error: { message: "must NOT be valid" }
      };
      not.default = def2;
      return not;
    }
    var anyOf = {};
    var hasRequiredAnyOf;
    function requireAnyOf() {
      if (hasRequiredAnyOf) return anyOf;
      hasRequiredAnyOf = 1;
      Object.defineProperty(anyOf, "__esModule", { value: true });
      const code_1 = requireCode();
      const def2 = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: true,
        code: code_1.validateUnion,
        error: { message: "must match a schema in anyOf" }
      };
      anyOf.default = def2;
      return anyOf;
    }
    var oneOf = {};
    var hasRequiredOneOf;
    function requireOneOf() {
      if (hasRequiredOneOf) return oneOf;
      hasRequiredOneOf = 1;
      Object.defineProperty(oneOf, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: "must match exactly one schema in oneOf",
        params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
      };
      const def2 = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          if (it.opts.discriminator && parentSchema.discriminator)
            return;
          const schArr = schema;
          const valid = gen.let("valid", false);
          const passing = gen.let("passing", null);
          const schValid = gen.name("_valid");
          cxt.setParams({ passing });
          gen.block(validateOneOf);
          cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
          function validateOneOf() {
            schArr.forEach((sch, i) => {
              let schCxt;
              if ((0, util_1.alwaysValidSchema)(it, sch)) {
                gen.var(schValid, true);
              } else {
                schCxt = cxt.subschema({
                  keyword: "oneOf",
                  schemaProp: i,
                  compositeRule: true
                }, schValid);
              }
              if (i > 0) {
                gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
              }
              gen.if(schValid, () => {
                gen.assign(valid, true);
                gen.assign(passing, i);
                if (schCxt)
                  cxt.mergeEvaluated(schCxt, codegen_1.Name);
              });
            });
          }
        }
      };
      oneOf.default = def2;
      return oneOf;
    }
    var allOf = {};
    var hasRequiredAllOf;
    function requireAllOf() {
      if (hasRequiredAllOf) return allOf;
      hasRequiredAllOf = 1;
      Object.defineProperty(allOf, "__esModule", { value: true });
      const util_1 = requireUtil();
      const def2 = {
        keyword: "allOf",
        schemaType: "array",
        code(cxt) {
          const { gen, schema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const valid = gen.name("valid");
          schema.forEach((sch, i) => {
            if ((0, util_1.alwaysValidSchema)(it, sch))
              return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
          });
        }
      };
      allOf.default = def2;
      return allOf;
    }
    var _if = {};
    var hasRequired_if;
    function require_if() {
      if (hasRequired_if) return _if;
      hasRequired_if = 1;
      Object.defineProperty(_if, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
        params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
      };
      const def2 = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, parentSchema, it } = cxt;
          if (parentSchema.then === void 0 && parentSchema.else === void 0) {
            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
          }
          const hasThen = hasSchema(it, "then");
          const hasElse = hasSchema(it, "else");
          if (!hasThen && !hasElse)
            return;
          const valid = gen.let("valid", true);
          const schValid = gen.name("_valid");
          validateIf();
          cxt.reset();
          if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
          } else if (hasThen) {
            gen.if(schValid, validateClause("then"));
          } else {
            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
          }
          cxt.pass(valid, () => cxt.error(true));
          function validateIf() {
            const schCxt = cxt.subschema({
              keyword: "if",
              compositeRule: true,
              createErrors: false,
              allErrors: false
            }, schValid);
            cxt.mergeEvaluated(schCxt);
          }
          function validateClause(keyword2, ifClause) {
            return () => {
              const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
              gen.assign(valid, schValid);
              cxt.mergeValidEvaluated(schCxt, valid);
              if (ifClause)
                gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
              else
                cxt.setParams({ ifClause: keyword2 });
            };
          }
        }
      };
      function hasSchema(it, keyword2) {
        const schema = it.schema[keyword2];
        return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
      }
      _if.default = def2;
      return _if;
    }
    var thenElse = {};
    var hasRequiredThenElse;
    function requireThenElse() {
      if (hasRequiredThenElse) return thenElse;
      hasRequiredThenElse = 1;
      Object.defineProperty(thenElse, "__esModule", { value: true });
      const util_1 = requireUtil();
      const def2 = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword: keyword2, parentSchema, it }) {
          if (parentSchema.if === void 0)
            (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
        }
      };
      thenElse.default = def2;
      return thenElse;
    }
    var hasRequiredApplicator;
    function requireApplicator() {
      if (hasRequiredApplicator) return applicator;
      hasRequiredApplicator = 1;
      Object.defineProperty(applicator, "__esModule", { value: true });
      const additionalItems_1 = requireAdditionalItems();
      const prefixItems_1 = requirePrefixItems();
      const items_1 = requireItems();
      const items2020_1 = requireItems2020();
      const contains_1 = requireContains();
      const dependencies_1 = requireDependencies();
      const propertyNames_1 = requirePropertyNames();
      const additionalProperties_1 = requireAdditionalProperties();
      const properties_1 = requireProperties();
      const patternProperties_1 = requirePatternProperties();
      const not_1 = requireNot();
      const anyOf_1 = requireAnyOf();
      const oneOf_1 = requireOneOf();
      const allOf_1 = requireAllOf();
      const if_1 = require_if();
      const thenElse_1 = requireThenElse();
      function getApplicator(draft2020 = false) {
        const applicator2 = [
          // any
          not_1.default,
          anyOf_1.default,
          oneOf_1.default,
          allOf_1.default,
          if_1.default,
          thenElse_1.default,
          // object
          propertyNames_1.default,
          additionalProperties_1.default,
          dependencies_1.default,
          properties_1.default,
          patternProperties_1.default
        ];
        if (draft2020)
          applicator2.push(prefixItems_1.default, items2020_1.default);
        else
          applicator2.push(additionalItems_1.default, items_1.default);
        applicator2.push(contains_1.default);
        return applicator2;
      }
      applicator.default = getApplicator;
      return applicator;
    }
    var format$1 = {};
    var format = {};
    var hasRequiredFormat$1;
    function requireFormat$1() {
      if (hasRequiredFormat$1) return format;
      hasRequiredFormat$1 = 1;
      Object.defineProperty(format, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
      };
      const def2 = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: true,
        error,
        code(cxt, ruleType) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          if ($data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format2 = gen.let("format");
            gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
              if (opts.strictSchema === false)
                return codegen_1.nil;
              return (0, codegen_1._)`${schemaCode} && !${format2}`;
            }
            function invalidFmt() {
              const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
              const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
              return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
          }
          function validateFormat() {
            const formatDef = self2.formats[schema];
            if (!formatDef) {
              unknownFormat();
              return;
            }
            if (formatDef === true)
              return;
            const [fmtType, format2, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
              cxt.pass(validCondition());
            function unknownFormat() {
              if (opts.strictSchema === false) {
                self2.logger.warn(unknownMsg());
                return;
              }
              throw new Error(unknownMsg());
              function unknownMsg() {
                return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
              }
            }
            function getFormat(fmtDef) {
              const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
              const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
              if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
              }
              return ["string", fmtDef, fmt];
            }
            function validCondition() {
              if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                if (!schemaEnv.$async)
                  throw new Error("async format in sync schema");
                return (0, codegen_1._)`await ${fmtRef}(${data})`;
              }
              return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
            }
          }
        }
      };
      format.default = def2;
      return format;
    }
    var hasRequiredFormat;
    function requireFormat() {
      if (hasRequiredFormat) return format$1;
      hasRequiredFormat = 1;
      Object.defineProperty(format$1, "__esModule", { value: true });
      const format_1 = requireFormat$1();
      const format2 = [format_1.default];
      format$1.default = format2;
      return format$1;
    }
    var metadata = {};
    var hasRequiredMetadata;
    function requireMetadata() {
      if (hasRequiredMetadata) return metadata;
      hasRequiredMetadata = 1;
      Object.defineProperty(metadata, "__esModule", { value: true });
      metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
      metadata.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples"
      ];
      metadata.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema"
      ];
      return metadata;
    }
    var hasRequiredDraft7;
    function requireDraft7() {
      if (hasRequiredDraft7) return draft7;
      hasRequiredDraft7 = 1;
      Object.defineProperty(draft7, "__esModule", { value: true });
      const core_1 = requireCore();
      const validation_1 = requireValidation();
      const applicator_1 = requireApplicator();
      const format_1 = requireFormat();
      const metadata_1 = requireMetadata();
      const draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        (0, applicator_1.default)(),
        format_1.default,
        metadata_1.metadataVocabulary,
        metadata_1.contentVocabulary
      ];
      draft7.default = draft7Vocabularies;
      return draft7;
    }
    var discriminator = {};
    var types = {};
    var hasRequiredTypes;
    function requireTypes() {
      if (hasRequiredTypes) return types;
      hasRequiredTypes = 1;
      Object.defineProperty(types, "__esModule", { value: true });
      types.DiscrError = void 0;
      var DiscrError;
      (function(DiscrError2) {
        DiscrError2["Tag"] = "tag";
        DiscrError2["Mapping"] = "mapping";
      })(DiscrError || (types.DiscrError = DiscrError = {}));
      return types;
    }
    var hasRequiredDiscriminator;
    function requireDiscriminator() {
      if (hasRequiredDiscriminator) return discriminator;
      hasRequiredDiscriminator = 1;
      Object.defineProperty(discriminator, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const types_1 = requireTypes();
      const compile_1 = requireCompile();
      const ref_error_1 = requireRef_error();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
      };
      const def2 = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error,
        code(cxt) {
          const { gen, data, schema, parentSchema, it } = cxt;
          const { oneOf: oneOf2 } = parentSchema;
          if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
          }
          const tagName = schema.propertyName;
          if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
          if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
          if (!oneOf2)
            throw new Error("discriminator: requires oneOf keyword");
          const valid = gen.let("valid", false);
          const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
          gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
          cxt.ok(valid);
          function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
              gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
              gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
          }
          function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
          }
          function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf2.length; i++) {
              let sch = oneOf2[i];
              if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                const ref2 = sch.$ref;
                sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
                if (sch instanceof compile_1.SchemaEnv)
                  sch = sch.schema;
                if (sch === void 0)
                  throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
              }
              const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
              if (typeof propSch != "object") {
                throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
              }
              tagRequired = tagRequired && (topRequired || hasRequired(sch));
              addMappings(propSch, i);
            }
            if (!tagRequired)
              throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required: required2 }) {
              return Array.isArray(required2) && required2.includes(tagName);
            }
            function addMappings(sch, i) {
              if (sch.const) {
                addMapping(sch.const, i);
              } else if (sch.enum) {
                for (const tagValue of sch.enum) {
                  addMapping(tagValue, i);
                }
              } else {
                throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
              }
            }
            function addMapping(tagValue, i) {
              if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                throw new Error(`discriminator: "${tagName}" values must be unique strings`);
              }
              oneOfMapping[tagValue] = i;
            }
          }
        }
      };
      discriminator.default = def2;
      return discriminator;
    }
    const $schema = "http://json-schema.org/draft-07/schema#";
    const $id = "http://json-schema.org/draft-07/schema#";
    const title = "Core schema meta-schema";
    const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
    const type = ["object", "boolean"];
    const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
    const require$$3 = {
      $schema,
      $id,
      title,
      definitions,
      type,
      properties,
      "default": true
    };
    var hasRequiredAjv;
    function requireAjv() {
      if (hasRequiredAjv) return ajv.exports;
      hasRequiredAjv = 1;
      (function(module, exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
        const core_1 = requireCore$1();
        const draft7_1 = requireDraft7();
        const discriminator_1 = requireDiscriminator();
        const draft7MetaSchema = require$$3;
        const META_SUPPORT_DATA = ["/properties"];
        const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
        class Ajv2 extends core_1.default {
          _addVocabularies() {
            super._addVocabularies();
            draft7_1.default.forEach((v) => this.addVocabulary(v));
            if (this.opts.discriminator)
              this.addKeyword(discriminator_1.default);
          }
          _addDefaultMetaSchema() {
            super._addDefaultMetaSchema();
            if (!this.opts.meta)
              return;
            const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
            this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
            this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
          }
          defaultMeta() {
            return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
          }
        }
        exports.Ajv = Ajv2;
        module.exports = exports = Ajv2;
        module.exports.Ajv = Ajv2;
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.default = Ajv2;
        var validate_1 = requireValidate();
        Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
          return validate_1.KeywordCxt;
        } });
        var codegen_1 = requireCodegen();
        Object.defineProperty(exports, "_", { enumerable: true, get: function() {
          return codegen_1._;
        } });
        Object.defineProperty(exports, "str", { enumerable: true, get: function() {
          return codegen_1.str;
        } });
        Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
          return codegen_1.stringify;
        } });
        Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
          return codegen_1.nil;
        } });
        Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
          return codegen_1.Name;
        } });
        Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
          return codegen_1.CodeGen;
        } });
        var validation_error_1 = requireValidation_error();
        Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
          return validation_error_1.default;
        } });
        var ref_error_1 = requireRef_error();
        Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
          return ref_error_1.default;
        } });
      })(ajv, ajv.exports);
      return ajv.exports;
    }
    var ajvExports = requireAjv();
    const Ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
    var dist$1 = { exports: {} };
    var formats = {};
    var hasRequiredFormats;
    function requireFormats() {
      if (hasRequiredFormats) return formats;
      hasRequiredFormats = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
        function fmtDef(validate2, compare) {
          return { validate: validate2, compare };
        }
        exports.fullFormats = {
          // date: http://tools.ietf.org/html/rfc3339#section-5.6
          date: fmtDef(date, compareDate),
          // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
          time: fmtDef(getTime(true), compareTime),
          "date-time": fmtDef(getDateTime(true), compareDateTime),
          "iso-time": fmtDef(getTime(), compareIsoTime),
          "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
          // duration: https://tools.ietf.org/html/rfc3339#appendix-A
          duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
          uri: uri2,
          "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
          // uri-template: https://tools.ietf.org/html/rfc6570
          "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
          // For the source: https://gist.github.com/dperini/729294
          // For test cases: https://mathiasbynens.be/demo/url-regex
          url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
          email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
          hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
          // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
          ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
          ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
          regex,
          // uuid: http://tools.ietf.org/html/rfc4122
          uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
          // JSON-pointer: https://tools.ietf.org/html/rfc6901
          // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
          "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
          "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
          // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
          "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
          // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
          // byte: https://github.com/miguelmota/is-base64
          byte,
          // signed 32 bit integer
          int32: { type: "number", validate: validateInt32 },
          // signed 64 bit integer
          int64: { type: "number", validate: validateInt64 },
          // C-type float
          float: { type: "number", validate: validateNumber },
          // C-type double
          double: { type: "number", validate: validateNumber },
          // hint to the UI to hide input strings
          password: true,
          // unchecked string payload
          binary: true
        };
        exports.fastFormats = {
          ...exports.fullFormats,
          date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
          time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
          "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
          "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
          "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
          // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
          uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
          "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
          // email (sources from jsen validator):
          // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
          // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
          email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
        };
        exports.formatNames = Object.keys(exports.fullFormats);
        function isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
        const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function date(str) {
          const matches = DATE.exec(str);
          if (!matches)
            return false;
          const year = +matches[1];
          const month = +matches[2];
          const day = +matches[3];
          return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
        }
        function compareDate(d1, d2) {
          if (!(d1 && d2))
            return void 0;
          if (d1 > d2)
            return 1;
          if (d1 < d2)
            return -1;
          return 0;
        }
        const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
        function getTime(strictTimeZone) {
          return function time(str) {
            const matches = TIME.exec(str);
            if (!matches)
              return false;
            const hr = +matches[1];
            const min = +matches[2];
            const sec = +matches[3];
            const tz = matches[4];
            const tzSign = matches[5] === "-" ? -1 : 1;
            const tzH = +(matches[6] || 0);
            const tzM = +(matches[7] || 0);
            if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
              return false;
            if (hr <= 23 && min <= 59 && sec < 60)
              return true;
            const utcMin = min - tzM * tzSign;
            const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
            return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
          };
        }
        function compareTime(s1, s2) {
          if (!(s1 && s2))
            return void 0;
          const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
          const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
          if (!(t1 && t2))
            return void 0;
          return t1 - t2;
        }
        function compareIsoTime(t1, t2) {
          if (!(t1 && t2))
            return void 0;
          const a1 = TIME.exec(t1);
          const a2 = TIME.exec(t2);
          if (!(a1 && a2))
            return void 0;
          t1 = a1[1] + a1[2] + a1[3];
          t2 = a2[1] + a2[2] + a2[3];
          if (t1 > t2)
            return 1;
          if (t1 < t2)
            return -1;
          return 0;
        }
        const DATE_TIME_SEPARATOR = /t|\s/i;
        function getDateTime(strictTimeZone) {
          const time = getTime(strictTimeZone);
          return function date_time(str) {
            const dateTime = str.split(DATE_TIME_SEPARATOR);
            return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
          };
        }
        function compareDateTime(dt1, dt2) {
          if (!(dt1 && dt2))
            return void 0;
          const d1 = new Date(dt1).valueOf();
          const d2 = new Date(dt2).valueOf();
          if (!(d1 && d2))
            return void 0;
          return d1 - d2;
        }
        function compareIsoDateTime(dt1, dt2) {
          if (!(dt1 && dt2))
            return void 0;
          const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
          const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
          const res = compareDate(d1, d2);
          if (res === void 0)
            return void 0;
          return res || compareTime(t1, t2);
        }
        const NOT_URI_FRAGMENT = /\/|:/;
        const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
        function uri2(str) {
          return NOT_URI_FRAGMENT.test(str) && URI.test(str);
        }
        const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
        function byte(str) {
          BYTE.lastIndex = 0;
          return BYTE.test(str);
        }
        const MIN_INT32 = -2147483648;
        const MAX_INT32 = 2 ** 31 - 1;
        function validateInt32(value) {
          return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
        }
        function validateInt64(value) {
          return Number.isInteger(value);
        }
        function validateNumber() {
          return true;
        }
        const Z_ANCHOR = /[^\\]\\Z/;
        function regex(str) {
          if (Z_ANCHOR.test(str))
            return false;
          try {
            new RegExp(str);
            return true;
          } catch (e) {
            return false;
          }
        }
      })(formats);
      return formats;
    }
    var limit = {};
    var hasRequiredLimit;
    function requireLimit() {
      if (hasRequiredLimit) return limit;
      hasRequiredLimit = 1;
      (function(exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.formatLimitDefinition = void 0;
        const ajv_1 = requireAjv();
        const codegen_1 = requireCodegen();
        const ops = codegen_1.operators;
        const KWDs = {
          formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
          formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
          formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
          formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
        };
        const error = {
          message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
          params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
        };
        exports.formatLimitDefinition = {
          keyword: Object.keys(KWDs),
          type: "string",
          schemaType: "string",
          $data: true,
          error,
          code(cxt) {
            const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
            const { opts, self: self2 } = it;
            if (!opts.validateFormats)
              return;
            const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
            if (fCxt.$data)
              validate$DataFormat();
            else
              validateFormat();
            function validate$DataFormat() {
              const fmts = gen.scopeValue("formats", {
                ref: self2.formats,
                code: opts.code.formats
              });
              const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
              cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
            }
            function validateFormat() {
              const format2 = fCxt.schema;
              const fmtDef = self2.formats[format2];
              if (!fmtDef || fmtDef === true)
                return;
              if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
                throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
              }
              const fmt = gen.scopeValue("formats", {
                key: format2,
                ref: fmtDef,
                code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
              });
              cxt.fail$data(compareCode(fmt));
            }
            function compareCode(fmt) {
              return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
            }
          },
          dependencies: ["format"]
        };
        const formatLimitPlugin = (ajv2) => {
          ajv2.addKeyword(exports.formatLimitDefinition);
          return ajv2;
        };
        exports.default = formatLimitPlugin;
      })(limit);
      return limit;
    }
    var hasRequiredDist$1;
    function requireDist$1() {
      if (hasRequiredDist$1) return dist$1.exports;
      hasRequiredDist$1 = 1;
      (function(module, exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        const formats_1 = requireFormats();
        const limit_1 = requireLimit();
        const codegen_1 = requireCodegen();
        const fullName = new codegen_1.Name("fullFormats");
        const fastName = new codegen_1.Name("fastFormats");
        const formatsPlugin = (ajv2, opts = { keywords: true }) => {
          if (Array.isArray(opts)) {
            addFormats2(ajv2, opts, formats_1.fullFormats, fullName);
            return ajv2;
          }
          const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
          const list = opts.formats || formats_1.formatNames;
          addFormats2(ajv2, list, formats2, exportName);
          if (opts.keywords)
            (0, limit_1.default)(ajv2);
          return ajv2;
        };
        formatsPlugin.get = (name, mode = "full") => {
          const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
          const f = formats2[name];
          if (!f)
            throw new Error(`Unknown format "${name}"`);
          return f;
        };
        function addFormats2(ajv2, list, fs, exportName) {
          var _a;
          var _b;
          (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
          for (const f of list)
            ajv2.addFormat(f, fs[f]);
        }
        module.exports = exports = formatsPlugin;
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.default = formatsPlugin;
      })(dist$1, dist$1.exports);
      return dist$1.exports;
    }
    var distExports$1 = requireDist$1();
    const addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports$1);
    var dist = { exports: {} };
    var hasRequiredDist;
    function requireDist() {
      if (hasRequiredDist) return dist.exports;
      hasRequiredDist = 1;
      (function(module, exports) {
        Object.defineProperty(exports, "__esModule", { value: true });
        const ajv_1 = requireAjv();
        const codegen_1 = requireCodegen();
        const code_1 = requireCode$1();
        const validate_1 = requireValidate();
        const errors_1 = requireErrors();
        const names_1 = requireNames();
        const keyword2 = "errorMessage";
        const used = new ajv_1.Name("emUsed");
        const KEYWORD_PROPERTY_PARAMS = {
          required: "missingProperty",
          dependencies: "property",
          dependentRequired: "property"
        };
        const INTERPOLATION = /\$\{[^}]+\}/;
        const INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
        const EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
        function errorMessage(options) {
          return {
            keyword: keyword2,
            schemaType: ["string", "object"],
            post: true,
            code(cxt) {
              const { gen, data, schema, schemaValue, it } = cxt;
              if (it.createErrors === false)
                return;
              const sch = schema;
              const instancePath = codegen_1.strConcat(names_1.default.instancePath, it.errorPath);
              gen.if(ajv_1._`${names_1.default.errors} > 0`, () => {
                if (typeof sch == "object") {
                  const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
                  if (kwdErrors)
                    processKeywordErrors(kwdErrors);
                  if (kwdPropErrors)
                    processKeywordPropErrors(kwdPropErrors);
                  processChildErrors(childErrorsConfig(sch));
                }
                const schMessage = typeof sch == "string" ? sch : sch._;
                if (schMessage)
                  processAllErrors(schMessage);
                if (!options.keepErrors)
                  removeUsedErrors();
              });
              function childErrorsConfig({ properties: properties2, items: items2 }) {
                const errors2 = {};
                if (properties2) {
                  errors2.props = {};
                  for (const p2 in properties2)
                    errors2.props[p2] = [];
                }
                if (items2) {
                  errors2.items = {};
                  for (let i = 0; i < items2.length; i++)
                    errors2.items[i] = [];
                }
                return errors2;
              }
              function keywordErrorsConfig(emSchema) {
                let propErrors;
                let errors2;
                for (const k in emSchema) {
                  if (k === "properties" || k === "items")
                    continue;
                  const kwdSch = emSchema[k];
                  if (typeof kwdSch == "object") {
                    propErrors || (propErrors = {});
                    const errMap = propErrors[k] = {};
                    for (const p2 in kwdSch)
                      errMap[p2] = [];
                  } else {
                    errors2 || (errors2 = {});
                    errors2[k] = [];
                  }
                }
                return [propErrors, errors2];
              }
              function processKeywordErrors(kwdErrors) {
                const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
                const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
                const { singleError } = options;
                if (singleError) {
                  const message = gen.let("message", ajv_1._`""`);
                  const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
                  loopErrors((key) => {
                    gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                    gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                    gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
                  });
                  errors_1.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
                } else {
                  loopErrors((key) => errors_1.reportError(cxt, {
                    message: errMessage(key),
                    params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
                  }));
                }
                function loopErrors(body) {
                  gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
                }
                function errMessage(key) {
                  return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
                }
              }
              function processKeywordPropErrors(kwdPropErrors) {
                const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
                const templatesCode = [];
                for (const k in kwdPropErrors) {
                  templatesCode.push([
                    k,
                    getTemplatesCode(kwdPropErrors[k], schema[k])
                  ]);
                }
                const templates = gen.const("templates", gen.object(...templatesCode));
                const kwdPropParams = gen.scopeValue("obj", {
                  ref: KEYWORD_PROPERTY_PARAMS,
                  code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
                });
                const propParam = gen.let("emPropParams");
                const paramsErrors = gen.let("emParamsErrors");
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
                  gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
                  gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
                  gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
                }));
                gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
                  gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
                  gen.if(ajv_1._`${paramsErrors}.length`, () => {
                    const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                    errors_1.reportError(cxt, {
                      message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                      params: ajv_1._`{errors: ${paramsErrors}}`
                    });
                  });
                }));
              }
              function processChildErrors(childErrors) {
                const { props, items: items2 } = childErrors;
                if (!props && !items2)
                  return;
                const isObj = ajv_1._`typeof ${data} == "object"`;
                const isArr = ajv_1._`Array.isArray(${data})`;
                const childErrs = gen.let("emErrors");
                let childKwd;
                let childProp;
                const templates = gen.let("templates");
                if (props && items2) {
                  childKwd = gen.let("emChildKwd");
                  gen.if(isObj);
                  gen.if(isArr, () => {
                    init(items2, schema.items);
                    gen.assign(childKwd, ajv_1.str`items`);
                  }, () => {
                    init(props, schema.properties);
                    gen.assign(childKwd, ajv_1.str`properties`);
                  });
                  childProp = ajv_1._`[${childKwd}]`;
                } else if (items2) {
                  gen.if(isArr);
                  init(items2, schema.items);
                  childProp = ajv_1._`.items`;
                } else if (props) {
                  gen.if(codegen_1.and(isObj, codegen_1.not(isArr)));
                  init(props, schema.properties);
                  childProp = ajv_1._`.properties`;
                }
                gen.forOf("err", names_1.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
                gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
                  errors_1.reportError(cxt, {
                    message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                    params: ajv_1._`{errors: ${childErrs}[${key}]}`
                  });
                  gen.assign(ajv_1._`${names_1.default.vErrors}[${names_1.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
                }));
                gen.endIf();
                function init(children, msgs) {
                  gen.assign(childErrs, ajv_1.stringify(children));
                  gen.assign(templates, getTemplatesCode(children, msgs));
                }
              }
              function processAllErrors(schMessage) {
                const errs = gen.const("emErrs", ajv_1._`[]`);
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
                gen.if(ajv_1._`${errs}.length`, () => errors_1.reportError(cxt, {
                  message: templateExpr(schMessage),
                  params: ajv_1._`{errors: ${errs}}`
                }));
              }
              function removeUsedErrors() {
                const errs = gen.const("emErrs", ajv_1._`[]`);
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
                gen.assign(names_1.default.vErrors, errs).assign(names_1.default.errors, ajv_1._`${errs}.length`);
              }
              function matchKeywordError(err, kwdErrs) {
                return codegen_1.and(
                  ajv_1._`${err}.keyword !== ${keyword2}`,
                  ajv_1._`!${err}.${used}`,
                  ajv_1._`${err}.instancePath === ${instancePath}`,
                  ajv_1._`${err}.keyword in ${kwdErrs}`,
                  // TODO match the end of the string?
                  ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,
                  ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`
                );
              }
              function ifMatchesChildError(err, childErrs, thenBody) {
                gen.if(codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
                  const childRegex = gen.scopeValue("pattern", {
                    ref: /^\/([^/]*)(?:\/|$)/,
                    code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
                  });
                  const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
                  const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
                  gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
                });
              }
              function matchAnyError(err) {
                return codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, codegen_1.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_1.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it.errSchemaPath}.length] === "/"`);
              }
              function getTemplatesCode(keys, msgs) {
                const templatesCode = [];
                for (const k in keys) {
                  const msg = msgs[k];
                  if (INTERPOLATION.test(msg))
                    templatesCode.push([k, templateFunc(msg)]);
                }
                return gen.object(...templatesCode);
              }
              function templateExpr(msg) {
                if (!INTERPOLATION.test(msg))
                  return ajv_1.stringify(msg);
                return new code_1._Code(code_1.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_1.getData(ptr, it)}) + "`).replace(EMPTY_STR, ""));
              }
              function templateFunc(msg) {
                return ajv_1._`function(){return ${templateExpr(msg)}}`;
              }
            },
            metaSchema: {
              anyOf: [
                { type: "string" },
                {
                  type: "object",
                  properties: {
                    properties: { $ref: "#/$defs/stringMap" },
                    items: { $ref: "#/$defs/stringList" },
                    required: { $ref: "#/$defs/stringOrMap" },
                    dependencies: { $ref: "#/$defs/stringOrMap" }
                  },
                  additionalProperties: { type: "string" }
                }
              ],
              $defs: {
                stringMap: {
                  type: "object",
                  additionalProperties: { type: "string" }
                },
                stringOrMap: {
                  anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
                },
                stringList: { type: "array", items: { type: "string" } }
              }
            }
          };
        }
        const ajvErrors = (ajv2, options = {}) => {
          if (!ajv2.opts.allErrors)
            throw new Error("ajv-errors: Ajv option allErrors must be true");
          if (ajv2.opts.jsPropertySyntax) {
            throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
          }
          return ajv2.addKeyword(errorMessage(options));
        };
        exports.default = ajvErrors;
        module.exports = ajvErrors;
        module.exports.default = ajvErrors;
      })(dist, dist.exports);
      return dist.exports;
    }
    var distExports = requireDist();
    const addErrors = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
    class ValidatorService {
      constructor(options) {
        __publicField(this, "ajv");
        this.ajv = new Ajv({
          allErrors: true,
          useDefaults: "empty",
          verbose: true,
          validateFormats: true,
          strict: true,
          coerceTypes: true,
          ...options
        });
        console.log(this.ajv.schemas);
        addFormats(this.ajv);
        addErrors(this.ajv);
        this.ajv.addKeyword("nodeType");
      }
      createValidator(schema) {
        return this.ajv.compile(schema);
      }
      resetCache() {
        this.ajv.cache.clear();
      }
      errors(errors2, options) {
        return this.ajv.errorsText(errors2, options);
      }
    }
    const validatorService = new ValidatorService();
    var jsonpointer$1 = {};
    var hasRequiredJsonpointer;
    function requireJsonpointer() {
      if (hasRequiredJsonpointer) return jsonpointer$1;
      hasRequiredJsonpointer = 1;
      var hasExcape = /~/;
      var escapeMatcher = /~[01]/g;
      function escapeReplacer(m) {
        switch (m) {
          case "~1":
            return "/";
          case "~0":
            return "~";
        }
        throw new Error("Invalid tilde escape: " + m);
      }
      function untilde(str) {
        if (!hasExcape.test(str)) return str;
        return str.replace(escapeMatcher, escapeReplacer);
      }
      function setter(obj, pointer, value) {
        var part;
        var hasNextPart;
        for (var p2 = 1, len = pointer.length; p2 < len; ) {
          if (pointer[p2] === "constructor" || pointer[p2] === "prototype" || pointer[p2] === "__proto__") return obj;
          part = untilde(pointer[p2++]);
          hasNextPart = len > p2;
          if (typeof obj[part] === "undefined") {
            if (Array.isArray(obj) && part === "-") {
              part = obj.length;
            }
            if (hasNextPart) {
              if (pointer[p2] !== "" && pointer[p2] < Infinity || pointer[p2] === "-") obj[part] = [];
              else obj[part] = {};
            }
          }
          if (!hasNextPart) break;
          obj = obj[part];
        }
        var oldValue = obj[part];
        if (value === void 0) delete obj[part];
        else obj[part] = value;
        return oldValue;
      }
      function compilePointer(pointer) {
        if (typeof pointer === "string") {
          pointer = pointer.split("/");
          if (pointer[0] === "") return pointer;
          throw new Error("Invalid JSON pointer.");
        } else if (Array.isArray(pointer)) {
          for (const part of pointer) {
            if (typeof part !== "string" && typeof part !== "number") {
              throw new Error("Invalid JSON pointer. Must be of type string or number.");
            }
          }
          return pointer;
        }
        throw new Error("Invalid JSON pointer.");
      }
      function get(obj, pointer) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        var len = pointer.length;
        if (len === 1) return obj;
        for (var p2 = 1; p2 < len; ) {
          obj = obj[untilde(pointer[p2++])];
          if (len === p2) return obj;
          if (typeof obj !== "object" || obj === null) return void 0;
        }
      }
      function set(obj, pointer, value) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
        return setter(obj, pointer, value);
      }
      function compile2(pointer) {
        var compiled = compilePointer(pointer);
        return {
          get: function(object) {
            return get(object, compiled);
          },
          set: function(object, value) {
            return set(object, compiled, value);
          }
        };
      }
      jsonpointer$1.get = get;
      jsonpointer$1.set = set;
      jsonpointer$1.compile = compile2;
      return jsonpointer$1;
    }
    var jsonpointerExports = requireJsonpointer();
    const jsonpointer = /* @__PURE__ */ getDefaultExportFromCjs(jsonpointerExports);
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const _sfc_main$7 = {
      name: "NodeRedVueApp",
      props: {
        node: {
          type: Object,
          required: true
        },
        validator: {
          type: Function,
          required: true
        }
      },
      data() {
        return {
          localNode: this.node,
          errors: {}
        };
      },
      beforeMount() {
        this.validator(this.localNode);
        Object.keys(this.localNode._def.defaults).forEach((prop) => {
          this.$watch(
            () => this.localNode[prop],
            (newVal) => {
              this.validate();
            },
            { deep: true }
          );
        });
        Object.keys(this.localNode._def.credentials).forEach((prop) => {
          if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`]) {
            this.localNode.credentials[prop] = "__PWD__";
          }
          this.$watch(
            () => this.localNode.credentials[prop],
            (newVal, oldVal) => {
              this.validate();
              if (this.localNode._def.credentials[prop].type === "password" && newVal !== oldVal) {
                this.localNode.credentials[`has_${prop}`] = !!newVal;
              }
            },
            { deep: true }
          );
        });
      },
      beforeUnmount() {
        var _a, _b;
        (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", false).removeClass("disabled");
        (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", false).removeClass("disabled");
        $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
        Object.keys(this.localNode._def.credentials).forEach((prop) => {
          if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`] && this.localNode.credentials[prop] === "__PWD__") {
            this.localNode.credentials[prop] = void 0;
          }
        });
      },
      methods: {
        validate() {
          var _a, _b;
          const valid = this.validator(this.localNode);
          if (!valid) {
            const errors2 = this.validator.errors;
            this.errors = errors2.reduce((acc, error) => {
              const errorValue = jsonpointer.get(
                this.localNode,
                error.instancePath
              );
              if (error.parentSchema.format === "password" && errorValue === "__PWD__") {
                console.log(
                  "password fields with value equal to __PWD__ should not be an error"
                );
                return acc;
              } else {
                const key = `node${error.instancePath.replaceAll("/", ".")}`;
                acc[key] = error.message;
                return acc;
              }
            }, {});
          } else {
            this.errors = {};
          }
          if (Object.keys(this.errors).length) {
            (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", true).addClass("disabled");
            (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", true).addClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "none", "important");
          } else {
            $("#node-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#node-config-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
          }
        }
      }
    };
    const _hoisted_1$7 = { style: { "width": "100%" } };
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_NodeRedNodeForm = resolveComponent("NodeRedNodeForm");
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createVNode(_component_NodeRedNodeForm, {
          node: $data.localNode,
          errors: $data.errors,
          style: { "width": "100%" }
        }, null, 8, ["node", "errors"])
      ]);
    }
    const NodeRedVueApp = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
    const _sfc_main$6 = {
      props: {
        value: String,
        type: {
          type: String,
          default: "text",
          validator: function(value) {
            return ["text", "password"].includes(value);
          }
        },
        placeholder: String,
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value", "input"],
      data() {
        return {
          internalValue: "",
          secretPattern: "*************"
        };
      },
      beforeMount() {
        this.internalValue = this.value;
        this.onBlur();
      },
      methods: {
        onInput(event) {
          this.internalValue = event.target.value;
          this.$emit("update:value", this.internalValue);
          this.$emit("input", this.internalValue);
        },
        onFocus() {
          if (this.type === "password" && this.internalValue === this.secretPattern) {
            this.internalValue = "";
          }
        },
        onBlur() {
          if (this.type === "password" && this.value === "__PWD__") {
            this.internalValue = this.secretPattern;
          }
        }
      }
    };
    const _hoisted_1$6 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$6 = ["type", "value", "placeholder"];
    const _hoisted_3$4 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("input", {
          ref: "inputField",
          type: $props.type,
          value: $data.internalValue,
          placeholder: $props.placeholder,
          onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
          onFocus: _cache[1] || (_cache[1] = (...args) => $options.onFocus && $options.onFocus(...args)),
          onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
          style: { "flex": "1", "width": "100%" }
        }, null, 40, _hoisted_2$6),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$4, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedInput = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
    const TYPED_INPUT_TYPES = [
      "msg",
      "flow",
      "global",
      "str",
      "num",
      "bool",
      "json",
      "bin",
      "re",
      "jsonata",
      "date",
      "env",
      "node",
      "cred"
    ];
    const _sfc_main$5 = {
      props: {
        value: {
          type: Object,
          required: true,
          validator: function(obj) {
            if (false) {
              console.warn("Prop 'value' must be an object.");
              return false;
            }
            const isValid = obj.hasOwnProperty("value") && obj.hasOwnProperty("type") && typeof obj.value === "string" && typeof obj.type === "string";
            if (!isValid) {
              console.warn(
                "Validation failed for prop 'value': It must be an object with 'value' and 'type' properties being strings.",
                obj
              );
            }
            return isValid;
          }
        },
        types: {
          type: Array,
          default: () => TYPED_INPUT_TYPES
        },
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      computed: {
        isProvidedValueTypeValid() {
          const type2 = this.value.type;
          const types2 = this.types;
          return types2.includes(type2);
        }
      },
      watch: {
        isProvidedValueTypeValid: {
          handler(newValue) {
            if (!newValue) {
              console.warn(
                `Validation failed: this.value.type (${this.value.type}) must be one of the provided types (${this.types}).`
              );
            }
          },
          immediate: true
        }
      },
      mounted() {
        const inputElement = this.$refs.typedInput;
        this.$input = $(inputElement).typedInput({
          default: this.value.type || this.types[0],
          types: this.types
        });
        this.$input.typedInput("value", this.value.value || "");
        this.$input.typedInput("type", this.value.type || this.types[0]);
        this.$nextTick(() => {
          const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.attributeName === "value") {
                this.onChange();
              }
            }
          });
          observer.observe(inputElement, {
            attributes: true,
            attributeFilter: ["value"]
          });
          this._observer = observer;
        });
        this.$input.on("change", () => {
          this.onChange();
        });
      },
      watch: {
        error(newVal) {
          this.$nextTick(() => {
            const targetDiv = this.$el.querySelector(
              ".red-ui-typedInput-container"
            );
            if (newVal) {
              targetDiv.classList.add("input-error");
            } else {
              targetDiv.classList.remove("input-error");
            }
          });
        }
      },
      methods: {
        onChange() {
          const newValue = this.$input.typedInput("value");
          const newType = this.$input.typedInput("type");
          if (this.value.value !== newValue || this.value.type !== newType) {
            this.$emit("update:value", {
              value: newValue,
              type: newType
            });
          }
        }
      }
    };
    const _hoisted_1$5 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$5 = {
      type: "text",
      ref: "typedInput",
      class: "node-red-typed-input",
      style: { "flex": "1", "width": "100%" }
    };
    const _hoisted_3$3 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        createBaseVNode("input", _hoisted_2$5, null, 512),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$3, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedTypedInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
    const _sfc_main$4 = {
      props: {
        value: String,
        type: String,
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      computed: {
        inputPrefix() {
          return "node-input-" + Math.random().toString(36).substring(2, 9);
        },
        inputId() {
          return this.inputPrefix + "-" + this.value;
        }
      },
      mounted() {
        RED.editor.prepareConfigNodeSelect(
          this,
          this.value,
          this.type,
          this.inputPrefix
        );
        const input = $("#" + this.inputId);
        input.on("change", () => {
          this.$emit("update:value", input.val());
        });
        input.val(this.value || "_ADD_");
      }
    };
    const _hoisted_1$4 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$4 = ["id"];
    const _hoisted_3$2 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("input", {
          type: "text",
          id: $options.inputId,
          style: { "width": "100%" }
        }, null, 8, _hoisted_2$4),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$2, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedConfigInput = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
    const _sfc_main$3 = {
      props: {
        value: String | Array,
        options: {
          type: Array,
          required: true,
          validator: function(value) {
            if (!Array.isArray(value)) {
              console.warn("Prop 'options' must be an array.");
              return false;
            }
            const isValid = value.every((item) => {
              const isObject2 = typeof item === "object" && item !== null;
              if (!isObject2) return false;
              return item.hasOwnProperty("value") && item.hasOwnProperty("label") && typeof item.value === "string" && typeof item.label === "string";
            });
            if (!isValid) {
              console.warn(
                "Validation failed for prop 'options': Each item must be an object with 'value' and 'label' properties being strings.",
                value
              );
            }
            return isValid;
          }
        },
        multiple: {
          type: Boolean,
          default: false
        },
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      mounted() {
        const inputElement = this.$refs.selectInput;
        const $selectInput = $(inputElement);
        $selectInput.typedInput({
          types: [
            {
              multiple: this.multiple,
              options: this.options
            }
          ]
        });
        $selectInput.typedInput(
          "value",
          Array.isArray(this.value) ? this.value.join(",") : this.value
        );
        $selectInput.on("change", () => {
          var _a;
          const newValue = this.multiple ? (_a = $selectInput.typedInput("value")) == null ? void 0 : _a.split(",") : $selectInput.typedInput("value");
          this.$emit("update:value", newValue);
        });
      }
    };
    const _hoisted_1$3 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$3 = {
      type: "text",
      ref: "selectInput",
      class: "node-input-select",
      style: { "width": "100%" }
    };
    const _hoisted_3$1 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("input", _hoisted_2$3, null, 512),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$1, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
    const _sfc_main$2 = {
      props: {
        value: String,
        language: {
          type: String,
          default: "json",
          validator: function(value) {
            const allowedLanguages = [
              "text",
              "json",
              "javascript",
              "html",
              "css",
              "markdown",
              "sql",
              "yaml"
            ];
            const isValid = allowedLanguages.includes(value);
            if (!isValid) {
              console.warn(
                `[NodeRedEditorComponent] Invalid ACE editor mode prop: "${value}". Expected one of: ${allowedLanguages.join(", ")}`
              );
            }
            return isValid;
          }
        },
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      editor: null,
      data() {
        return {
          editorId: "node-red-editor-" + Math.random().toString(36).substring(2, 9)
        };
      },
      mounted() {
        this.mountEditor();
      },
      methods: {
        mountEditor() {
          this.$nextTick(() => {
            const containerEl = this.$refs.containerDiv;
            const editorEl = this.$refs.editorDiv;
            if (containerEl && editorEl) {
              try {
                const inlineHeight = containerEl.style.height;
                const inlineWidth = containerEl.style.width;
                if (inlineHeight) {
                  editorEl.style.height = inlineHeight;
                } else {
                  editorEl.style.height = "200px";
                }
                if (inlineWidth) {
                  editorEl.style.width = inlineWidth;
                } else {
                  editorEl.style.width = "100%";
                }
                this.createEditorInstance();
              } catch (e) {
                console.error(
                  "[NodeRedEditorInput] Error setting initial editor style:",
                  e
                );
                this.createEditorInstance();
              }
            } else {
              console.error(
                "[NodeRedEditorInput] Container or Editor div refs not found on mount."
              );
            }
          });
        },
        createEditorInstance() {
          this.editorInstance = RED.editor.createEditor({
            id: this.editorId,
            mode: this.language,
            value: this.value
          });
          this.editorInstance.getSession().on("change", () => {
            const currentValue = this.editorInstance.getValue();
            if (currentValue !== this.value) {
              this.$emit("update:value", currentValue);
            }
          });
        }
      },
      beforeUnmount() {
        if (this.editorInstance) {
          try {
            this.editorInstance.destroy();
          } catch (err) {
            console.error(`Error destroying editor for ID ${this.editorId}:`, err);
          }
          this.editorInstance = null;
        }
      }
    };
    const _hoisted_1$2 = {
      ref: "containerDiv",
      class: "node-text-editor-container"
    };
    const _hoisted_2$2 = ["id"];
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("div", {
          ref: "editorDiv",
          id: $data.editorId,
          class: "node-text-editor"
        }, null, 8, _hoisted_2$2),
        withDirectives(createBaseVNode("div", { class: "node-red-vue-input-error-message" }, toDisplayString($props.error), 513), [
          [vShow, $props.error]
        ])
      ], 512);
    }
    const NodeRedEditorInput = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
    function createNodeRedVueApp(node, form2, validator) {
      const app = createApp(NodeRedVueApp, {
        node,
        validator
      });
      app.component("NodeRedInput", NodeRedInput);
      app.component("NodeRedTypedInput", NodeRedTypedInput);
      app.component("NodeRedConfigInput", NodeRedConfigInput);
      app.component("NodeRedSelectInput", NodeRedSelectInput);
      app.component("NodeRedEditorInput", NodeRedEditorInput);
      app.component("NodeRedNodeForm", form2);
      return app;
    }
    function mountApp(node, form2, validator) {
      $$1("#app").empty();
      node._newState = cloneDeep(node);
      node._app = createNodeRedVueApp(node._newState, form2, validator);
      node._app.mount("#app");
    }
    function unmountApp(node) {
      if (node._app) {
        node._app.unmount();
        node._app = null;
      }
    }
    function getNodeState(node) {
      const state = {
        credentials: {}
      };
      Object.keys(node._def.defaults).forEach((prop) => {
        state[prop] = node[prop];
      });
      Object.keys(node._def.credentials).forEach((prop) => {
        state.credentials[prop] = node.credentials[prop];
        if (node._def.credentials[prop].type === "password") {
          state.credentials[`has_${prop}`] = node.credentials[`has_${prop}`] || false;
        }
      });
      return state;
    }
    function getChanges(o, n) {
      const changes = {};
      Object.keys(o).forEach((prop) => {
        const _o = o[prop];
        const _n = n[prop];
        if (typeof _o === "object") {
          const _changes = getChanges(_o, _n);
          if (Object.keys(_changes).length) {
            changes[prop] = _changes;
          }
        } else if (!isEqual(_o, _n)) {
          changes[prop] = _o;
        }
      });
      return changes;
    }
    function registerType(options) {
      return async function(type2) {
        try {
          const response = await fetch(`/nrg/nodes/${type2}`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const { schema } = await response.json();
          const defaults2 = getDefaultsFromSchema(schema);
          if (defaults2.credentials) delete defaults2.credentials;
          const credentials = getCredentialsFromSchema(
            schema.properties.credentials
          );
          console.log("defaults", defaults2);
          console.log("credentials", credentials);
          RED.nodes.registerType(type2, {
            ...options,
            defaults: defaults2,
            credentials,
            type: type2,
            label: function() {
              return this.name;
            },
            oneditprepare: function() {
              const validator = validatorService.createValidator(schema);
              mountApp(this, options.form, validator);
            },
            oneditsave: function() {
              var _a;
              const node = this;
              unmountApp(node);
              const newState = getNodeState(node._newState);
              const oldState = getNodeState(node);
              const changes = getChanges(oldState, newState);
              const changed = !!((_a = Object.keys(changes)) == null ? void 0 : _a.length);
              if (!changed) return false;
              Object.keys(node._def.defaults).forEach((prop) => {
                var _a2, _b;
                if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
                  const oldConfigNodeId = node[prop];
                  const newConfigNodeId = node._newState[prop];
                  if (oldConfigNodeId !== newConfigNodeId) {
                    const oldConfigNode = RED.nodes.node(oldConfigNodeId);
                    if (oldConfigNode && oldConfigNode._def.category === "config") {
                      const parentNodeIndex = oldConfigNode.users.findIndex(
                        (_node) => _node.id === node.id
                      );
                      if (parentNodeIndex !== -1) {
                        oldConfigNode.users.splice(parentNodeIndex, 1);
                      }
                    }
                  }
                }
              });
              Object.keys(node._def.defaults).forEach((prop) => {
                var _a2, _b;
                if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
                  const newStateConfigNodeId = node._newState[prop];
                  const newStateConfigNode = RED.nodes.node(newStateConfigNodeId);
                  if (newStateConfigNode && newStateConfigNode._def.category === "config") {
                    const parentNodeIndex = newStateConfigNode.users.findIndex(
                      (_node) => _node.id === node.id
                    );
                    if (parentNodeIndex === -1) {
                      newStateConfigNode.users.push(node);
                    }
                  }
                }
              });
              merge(node, newState);
              return {
                changed,
                history: [
                  {
                    t: "edit",
                    node,
                    changes,
                    links: [],
                    dirty: RED.nodes.dirty(),
                    changed
                  }
                ]
              };
            },
            oneditcancel: function() {
              unmountApp(this);
            },
            oneditdelete: function() {
              unmountApp(this);
            },
            onpaletteadd: options.onPaletteAdd,
            onpaltteremove: options.onPaletteRemove
          });
        } catch (error) {
          console.error(`Error fetching node type ${type2}:`, error);
          throw error;
        }
      };
    }
    const _sfc_main$1 = {
      name: "NodeRedNodeForm",
      props: {
        node: {
          type: Object,
          required: true
        },
        errors: {
          type: Object,
          default: () => ({})
        }
      }
    };
    const _hoisted_1$1 = { class: "form-row" };
    const _hoisted_2$1 = { class: "form-row" };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_NodeRedInput = resolveComponent("NodeRedInput");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$1, [
          _cache[2] || (_cache[2] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Name")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.name,
            "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.name = $event),
            error: $props.errors["node.name"],
            placeholder: "name"
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_2$1, [
          _cache[3] || (_cache[3] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Hostname")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.host,
            "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.host = $event),
            error: $props.errors["node.host"],
            placeholder: "hostname"
          }, null, 8, ["value", "error"])
        ])
      ]);
    }
    const form$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
    const remoteServer = registerType({
      category: "config",
      color: "#a6bbcf",
      form: form$1
    });
    const _sfc_main = {
      name: "NodeRedNodeForm",
      props: {
        node: {
          type: Object,
          required: true
        },
        errors: {
          type: Object,
          default: () => ({})
        }
      },
      data() {
        return {
          types: ["str", "msg", "node"],
          countries: [
            { value: "usa", label: "usa" },
            { value: "argentina", label: "argentina" },
            { value: "brasil", label: "brasil" }
          ],
          fruits: [
            { value: "apple", label: "apple" },
            { value: "melon", label: "melon" },
            { value: "raspberry", label: "raspberry" }
          ],
          numbers: [
            { value: "1", label: "1" },
            { value: "2", label: "2" },
            { value: "3", label: "3" }
          ],
          objects: [
            { value: JSON.stringify({ test: "a" }), label: "a" },
            { value: JSON.stringify({ test: "b" }), label: "b" },
            { value: JSON.stringify({ test: "c" }), label: "c" }
          ],
          arrays: [
            { value: JSON.stringify(["a"]), label: "a" },
            { value: JSON.stringify(["b"]), label: "b" },
            { value: JSON.stringify(["c"]), label: "c" }
          ]
        };
      }
    };
    const _hoisted_1 = { class: "form-row" };
    const _hoisted_2 = { class: "form-row" };
    const _hoisted_3 = { class: "form-row" };
    const _hoisted_4 = { class: "form-row" };
    const _hoisted_5 = { class: "form-row" };
    const _hoisted_6 = { class: "form-row" };
    const _hoisted_7 = { class: "form-row" };
    const _hoisted_8 = { class: "form-row" };
    const _hoisted_9 = { class: "form-row" };
    const _hoisted_10 = { class: "form-row" };
    const _hoisted_11 = { class: "form-row" };
    const _hoisted_12 = { class: "form-row" };
    const _hoisted_13 = { class: "form-row" };
    const _hoisted_14 = { class: "form-row" };
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_NodeRedInput = resolveComponent("NodeRedInput");
      const _component_NodeRedTypedInput = resolveComponent("NodeRedTypedInput");
      const _component_NodeRedConfigInput = resolveComponent("NodeRedConfigInput");
      const _component_NodeRedSelectInput = resolveComponent("NodeRedSelectInput");
      const _component_NodeRedEditorInput = resolveComponent("NodeRedEditorInput");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1, [
          _cache[14] || (_cache[14] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Username")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.credentials.username,
            "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.credentials.username = $event),
            error: $props.errors["node.credentials.username"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_2, [
          _cache[15] || (_cache[15] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Password")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.credentials.password,
            "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.credentials.password = $event),
            type: "password",
            error: $props.errors["node.credentials.password"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_3, [
          _cache[16] || (_cache[16] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Password 2")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.credentials.password2,
            "onUpdate:value": _cache[2] || (_cache[2] = ($event) => $props.node.credentials.password2 = $event),
            type: "password",
            error: $props.errors["node.credentials.password2"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_4, [
          _cache[17] || (_cache[17] = createBaseVNode("label", null, "Typed Input", -1)),
          createVNode(_component_NodeRedTypedInput, {
            value: $props.node.myProperty,
            "onUpdate:value": _cache[3] || (_cache[3] = ($event) => $props.node.myProperty = $event),
            types: $data.types,
            error: $props.errors["node.myProperty"]
          }, null, 8, ["value", "types", "error"])
        ]),
        createBaseVNode("div", _hoisted_5, [
          _cache[18] || (_cache[18] = createBaseVNode("label", null, "Typed Input 2", -1)),
          createVNode(_component_NodeRedTypedInput, {
            value: $props.node.myProperty2,
            "onUpdate:value": _cache[4] || (_cache[4] = ($event) => $props.node.myProperty2 = $event),
            error: $props.errors["node.myProperty2"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_6, [
          _cache[19] || (_cache[19] = createBaseVNode("label", null, "Config Input", -1)),
          createVNode(_component_NodeRedConfigInput, {
            value: $props.node.remoteServer,
            "onUpdate:value": _cache[5] || (_cache[5] = ($event) => $props.node.remoteServer = $event),
            type: "remote-server",
            error: $props.errors["node.remoteServer"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_7, [
          _cache[20] || (_cache[20] = createBaseVNode("label", null, "Config Input", -1)),
          createVNode(_component_NodeRedConfigInput, {
            value: $props.node.anotherRemoteServer,
            "onUpdate:value": _cache[6] || (_cache[6] = ($event) => $props.node.anotherRemoteServer = $event),
            type: "remote-server",
            error: $props.errors["node.anotherRemoteServer"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_8, [
          _cache[21] || (_cache[21] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.country,
            "onUpdate:value": _cache[7] || (_cache[7] = ($event) => $props.node.country = $event),
            options: $data.countries,
            error: $props.errors["node.country"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_9, [
          _cache[22] || (_cache[22] = createBaseVNode("label", null, "MultiSelect Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.fruit,
            "onUpdate:value": _cache[8] || (_cache[8] = ($event) => $props.node.fruit = $event),
            options: $data.fruits,
            multiple: "",
            error: $props.errors["node.fruit"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_10, [
          _cache[23] || (_cache[23] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.number,
            "onUpdate:value": _cache[9] || (_cache[9] = ($event) => $props.node.number = $event),
            options: $data.numbers,
            error: $props.errors["node.number"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_11, [
          _cache[24] || (_cache[24] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.object,
            "onUpdate:value": _cache[10] || (_cache[10] = ($event) => $props.node.object = $event),
            options: $data.objects,
            multiple: "",
            error: $props.errors["node.object"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_12, [
          _cache[25] || (_cache[25] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.array,
            "onUpdate:value": _cache[11] || (_cache[11] = ($event) => $props.node.array = $event),
            options: $data.arrays,
            error: $props.errors["node.array"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_13, [
          _cache[26] || (_cache[26] = createBaseVNode("label", null, "Editor with default height 200px and JSON", -1)),
          createVNode(_component_NodeRedEditorInput, {
            value: $props.node.jsontest,
            "onUpdate:value": _cache[12] || (_cache[12] = ($event) => $props.node.jsontest = $event),
            error: $props.errors["node.jsontest"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_14, [
          _cache[27] || (_cache[27] = createBaseVNode("label", null, "Editor with custom height and CSS", -1)),
          createVNode(_component_NodeRedEditorInput, {
            value: $props.node.csstest,
            "onUpdate:value": _cache[13] || (_cache[13] = ($event) => $props.node.csstest = $event),
            language: "css",
            style: { "height": "100px" },
            error: $props.errors["node.csstest"]
          }, null, 8, ["value", "error"])
        ])
      ]);
    }
    const form = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
    const yourNode = registerType({
      category: "function",
      color: "#FFFFFF",
      inputs: 1,
      outputs: 1,
      icon: "vue.png",
      form,
      onPaletteAdd: () => {
        console.log("NODE TYPE REGISTERED ON THE PALETTE");
      }
    });
    async function registerNodes() {
      try {
        await Promise.all([remoteServer("remote-server"), yourNode("your-node")]);
        console.log("All node types registered in parallel");
      } catch (error) {
        console.error("Error registering node types:", error);
      }
    }
    registerNodes();
  })($);
  //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnJnLkJYekk0RVJDLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2Z1bmN0aW9uL25vb3AubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNQcmltaXRpdmUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNUeXBlZEFycmF5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L19pbnRlcm5hbC9nZXRTeW1ib2xzLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L19pbnRlcm5hbC9nZXRUYWcubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvX2ludGVybmFsL3RhZ3MubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9vYmplY3QvY2xvbmVEZWVwV2l0aC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9jbG9uZURlZXAubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNQbGFpbk9iamVjdC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9tZXJnZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC91dGlsL2VxLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzRXF1YWxXaXRoLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzRXF1YWwubWpzIiwiLi4vc3JjL2NvcmUvdXRpbHMudHMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL3Njb3BlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3V0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9uYW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2Vycm9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2Jvb2xTY2hlbWEuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9ydWxlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RlZmF1bHRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUva2V5d29yZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL3N1YnNjaGVtYS5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZXNvbHZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVmX2Vycm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3Njb3BlZENoYXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3VyaS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2lkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL3JlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9tdWx0aXBsZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9wYXR0ZXJuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdEl0ZW1zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvZXF1YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vY29uc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZW51bS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2NvbnRhaW5zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0eU5hbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcGF0dGVyblByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL29uZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FsbE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3RoZW5FbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kcmFmdDcuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvdHlwZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvYWp2LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2xpbWl0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2LWVycm9ycy9kaXN0L2luZGV4LmpzIiwiLi4vc3JjL2NvcmUvdmFsaWRhdG9yLXNlcnZpY2UudHMiLCIuLi9zcmMvY29yZS92YWxpZGF0b3IudHMiLCIuLi9ub2RlX21vZHVsZXMvanNvbnBvaW50ZXIvanNvbnBvaW50ZXIuanMiLCIuLi9zcmMvY29yZS9BcHAudnVlIiwiLi4vc3JjL2NvcmUvY29tcG9uZW50cy9Ob2RlUmVkSW5wdXQudnVlIiwiLi4vc3JjL2NvcmUvY29uc3RhbnRzLnRzIiwiLi4vc3JjL2NvcmUvY29tcG9uZW50cy9Ob2RlUmVkVHlwZWRJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRDb25maWdJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRTZWxlY3RJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRFZGl0b3JJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9pbmRleC50cyIsIi4uL3NyYy9ub2Rlcy9yZW1vdGUtc2VydmVyL0Zvcm0udnVlIiwiLi4vc3JjL25vZGVzL3JlbW90ZS1zZXJ2ZXIvaW5kZXgudHMiLCIuLi9zcmMvbm9kZXMveW91ci1ub2RlL0Zvcm0udnVlIiwiLi4vc3JjL25vZGVzL3lvdXItbm9kZS9pbmRleC50cyIsIi4uL3NyYy9jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEB2dWUvc2hhcmVkIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBzdHIuc3BsaXQoXCIsXCIpKSBtYXBba2V5XSA9IDE7XG4gIHJldHVybiAodmFsKSA9PiB2YWwgaW4gbWFwO1xufVxuXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyB1cHBlcmNhc2UgbGV0dGVyXG4oa2V5LmNoYXJDb2RlQXQoMikgPiAxMjIgfHwga2V5LmNoYXJDb2RlQXQoMikgPCA5Nyk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIC8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbiAgXCIsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLG9uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZFwiXG4pO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbiAgfVxuKTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgY29uc3QgcyA9IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYDtcbiAgICByZXR1cm4gcztcbiAgfVxuKTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIC4uLmFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXSguLi5hcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSwgd3JpdGFibGUgPSBmYWxzZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGUsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cbmZ1bmN0aW9uIGdlbkNhY2hlS2V5KHNvdXJjZSwgb3B0aW9ucykge1xuICByZXR1cm4gc291cmNlICsgSlNPTi5zdHJpbmdpZnkoXG4gICAgb3B0aW9ucyxcbiAgICAoXywgdmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwudG9TdHJpbmcoKSA6IHZhbFxuICApO1xufVxuXG5jb25zdCBQYXRjaEZsYWdzID0ge1xuICBcIlRFWFRcIjogMSxcbiAgXCIxXCI6IFwiVEVYVFwiLFxuICBcIkNMQVNTXCI6IDIsXG4gIFwiMlwiOiBcIkNMQVNTXCIsXG4gIFwiU1RZTEVcIjogNCxcbiAgXCI0XCI6IFwiU1RZTEVcIixcbiAgXCJQUk9QU1wiOiA4LFxuICBcIjhcIjogXCJQUk9QU1wiLFxuICBcIkZVTExfUFJPUFNcIjogMTYsXG4gIFwiMTZcIjogXCJGVUxMX1BST1BTXCIsXG4gIFwiTkVFRF9IWURSQVRJT05cIjogMzIsXG4gIFwiMzJcIjogXCJORUVEX0hZRFJBVElPTlwiLFxuICBcIlNUQUJMRV9GUkFHTUVOVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlNUQUJMRV9GUkFHTUVOVFwiLFxuICBcIktFWUVEX0ZSQUdNRU5UXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJLRVlFRF9GUkFHTUVOVFwiLFxuICBcIlVOS0VZRURfRlJBR01FTlRcIjogMjU2LFxuICBcIjI1NlwiOiBcIlVOS0VZRURfRlJBR01FTlRcIixcbiAgXCJORUVEX1BBVENIXCI6IDUxMixcbiAgXCI1MTJcIjogXCJORUVEX1BBVENIXCIsXG4gIFwiRFlOQU1JQ19TTE9UU1wiOiAxMDI0LFxuICBcIjEwMjRcIjogXCJEWU5BTUlDX1NMT1RTXCIsXG4gIFwiREVWX1JPT1RfRlJBR01FTlRcIjogMjA0OCxcbiAgXCIyMDQ4XCI6IFwiREVWX1JPT1RfRlJBR01FTlRcIixcbiAgXCJDQUNIRURcIjogLTEsXG4gIFwiLTFcIjogXCJDQUNIRURcIixcbiAgXCJCQUlMXCI6IC0yLFxuICBcIi0yXCI6IFwiQkFJTFwiXG59O1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gIFsxXTogYFRFWFRgLFxuICBbMl06IGBDTEFTU2AsXG4gIFs0XTogYFNUWUxFYCxcbiAgWzhdOiBgUFJPUFNgLFxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXG4gIFszMl06IGBORUVEX0hZRFJBVElPTmAsXG4gIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXG4gIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgWy0xXTogYEhPSVNURURgLFxuICBbLTJdOiBgQkFJTGBcbn07XG5cbmNvbnN0IFNoYXBlRmxhZ3MgPSB7XG4gIFwiRUxFTUVOVFwiOiAxLFxuICBcIjFcIjogXCJFTEVNRU5UXCIsXG4gIFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIjogMixcbiAgXCIyXCI6IFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIixcbiAgXCJTVEFURUZVTF9DT01QT05FTlRcIjogNCxcbiAgXCI0XCI6IFwiU1RBVEVGVUxfQ09NUE9ORU5UXCIsXG4gIFwiVEVYVF9DSElMRFJFTlwiOiA4LFxuICBcIjhcIjogXCJURVhUX0NISUxEUkVOXCIsXG4gIFwiQVJSQVlfQ0hJTERSRU5cIjogMTYsXG4gIFwiMTZcIjogXCJBUlJBWV9DSElMRFJFTlwiLFxuICBcIlNMT1RTX0NISUxEUkVOXCI6IDMyLFxuICBcIjMyXCI6IFwiU0xPVFNfQ0hJTERSRU5cIixcbiAgXCJURUxFUE9SVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlRFTEVQT1JUXCIsXG4gIFwiU1VTUEVOU0VcIjogMTI4LFxuICBcIjEyOFwiOiBcIlNVU1BFTlNFXCIsXG4gIFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCI6IDI1NixcbiAgXCIyNTZcIjogXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIixcbiAgXCJDT01QT05FTlRfS0VQVF9BTElWRVwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIixcbiAgXCJDT01QT05FTlRcIjogNixcbiAgXCI2XCI6IFwiQ09NUE9ORU5UXCJcbn07XG5cbmNvbnN0IFNsb3RGbGFncyA9IHtcbiAgXCJTVEFCTEVcIjogMSxcbiAgXCIxXCI6IFwiU1RBQkxFXCIsXG4gIFwiRFlOQU1JQ1wiOiAyLFxuICBcIjJcIjogXCJEWU5BTUlDXCIsXG4gIFwiRk9SV0FSREVEXCI6IDMsXG4gIFwiM1wiOiBcIkZPUldBUkRFRFwiXG59O1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgWzFdOiBcIlNUQUJMRVwiLFxuICBbMl06IFwiRFlOQU1JQ1wiLFxuICBbM106IFwiRk9SV0FSREVEXCJcbn07XG5cbmNvbnN0IEdMT0JBTFNfQUxMT1dFRCA9IFwiSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LGNvbnNvbGUsRXJyb3IsU3ltYm9sXCI7XG5jb25zdCBpc0dsb2JhbGx5QWxsb3dlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfQUxMT1dFRCk7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSBpc0dsb2JhbGx5QWxsb3dlZDtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCwgc291cmNlLmxlbmd0aCkpO1xuICBlbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlbmQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gXCJcIjtcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGggfHwgMCk7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgcmVzLnB1c2goXG4gICAgICAgICAgYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gbmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCIgXCIucmVwZWF0KHBhZCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooW15dKykvO1xuY29uc3Qgc3R5bGVDb21tZW50UkUgPSAvXFwvXFwqW15dKj9cXCpcXC8vZztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY3NzVGV4dC5yZXBsYWNlKHN0eWxlQ29tbWVudFJFLCBcIlwiKS5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gIGlmICghc3R5bGVzKSByZXR1cm4gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHN0eWxlcykpIHJldHVybiBzdHlsZXM7XG4gIGxldCByZXQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXMgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xuICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbmNvbnN0IEhUTUxfVEFHUyA9IFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LHN1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3RcIjtcbmNvbnN0IFNWR19UQUdTID0gXCJzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlcixmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLGZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCxmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLGZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzayxtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXdcIjtcbmNvbnN0IE1BVEhfVEFHUyA9IFwiYW5ub3RhdGlvbixhbm5vdGF0aW9uLXhtbCxtYWN0aW9uLG1hbGlnbmdyb3VwLG1hbGlnbm1hcmssbWF0aCxtZW5jbG9zZSxtZXJyb3IsbWZlbmNlZCxtZnJhYyxtZnJhY3Rpb24sbWdseXBoLG1pLG1sYWJlbGVkdHIsbWxvbmdkaXYsbW11bHRpc2NyaXB0cyxtbixtbyxtb3ZlcixtcGFkZGVkLG1waGFudG9tLG1wcmVzY3JpcHRzLG1yb290LG1yb3csbXMsbXNjYXJyaWVzLG1zY2FycnksbXNncm91cCxtc2xpbmUsbXNwYWNlLG1zcXJ0LG1zcm93LG1zdGFjayxtc3R5bGUsbXN1Yixtc3Vic3VwLG1zdXAsbXRhYmxlLG10ZCxtdGV4dCxtdHIsbXVuZGVyLG11bmRlcm92ZXIsbm9uZSxzZW1hbnRpY3NcIjtcbmNvbnN0IFZPSURfVEFHUyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIjtcbmNvbnN0IGlzSFRNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG5jb25zdCBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcbmNvbnN0IGlzTWF0aE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoTUFUSF9UQUdTKTtcbmNvbnN0IGlzVm9pZFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixpbmVydCxsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgXG4pO1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSBcIlwiO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICB9XG4gIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xuICBpZiAoaXNVbnNhZmUpIHtcbiAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgfVxuICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZTtcbn1cbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xuICBhY2NlcHRDaGFyc2V0OiBcImFjY2VwdC1jaGFyc2V0XCIsXG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiLFxuICBodHRwRXF1aXY6IFwiaHR0cC1lcXVpdlwiXG59O1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGluZXJ0LGludGVncml0eSxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcGBcbik7XG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxyZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxyZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2Usc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyx3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbG5zOnhsaW5rLHhtbDpiYXNlLHhtbDpsYW5nLHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYFxuKTtcbmNvbnN0IGlzS25vd25NYXRoTUxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlbnQsYWNjZW50dW5kZXIsYWN0aW9udHlwZSxhbGlnbixhbGlnbm1lbnRzY29wZSxhbHRpbWcsYWx0aW1nLWhlaWdodCxhbHRpbWctdmFsaWduLGFsdGltZy13aWR0aCxhbHR0ZXh0LGJldmVsbGVkLGNsb3NlLGNvbHVtbnNhbGlnbixjb2x1bW5saW5lcyxjb2x1bW5zcGFuLGRlbm9tYWxpZ24sZGVwdGgsZGlyLGRpc3BsYXksZGlzcGxheXN0eWxlLGVuY29kaW5nLGVxdWFsY29sdW1ucyxlcXVhbHJvd3MsZmVuY2UsZm9udHN0eWxlLGZvbnR3ZWlnaHQsZm9ybSxmcmFtZSxmcmFtZXNwYWNpbmcsZ3JvdXBhbGlnbixoZWlnaHQsaHJlZixpZCxpbmRlbnRhbGlnbixpbmRlbnRhbGlnbmZpcnN0LGluZGVudGFsaWdubGFzdCxpbmRlbnRzaGlmdCxpbmRlbnRzaGlmdGZpcnN0LGluZGVudHNoaWZ0bGFzdCxpbmRleHR5cGUsanVzdGlmeSxsYXJnZXRvcCxsYXJnZW9wLGxxdW90ZSxsc3BhY2UsbWF0aGJhY2tncm91bmQsbWF0aGNvbG9yLG1hdGhzaXplLG1hdGh2YXJpYW50LG1heHNpemUsbWlubGFiZWxzcGFjaW5nLG1vZGUsb3RoZXIsb3ZlcmZsb3cscG9zaXRpb24scm93YWxpZ24scm93bGluZXMscm93c3BhbixycXVvdGUscnNwYWNlLHNjcmlwdGxldmVsLHNjcmlwdG1pbnNpemUsc2NyaXB0c2l6ZW11bHRpcGxpZXIsc2VsZWN0aW9uLHNlcGFyYXRvcixzZXBhcmF0b3JzLHNoaWZ0LHNpZGUsc3JjLHN0YWNrYWxpZ24sc3RyZXRjaHksc3Vic2NyaXB0c2hpZnQsc3VwZXJzY3JpcHRzaGlmdCxzeW1tZXRyaWMsdm9mZnNldCx3aWR0aCx3aWR0aHMseGxpbms6aHJlZix4bGluazpzaG93LHhsaW5rOnR5cGUseG1sbnNgXG4pO1xuZnVuY3Rpb24gaXNSZW5kZXJhYmxlQXR0clZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5jb25zdCBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFID0gL1sgIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXFxdXmB7fH1+XS9nO1xuZnVuY3Rpb24gZ2V0RXNjYXBlZENzc1Zhck5hbWUoa2V5LCBkb3VibGVFc2NhcGUpIHtcbiAgcmV0dXJuIGtleS5yZXBsYWNlKFxuICAgIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsXG4gICAgKHMpID0+IGRvdWJsZUVzY2FwZSA/IHMgPT09ICdcIicgPyAnXFxcXFxcXFxcXFxcXCInIDogYFxcXFxcXFxcJHtzfWAgOiBgXFxcXCR7c31gXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuY29uc3QgaXNSZWYgPSAodmFsKSA9PiB7XG4gIHJldHVybiAhISh2YWwgJiYgdmFsW1wiX192X2lzUmVmXCJdID09PSB0cnVlKTtcbn07XG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBpc1JlZih2YWwpID8gdG9EaXNwbGF5U3RyaW5nKHZhbC52YWx1ZSkgOiBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAoaXNSZWYodmFsKSkge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoXG4gICAgICAgIChlbnRyaWVzLCBba2V5LCB2YWwyXSwgaSkgPT4ge1xuICAgICAgICAgIGVudHJpZXNbc3RyaW5naWZ5U3ltYm9sKGtleSwgaSkgKyBcIiA9PlwiXSA9IHZhbDI7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXS5tYXAoKHYpID0+IHN0cmluZ2lmeVN5bWJvbCh2KSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU3ltYm9sKHZhbCkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3ltYm9sKHZhbCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5jb25zdCBzdHJpbmdpZnlTeW1ib2wgPSAodiwgaSA9IFwiXCIpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKFxuICAgIC8vIFN5bWJvbC5kZXNjcmlwdGlvbiBpbiBlczIwMTkrIHNvIHdlIG5lZWQgdG8gY2FzdCBoZXJlIHRvIHBhc3NcbiAgICAvLyB0aGUgbGliOiBlczIwMTYgY2hlY2tcbiAgICBpc1N5bWJvbCh2KSA/IGBTeW1ib2woJHsoX2EgPSB2LmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBpfSlgIDogdlxuICApO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgUGF0Y2hGbGFncywgU2hhcGVGbGFncywgU2xvdEZsYWdzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5DYWNoZUtleSwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRFc2NhcGVkQ3NzVmFyTmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5QWxsb3dlZCwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duTWF0aE1MQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01hdGhNTFRhZywgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwiLyoqXG4qIEB2dWUvcmVhY3Rpdml0eSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBoYXNDaGFuZ2VkLCBleHRlbmQsIGlzQXJyYXksIGlzSW50ZWdlcktleSwgaXNTeW1ib2wsIGlzTWFwLCBoYXNPd24sIGlzT2JqZWN0LCBtYWtlTWFwLCB0b1Jhd1R5cGUsIGNhcGl0YWxpemUsIGRlZiwgaXNGdW5jdGlvbiwgRU1QVFlfT0JKLCBpc1NldCwgaXNQbGFpbk9iamVjdCwgTk9PUCwgcmVtb3ZlIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgdGhpcy5pbmRleCA9IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaChcbiAgICAgICAgdGhpc1xuICAgICAgKSAtIDE7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5zY29wZXNbaV0ucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIHRoZSBlZmZlY3Qgc2NvcGUsIGluY2x1ZGluZyBhbGwgY2hpbGQgc2NvcGVzIGFuZCBlZmZlY3RzLlxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSwgbDtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zY29wZXNbaV0ucmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJ1bihmbikge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb24oKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2ZmKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFudXBzLmxlbmd0aCA9IDA7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcbiAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuXG5sZXQgYWN0aXZlU3ViO1xuY29uc3QgRWZmZWN0RmxhZ3MgPSB7XG4gIFwiQUNUSVZFXCI6IDEsXG4gIFwiMVwiOiBcIkFDVElWRVwiLFxuICBcIlJVTk5JTkdcIjogMixcbiAgXCIyXCI6IFwiUlVOTklOR1wiLFxuICBcIlRSQUNLSU5HXCI6IDQsXG4gIFwiNFwiOiBcIlRSQUNLSU5HXCIsXG4gIFwiTk9USUZJRURcIjogOCxcbiAgXCI4XCI6IFwiTk9USUZJRURcIixcbiAgXCJESVJUWVwiOiAxNixcbiAgXCIxNlwiOiBcIkRJUlRZXCIsXG4gIFwiQUxMT1dfUkVDVVJTRVwiOiAzMixcbiAgXCIzMlwiOiBcIkFMTE9XX1JFQ1VSU0VcIixcbiAgXCJQQVVTRURcIjogNjQsXG4gIFwiNjRcIjogXCJQQVVTRURcIlxufTtcbmNvbnN0IHBhdXNlZFF1ZXVlRWZmZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY2xhc3MgUmVhY3RpdmVFZmZlY3Qge1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmZsYWdzID0gMSB8IDQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuY2xlYW51cCA9IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHZvaWQgMDtcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUgJiYgYWN0aXZlRWZmZWN0U2NvcGUuYWN0aXZlKSB7XG4gICAgICBhY3RpdmVFZmZlY3RTY29wZS5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgfVxuICB9XG4gIHBhdXNlKCkge1xuICAgIHRoaXMuZmxhZ3MgfD0gNjQ7XG4gIH1cbiAgcmVzdW1lKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgNjQpIHtcbiAgICAgIHRoaXMuZmxhZ3MgJj0gfjY0O1xuICAgICAgaWYgKHBhdXNlZFF1ZXVlRWZmZWN0cy5oYXModGhpcykpIHtcbiAgICAgICAgcGF1c2VkUXVldWVFZmZlY3RzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeSgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDIgJiYgISh0aGlzLmZsYWdzICYgMzIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHRoaXMuZmxhZ3MgJiA4KSkge1xuICAgICAgYmF0Y2godGhpcyk7XG4gICAgfVxuICB9XG4gIHJ1bigpIHtcbiAgICBpZiAoISh0aGlzLmZsYWdzICYgMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfVxuICAgIHRoaXMuZmxhZ3MgfD0gMjtcbiAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgIHByZXBhcmVEZXBzKHRoaXMpO1xuICAgIGNvbnN0IHByZXZFZmZlY3QgPSBhY3RpdmVTdWI7XG4gICAgY29uc3QgcHJldlNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gICAgYWN0aXZlU3ViID0gdGhpcztcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1YiAhPT0gdGhpcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiQWN0aXZlIGVmZmVjdCB3YXMgbm90IHJlc3RvcmVkIGNvcnJlY3RseSAtIHRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFsIGJ1Zy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2xlYW51cERlcHModGhpcyk7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2RWZmZWN0O1xuICAgICAgc2hvdWxkVHJhY2sgPSBwcmV2U2hvdWxkVHJhY2s7XG4gICAgICB0aGlzLmZsYWdzICY9IH4yO1xuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgMSkge1xuICAgICAgZm9yIChsZXQgbGluayA9IHRoaXMuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgICAgICByZW1vdmVTdWIobGluayk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlcHMgPSB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICAgIHRoaXMub25TdG9wICYmIHRoaXMub25TdG9wKCk7XG4gICAgICB0aGlzLmZsYWdzICY9IH4xO1xuICAgIH1cbiAgfVxuICB0cmlnZ2VyKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgNjQpIHtcbiAgICAgIHBhdXNlZFF1ZXVlRWZmZWN0cy5hZGQodGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zY2hlZHVsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydW5JZkRpcnR5KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJ1bklmRGlydHkoKSB7XG4gICAgaWYgKGlzRGlydHkodGhpcykpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICB9XG4gIGdldCBkaXJ0eSgpIHtcbiAgICByZXR1cm4gaXNEaXJ0eSh0aGlzKTtcbiAgfVxufVxubGV0IGJhdGNoRGVwdGggPSAwO1xubGV0IGJhdGNoZWRTdWI7XG5sZXQgYmF0Y2hlZENvbXB1dGVkO1xuZnVuY3Rpb24gYmF0Y2goc3ViLCBpc0NvbXB1dGVkID0gZmFsc2UpIHtcbiAgc3ViLmZsYWdzIHw9IDg7XG4gIGlmIChpc0NvbXB1dGVkKSB7XG4gICAgc3ViLm5leHQgPSBiYXRjaGVkQ29tcHV0ZWQ7XG4gICAgYmF0Y2hlZENvbXB1dGVkID0gc3ViO1xuICAgIHJldHVybjtcbiAgfVxuICBzdWIubmV4dCA9IGJhdGNoZWRTdWI7XG4gIGJhdGNoZWRTdWIgPSBzdWI7XG59XG5mdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICBiYXRjaERlcHRoKys7XG59XG5mdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgaWYgKC0tYmF0Y2hEZXB0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJhdGNoZWRDb21wdXRlZCkge1xuICAgIGxldCBlID0gYmF0Y2hlZENvbXB1dGVkO1xuICAgIGJhdGNoZWRDb21wdXRlZCA9IHZvaWQgMDtcbiAgICB3aGlsZSAoZSkge1xuICAgICAgY29uc3QgbmV4dCA9IGUubmV4dDtcbiAgICAgIGUubmV4dCA9IHZvaWQgMDtcbiAgICAgIGUuZmxhZ3MgJj0gfjg7XG4gICAgICBlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgbGV0IGVycm9yO1xuICB3aGlsZSAoYmF0Y2hlZFN1Yikge1xuICAgIGxldCBlID0gYmF0Y2hlZFN1YjtcbiAgICBiYXRjaGVkU3ViID0gdm9pZCAwO1xuICAgIHdoaWxlIChlKSB7XG4gICAgICBjb25zdCBuZXh0ID0gZS5uZXh0O1xuICAgICAgZS5uZXh0ID0gdm9pZCAwO1xuICAgICAgZS5mbGFncyAmPSB+ODtcbiAgICAgIGlmIChlLmZsYWdzICYgMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBlLnRyaWdnZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUgPSBuZXh0O1xuICAgIH1cbiAgfVxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gcHJlcGFyZURlcHMoc3ViKSB7XG4gIGZvciAobGV0IGxpbmsgPSBzdWIuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgIGxpbmsudmVyc2lvbiA9IC0xO1xuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSBsaW5rLmRlcC5hY3RpdmVMaW5rO1xuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRGVwcyhzdWIpIHtcbiAgbGV0IGhlYWQ7XG4gIGxldCB0YWlsID0gc3ViLmRlcHNUYWlsO1xuICBsZXQgbGluayA9IHRhaWw7XG4gIHdoaWxlIChsaW5rKSB7XG4gICAgY29uc3QgcHJldiA9IGxpbmsucHJldkRlcDtcbiAgICBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xuICAgICAgaWYgKGxpbmsgPT09IHRhaWwpIHRhaWwgPSBwcmV2O1xuICAgICAgcmVtb3ZlU3ViKGxpbmspO1xuICAgICAgcmVtb3ZlRGVwKGxpbmspO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gbGluaztcbiAgICB9XG4gICAgbGluay5kZXAuYWN0aXZlTGluayA9IGxpbmsucHJldkFjdGl2ZUxpbms7XG4gICAgbGluay5wcmV2QWN0aXZlTGluayA9IHZvaWQgMDtcbiAgICBsaW5rID0gcHJldjtcbiAgfVxuICBzdWIuZGVwcyA9IGhlYWQ7XG4gIHN1Yi5kZXBzVGFpbCA9IHRhaWw7XG59XG5mdW5jdGlvbiBpc0RpcnR5KHN1Yikge1xuICBmb3IgKGxldCBsaW5rID0gc3ViLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICBpZiAobGluay5kZXAudmVyc2lvbiAhPT0gbGluay52ZXJzaW9uIHx8IGxpbmsuZGVwLmNvbXB1dGVkICYmIChyZWZyZXNoQ29tcHV0ZWQobGluay5kZXAuY29tcHV0ZWQpIHx8IGxpbmsuZGVwLnZlcnNpb24gIT09IGxpbmsudmVyc2lvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc3ViLl9kaXJ0eSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlZnJlc2hDb21wdXRlZChjb21wdXRlZCkge1xuICBpZiAoY29tcHV0ZWQuZmxhZ3MgJiA0ICYmICEoY29tcHV0ZWQuZmxhZ3MgJiAxNikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZmxhZ3MgJj0gfjE2O1xuICBpZiAoY29tcHV0ZWQuZ2xvYmFsVmVyc2lvbiA9PT0gZ2xvYmFsVmVyc2lvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wdXRlZC5nbG9iYWxWZXJzaW9uID0gZ2xvYmFsVmVyc2lvbjtcbiAgY29uc3QgZGVwID0gY29tcHV0ZWQuZGVwO1xuICBjb21wdXRlZC5mbGFncyB8PSAyO1xuICBpZiAoZGVwLnZlcnNpb24gPiAwICYmICFjb21wdXRlZC5pc1NTUiAmJiBjb21wdXRlZC5kZXBzICYmICFpc0RpcnR5KGNvbXB1dGVkKSkge1xuICAgIGNvbXB1dGVkLmZsYWdzICY9IH4yO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgYWN0aXZlU3ViID0gY29tcHV0ZWQ7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBwcmVwYXJlRGVwcyhjb21wdXRlZCk7XG4gICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZC5mbihjb21wdXRlZC5fdmFsdWUpO1xuICAgIGlmIChkZXAudmVyc2lvbiA9PT0gMCB8fCBoYXNDaGFuZ2VkKHZhbHVlLCBjb21wdXRlZC5fdmFsdWUpKSB7XG4gICAgICBjb21wdXRlZC5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlcC52ZXJzaW9uKys7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZXAudmVyc2lvbisrO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgIGNsZWFudXBEZXBzKGNvbXB1dGVkKTtcbiAgICBjb21wdXRlZC5mbGFncyAmPSB+MjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3ViKGxpbmssIHNvZnQgPSBmYWxzZSkge1xuICBjb25zdCB7IGRlcCwgcHJldlN1YiwgbmV4dFN1YiB9ID0gbGluaztcbiAgaWYgKHByZXZTdWIpIHtcbiAgICBwcmV2U3ViLm5leHRTdWIgPSBuZXh0U3ViO1xuICAgIGxpbmsucHJldlN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAobmV4dFN1Yikge1xuICAgIG5leHRTdWIucHJldlN1YiA9IHByZXZTdWI7XG4gICAgbGluay5uZXh0U3ViID0gdm9pZCAwO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlcC5zdWJzSGVhZCA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzSGVhZCA9IG5leHRTdWI7XG4gIH1cbiAgaWYgKGRlcC5zdWJzID09PSBsaW5rKSB7XG4gICAgZGVwLnN1YnMgPSBwcmV2U3ViO1xuICAgIGlmICghcHJldlN1YiAmJiBkZXAuY29tcHV0ZWQpIHtcbiAgICAgIGRlcC5jb21wdXRlZC5mbGFncyAmPSB+NDtcbiAgICAgIGZvciAobGV0IGwgPSBkZXAuY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICByZW1vdmVTdWIobCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghc29mdCAmJiAhLS1kZXAuc2MgJiYgZGVwLm1hcCkge1xuICAgIGRlcC5tYXAuZGVsZXRlKGRlcC5rZXkpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVEZXAobGluaykge1xuICBjb25zdCB7IHByZXZEZXAsIG5leHREZXAgfSA9IGxpbms7XG4gIGlmIChwcmV2RGVwKSB7XG4gICAgcHJldkRlcC5uZXh0RGVwID0gbmV4dERlcDtcbiAgICBsaW5rLnByZXZEZXAgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHREZXApIHtcbiAgICBuZXh0RGVwLnByZXZEZXAgPSBwcmV2RGVwO1xuICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gIGlmIChmbi5lZmZlY3QgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGZuID0gZm4uZWZmZWN0LmZuO1xuICB9XG4gIGNvbnN0IGUgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZChlLCBvcHRpb25zKTtcbiAgfVxuICB0cnkge1xuICAgIGUucnVuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGUuc3RvcCgpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBjb25zdCBydW5uZXIgPSBlLnJ1bi5iaW5kKGUpO1xuICBydW5uZXIuZWZmZWN0ID0gZTtcbiAgcmV0dXJuIHJ1bm5lcjtcbn1cbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XG4gIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiBvbkVmZmVjdENsZWFudXAoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVTdWIgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGFjdGl2ZVN1Yi5jbGVhbnVwID0gZm47XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbkVmZmVjdENsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSBlZmZlY3QgdG8gYXNzb2NpYXRlIHdpdGguYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZSkge1xuICBjb25zdCB7IGNsZWFudXAgfSA9IGU7XG4gIGUuY2xlYW51cCA9IHZvaWQgMDtcbiAgaWYgKGNsZWFudXApIHtcbiAgICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICAgIGFjdGl2ZVN1YiA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgZ2xvYmFsVmVyc2lvbiA9IDA7XG5jbGFzcyBMaW5rIHtcbiAgY29uc3RydWN0b3Ioc3ViLCBkZXApIHtcbiAgICB0aGlzLnN1YiA9IHN1YjtcbiAgICB0aGlzLmRlcCA9IGRlcDtcbiAgICB0aGlzLnZlcnNpb24gPSBkZXAudmVyc2lvbjtcbiAgICB0aGlzLm5leHREZXAgPSB0aGlzLnByZXZEZXAgPSB0aGlzLm5leHRTdWIgPSB0aGlzLnByZXZTdWIgPSB0aGlzLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xuICB9XG59XG5jbGFzcyBEZXAge1xuICBjb25zdHJ1Y3Rvcihjb21wdXRlZCkge1xuICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIExpbmsgYmV0d2VlbiB0aGlzIGRlcCBhbmQgdGhlIGN1cnJlbnQgYWN0aXZlIGVmZmVjdFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlTGluayA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBEb3VibHkgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJzY3JpYmluZyBlZmZlY3RzICh0YWlsKVxuICAgICAqL1xuICAgIHRoaXMuc3VicyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBGb3Igb2JqZWN0IHByb3BlcnR5IGRlcHMgY2xlYW51cFxuICAgICAqL1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXIgY291bnRlclxuICAgICAqL1xuICAgIHRoaXMuc2MgPSAwO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLnN1YnNIZWFkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICB0cmFjayhkZWJ1Z0luZm8pIHtcbiAgICBpZiAoIWFjdGl2ZVN1YiB8fCAhc2hvdWxkVHJhY2sgfHwgYWN0aXZlU3ViID09PSB0aGlzLmNvbXB1dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsaW5rID0gdGhpcy5hY3RpdmVMaW5rO1xuICAgIGlmIChsaW5rID09PSB2b2lkIDAgfHwgbGluay5zdWIgIT09IGFjdGl2ZVN1Yikge1xuICAgICAgbGluayA9IHRoaXMuYWN0aXZlTGluayA9IG5ldyBMaW5rKGFjdGl2ZVN1YiwgdGhpcyk7XG4gICAgICBpZiAoIWFjdGl2ZVN1Yi5kZXBzKSB7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgfVxuICAgICAgYWRkU3ViKGxpbmspO1xuICAgIH0gZWxzZSBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgaWYgKGxpbmsubmV4dERlcCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gbGluay5uZXh0RGVwO1xuICAgICAgICBuZXh0LnByZXZEZXAgPSBsaW5rLnByZXZEZXA7XG4gICAgICAgIGlmIChsaW5rLnByZXZEZXApIHtcbiAgICAgICAgICBsaW5rLnByZXZEZXAubmV4dERlcCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xuICAgICAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgICAgaWYgKGFjdGl2ZVN1Yi5kZXBzID09PSBsaW5rKSB7XG4gICAgICAgICAgYWN0aXZlU3ViLmRlcHMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1Yi5vblRyYWNrKSB7XG4gICAgICBhY3RpdmVTdWIub25UcmFjayhcbiAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlU3ViXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH1cbiAgdHJpZ2dlcihkZWJ1Z0luZm8pIHtcbiAgICB0aGlzLnZlcnNpb24rKztcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgdGhpcy5ub3RpZnkoZGVidWdJbmZvKTtcbiAgfVxuICBub3RpZnkoZGVidWdJbmZvKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGxldCBoZWFkID0gdGhpcy5zdWJzSGVhZDsgaGVhZDsgaGVhZCA9IGhlYWQubmV4dFN1Yikge1xuICAgICAgICAgIGlmIChoZWFkLnN1Yi5vblRyaWdnZXIgJiYgIShoZWFkLnN1Yi5mbGFncyAmIDgpKSB7XG4gICAgICAgICAgICBoZWFkLnN1Yi5vblRyaWdnZXIoXG4gICAgICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlZmZlY3Q6IGhlYWQuc3ViXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLnN1YnM7IGxpbms7IGxpbmsgPSBsaW5rLnByZXZTdWIpIHtcbiAgICAgICAgaWYgKGxpbmsuc3ViLm5vdGlmeSgpKSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGxpbmsuc3ViLmRlcC5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkU3ViKGxpbmspIHtcbiAgbGluay5kZXAuc2MrKztcbiAgaWYgKGxpbmsuc3ViLmZsYWdzICYgNCkge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gbGluay5kZXAuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkICYmICFsaW5rLmRlcC5zdWJzKSB7XG4gICAgICBjb21wdXRlZC5mbGFncyB8PSA0IHwgMTY7XG4gICAgICBmb3IgKGxldCBsID0gY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICBhZGRTdWIobCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUYWlsID0gbGluay5kZXAuc3VicztcbiAgICBpZiAoY3VycmVudFRhaWwgIT09IGxpbmspIHtcbiAgICAgIGxpbmsucHJldlN1YiA9IGN1cnJlbnRUYWlsO1xuICAgICAgaWYgKGN1cnJlbnRUYWlsKSBjdXJyZW50VGFpbC5uZXh0U3ViID0gbGluaztcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbGluay5kZXAuc3Vic0hlYWQgPT09IHZvaWQgMCkge1xuICAgICAgbGluay5kZXAuc3Vic0hlYWQgPSBsaW5rO1xuICAgIH1cbiAgICBsaW5rLmRlcC5zdWJzID0gbGluaztcbiAgfVxufVxuY29uc3QgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiT2JqZWN0IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5jb25zdCBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJNYXAga2V5cyBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgQVJSQVlfSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkFycmF5IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlU3ViKSB7XG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFkZXBzTWFwKSB7XG4gICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgRGVwKCkpO1xuICAgICAgZGVwLm1hcCA9IGRlcHNNYXA7XG4gICAgICBkZXAua2V5ID0ga2V5O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXAudHJhY2soKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghZGVwc01hcCkge1xuICAgIGdsb2JhbFZlcnNpb24rKztcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcnVuID0gKGRlcCkgPT4ge1xuICAgIGlmIChkZXApIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YXJ0QmF0Y2goKTtcbiAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgIGRlcHNNYXAuZm9yRWFjaChydW4pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgY29uc3QgaXNBcnJheUluZGV4ID0gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KTtcbiAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiBrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IE51bWJlcihuZXdWYWx1ZSk7XG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID09PSBBUlJBWV9JVEVSQVRFX0tFWSB8fCAhaXNTeW1ib2woa2V5MikgJiYga2V5MiA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgICBydW4oZGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgIT09IHZvaWQgMCB8fCBkZXBzTWFwLmhhcyh2b2lkIDApKSB7XG4gICAgICAgIHJ1bihkZXBzTWFwLmdldChrZXkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW5kZXgpIHtcbiAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KEFSUkFZX0lURVJBVEVfS0VZKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCk7XG59XG5mdW5jdGlvbiBnZXREZXBGcm9tUmVhY3RpdmUob2JqZWN0LCBrZXkpIHtcbiAgY29uc3QgZGVwTWFwID0gdGFyZ2V0TWFwLmdldChvYmplY3QpO1xuICByZXR1cm4gZGVwTWFwICYmIGRlcE1hcC5nZXQoa2V5KTtcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmVSZWFkQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmF3ID0gdG9SYXcoYXJyYXkpO1xuICBpZiAocmF3ID09PSBhcnJheSkgcmV0dXJuIHJhdztcbiAgdHJhY2socmF3LCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gaXNTaGFsbG93KGFycmF5KSA/IHJhdyA6IHJhdy5tYXAodG9SZWFjdGl2ZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZEFycmF5KGFycikge1xuICB0cmFjayhhcnIgPSB0b1JhdyhhcnIpLCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gYXJyO1xufVxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBTeW1ib2wuaXRlcmF0b3IsIHRvUmVhY3RpdmUpO1xuICB9LFxuICBjb25jYXQoLi4uYXJncykge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5jb25jYXQoXG4gICAgICAuLi5hcmdzLm1hcCgoeCkgPT4gaXNBcnJheSh4KSA/IHJlYWN0aXZlUmVhZEFycmF5KHgpIDogeClcbiAgICApO1xuICB9LFxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcImVudHJpZXNcIiwgKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZVsxXSA9IHRvUmVhY3RpdmUodmFsdWVbMV0pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LFxuICBldmVyeShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImV2ZXJ5XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbHRlcihmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbHRlclwiLCBmbiwgdGhpc0FyZywgKHYpID0+IHYubWFwKHRvUmVhY3RpdmUpLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZFwiLCBmbiwgdGhpc0FyZywgdG9SZWFjdGl2ZSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZEluZGV4KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZExhc3RcIiwgZm4sIHRoaXNBcmcsIHRvUmVhY3RpdmUsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0SW5kZXgoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kTGFzdEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIC8vIGZsYXQsIGZsYXRNYXAgY291bGQgYmVuZWZpdCBmcm9tIEFSUkFZX0lURVJBVEUgYnV0IGFyZSBub3Qgc3RyYWlnaHQtZm9yd2FyZCB0byBpbXBsZW1lbnRcbiAgZm9yRWFjaChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZvckVhY2hcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgaW5jbHVkZXMoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImluY2x1ZGVzXCIsIGFyZ3MpO1xuICB9LFxuICBpbmRleE9mKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5qb2luKHNlcGFyYXRvcik7XG4gIH0sXG4gIC8vIGtleXMoKSBpdGVyYXRvciBvbmx5IHJlYWRzIGBsZW5ndGhgLCBubyBvcHRpbWlzYXRpb24gcmVxdWlyZWRcbiAgbGFzdEluZGV4T2YoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImxhc3RJbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBtYXAoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJtYXBcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgcG9wKCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicG9wXCIpO1xuICB9LFxuICBwdXNoKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInB1c2hcIiwgYXJncyk7XG4gIH0sXG4gIHJlZHVjZShmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VcIiwgZm4sIGFyZ3MpO1xuICB9LFxuICByZWR1Y2VSaWdodChmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VSaWdodFwiLCBmbiwgYXJncyk7XG4gIH0sXG4gIHNoaWZ0KCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic2hpZnRcIik7XG4gIH0sXG4gIC8vIHNsaWNlIGNvdWxkIHVzZSBBUlJBWV9JVEVSQVRFIGJ1dCBhbHNvIHNlZW1zIHRvIGJlZyBmb3IgcmFuZ2UgdHJhY2tpbmdcbiAgc29tZShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcInNvbWVcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgc3BsaWNlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInNwbGljZVwiLCBhcmdzKTtcbiAgfSxcbiAgdG9SZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9SZXZlcnNlZCgpO1xuICB9LFxuICB0b1NvcnRlZChjb21wYXJlcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1NvcnRlZChjb21wYXJlcik7XG4gIH0sXG4gIHRvU3BsaWNlZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU3BsaWNlZCguLi5hcmdzKTtcbiAgfSxcbiAgdW5zaGlmdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJ1bnNoaWZ0XCIsIGFyZ3MpO1xuICB9LFxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFwidmFsdWVzXCIsIHRvUmVhY3RpdmUpO1xuICB9XG59O1xuZnVuY3Rpb24gaXRlcmF0b3Ioc2VsZiwgbWV0aG9kLCB3cmFwVmFsdWUpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgaXRlciA9IGFyclttZXRob2RdKCk7XG4gIGlmIChhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKSkge1xuICAgIGl0ZXIuX25leHQgPSBpdGVyLm5leHQ7XG4gICAgaXRlci5uZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaXRlci5fbmV4dCgpO1xuICAgICAgaWYgKHJlc3VsdC52YWx1ZSkge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB3cmFwVmFsdWUocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gaXRlcjtcbn1cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5mdW5jdGlvbiBhcHBseShzZWxmLCBtZXRob2QsIGZuLCB0aGlzQXJnLCB3cmFwcGVkUmV0Rm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgbmVlZHNXcmFwID0gYXJyICE9PSBzZWxmICYmICFpc1NoYWxsb3coc2VsZik7XG4gIGNvbnN0IG1ldGhvZEZuID0gYXJyW21ldGhvZF07XG4gIGlmIChtZXRob2RGbiAhPT0gYXJyYXlQcm90b1ttZXRob2RdKSB7XG4gICAgY29uc3QgcmVzdWx0MiA9IG1ldGhvZEZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIHJldHVybiBuZWVkc1dyYXAgPyB0b1JlYWN0aXZlKHJlc3VsdDIpIDogcmVzdWx0MjtcbiAgfVxuICBsZXQgd3JhcHBlZEZuID0gZm47XG4gIGlmIChhcnIgIT09IHNlbGYpIHtcbiAgICBpZiAobmVlZHNXcmFwKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0b1JlYWN0aXZlKGl0ZW0pLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm4ubGVuZ3RoID4gMikge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgaXRlbSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbWV0aG9kRm4uY2FsbChhcnIsIHdyYXBwZWRGbiwgdGhpc0FyZyk7XG4gIHJldHVybiBuZWVkc1dyYXAgJiYgd3JhcHBlZFJldEZuID8gd3JhcHBlZFJldEZuKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWR1Y2Uoc2VsZiwgbWV0aG9kLCBmbiwgYXJncykge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBsZXQgd3JhcHBlZEZuID0gZm47XG4gIGlmIChhcnIgIT09IHNlbGYpIHtcbiAgICBpZiAoIWlzU2hhbGxvdyhzZWxmKSkge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIHRvUmVhY3RpdmUoaXRlbSksIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAzKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFjYywgaXRlbSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyclttZXRob2RdKHdyYXBwZWRGbiwgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBzZWFyY2hQcm94eShzZWxmLCBtZXRob2QsIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gdG9SYXcoc2VsZik7XG4gIHRyYWNrKGFyciwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgY29uc3QgcmVzID0gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIGlmICgocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSAmJiBpc1Byb3h5KGFyZ3NbMF0pKSB7XG4gICAgYXJnc1swXSA9IHRvUmF3KGFyZ3NbMF0pO1xuICAgIHJldHVybiBhcnJbbWV0aG9kXSguLi5hcmdzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbm9UcmFja2luZyhzZWxmLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIHN0YXJ0QmF0Y2goKTtcbiAgY29uc3QgcmVzID0gdG9SYXcoc2VsZilbbWV0aG9kXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgZW5kQmF0Y2goKTtcbiAgcmVzZXRUcmFja2luZygpO1xuICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoXG4gIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLmZpbHRlcigoa2V5KSA9PiBrZXkgIT09IFwiYXJndW1lbnRzXCIgJiYga2V5ICE9PSBcImNhbGxlclwiKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbClcbik7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgaWYgKCFpc1N5bWJvbChrZXkpKSBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XG4gIHRyYWNrKG9iaiwgXCJoYXNcIiwga2V5KTtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xufVxuY2xhc3MgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKF9pc1JlYWRvbmx5ID0gZmFsc2UsIF9pc1NoYWxsb3cgPSBmYWxzZSkge1xuICAgIHRoaXMuX2lzUmVhZG9ubHkgPSBfaXNSZWFkb25seTtcbiAgICB0aGlzLl9pc1NoYWxsb3cgPSBfaXNTaGFsbG93O1xuICB9XG4gIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIpIHJldHVybiB0YXJnZXRbXCJfX3Zfc2tpcFwiXTtcbiAgICBjb25zdCBpc1JlYWRvbmx5MiA9IHRoaXMuX2lzUmVhZG9ubHksIGlzU2hhbGxvdzIgPSB0aGlzLl9pc1NoYWxsb3c7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIpIHtcbiAgICAgIHJldHVybiBpc1NoYWxsb3cyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgaWYgKHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpIHx8IC8vIHJlY2VpdmVyIGlzIG5vdCB0aGUgcmVhY3RpdmUgcHJveHksIGJ1dCBoYXMgdGhlIHNhbWUgcHJvdG90eXBlXG4gICAgICAvLyB0aGlzIG1lYW5zIHRoZSByZWNlaXZlciBpcyBhIHVzZXIgcHJveHkgb2YgdGhlIHJlYWN0aXZlIHByb3h5XG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHJlY2VpdmVyKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIGxldCBmbjtcbiAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIChmbiA9IGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImhhc093blByb3BlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldChcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm94eSB3cmFwcGluZyBhIHJlZiwgcmV0dXJuIG1ldGhvZHMgdXNpbmcgdGhlIHJhdyByZWZcbiAgICAgIC8vIGFzIHJlY2VpdmVyIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjYWxsIGB0b1Jhd2Agb24gdGhlIHJlZiBpbiBhbGxcbiAgICAgIC8vIGl0cyBjbGFzcyBtZXRob2RzXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcbiAgICApO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoaXNTaGFsbG93Mikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpID8gcmVzIDogcmVzLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cbmNsYXNzIE11dGFibGVSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoaXNTaGFsbG93MiA9IGZhbHNlKSB7XG4gICAgc3VwZXIoZmFsc2UsIGlzU2hhbGxvdzIpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCF0aGlzLl9pc1NoYWxsb3cpIHtcbiAgICAgIGNvbnN0IGlzT2xkVmFsdWVSZWFkb25seSA9IGlzUmVhZG9ubHkob2xkVmFsdWUpO1xuICAgICAgaWYgKCFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBpZiAoaXNPbGRWYWx1ZVJlYWRvbmx5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldChcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgaXNSZWYodGFyZ2V0KSA/IHRhcmdldCA6IHJlY2VpdmVyXG4gICAgKTtcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICB0cmFjayhcbiAgICAgIHRhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH1cbn1cbmNsYXNzIFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKHRydWUsIGlzU2hhbGxvdzIpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIoKTtcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXV0YWJsZVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHkyLCBpc1NoYWxsb3cyKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XG4gICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93MiA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKFxuICAgICAgcmF3VGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyB2YWx1ZSwgZG9uZSB9IDoge1xuICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0b1Jhdyh0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHR5cGUgPT09IFwiY2xlYXJcIiA/IHZvaWQgMCA6IHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKHJlYWRvbmx5LCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgIGlmICghcmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwgcmF3S2V5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICAgICAgY29uc3Qgd3JhcCA9IHNoYWxsb3cgPyB0b1NoYWxsb3cgOiByZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICAgICAgfSBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgICFyZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgXCJzaXplXCIsIHRhcmdldCk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgaWYgKCFyZWFkb25seSkge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcbiAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbiAgICB9LFxuICAgIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCB3cmFwID0gc2hhbGxvdyA/IHRvU2hhbGxvdyA6IHJlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXh0ZW5kKFxuICAgIGluc3RydW1lbnRhdGlvbnMsXG4gICAgcmVhZG9ubHkgPyB7XG4gICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKVxuICAgIH0gOiB7XG4gICAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKGhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICAgICAgICBjb25zdCBvbGRUYXJnZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gICAgICAgIGlmIChoYWRJdGVtcykge1xuICAgICAgICAgIHRyaWdnZXIoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBcImNsZWFyXCIsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBvbGRUYXJnZXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXG4gICAgXCJrZXlzXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcImVudHJpZXNcIixcbiAgICBTeW1ib2wuaXRlcmF0b3JcbiAgXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgcmVhZG9ubHksIHNoYWxsb3cpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seTIsIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoaXNSZWFkb25seTIsIHNoYWxsb3cpO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXG4gICAgICBoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHJlY2VpdmVyXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KSB7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgd2FybihcbiAgICAgIGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgPyAwIC8qIElOVkFMSUQgKi8gOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgbXV0YWJsZUhhbmRsZXJzLFxuICAgIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyxcbiAgICBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICByZWFkb25seUhhbmRsZXJzLFxuICAgIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSAke2lzUmVhZG9ubHkyID8gXCJyZWFkb25seVwiIDogXCJyZWFjdGl2ZVwifTogJHtTdHJpbmcoXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG4gIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XG4gIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHRhcmdldCxcbiAgICB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnNcbiAgKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XG4gIH1cbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/ICEhdmFsdWVbXCJfX3ZfcmF3XCJdIDogZmFsc2U7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gIGlmICghaGFzT3duKHZhbHVlLCBcIl9fdl9za2lwXCIpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuIHIgPyByW1wiX192X2lzUmVmXCJdID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIGlzU2hhbGxvdzIpIHtcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSA9IGZhbHNlO1xuICAgIHRoaXMuX3Jhd1ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBpc1NoYWxsb3cyO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5kZXAudHJhY2soe1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXAudHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmF3VmFsdWU7XG4gICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSB8fCBpc1NoYWxsb3cobmV3VmFsdWUpIHx8IGlzUmVhZG9ubHkobmV3VmFsdWUpO1xuICAgIG5ld1ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmF3KG5ld1ZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbHVlIDogdG9SZWFjdGl2ZShuZXdWYWx1ZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICBpZiAocmVmMi5kZXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcmVmMi5kZXAudHJpZ2dlcih7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgIG5ld1ZhbHVlOiByZWYyLl92YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgcmV0dXJuIGlzUmVmKHJlZjIpID8gcmVmMi52YWx1ZSA6IHJlZjI7XG59XG5mdW5jdGlvbiB0b1ZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihzb3VyY2UpID8gc291cmNlKCkgOiB1bnJlZihzb3VyY2UpO1xufVxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IGtleSA9PT0gXCJfX3ZfcmF3XCIgPyB0YXJnZXQgOiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpID8gb2JqZWN0V2l0aFJlZnMgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XG59XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoZGVwLnRyYWNrLmJpbmQoZGVwKSwgZGVwLnRyaWdnZXIuYmluZChkZXApKTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgdGhpcy5fc2V0ID0gc2V0O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgIHdhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICB9XG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICByZXRba2V5XSA9IHByb3BlcnR5VG9SZWYob2JqZWN0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB2YWwgPT09IHZvaWQgMCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XG4gIH1cbiAgZ2V0IGRlcCgpIHtcbiAgICByZXR1cm4gZ2V0RGVwRnJvbVJlYWN0aXZlKHRvUmF3KHRoaXMuX29iamVjdCksIHRoaXMuX2tleSk7XG4gIH1cbn1cbmNsYXNzIEdldHRlclJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihfZ2V0dGVyKSB7XG4gICAgdGhpcy5fZ2V0dGVyID0gX2dldHRlcjtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXR0ZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBHZXR0ZXJSZWZJbXBsKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWYoc291cmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbCA9IHNvdXJjZVtrZXldO1xuICByZXR1cm4gaXNSZWYodmFsKSA/IHZhbCA6IG5ldyBPYmplY3RSZWZJbXBsKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcihmbiwgc2V0dGVyLCBpc1NTUikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLnNldHRlciA9IHNldHRlcjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAodGhpcyk7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIC8vIFRPRE8gaXNvbGF0ZWREZWNsYXJhdGlvbnMgXCJfX3ZfaXNSZWFkb25seVwiXG4gICAgLy8gQSBjb21wdXRlZCBpcyBhbHNvIGEgc3Vic2NyaWJlciB0aGF0IHRyYWNrcyBvdGhlciBkZXBzXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDE2O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb24gLSAxO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMuZWZmZWN0ID0gdGhpcztcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSAhc2V0dGVyO1xuICAgIHRoaXMuaXNTU1IgPSBpc1NTUjtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgdGhpcy5mbGFncyB8PSAxNjtcbiAgICBpZiAoISh0aGlzLmZsYWdzICYgOCkgJiYgLy8gYXZvaWQgaW5maW5pdGUgc2VsZiByZWN1cnNpb25cbiAgICBhY3RpdmVTdWIgIT09IHRoaXMpIHtcbiAgICAgIGJhdGNoKHRoaXMsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGNvbnN0IGxpbmsgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdGhpcy5kZXAudHJhY2soe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgfSkgOiB0aGlzLmRlcC50cmFjaygpO1xuICAgIHJlZnJlc2hDb21wdXRlZCh0aGlzKTtcbiAgICBpZiAobGluaykge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy5kZXAudmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnNldHRlcikge1xuICAgICAgdGhpcy5zZXR0ZXIobmV3VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcIldyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5XCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzU1NSID0gZmFsc2UpIHtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IHNldHRlcjtcbiAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gIH1cbiAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzU1NSKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xuICAgIGNSZWYub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgIGNSZWYub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICByZXR1cm4gY1JlZjtcbn1cblxuY29uc3QgVHJhY2tPcFR5cGVzID0ge1xuICBcIkdFVFwiOiBcImdldFwiLFxuICBcIkhBU1wiOiBcImhhc1wiLFxuICBcIklURVJBVEVcIjogXCJpdGVyYXRlXCJcbn07XG5jb25zdCBUcmlnZ2VyT3BUeXBlcyA9IHtcbiAgXCJTRVRcIjogXCJzZXRcIixcbiAgXCJBRERcIjogXCJhZGRcIixcbiAgXCJERUxFVEVcIjogXCJkZWxldGVcIixcbiAgXCJDTEVBUlwiOiBcImNsZWFyXCJcbn07XG5jb25zdCBSZWFjdGl2ZUZsYWdzID0ge1xuICBcIlNLSVBcIjogXCJfX3Zfc2tpcFwiLFxuICBcIklTX1JFQUNUSVZFXCI6IFwiX192X2lzUmVhY3RpdmVcIixcbiAgXCJJU19SRUFET05MWVwiOiBcIl9fdl9pc1JlYWRvbmx5XCIsXG4gIFwiSVNfU0hBTExPV1wiOiBcIl9fdl9pc1NoYWxsb3dcIixcbiAgXCJSQVdcIjogXCJfX3ZfcmF3XCIsXG4gIFwiSVNfUkVGXCI6IFwiX192X2lzUmVmXCJcbn07XG5cbmNvbnN0IFdhdGNoRXJyb3JDb2RlcyA9IHtcbiAgXCJXQVRDSF9HRVRURVJcIjogMixcbiAgXCIyXCI6IFwiV0FUQ0hfR0VUVEVSXCIsXG4gIFwiV0FUQ0hfQ0FMTEJBQ0tcIjogMyxcbiAgXCIzXCI6IFwiV0FUQ0hfQ0FMTEJBQ0tcIixcbiAgXCJXQVRDSF9DTEVBTlVQXCI6IDQsXG4gIFwiNFwiOiBcIldBVENIX0NMRUFOVVBcIlxufTtcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuY29uc3QgY2xlYW51cE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IGFjdGl2ZVdhdGNoZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBnZXRDdXJyZW50V2F0Y2hlcigpIHtcbiAgcmV0dXJuIGFjdGl2ZVdhdGNoZXI7XG59XG5mdW5jdGlvbiBvbldhdGNoZXJDbGVhbnVwKGNsZWFudXBGbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UsIG93bmVyID0gYWN0aXZlV2F0Y2hlcikge1xuICBpZiAob3duZXIpIHtcbiAgICBsZXQgY2xlYW51cHMgPSBjbGVhbnVwTWFwLmdldChvd25lcik7XG4gICAgaWYgKCFjbGVhbnVwcykgY2xlYW51cE1hcC5zZXQob3duZXIsIGNsZWFudXBzID0gW10pO1xuICAgIGNsZWFudXBzLnB1c2goY2xlYW51cEZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uV2F0Y2hlckNsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSB3YXRjaGVyIHRvIGFzc29jaWF0ZSB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBvbmNlLCBzY2hlZHVsZXIsIGF1Z21lbnRKb2IsIGNhbGwgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICAob3B0aW9ucy5vbldhcm4gfHwgd2FybikoXG4gICAgICBgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsXG4gICAgICBzLFxuICAgICAgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcmVhY3RpdmVHZXR0ZXIgPSAoc291cmNlMikgPT4ge1xuICAgIGlmIChkZWVwKSByZXR1cm4gc291cmNlMjtcbiAgICBpZiAoaXNTaGFsbG93KHNvdXJjZTIpIHx8IGRlZXAgPT09IGZhbHNlIHx8IGRlZXAgPT09IDApXG4gICAgICByZXR1cm4gdHJhdmVyc2Uoc291cmNlMiwgMSk7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIpO1xuICB9O1xuICBsZXQgZWZmZWN0O1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgY2xlYW51cDtcbiAgbGV0IGJvdW5kQ2xlYW51cDtcbiAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xuICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBpc1NoYWxsb3coc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiByZWFjdGl2ZUdldHRlcihzb3VyY2UpO1xuICAgIGZvcmNlVHJpZ2dlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUoKHMpID0+IGlzUmVhY3RpdmUocykgfHwgaXNTaGFsbG93KHMpKTtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKChzKSA9PiB7XG4gICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgcmV0dXJuIHJlYWN0aXZlR2V0dGVyKHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzLCAyKSA6IHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBnZXR0ZXIgPSBjYWxsID8gKCkgPT4gY2FsbChzb3VyY2UsIDIpIDogc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEVmZmVjdCA9IGFjdGl2ZVdhdGNoZXI7XG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsKHNvdXJjZSwgMywgW2JvdW5kQ2xlYW51cF0pIDogc291cmNlKGJvdW5kQ2xlYW51cCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IE5PT1A7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xuICB9XG4gIGlmIChjYiAmJiBkZWVwKSB7XG4gICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICBjb25zdCBkZXB0aCA9IGRlZXAgPT09IHRydWUgPyBJbmZpbml0eSA6IGRlZXA7XG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpLCBkZXB0aCk7XG4gIH1cbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSAoKSA9PiB7XG4gICAgZWZmZWN0LnN0b3AoKTtcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgICByZW1vdmUoc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmIChvbmNlICYmIGNiKSB7XG4gICAgY29uc3QgX2NiID0gY2I7XG4gICAgY2IgPSAoLi4uYXJncykgPT4ge1xuICAgICAgX2NiKC4uLmFyZ3MpO1xuICAgICAgd2F0Y2hIYW5kbGUoKTtcbiAgICB9O1xuICB9XG4gIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICBjb25zdCBqb2IgPSAoaW1tZWRpYXRlRmlyc3RSdW4pID0+IHtcbiAgICBpZiAoIShlZmZlY3QuZmxhZ3MgJiAxKSB8fCAhZWZmZWN0LmRpcnR5ICYmICFpbW1lZGlhdGVGaXJzdFJ1bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2IpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgICAgaWYgKGRlZXAgfHwgZm9yY2VUcmlnZ2VyIHx8IChpc011bHRpU291cmNlID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSkge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50V2F0Y2hlciA9IGFjdGl2ZVdhdGNoZXI7XG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB2b2lkIDAgOiBpc011bHRpU291cmNlICYmIG9sZFZhbHVlWzBdID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyBbXSA6IG9sZFZhbHVlLFxuICAgICAgICAgICAgYm91bmRDbGVhbnVwXG4gICAgICAgICAgXTtcbiAgICAgICAgICBjYWxsID8gY2FsbChjYiwgMywgYXJncykgOiAoXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBjYiguLi5hcmdzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgb2xkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhY3RpdmVXYXRjaGVyID0gY3VycmVudFdhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGF1Z21lbnRKb2IpIHtcbiAgICBhdWdtZW50Sm9iKGpvYik7XG4gIH1cbiAgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlcik7XG4gIGVmZmVjdC5zY2hlZHVsZXIgPSBzY2hlZHVsZXIgPyAoKSA9PiBzY2hlZHVsZXIoam9iLCBmYWxzZSkgOiBqb2I7XG4gIGJvdW5kQ2xlYW51cCA9IChmbikgPT4gb25XYXRjaGVyQ2xlYW51cChmbiwgZmFsc2UsIGVmZmVjdCk7XG4gIGNsZWFudXAgPSBlZmZlY3Qub25TdG9wID0gKCkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQoZWZmZWN0KTtcbiAgICBpZiAoY2xlYW51cHMpIHtcbiAgICAgIGlmIChjYWxsKSB7XG4gICAgICAgIGNhbGwoY2xlYW51cHMsIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBjbGVhbnVwMiBvZiBjbGVhbnVwcykgY2xlYW51cDIoKTtcbiAgICAgIH1cbiAgICAgIGNsZWFudXBNYXAuZGVsZXRlKGVmZmVjdCk7XG4gICAgfVxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGVmZmVjdC5vblRyYWNrID0gb3B0aW9ucy5vblRyYWNrO1xuICAgIGVmZmVjdC5vblRyaWdnZXIgPSBvcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBqb2IodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzY2hlZHVsZXIpIHtcbiAgICBzY2hlZHVsZXIoam9iLmJpbmQobnVsbCwgdHJ1ZSksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5ydW4oKTtcbiAgfVxuICB3YXRjaEhhbmRsZS5wYXVzZSA9IGVmZmVjdC5wYXVzZS5iaW5kKGVmZmVjdCk7XG4gIHdhdGNoSGFuZGxlLnJlc3VtZSA9IGVmZmVjdC5yZXN1bWUuYmluZChlZmZlY3QpO1xuICB3YXRjaEhhbmRsZS5zdG9wID0gd2F0Y2hIYW5kbGU7XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbHVlLCBkZXB0aCA9IEluZmluaXR5LCBzZWVuKSB7XG4gIGlmIChkZXB0aCA8PSAwIHx8ICFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiXSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4uYWRkKHZhbHVlKTtcbiAgZGVwdGgtLTtcbiAgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHRyYXZlcnNlKHZhbHVlLnZhbHVlLCBkZXB0aCwgc2Vlbik7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgZGVwdGgsIHNlZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xuICAgICAgdHJhdmVyc2UodiwgZGVwdGgsIHNlZW4pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgZGVwdGgsIHNlZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IEFSUkFZX0lURVJBVEVfS0VZLCBFZmZlY3RGbGFncywgRWZmZWN0U2NvcGUsIElURVJBVEVfS0VZLCBNQVBfS0VZX0lURVJBVEVfS0VZLCBSZWFjdGl2ZUVmZmVjdCwgUmVhY3RpdmVGbGFncywgVHJhY2tPcFR5cGVzLCBUcmlnZ2VyT3BUeXBlcywgV2F0Y2hFcnJvckNvZGVzLCBjb21wdXRlZCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBlbmFibGVUcmFja2luZywgZ2V0Q3VycmVudFNjb3BlLCBnZXRDdXJyZW50V2F0Y2hlciwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25FZmZlY3RDbGVhbnVwLCBvblNjb3BlRGlzcG9zZSwgb25XYXRjaGVyQ2xlYW51cCwgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhY3RpdmVSZWFkQXJyYXksIHJlYWRvbmx5LCByZWYsIHJlc2V0VHJhY2tpbmcsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRBcnJheSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWFjdGl2ZSwgdG9SZWFkb25seSwgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJhY2ssIHRyYXZlcnNlLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiwgd2F0Y2ggfTtcbiIsIi8qKlxuKiBAdnVlL3J1bnRpbWUtY29yZSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBwYXVzZVRyYWNraW5nLCByZXNldFRyYWNraW5nLCBpc1JlZiwgdG9SYXcsIHRyYXZlcnNlLCBzaGFsbG93UmVmLCByZWFkb25seSwgaXNSZWFjdGl2ZSwgcmVmLCBpc1NoYWxsb3csIHNoYWxsb3dSZWFkQXJyYXksIHRvUmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIFJlYWN0aXZlRWZmZWN0LCB3YXRjaCBhcyB3YXRjaCQxLCBjdXN0b21SZWYsIGlzUHJveHksIHByb3h5UmVmcywgbWFya1JhdywgRWZmZWN0U2NvcGUsIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBUcmFja09wVHlwZXMsIFRyaWdnZXJPcFR5cGVzLCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBvbldhdGNoZXJDbGVhbnVwLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIEVNUFRZX09CSiwgTk9PUCwgZ2V0R2xvYmFsVGhpcywgZXh0ZW5kLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGhhc093biwgcmVtb3ZlLCBkZWYsIGlzT24sIGlzUmVzZXJ2ZWRQcm9wLCBub3JtYWxpemVDbGFzcywgc3RyaW5naWZ5U3R5bGUsIG5vcm1hbGl6ZVN0eWxlLCBpc0tub3duU3ZnQXR0ciwgaXNCb29sZWFuQXR0ciwgaXNLbm93bkh0bWxBdHRyLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGlzT2JqZWN0LCBpc1JlZ0V4cCwgaW52b2tlQXJyYXlGbnMsIHRvSGFuZGxlcktleSwgY2FwaXRhbGl6ZSwgY2FtZWxpemUsIGlzU3ltYm9sLCBpc0dsb2JhbGx5QWxsb3dlZCwgTk8sIGh5cGhlbmF0ZSwgRU1QVFlfQVJSLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIGhhc0NoYW5nZWQsIGxvb3NlVG9OdW1iZXIsIGlzTW9kZWxMaXN0ZW5lciwgdG9OdW1iZXIgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcbiAgc3RhY2sucHVzaCh2bm9kZSk7XG59XG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcbiAgc3RhY2sucG9wKCk7XG59XG5sZXQgaXNXYXJuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuJDEobXNnLCAuLi5hcmdzKSB7XG4gIGlmIChpc1dhcm5pbmcpIHJldHVybjtcbiAgaXNXYXJuaW5nID0gdHJ1ZTtcbiAgcGF1c2VUcmFja2luZygpO1xuICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XG4gIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XG4gIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcbiAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgYXBwV2FybkhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDExLFxuICAgICAgW1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgbXNnICsgYXJncy5tYXAoKGEpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBhLnRvU3RyaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChhKSkgIT0gbnVsbCA/IF9iIDogSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxuICAgICAgICB0cmFjZS5tYXAoXG4gICAgICAgICAgKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gXG4gICAgICAgICkuam9pbihcIlxcblwiKSxcbiAgICAgICAgdHJhY2VcbiAgICAgIF1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcbiAgICBpZiAodHJhY2UubGVuZ3RoICYmIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXG4gICAgdHJ1ZSkge1xuICAgICAgd2FybkFyZ3MucHVzaChgXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xuICB9XG4gIHJlc2V0VHJhY2tpbmcoKTtcbiAgaXNXYXJuaW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcbiAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICBpZiAoIWN1cnJlbnRWTm9kZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xuICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XG4gICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XG4gICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXG4gICAgICAgIHJlY3Vyc2VDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcbiAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcbiAgY29uc3QgbG9ncyA9IFtdO1xuICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgIGxvZ3MucHVzaCguLi5pID09PSAwID8gW10gOiBbYFxuYF0sIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcbiAgfSk7XG4gIHJldHVybiBsb2dzO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xuICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xuICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcbiAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICB2bm9kZS5jb21wb25lbnQsXG4gICAgdm5vZGUudHlwZSxcbiAgICBpc1Jvb3RcbiAgKX1gO1xuICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XG4gIHJldHVybiB2bm9kZS5wcm9wcyA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXSA6IFtvcGVuICsgY2xvc2VdO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcbiAgfSk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcbiAgICByZXMucHVzaChgIC4uLmApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIodmFsLCB0eXBlKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgcmV0dXJuO1xuICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgIHdhcm4kMShgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybiQxKGAke3R5cGV9IGlzIE5hTiAtIHRoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC5gKTtcbiAgfVxufVxuXG5jb25zdCBFcnJvckNvZGVzID0ge1xuICBcIlNFVFVQX0ZVTkNUSU9OXCI6IDAsXG4gIFwiMFwiOiBcIlNFVFVQX0ZVTkNUSU9OXCIsXG4gIFwiUkVOREVSX0ZVTkNUSU9OXCI6IDEsXG4gIFwiMVwiOiBcIlJFTkRFUl9GVU5DVElPTlwiLFxuICBcIk5BVElWRV9FVkVOVF9IQU5ETEVSXCI6IDUsXG4gIFwiNVwiOiBcIk5BVElWRV9FVkVOVF9IQU5ETEVSXCIsXG4gIFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIjogNixcbiAgXCI2XCI6IFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIixcbiAgXCJWTk9ERV9IT09LXCI6IDcsXG4gIFwiN1wiOiBcIlZOT0RFX0hPT0tcIixcbiAgXCJESVJFQ1RJVkVfSE9PS1wiOiA4LFxuICBcIjhcIjogXCJESVJFQ1RJVkVfSE9PS1wiLFxuICBcIlRSQU5TSVRJT05fSE9PS1wiOiA5LFxuICBcIjlcIjogXCJUUkFOU0lUSU9OX0hPT0tcIixcbiAgXCJBUFBfRVJST1JfSEFORExFUlwiOiAxMCxcbiAgXCIxMFwiOiBcIkFQUF9FUlJPUl9IQU5ETEVSXCIsXG4gIFwiQVBQX1dBUk5fSEFORExFUlwiOiAxMSxcbiAgXCIxMVwiOiBcIkFQUF9XQVJOX0hBTkRMRVJcIixcbiAgXCJGVU5DVElPTl9SRUZcIjogMTIsXG4gIFwiMTJcIjogXCJGVU5DVElPTl9SRUZcIixcbiAgXCJBU1lOQ19DT01QT05FTlRfTE9BREVSXCI6IDEzLFxuICBcIjEzXCI6IFwiQVNZTkNfQ09NUE9ORU5UX0xPQURFUlwiLFxuICBcIlNDSEVEVUxFUlwiOiAxNCxcbiAgXCIxNFwiOiBcIlNDSEVEVUxFUlwiLFxuICBcIkNPTVBPTkVOVF9VUERBVEVcIjogMTUsXG4gIFwiMTVcIjogXCJDT01QT05FTlRfVVBEQVRFXCIsXG4gIFwiQVBQX1VOTU9VTlRfQ0xFQU5VUFwiOiAxNixcbiAgXCIxNlwiOiBcIkFQUF9VTk1PVU5UX0NMRUFOVVBcIlxufTtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MkMSA9IHtcbiAgW1wic3BcIl06IFwic2VydmVyUHJlZmV0Y2ggaG9va1wiLFxuICBbXCJiY1wiXTogXCJiZWZvcmVDcmVhdGUgaG9va1wiLFxuICBbXCJjXCJdOiBcImNyZWF0ZWQgaG9va1wiLFxuICBbXCJibVwiXTogXCJiZWZvcmVNb3VudCBob29rXCIsXG4gIFtcIm1cIl06IFwibW91bnRlZCBob29rXCIsXG4gIFtcImJ1XCJdOiBcImJlZm9yZVVwZGF0ZSBob29rXCIsXG4gIFtcInVcIl06IFwidXBkYXRlZFwiLFxuICBbXCJidW1cIl06IFwiYmVmb3JlVW5tb3VudCBob29rXCIsXG4gIFtcInVtXCJdOiBcInVubW91bnRlZCBob29rXCIsXG4gIFtcImFcIl06IFwiYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZGFcIl06IFwiZGVhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJlY1wiXTogXCJlcnJvckNhcHR1cmVkIGhvb2tcIixcbiAgW1wicnRjXCJdOiBcInJlbmRlclRyYWNrZWQgaG9va1wiLFxuICBbXCJydGdcIl06IFwicmVuZGVyVHJpZ2dlcmVkIGhvb2tcIixcbiAgWzBdOiBcInNldHVwIGZ1bmN0aW9uXCIsXG4gIFsxXTogXCJyZW5kZXIgZnVuY3Rpb25cIixcbiAgWzJdOiBcIndhdGNoZXIgZ2V0dGVyXCIsXG4gIFszXTogXCJ3YXRjaGVyIGNhbGxiYWNrXCIsXG4gIFs0XTogXCJ3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb25cIixcbiAgWzVdOiBcIm5hdGl2ZSBldmVudCBoYW5kbGVyXCIsXG4gIFs2XTogXCJjb21wb25lbnQgZXZlbnQgaGFuZGxlclwiLFxuICBbN106IFwidm5vZGUgaG9va1wiLFxuICBbOF06IFwiZGlyZWN0aXZlIGhvb2tcIixcbiAgWzldOiBcInRyYW5zaXRpb24gaG9va1wiLFxuICBbMTBdOiBcImFwcCBlcnJvckhhbmRsZXJcIixcbiAgWzExXTogXCJhcHAgd2FybkhhbmRsZXJcIixcbiAgWzEyXTogXCJyZWYgZnVuY3Rpb25cIixcbiAgWzEzXTogXCJhc3luYyBjb21wb25lbnQgbG9hZGVyXCIsXG4gIFsxNF06IFwic2NoZWR1bGVyIGZsdXNoXCIsXG4gIFsxNV06IFwiY29tcG9uZW50IHVwZGF0ZVwiLFxuICBbMTZdOiBcImFwcCB1bm1vdW50IGNsZWFudXAgZnVuY3Rpb25cIlxufTtcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChpc0FycmF5KGZuKSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgSW52YWxpZCB2YWx1ZSB0eXBlIHBhc3NlZCB0byBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZygpOiAke3R5cGVvZiBmbn1gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcbiAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XG4gIGNvbnN0IHsgZXJyb3JIYW5kbGVyLCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uIH0gPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyB8fCBFTVBUWV9PQko7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XG4gICAgY29uc3QgZXJyb3JJbmZvID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXSA6IGBodHRwczovL3Z1ZWpzLm9yZy9lcnJvci1yZWZlcmVuY2UvI3J1bnRpbWUtJHt0eXBlfWA7XG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xuICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgIH1cbiAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZXJyb3JIYW5kbGVyLCBudWxsLCAxMCwgW1xuICAgICAgICBlcnIsXG4gICAgICAgIGV4cG9zZWRJbnN0YW5jZSxcbiAgICAgICAgZXJyb3JJbmZvXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYsIHRocm93VW5oYW5kbGVkRXJyb3JJblByb2R1Y3Rpb24pO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlLCB0aHJvd0luUHJvZCA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcbiAgICB9XG4gICAgd2FybiQxKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgIH1cbiAgICBpZiAodGhyb3dJbkRldikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRocm93SW5Qcm9kKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IGZsdXNoSW5kZXggPSAtMTtcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcbiAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcbn1cbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChpZCkge1xuICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcbiAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBlbmQgPj4+IDE7XG4gICAgY29uc3QgbWlkZGxlSm9iID0gcXVldWVbbWlkZGxlXTtcbiAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKG1pZGRsZUpvYik7XG4gICAgaWYgKG1pZGRsZUpvYklkIDwgaWQgfHwgbWlkZGxlSm9iSWQgPT09IGlkICYmIG1pZGRsZUpvYi5mbGFncyAmIDIpIHtcbiAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gbWlkZGxlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcbiAgaWYgKCEoam9iLmZsYWdzICYgMSkpIHtcbiAgICBjb25zdCBqb2JJZCA9IGdldElkKGpvYik7XG4gICAgY29uc3QgbGFzdEpvYiA9IHF1ZXVlW3F1ZXVlLmxlbmd0aCAtIDFdO1xuICAgIGlmICghbGFzdEpvYiB8fCAvLyBmYXN0IHBhdGggd2hlbiB0aGUgam9iIGlkIGlzIGxhcmdlciB0aGFuIHRoZSB0YWlsXG4gICAgIShqb2IuZmxhZ3MgJiAyKSAmJiBqb2JJZCA+PSBnZXRJZChsYXN0Sm9iKSkge1xuICAgICAgcXVldWUucHVzaChqb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYklkKSwgMCwgam9iKTtcbiAgICB9XG4gICAgam9iLmZsYWdzIHw9IDE7XG4gICAgcXVldWVGbHVzaCgpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xuICBpZiAoIWN1cnJlbnRGbHVzaFByb21pc2UpIHtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xuICBpZiAoIWlzQXJyYXkoY2IpKSB7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicyAmJiBjYi5pZCA9PT0gLTEpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zcGxpY2UocG9zdEZsdXNoSW5kZXggKyAxLCAwLCBjYik7XG4gICAgfSBlbHNlIGlmICghKGNiLmZsYWdzICYgMSkpIHtcbiAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaChjYik7XG4gICAgICBjYi5mbGFncyB8PSAxO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goLi4uY2IpO1xuICB9XG4gIHF1ZXVlRmx1c2goKTtcbn1cbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoaW5zdGFuY2UsIHNlZW4sIGkgPSBmbHVzaEluZGV4ICsgMSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNiID0gcXVldWVbaV07XG4gICAgaWYgKGNiICYmIGNiLmZsYWdzICYgMikge1xuICAgICAgaWYgKGluc3RhbmNlICYmIGNiLmlkICE9PSBpbnN0YW5jZS51aWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgaS0tO1xuICAgICAgaWYgKGNiLmZsYWdzICYgNCkge1xuICAgICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICAgIGNiKCk7XG4gICAgICBpZiAoIShjYi5mbGFncyAmIDQpKSB7XG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xuICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldLnNvcnQoXG4gICAgICAoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKVxuICAgICk7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBjYiA9IGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF07XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNiLmZsYWdzICYgNCkge1xuICAgICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICAgIGlmICghKGNiLmZsYWdzICYgOCkpIGNiKCk7XG4gICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbiAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XG4gIH1cbn1cbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBqb2IuZmxhZ3MgJiAyID8gLTEgOiBJbmZpbml0eSA6IGpvYi5pZDtcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBjb25zdCBjaGVjayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKSA6IE5PT1A7XG4gIHRyeSB7XG4gICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IgJiYgIShqb2IuZmxhZ3MgJiA4KSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVjayhqb2IpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpvYi5mbGFncyAmIDQpIHtcbiAgICAgICAgICBqb2IuZmxhZ3MgJj0gfjE7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgICAgIGpvYixcbiAgICAgICAgICBqb2IuaSxcbiAgICAgICAgICBqb2IuaSA/IDE1IDogMTRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEoam9iLmZsYWdzICYgNCkpIHtcbiAgICAgICAgICBqb2IuZmxhZ3MgJj0gfjE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZm9yICg7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iKSB7XG4gICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hJbmRleCA9IC0xO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCB8fCBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgICAgZmx1c2hKb2JzKHNlZW4pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XG4gIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pIHx8IDA7XG4gIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZm4uaTtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcbiAgICBoYW5kbGVFcnJvcihcbiAgICAgIGBNYXhpbXVtIHJlY3Vyc2l2ZSB1cGRhdGVzIGV4Y2VlZGVkJHtjb21wb25lbnROYW1lID8gYCBpbiBjb21wb25lbnQgPCR7Y29tcG9uZW50TmFtZX0+YCA6IGBgfS4gVGhpcyBtZWFucyB5b3UgaGF2ZSBhIHJlYWN0aXZlIGVmZmVjdCB0aGF0IGlzIG11dGF0aW5nIGl0cyBvd24gZGVwZW5kZW5jaWVzIGFuZCB0aHVzIHJlY3Vyc2l2ZWx5IHRyaWdnZXJpbmcgaXRzZWxmLiBQb3NzaWJsZSBzb3VyY2VzIGluY2x1ZGUgY29tcG9uZW50IHRlbXBsYXRlLCByZW5kZXIgZnVuY3Rpb24sIHVwZGF0ZWQgaG9vayBvciB3YXRjaGVyIHNvdXJjZSBmdW5jdGlvbi5gLFxuICAgICAgbnVsbCxcbiAgICAgIDEwXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZWVuLnNldChmbiwgY291bnQgKyAxKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xuICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxuICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcbiAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxuICB9O1xufVxuY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xuICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcbiAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgfVxuICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xuICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFwLnNldChpZCwge1xuICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxuICAgIGluc3RhbmNlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gIFsuLi5yZWNvcmQuaW5zdGFuY2VzXS5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgIGlmIChuZXdSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcbiAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkgcmV0dXJuO1xuICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XG4gIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XG4gIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5yZWNvcmQuaW5zdGFuY2VzXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XG4gICAgbGV0IGRpcnR5SW5zdGFuY2VzID0gaG1yRGlydHlDb21wb25lbnRzLmdldChvbGRDb21wKTtcbiAgICBpZiAoIWRpcnR5SW5zdGFuY2VzKSB7XG4gICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xuICAgICAgfVxuICAgICAgaG1yRGlydHlDb21wb25lbnRzLnNldChvbGRDb21wLCBkaXJ0eUluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBkaXJ0eUluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQucHJvcHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5lbWl0c0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XG4gICAgICBkaXJ0eUluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xuICAgICAgaW5zdGFuY2UuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xuICAgICAgZGlydHlJbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgcXVldWVKb2IoKCkgPT4ge1xuICAgICAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UucGFyZW50LnVwZGF0ZSgpO1xuICAgICAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XG4gICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnJvb3QuY2UgJiYgaW5zdGFuY2UgIT09IGluc3RhbmNlLnJvb3QpIHtcbiAgICAgIGluc3RhbmNlLnJvb3QuY2UuX3JlbW92ZUNoaWxkU3R5bGUob2xkQ29tcCk7XG4gICAgfVxuICB9XG4gIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xuICAgIGhtckRpcnR5Q29tcG9uZW50cy5jbGVhcigpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XG4gIGV4dGVuZChvbGRDb21wLCBuZXdDb21wKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xuICAgIGlmIChrZXkgIT09IFwiX19maWxlXCIgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcbiAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cnlXcmFwKGZuKSB7XG4gIHJldHVybiAoaWQsIGFyZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oaWQsIGFyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5sZXQgZGV2dG9vbHMkMTtcbmxldCBidWZmZXIgPSBbXTtcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdCQxKGV2ZW50LCAuLi5hcmdzKSB7XG4gIGlmIChkZXZ0b29scyQxKSB7XG4gICAgZGV2dG9vbHMkMS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfSBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcbiAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2skMShob29rLCB0YXJnZXQpIHtcbiAgdmFyIF9hLCBfYjtcbiAgZGV2dG9vbHMkMSA9IGhvb2s7XG4gIGlmIChkZXZ0b29scyQxKSB7XG4gICAgZGV2dG9vbHMkMS5lbmFibGVkID0gdHJ1ZTtcbiAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfSBlbHNlIGlmIChcbiAgICAvLyBoYW5kbGUgbGF0ZSBkZXZ0b29scyBpbmplY3Rpb24gLSBvbmx5IGRvIHRoaXMgaWYgd2UgYXJlIGluIGFuIGFjdHVhbFxuICAgIC8vIGJyb3dzZXIgZW52aXJvbm1lbnQgdG8gYXZvaWQgdGhlIHRpbWVyIGhhbmRsZSBzdGFsbGluZyB0ZXN0IHJ1bm5lciBleGl0XG4gICAgLy8gKCM0ODE1KVxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgLy8gc29tZSBlbnZzIG1vY2sgd2luZG93IGJ1dCBub3QgZnVsbHlcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiYgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJqc2RvbVwiKSlcbiAgKSB7XG4gICAgY29uc3QgcmVwbGF5ID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyB8fCBbXTtcbiAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgc2V0RGV2dG9vbHNIb29rJDEobmV3SG9vaywgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghZGV2dG9vbHMkMSkge1xuICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfSwgM2UzKTtcbiAgfSBlbHNlIHtcbiAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgYnVmZmVyID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcbiAgZW1pdCQxKFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XG4gICAgRnJhZ21lbnQsXG4gICAgVGV4dCxcbiAgICBDb21tZW50LFxuICAgIFN0YXRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcbiAgZW1pdCQxKFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgYXBwKTtcbn1cbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovKTtcbmNvbnN0IF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFxuICBcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi9cbik7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAoY29tcG9uZW50KSA9PiB7XG4gIGlmIChkZXZ0b29scyQxICYmIHR5cGVvZiBkZXZ0b29scyQxLmNsZWFudXBCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyByZW1vdmUgdGhlIGNvbXBvbmVudCBpZiBpdCB3YXNuJ3QgYnVmZmVyZWRcbiAgIWRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XG4gICAgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChjb21wb25lbnQpO1xuICB9XG59O1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcbiAgICBlbWl0JDEoXG4gICAgICBob29rLFxuICAgICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgICAgY29tcG9uZW50LnVpZCxcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHZvaWQgMCxcbiAgICAgIGNvbXBvbmVudFxuICAgICk7XG4gIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqLyk7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqLyk7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XG4gICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgZW1pdCQxKFxuICAgIFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLyxcbiAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgY29tcG9uZW50LFxuICAgIGV2ZW50LFxuICAgIHBhcmFtc1xuICApO1xufVxuXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XG4gIGN1cnJlbnRTY29wZUlkID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQgfHwgbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICBjdXJyZW50U2NvcGVJZCA9IGlkO1xufVxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QpIHtcbiAgaWYgKCFjdHgpIHJldHVybiBmbjtcbiAgaWYgKGZuLl9uKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG4gIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gZm4oLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xuICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XG4gIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICB3YXJuJDEoXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSk7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xuICAgIGlmIChkaXIpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcbiAgICAgICAgZGlyID0ge1xuICAgICAgICAgIG1vdW50ZWQ6IGRpcixcbiAgICAgICAgICB1cGRhdGVkOiBkaXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXIuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgZGlyLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGFyZyxcbiAgICAgICAgbW9kaWZpZXJzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgcHJldlZOb2RlLCBpbnN0YW5jZSwgbmFtZSkge1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XG4gIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgIGlmIChvbGRCaW5kaW5ncykge1xuICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xuICAgIH1cbiAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgIGlmIChob29rKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCwgW1xuICAgICAgICB2bm9kZS5lbCxcbiAgICAgICAgYmluZGluZyxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHByZXZWTm9kZVxuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRlbGVwb3J0RW5kS2V5ID0gU3ltYm9sKFwiX3Z0ZVwiKTtcbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gXCJcIik7XG5jb25zdCBpc1RlbGVwb3J0RGVmZXJyZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kZWZlciB8fCBwcm9wcy5kZWZlciA9PT0gXCJcIik7XG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCBpc1RhcmdldE1hdGhNTCA9ICh0YXJnZXQpID0+IHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudDtcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xuICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xuICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XG4gICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldCAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTZWxlY3RvcjtcbiAgfVxufTtcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcbiAgbmFtZTogXCJUZWxlcG9ydFwiLFxuICBfX2lzVGVsZXBvcnQ6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgICAgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfVxuICAgIH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xuICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBuMi5lbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgc3RhcnRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgZW5kXCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lcjIsIGFuY2hvcjIpID0+IHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuaXNDRSkge1xuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmNlLl90ZWxlcG9ydFRhcmdldCA9IGNvbnRhaW5lcjI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbW91bnRUb1RhcmdldCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3Rvcik7XG4gICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IHByZXBhcmVBbmNob3IodGFyZ2V0LCBuMiwgY3JlYXRlVGV4dCwgaW5zZXJ0KTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIGlmIChuYW1lc3BhY2UgIT09IFwic3ZnXCIgJiYgaXNUYXJnZXRTVkcodGFyZ2V0KSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSAhPT0gXCJtYXRobWxcIiAmJiBpc1RhcmdldE1hdGhNTCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICB1cGRhdGVDc3NWYXJzKG4yLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDpcIixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgICB1cGRhdGVDc3NWYXJzKG4yLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RlbGVwb3J0RGVmZXJyZWQobjIucHJvcHMpKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbW91bnRUb1RhcmdldCgpO1xuICAgICAgICAgIG4yLmVsLl9faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRUb1RhcmdldCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZWxlcG9ydERlZmVycmVkKG4yLnByb3BzKSAmJiAhbjEuZWwuX19pc01vdW50ZWQpIHtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBUZWxlcG9ydEltcGwucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGVsZXRlIG4xLmVsLl9faXNNb3VudGVkO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi50YXJnZXRTdGFydCA9IG4xLnRhcmdldFN0YXJ0O1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IG4xLnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcjtcbiAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBcIm1hdGhtbFwiIHx8IGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIGN1cnJlbnRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBtYWluQW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG4yLnByb3BzICYmIG4xLnByb3BzICYmIG4yLnByb3BzLnRvICE9PSBuMS5wcm9wcy50bykge1xuICAgICAgICAgICAgbjIucHJvcHMudG8gPSBuMS5wcm9wcy50bztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgICAgICAgICBuMi5wcm9wcyxcbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgICBuZXh0VGFyZ2V0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOlwiLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIGRpc2FibGVkKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgYW5jaG9yLFxuICAgICAgdGFyZ2V0U3RhcnQsXG4gICAgICB0YXJnZXRBbmNob3IsXG4gICAgICB0YXJnZXQsXG4gICAgICBwcm9wc1xuICAgIH0gPSB2bm9kZTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBob3N0UmVtb3ZlKHRhcmdldFN0YXJ0KTtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcbiAgICB9XG4gICAgZG9SZW1vdmUgJiYgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlID0gZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNob3VsZFJlbW92ZSxcbiAgICAgICAgICAhIWNoaWxkLmR5bmFtaWNDaGlsZHJlblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW92ZTogbW92ZVRlbGVwb3J0LFxuICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcbn07XG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyKSB7XG4gIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcbiAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDI7XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoXG4gICAgICAgICAgY2hpbGRyZW5baV0sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudEFuY2hvcixcbiAgICAgICAgICAyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHtcbiAgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciwgaW5zZXJ0LCBjcmVhdGVUZXh0IH1cbn0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgIHZub2RlLnByb3BzLFxuICAgIHF1ZXJ5U2VsZWN0b3JcbiAgKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKTtcbiAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudE5vZGUobm9kZSksXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXROb2RlO1xuICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlICYmIG5leHRTaWJsaW5nKHRhcmdldE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIGxldCB0YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xuICAgICAgICB3aGlsZSAodGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgaWYgKHRhcmdldEFuY2hvciAmJiB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBzdGFydCBhbmNob3JcIikge1xuICAgICAgICAgICAgICB2bm9kZS50YXJnZXRTdGFydCA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgICB0YXJnZXQuX2xwYSA9IHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0QW5jaG9yID0gbmV4dFNpYmxpbmcodGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgICAgIHByZXBhcmVBbmNob3IodGFyZ2V0LCB2bm9kZSwgY3JlYXRlVGV4dCwgaW5zZXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ3NzVmFycyh2bm9kZSwgZGlzYWJsZWQpO1xuICB9XG4gIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcbn1cbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSwgaXNEaXNhYmxlZCkge1xuICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gIGlmIChjdHggJiYgY3R4LnV0KSB7XG4gICAgbGV0IG5vZGUsIGFuY2hvcjtcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgbm9kZSA9IHZub2RlLmVsO1xuICAgICAgYW5jaG9yID0gdm5vZGUuYW5jaG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdm5vZGUudGFyZ2V0U3RhcnQ7XG4gICAgICBhbmNob3IgPSB2bm9kZS50YXJnZXRBbmNob3I7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGFuY2hvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12LW93bmVyXCIsIGN0eC51aWQpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGN0eC51dCgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCkge1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHZub2RlLnRhcmdldFN0YXJ0ID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgY29uc3QgdGFyZ2V0QW5jaG9yID0gdm5vZGUudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgdGFyZ2V0U3RhcnRbVGVsZXBvcnRFbmRLZXldID0gdGFyZ2V0QW5jaG9yO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgaW5zZXJ0KHRhcmdldFN0YXJ0LCB0YXJnZXQpO1xuICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEFuY2hvcjtcbn1cblxuY29uc3QgbGVhdmVDYktleSA9IFN5bWJvbChcIl9sZWF2ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzTGVhdmluZzogZmFsc2UsXG4gICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgfSk7XG4gIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XG5jb25zdCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbW9kZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgLy8gZW50ZXJcbiAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gbGVhdmVcbiAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gYXBwZWFyXG4gIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG59O1xuY29uc3QgcmVjdXJzaXZlR2V0U3VidHJlZSA9IChpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgcmV0dXJuIHN1YlRyZWUuY29tcG9uZW50ID8gcmVjdXJzaXZlR2V0U3VidHJlZShzdWJUcmVlLmNvbXBvbmVudCkgOiBzdWJUcmVlO1xufTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcbiAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcbiAgcHJvcHM6IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGQgPSBmaW5kTm9uQ29tbWVudENoaWxkKGNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1vZGUgJiYgbW9kZSAhPT0gXCJpbi1vdXRcIiAmJiBtb2RlICE9PSBcIm91dC1pblwiICYmIG1vZGUgIT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHdhcm4kMShgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0SW5uZXJDaGlsZCQxKGNoaWxkKTtcbiAgICAgIGlmICghaW5uZXJDaGlsZCkge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBsZXQgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIGlubmVyQ2hpbGQsXG4gICAgICAgIHJhd1Byb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIC8vICMxMTA2MSwgZW5zdXJlIGVudGVySG9va3MgaXMgZnJlc2ggYWZ0ZXIgY2xvbmVcbiAgICAgICAgKGhvb2tzKSA9PiBlbnRlckhvb2tzID0gaG9va3NcbiAgICAgICk7XG4gICAgICBpZiAoaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcbiAgICAgIH1cbiAgICAgIGxldCBvbGRJbm5lckNoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZSAmJiBnZXRJbm5lckNoaWxkJDEoaW5zdGFuY2Uuc3ViVHJlZSk7XG4gICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJiBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiYgIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSAmJiByZWN1cnNpdmVHZXRTdWJ0cmVlKGluc3RhbmNlKS50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGxldCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgIG9sZElubmVyQ2hpbGQsXG4gICAgICAgICAgcmF3UHJvcHMsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XG4gICAgICAgIGlmIChtb2RlID09PSBcIm91dC1pblwiICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlLmpvYi5mbGFncyAmIDgpKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlO1xuICAgICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImluLW91dFwiICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XG4gICAgICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcbiAgICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZGVsYXllZExlYXZlKCk7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9sZElubmVyQ2hpbGQpIHtcbiAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gZmluZE5vbkNvbW1lbnRDaGlsZChjaGlsZHJlbikge1xuICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaGFzRm91bmQpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBcIjx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjO1xuICAgICAgICBoYXNGb3VuZCA9IHRydWU7XG4gICAgICAgIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZDtcbn1cbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcbiAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcbiAgbGV0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGxlYXZpbmdWTm9kZXMuZ2V0KHZub2RlLnR5cGUpO1xuICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xuICAgIGxlYXZpbmdWTm9kZXNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxlYXZpbmdWTm9kZXMuc2V0KHZub2RlLnR5cGUsIGxlYXZpbmdWTm9kZXNDYWNoZSk7XG4gIH1cbiAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UsIHBvc3RDbG9uZSkge1xuICBjb25zdCB7XG4gICAgYXBwZWFyLFxuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkID0gZmFsc2UsXG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uQWZ0ZXJFbnRlcixcbiAgICBvbkVudGVyQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlTGVhdmUsXG4gICAgb25MZWF2ZSxcbiAgICBvbkFmdGVyTGVhdmUsXG4gICAgb25MZWF2ZUNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUFwcGVhcixcbiAgICBvbkFwcGVhcixcbiAgICBvbkFmdGVyQXBwZWFyLFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XG4gIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKTtcbiAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgIGhvb2sgJiYgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBob29rLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA5LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH07XG4gIGNvbnN0IGNhbGxBc3luY0hvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgIGNvbnN0IGRvbmUgPSBhcmdzWzFdO1xuICAgIGNhbGxIb29rKGhvb2ssIGFyZ3MpO1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBpZiAoaG9vay5ldmVyeSgoaG9vazIpID0+IGhvb2syLmxlbmd0aCA8PSAxKSkgZG9uZSgpO1xuICAgIH0gZWxzZSBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaG9va3MgPSB7XG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQsXG4gICAgYmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbFtsZWF2ZUNiS2V5XSkge1xuICAgICAgICBlbFtsZWF2ZUNiS2V5XShcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiYgaXNTYW1lVk5vZGVUeXBlKHZub2RlLCBsZWF2aW5nVk5vZGUpICYmIGxlYXZpbmdWTm9kZS5lbFtsZWF2ZUNiS2V5XSkge1xuICAgICAgICBsZWF2aW5nVk5vZGUuZWxbbGVhdmVDYktleV0oKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbF0pO1xuICAgIH0sXG4gICAgZW50ZXIoZWwpIHtcbiAgICAgIGxldCBob29rID0gb25FbnRlcjtcbiAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XG4gICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XG4gICAgICAgICAgYWZ0ZXJIb29rID0gb25BZnRlckFwcGVhciB8fCBvbkFmdGVyRW50ZXI7XG4gICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWxbZW50ZXJDYktleV0gPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKGFmdGVySG9vaywgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xuICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsW2VudGVyQ2JLZXldID0gdm9pZCAwO1xuICAgICAgfTtcbiAgICAgIGlmIChob29rKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2soaG9vaywgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XG4gICAgICBjb25zdCBrZXkyID0gU3RyaW5nKHZub2RlLmtleSk7XG4gICAgICBpZiAoZWxbZW50ZXJDYktleV0pIHtcbiAgICAgICAgZWxbZW50ZXJDYktleV0oXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlzVW5tb3VudGluZykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbFtsZWF2ZUNiS2V5XSA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxbbGVhdmVDYktleV0gPSB2b2lkIDA7XG4gICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPT09IHZub2RlKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9IHZub2RlO1xuICAgICAgaWYgKG9uTGVhdmUpIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lKHZub2RlMikge1xuICAgICAgY29uc3QgaG9va3MyID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgdm5vZGUyLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBwb3N0Q2xvbmVcbiAgICAgICk7XG4gICAgICBpZiAocG9zdENsb25lKSBwb3N0Q2xvbmUoaG9va3MyKTtcbiAgICAgIHJldHVybiBob29rczI7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaG9va3M7XG59XG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XG4gIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQkMSh2bm9kZSkge1xuICBpZiAoIWlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIGlmIChpc1RlbGVwb3J0KHZub2RlLnR5cGUpICYmIHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gZmluZE5vbkNvbW1lbnRDaGlsZCh2bm9kZS5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAzMiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuLmRlZmF1bHQpKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4uZGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleSA9PSBudWxsID8gY2hpbGQua2V5IDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCwga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucykge1xuICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IChcbiAgICAvLyAjODIzNjogZXh0ZW5kIGNhbGwgYW5kIG9wdGlvbnMubmFtZSBhY2Nlc3MgYXJlIGNvbnNpZGVyZWQgc2lkZS1lZmZlY3RzXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxuICAgIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXh0ZW5kKHsgbmFtZTogb3B0aW9ucy5uYW1lIH0sIGV4dHJhT3B0aW9ucywgeyBzZXR1cDogb3B0aW9ucyB9KSkoKVxuICApIDogb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGkpIHtcbiAgICByZXR1cm4gKGkuYXBwQ29udGV4dC5jb25maWcuaWRQcmVmaXggfHwgXCJ2XCIpICsgXCItXCIgKyBpLmlkc1swXSArIGkuaWRzWzFdKys7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGB1c2VJZCgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuaWRzID0gW2luc3RhbmNlLmlkc1swXSArIGluc3RhbmNlLmlkc1syXSsrICsgXCItXCIsIDAsIDBdO1xufVxuXG5jb25zdCBrbm93blRlbXBsYXRlUmVmcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gdXNlVGVtcGxhdGVSZWYoa2V5KSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgciA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGlmIChpKSB7XG4gICAgY29uc3QgcmVmcyA9IGkucmVmcyA9PT0gRU1QVFlfT0JKID8gaS5yZWZzID0ge30gOiBpLnJlZnM7XG4gICAgbGV0IGRlc2M7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlZnMsIGtleSkpICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgd2FybiQxKGB1c2VUZW1wbGF0ZVJlZignJHtrZXl9JykgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWZzLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiByLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2YWwpID0+IHIudmFsdWUgPSB2YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHVzZVRlbXBsYXRlUmVmKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbiAgY29uc3QgcmV0ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHJlYWRvbmx5KHIpIDogcjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBrbm93blRlbXBsYXRlUmVmcy5hZGQocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcbiAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xuICAgIHJhd1JlZi5mb3JFYWNoKFxuICAgICAgKHIsIGkpID0+IHNldFJlZihcbiAgICAgICAgcixcbiAgICAgICAgb2xkUmF3UmVmICYmIChpc0FycmF5KG9sZFJhd1JlZikgPyBvbGRSYXdSZWZbaV0gOiBvbGRSYXdSZWYpLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGlzVW5tb3VudFxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIWlzVW5tb3VudCkge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA1MTIgJiYgdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgJiYgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUuY29tcG9uZW50KSB7XG4gICAgICBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLnNoYXBlRmxhZyAmIDQgPyBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSh2bm9kZS5jb21wb25lbnQpIDogdm5vZGUuZWw7XG4gIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xuICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW93bmVyKSB7XG4gICAgd2FybiQxKFxuICAgICAgYE1pc3NpbmcgcmVmIG93bmVyIGNvbnRleHQuIHJlZiBjYW5ub3QgYmUgdXNlZCBvbiBob2lzdGVkIHZub2Rlcy4gQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcbiAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IG93bmVyLnJlZnMgPSB7fSA6IG93bmVyLnJlZnM7XG4gIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xuICBjb25zdCByYXdTZXR1cFN0YXRlID0gdG9SYXcoc2V0dXBTdGF0ZSk7XG4gIGNvbnN0IGNhblNldFNldHVwUmVmID0gc2V0dXBTdGF0ZSA9PT0gRU1QVFlfT0JKID8gKCkgPT4gZmFsc2UgOiAoa2V5KSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChoYXNPd24ocmF3U2V0dXBTdGF0ZSwga2V5KSAmJiAhaXNSZWYocmF3U2V0dXBTdGF0ZVtrZXldKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFRlbXBsYXRlIHJlZiBcIiR7a2V5fVwiIHVzZWQgb24gYSBub24tcmVmIHZhbHVlLiBJdCB3aWxsIG5vdCB3b3JrIGluIHRoZSBwcm9kdWN0aW9uIGJ1aWxkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChrbm93blRlbXBsYXRlUmVmcy5oYXMocmF3U2V0dXBTdGF0ZVtrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNPd24ocmF3U2V0dXBTdGF0ZSwga2V5KTtcbiAgfTtcbiAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XG4gICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcbiAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XG4gICAgICBpZiAoY2FuU2V0U2V0dXBSZWYob2xkUmVmKSkge1xuICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xuICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiwgW3ZhbHVlLCByZWZzXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgX2lzU3RyaW5nID0gaXNTdHJpbmcocmVmKTtcbiAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJhd1JlZi5mKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyBjYW5TZXRTZXR1cFJlZihyZWYpID8gc2V0dXBTdGF0ZVtyZWZdIDogcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xuICAgICAgICAgIGlmIChpc1VubW91bnQpIHtcbiAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZShleGlzdGluZywgcmVmVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihyZWYpKSB7XG4gICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSByZWZzW3JlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoY2FuU2V0U2V0dXBSZWYocmVmKSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1JlZikge1xuICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChyYXdSZWYuaykgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9TZXQuaWQgPSAtMTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1NldCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgfVxuICB9XG59XG5cbmxldCBoYXNMb2dnZWRNaXNtYXRjaEVycm9yID0gZmFsc2U7XG5jb25zdCBsb2dNaXNtYXRjaEVycm9yID0gKCkgPT4ge1xuICBpZiAoaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmVycm9yKFwiSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5cIik7XG4gIGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSB0cnVlO1xufTtcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcInN2Z1wiKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gXCJmb3JlaWduT2JqZWN0XCI7XG5jb25zdCBpc01hdGhNTENvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJNYXRoTUxcIik7XG5jb25zdCBnZXRDb250YWluZXJUeXBlID0gKGNvbnRhaW5lcikgPT4ge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaXNTVkdDb250YWluZXIoY29udGFpbmVyKSkgcmV0dXJuIFwic3ZnXCI7XG4gIGlmIChpc01hdGhNTENvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJtYXRobWxcIjtcbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIHA6IHBhdGNoLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcCxcbiAgICAgIGNyZWF0ZVRleHQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICByZW1vdmUsXG4gICAgICBpbnNlcnQsXG4gICAgICBjcmVhdGVDb21tZW50XG4gICAgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcbiAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiO1xuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcbiAgICAgIG5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgaXNGcmFnbWVudFN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICB2bm9kZS5lbCA9IG5vZGU7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZWYobm9kZSwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcbiAgICAgIGRlZihub2RlLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIGlmIChkb21UeXBlICE9PSAzKSB7XG4gICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcbiAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoIGluYCxcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YVxuICAgICAgICAgICAgICApfVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIHJlcGxhY2VOb2RlKFxuICAgICAgICAgICAgdm5vZGUuZWwgPSBub2RlLmNvbnRlbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGRvbVR5cGUgIT09IDggfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21UeXBlID09PSAxIHx8IGRvbVR5cGUgPT09IDMpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm5vZGVUeXBlID09PSAxID8gbmV4dE5vZGUub3V0ZXJIVE1MIDogbmV4dE5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzRnJhZ21lbnRTdGFydCA/IG5leHRTaWJsaW5nKG5leHROb2RlKSA6IG5leHROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIGlmICgoZG9tVHlwZSAhPT0gMSB8fCB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiAhaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0XCIpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlLCBub2RlLmRhdGEsIFwidGVsZXBvcnQgZW5kXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICF2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICAgICAgbGV0IHN1YlRyZWU7XG4gICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XG4gICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGUgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmcgOiBjb250YWluZXIubGFzdENoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoXCJcIikgOiBjcmVhdGVWTm9kZShcImRpdlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xuICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUgPSBzdWJUcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICAgIGh5ZHJhdGVDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGdldENvbnRhaW5lclR5cGUocGFyZW50Tm9kZShub2RlKSksXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgSG9zdFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dE5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGNvbnN0IGZvcmNlUGF0Y2ggPSB0eXBlID09PSBcImlucHV0XCIgfHwgdHlwZSA9PT0gXCJvcHRpb25cIjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmb3JjZVBhdGNoIHx8IHBhdGNoRmxhZyAhPT0gLTEpIHtcbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgICAgfVxuICAgICAgbGV0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gZmFsc2U7XG4gICAgICBpZiAoaXNUZW1wbGF0ZU5vZGUoZWwpKSB7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24oXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBubyBuZWVkIGNoZWNrIHBhcmVudFN1c3BlbnNlIGluIGh5ZHJhdGlvblxuICAgICAgICAgIHRyYW5zaXRpb25cbiAgICAgICAgKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcy5hcHBlYXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZU5vZGUoY29udGVudCwgZWwsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIHZub2RlLmVsID0gZWwgPSBjb250ZW50O1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2ICYmIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcbiAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIGVsLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgIHJlbW92ZShjdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgbGV0IGNsaWVudFRleHQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNsaWVudFRleHRbMF0gPT09IFwiXFxuXCIgJiYgKGVsLnRhZ05hbWUgPT09IFwiUFJFXCIgfHwgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSkge1xuICAgICAgICAgIGNsaWVudFRleHQgPSBjbGllbnRUZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gY2xpZW50VGV4dCkge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDAgLyogVEVYVCAqLykpIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2VsLnRleHRDb250ZW50fVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHt2bm9kZS5jaGlsZHJlbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fIHx8IGZvcmNlUGF0Y2ggfHwgIW9wdGltaXplZCB8fCBwYXRjaEZsYWcgJiAoMTYgfCAzMikpIHtcbiAgICAgICAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgLy8gIzExMTg5IHNraXAgaWYgdGhpcyBub2RlIGhhcyBkaXJlY3RpdmVzIHRoYXQgaGF2ZSBjcmVhdGVkIGhvb2tzXG4gICAgICAgICAgICAvLyBhcyBpdCBjb3VsZCBoYXZlIG11dGF0ZWQgdGhlIERPTSBpbiBhbnkgcG9zc2libGUgd2F5XG4gICAgICAgICAgICAhKGRpcnMgJiYgZGlycy5zb21lKChkKSA9PiBkLmRpci5jcmVhdGVkKSkgJiYgcHJvcEhhc01pc21hdGNoKGVsLCBrZXksIHByb3BzW2tleV0sIHZub2RlLCBwYXJlbnRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoICYmIChrZXkuZW5kc1dpdGgoXCJ2YWx1ZVwiKSB8fCBrZXkgPT09IFwiaW5kZXRlcm1pbmF0ZVwiKSB8fCBpc09uKGtleSkgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkgfHwgLy8gZm9yY2UgaHlkcmF0ZSB2LWJpbmQgd2l0aCAucHJvcCBtb2RpZmllcnNcbiAgICAgICAgICAgIGtleVswXSA9PT0gXCIuXCIgfHwgaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCB2b2lkIDAsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICBwYXRjaFByb3AoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2ssXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDQgJiYgaXNSZWFjdGl2ZShwcm9wcy5zdHlsZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcy5zdHlsZSkgcHJvcHMuc3R5bGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICBpZiAodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycyB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZCA/IGNoaWxkcmVuW2ldIDogY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBjb25zdCBpc1RleHQgPSB2bm9kZS50eXBlID09PSBUZXh0O1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzVGV4dCAmJiAhb3B0aW1pemVkKSB7XG4gICAgICAgICAgaWYgKGkgKyAxIDwgbCAmJiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpICsgMV0pLnR5cGUgPT09IFRleHQpIHtcbiAgICAgICAgICAgIGluc2VydChcbiAgICAgICAgICAgICAgY3JlYXRlVGV4dChcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEuc2xpY2Uodm5vZGUuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIG5leHRTaWJsaW5nKG5vZGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoY29udGFpbmVyLCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgYFxuU2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgbmV4dFNpYmxpbmcobm9kZSksXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgb3B0aW1pemVkXG4gICAgKTtcbiAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvciA9IG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICBpbnNlcnQodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApLCBjb250YWluZXIsIG5leHQpO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XG4gICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChub2RlLnBhcmVudEVsZW1lbnQsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxuLSByZW5kZXJlZCBvbiBzZXJ2ZXI6YCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGAodGV4dClgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWAgOiBgYCxcbiAgICAgICAgYFxuLSBleHBlY3RlZCBvbiBjbGllbnQ6YCxcbiAgICAgICAgdm5vZGUudHlwZVxuICAgICAgKTtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICB9XG4gICAgdm5vZGUuZWwgPSBudWxsO1xuICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dDIgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgaWYgKG5leHQyICYmIG5leHQyICE9PSBlbmQpIHtcbiAgICAgICAgICByZW1vdmUobmV4dDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIHJlbW92ZShub2RlKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5leHQsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gdm5vZGUuZWw7XG4gICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCB2bm9kZS5lbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9O1xuICBjb25zdCBsb2NhdGVDbG9zaW5nQW5jaG9yID0gKG5vZGUsIG9wZW4gPSBcIltcIiwgY2xvc2UgPSBcIl1cIikgPT4ge1xuICAgIGxldCBtYXRjaCA9IDA7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBvcGVuKSBtYXRjaCsrO1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBjbG9zZSkge1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgcmVwbGFjZU5vZGUgPSAobmV3Tm9kZSwgb2xkTm9kZSwgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgY29uc3QgcGFyZW50Tm9kZTIgPSBvbGROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUyKSB7XG4gICAgICBwYXJlbnROb2RlMi5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgb2xkTm9kZSk7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBwYXJlbnRDb21wb25lbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC52bm9kZS5lbCA9PT0gb2xkTm9kZSkge1xuICAgICAgICBwYXJlbnQudm5vZGUuZWwgPSBwYXJlbnQuc3ViVHJlZS5lbCA9IG5ld05vZGU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaXNUZW1wbGF0ZU5vZGUgPSAobm9kZSkgPT4ge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUudGFnTmFtZSA9PT0gXCJURU1QTEFURVwiO1xuICB9O1xuICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcbn1cbmZ1bmN0aW9uIHByb3BIYXNNaXNtYXRjaChlbCwga2V5LCBjbGllbnRWYWx1ZSwgdm5vZGUsIGluc3RhbmNlKSB7XG4gIGxldCBtaXNtYXRjaFR5cGU7XG4gIGxldCBtaXNtYXRjaEtleTtcbiAgbGV0IGFjdHVhbDtcbiAgbGV0IGV4cGVjdGVkO1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICBleHBlY3RlZCA9IG5vcm1hbGl6ZUNsYXNzKGNsaWVudFZhbHVlKTtcbiAgICBpZiAoIWlzU2V0RXF1YWwodG9DbGFzc1NldChhY3R1YWwgfHwgXCJcIiksIHRvQ2xhc3NTZXQoZXhwZWN0ZWQpKSkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gMiAvKiBDTEFTUyAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0gYGNsYXNzYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xuICAgIGV4cGVjdGVkID0gaXNTdHJpbmcoY2xpZW50VmFsdWUpID8gY2xpZW50VmFsdWUgOiBzdHJpbmdpZnlTdHlsZShub3JtYWxpemVTdHlsZShjbGllbnRWYWx1ZSkpO1xuICAgIGNvbnN0IGFjdHVhbE1hcCA9IHRvU3R5bGVNYXAoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZE1hcCA9IHRvU3R5bGVNYXAoZXhwZWN0ZWQpO1xuICAgIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgZGlyLCB2YWx1ZSB9IG9mIHZub2RlLmRpcnMpIHtcbiAgICAgICAgaWYgKGRpci5uYW1lID09PSBcInNob3dcIiAmJiAhdmFsdWUpIHtcbiAgICAgICAgICBleHBlY3RlZE1hcC5zZXQoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApO1xuICAgIH1cbiAgICBpZiAoIWlzTWFwRXF1YWwoYWN0dWFsTWFwLCBleHBlY3RlZE1hcCkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDMgLyogU1RZTEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IFwic3R5bGVcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGlzS25vd25TdmdBdHRyKGtleSkgfHwgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoaXNCb29sZWFuQXR0cihrZXkpIHx8IGlzS25vd25IdG1sQXR0cihrZXkpKSkge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBpbmNsdWRlQm9vbGVhbkF0dHIoY2xpZW50VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgYWN0dWFsID0gZWwuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgICBleHBlY3RlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICBhY3R1YWwgPSBlbC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhwZWN0ZWQgPSBpc1JlbmRlcmFibGVBdHRyVmFsdWUoY2xpZW50VmFsdWUpID8gU3RyaW5nKGNsaWVudFZhbHVlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gNCAvKiBBVFRSSUJVVEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGtleTtcbiAgICB9XG4gIH1cbiAgaWYgKG1pc21hdGNoVHlwZSAhPSBudWxsICYmICFpc01pc21hdGNoQWxsb3dlZChlbCwgbWlzbWF0Y2hUeXBlKSkge1xuICAgIGNvbnN0IGZvcm1hdCA9ICh2KSA9PiB2ID09PSBmYWxzZSA/IGAobm90IHJlbmRlcmVkKWAgOiBgJHttaXNtYXRjaEtleX09XCIke3Z9XCJgO1xuICAgIGNvbnN0IHByZVNlZ21lbnQgPSBgSHlkcmF0aW9uICR7TWlzbWF0Y2hUeXBlU3RyaW5nW21pc21hdGNoVHlwZV19IG1pc21hdGNoIG9uYDtcbiAgICBjb25zdCBwb3N0U2VnbWVudCA9IGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7Zm9ybWF0KGFjdHVhbCl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke2Zvcm1hdChleHBlY3RlZCl9XG4gIE5vdGU6IHRoaXMgbWlzbWF0Y2ggaXMgY2hlY2stb25seS4gVGhlIERPTSB3aWxsIG5vdCBiZSByZWN0aWZpZWQgaW4gcHJvZHVjdGlvbiBkdWUgdG8gcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXG4gIFlvdSBzaG91bGQgZml4IHRoZSBzb3VyY2Ugb2YgdGhlIG1pc21hdGNoLmA7XG4gICAge1xuICAgICAgd2FybiQxKHByZVNlZ21lbnQsIGVsLCBwb3N0U2VnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvQ2xhc3NTZXQoc3RyKSB7XG4gIHJldHVybiBuZXcgU2V0KHN0ci50cmltKCkuc3BsaXQoL1xccysvKSk7XG59XG5mdW5jdGlvbiBpc1NldEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgcyBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvU3R5bGVNYXAoc3RyKSB7XG4gIGNvbnN0IHN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHN0ci5zcGxpdChcIjtcIikpIHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdChcIjpcIik7XG4gICAga2V5ID0ga2V5LnRyaW0oKTtcbiAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnRyaW0oKTtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICBzdHlsZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTWFwRXF1YWwoYSwgYikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYSkge1xuICAgIGlmICh2YWx1ZSAhPT0gYi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApIHtcbiAgY29uc3Qgcm9vdCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIGlmIChpbnN0YW5jZS5nZXRDc3NWYXJzICYmICh2bm9kZSA9PT0gcm9vdCB8fCByb290ICYmIHJvb3QudHlwZSA9PT0gRnJhZ21lbnQgJiYgcm9vdC5jaGlsZHJlbi5pbmNsdWRlcyh2bm9kZSkpKSB7XG4gICAgY29uc3QgY3NzVmFycyA9IGluc3RhbmNlLmdldENzc1ZhcnMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjc3NWYXJzKSB7XG4gICAgICBleHBlY3RlZE1hcC5zZXQoXG4gICAgICAgIGAtLSR7Z2V0RXNjYXBlZENzc1Zhck5hbWUoa2V5LCBmYWxzZSl9YCxcbiAgICAgICAgU3RyaW5nKGNzc1ZhcnNba2V5XSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZSA9PT0gcm9vdCAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlLnZub2RlLCBleHBlY3RlZE1hcCk7XG4gIH1cbn1cbmNvbnN0IGFsbG93TWlzbWF0Y2hBdHRyID0gXCJkYXRhLWFsbG93LW1pc21hdGNoXCI7XG5jb25zdCBNaXNtYXRjaFR5cGVTdHJpbmcgPSB7XG4gIFswIC8qIFRFWFQgKi9dOiBcInRleHRcIixcbiAgWzEgLyogQ0hJTERSRU4gKi9dOiBcImNoaWxkcmVuXCIsXG4gIFsyIC8qIENMQVNTICovXTogXCJjbGFzc1wiLFxuICBbMyAvKiBTVFlMRSAqL106IFwic3R5bGVcIixcbiAgWzQgLyogQVRUUklCVVRFICovXTogXCJhdHRyaWJ1dGVcIlxufTtcbmZ1bmN0aW9uIGlzTWlzbWF0Y2hBbGxvd2VkKGVsLCBhbGxvd2VkVHlwZSkge1xuICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyB8fCBhbGxvd2VkVHlwZSA9PT0gMSAvKiBDSElMRFJFTiAqLykge1xuICAgIHdoaWxlIChlbCAmJiAhZWwuaGFzQXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKSkge1xuICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCBhbGxvd2VkQXR0ciA9IGVsICYmIGVsLmdldEF0dHJpYnV0ZShhbGxvd01pc21hdGNoQXR0cik7XG4gIGlmIChhbGxvd2VkQXR0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGFsbG93ZWRBdHRyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9IGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKTtcbiAgICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyAmJiBsaXN0LmluY2x1ZGVzKFwiY2hpbGRyZW5cIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYWxsb3dlZEF0dHIuc3BsaXQoXCIsXCIpLmluY2x1ZGVzKE1pc21hdGNoVHlwZVN0cmluZ1thbGxvd2VkVHlwZV0pO1xuICB9XG59XG5cbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSBnZXRHbG9iYWxUaGlzKCkucmVxdWVzdElkbGVDYWxsYmFjayB8fCAoKGNiKSA9PiBzZXRUaW1lb3V0KGNiLCAxKSk7XG5jb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPSBnZXRHbG9iYWxUaGlzKCkuY2FuY2VsSWRsZUNhbGxiYWNrIHx8ICgoaWQpID0+IGNsZWFyVGltZW91dChpZCkpO1xuY29uc3QgaHlkcmF0ZU9uSWRsZSA9ICh0aW1lb3V0ID0gMWU0KSA9PiAoaHlkcmF0ZSkgPT4ge1xuICBjb25zdCBpZCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soaHlkcmF0ZSwgeyB0aW1lb3V0IH0pO1xuICByZXR1cm4gKCkgPT4gY2FuY2VsSWRsZUNhbGxiYWNrKGlkKTtcbn07XG5mdW5jdGlvbiBlbGVtZW50SXNWaXNpYmxlSW5WaWV3cG9ydChlbCkge1xuICBjb25zdCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHsgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGggfSA9IHdpbmRvdztcbiAgcmV0dXJuICh0b3AgPiAwICYmIHRvcCA8IGlubmVySGVpZ2h0IHx8IGJvdHRvbSA+IDAgJiYgYm90dG9tIDwgaW5uZXJIZWlnaHQpICYmIChsZWZ0ID4gMCAmJiBsZWZ0IDwgaW5uZXJXaWR0aCB8fCByaWdodCA+IDAgJiYgcmlnaHQgPCBpbm5lcldpZHRoKTtcbn1cbmNvbnN0IGh5ZHJhdGVPblZpc2libGUgPSAob3B0cykgPT4gKGh5ZHJhdGUsIGZvckVhY2gpID0+IHtcbiAgY29uc3Qgb2IgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgaWYgKCFlLmlzSW50ZXJzZWN0aW5nKSBjb250aW51ZTtcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIGZvckVhY2goKGVsKSA9PiB7XG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgIGlmIChlbGVtZW50SXNWaXNpYmxlSW5WaWV3cG9ydChlbCkpIHtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2Iub2JzZXJ2ZShlbCk7XG4gIH0pO1xuICByZXR1cm4gKCkgPT4gb2IuZGlzY29ubmVjdCgpO1xufTtcbmNvbnN0IGh5ZHJhdGVPbk1lZGlhUXVlcnkgPSAocXVlcnkpID0+IChoeWRyYXRlKSA9PiB7XG4gIGlmIChxdWVyeSkge1xuICAgIGNvbnN0IG1xbCA9IG1hdGNoTWVkaWEocXVlcnkpO1xuICAgIGlmIChtcWwubWF0Y2hlcykge1xuICAgICAgaHlkcmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtcWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gbXFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaHlkcmF0ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgaHlkcmF0ZU9uSW50ZXJhY3Rpb24gPSAoaW50ZXJhY3Rpb25zID0gW10pID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGlmIChpc1N0cmluZyhpbnRlcmFjdGlvbnMpKSBpbnRlcmFjdGlvbnMgPSBbaW50ZXJhY3Rpb25zXTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGRvSHlkcmF0ZSA9IChlKSA9PiB7XG4gICAgaWYgKCFoYXNIeWRyYXRlZCkge1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgdGVhcmRvd24oKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IGUuY29uc3RydWN0b3IoZS50eXBlLCBlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB0ZWFyZG93biA9ICgpID0+IHtcbiAgICBmb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGksIGRvSHlkcmF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvckVhY2goKGVsKSA9PiB7XG4gICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGVhcmRvd247XG59O1xuZnVuY3Rpb24gZm9yRWFjaEVsZW1lbnQobm9kZSwgY2IpIHtcbiAgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiKSB7XG4gICAgbGV0IGRlcHRoID0gMTtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNiKG5leHQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChuZXh0KSkge1xuICAgICAgICBpZiAobmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgICAgIGlmICgtLWRlcHRoID09PSAwKSBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0LmRhdGEgPT09IFwiW1wiKSB7XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNiKG5vZGUpO1xuICB9XG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcbiAgfVxuICBjb25zdCB7XG4gICAgbG9hZGVyLFxuICAgIGxvYWRpbmdDb21wb25lbnQsXG4gICAgZXJyb3JDb21wb25lbnQsXG4gICAgZGVsYXkgPSAyMDAsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN0cmF0ZWd5LFxuICAgIHRpbWVvdXQsXG4gICAgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgc3VzcGVuc2libGUgPSB0cnVlLFxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yXG4gIH0gPSBzb3VyY2U7XG4gIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gIGxldCByZXNvbHZlZENvbXA7XG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgcmV0cmllcysrO1xuICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICByZXR1cm4gbG9hZCgpO1xuICB9O1xuICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3QgfHwgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPSBsb2FkZXIoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICBpZiAodXNlck9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKGNvbXApID0+IHtcbiAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNvbXApIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXAgJiYgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiTW9kdWxlXCIpKSB7XG4gICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSkpO1xuICB9O1xuICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBuYW1lOiBcIkFzeW5jQ29tcG9uZW50V3JhcHBlclwiLFxuICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXG4gICAgX19hc3luY0h5ZHJhdGUoZWwsIGluc3RhbmNlLCBoeWRyYXRlKSB7XG4gICAgICBjb25zdCBkb0h5ZHJhdGUgPSBoeWRyYXRlU3RyYXRlZ3kgPyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlYXJkb3duID0gaHlkcmF0ZVN0cmF0ZWd5KFxuICAgICAgICAgIGh5ZHJhdGUsXG4gICAgICAgICAgKGNiKSA9PiBmb3JFYWNoRWxlbWVudChlbCwgY2IpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0ZWFyZG93bikge1xuICAgICAgICAgIChpbnN0YW5jZS5idW0gfHwgKGluc3RhbmNlLmJ1bSA9IFtdKSkucHVzaCh0ZWFyZG93bik7XG4gICAgICAgIH1cbiAgICAgIH0gOiBoeWRyYXRlO1xuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICBkb0h5ZHJhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWQoKS50aGVuKCgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBkb0h5ZHJhdGUoKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcbiAgICB9LFxuICAgIHNldHVwKCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGhhbmRsZUVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAhZXJyb3JDb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBpZiAoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UgfHwgaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgICAgIHJldHVybiBsb2FkKCkudGhlbigoY29tcCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudCA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfSkgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XG4gICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xuICAgICAgY29uc3QgZGVsYXllZCA9IHJlZighIWRlbGF5KTtcbiAgICAgIGlmIChkZWxheSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCAmJiBpc0tlZXBBbGl2ZShpbnN0YW5jZS5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgICAgaW5zdGFuY2UucGFyZW50LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHBhcmVudCkge1xuICBjb25zdCB7IHJlZjogcmVmMiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XG4gIHZub2RlLnJlZiA9IHJlZjI7XG4gIHZub2RlLmNlID0gY2U7XG4gIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XG4gIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gIG5hbWU6IGBLZWVwQWxpdmVgLFxuICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxuICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gIF9faXNLZWVwQWxpdmU6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJlcjoge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgbTogbW92ZSxcbiAgICAgICAgdW06IF91bm1vdW50LFxuICAgICAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICAgICAgfVxuICAgIH0gPSBzaGFyZWRDb250ZXh0O1xuICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgbW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIDAsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBpbnN0YW5jZTIudm5vZGUsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgaW5zdGFuY2UyLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5hKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgaW52YWxpZGF0ZU1vdW50KGluc3RhbmNlMi5tKTtcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIuYSk7XG4gICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmRhKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1bm1vdW50KHZub2RlKSB7XG4gICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcbiAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XG4gICAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKGNhY2hlZCAmJiAoIWN1cnJlbnQgfHwgIWlzU2FtZVZOb2RlVHlwZShjYWNoZWQsIGN1cnJlbnQpKSkge1xuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxuICAgICAgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1N1c3BlbnNlKGluc3RhbmNlLnN1YlRyZWUudHlwZSkpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgICAgfSwgaW5zdGFuY2Uuc3ViVHJlZS5zdXNwZW5zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgICBjYWNoZS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlICYmIGNhY2hlZC5rZXkgPT09IHZub2RlLmtleSkge1xuICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICBpZiAoIXNsb3RzLmRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XG4gICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoYEtlZXBBbGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8ICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCkgJiYgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpKSB7XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcbiAgICAgIGlmICh2bm9kZS50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBpc0FzeW5jV3JhcHBlcih2bm9kZSkgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fSA6IGNvbXBcbiAgICAgICk7XG4gICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XG4gICAgICBpZiAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpIHx8IGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSB7XG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xuICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodm5vZGUuZWwpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XG4gICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcbiAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xuICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMjtcbiAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2O1xuICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8IChob29rLl9fd2RjID0gKCkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2soKTtcbiAgfSk7XG4gIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xuICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2soXG4gICAgdHlwZSxcbiAgICBob29rLFxuICAgIGtlZXBBbGl2ZVJvb3QsXG4gICAgdHJ1ZVxuICAgIC8qIHByZXBlbmQgKi9cbiAgKTtcbiAgb25Vbm1vdW50ZWQoKCkgPT4ge1xuICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XG4gIH0sIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH41MTI7XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHwgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XG4gICAgICByZXNldCgpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICBpZiAocHJlcGVuZCkge1xuICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZEhvb2s7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sIFwiXCIpKTtcbiAgICB3YXJuJDEoXG4gICAgICBgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC4gTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgKyAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYCApXG4gICAgKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IHtcbiAgaWYgKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIpIHtcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldCk7XG4gIH1cbn07XG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIpO1xuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIik7XG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXG4gIFwiYnVcIlxuKTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIpO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcbiAgXCJidW1cIlxuKTtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIpO1xuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXG4gIFwic3BcIlxuKTtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiKTtcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUhvb2soXCJydGNcIik7XG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGluamVjdEhvb2soXCJlY1wiLCBob29rLCB0YXJnZXQpO1xufVxuXG5jb25zdCBDT01QT05FTlRTID0gXCJjb21wb25lbnRzXCI7XG5jb25zdCBESVJFQ1RJVkVTID0gXCJkaXJlY3RpdmVzXCI7XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcbn1cbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2wuZm9yKFwidi1uZGNcIik7XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBpZiAoc2VsZk5hbWUgJiYgKHNlbGZOYW1lID09PSBuYW1lIHx8IHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fCBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IChcbiAgICAgIC8vIGxvY2FsIHJlZ2lzdHJhdGlvblxuICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKVxuICAgICk7XG4gICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFMgPyBgXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGNvbXBvbmVudCByZXNvbHV0aW9uIHZpYSBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50LmAgOiBgYDtcbiAgICAgIHdhcm4kMShgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICByZXR1cm4gcmVnaXN0cnkgJiYgKHJlZ2lzdHJ5W25hbWVdIHx8IHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fCByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gIGxldCByZXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlICYmIGNhY2hlW2luZGV4XTtcbiAgY29uc3Qgc291cmNlSXNBcnJheSA9IGlzQXJyYXkoc291cmNlKTtcbiAgaWYgKHNvdXJjZUlzQXJyYXkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIGNvbnN0IHNvdXJjZUlzUmVhY3RpdmVBcnJheSA9IHNvdXJjZUlzQXJyYXkgJiYgaXNSZWFjdGl2ZShzb3VyY2UpO1xuICAgIGxldCBuZWVkc1dyYXAgPSBmYWxzZTtcbiAgICBpZiAoc291cmNlSXNSZWFjdGl2ZUFycmF5KSB7XG4gICAgICBuZWVkc1dyYXAgPSAhaXNTaGFsbG93KHNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSBzaGFsbG93UmVhZEFycmF5KHNvdXJjZSk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oXG4gICAgICAgIG5lZWRzV3JhcCA/IHRvUmVhY3RpdmUoc291cmNlW2ldKSA6IHNvdXJjZVtpXSxcbiAgICAgICAgaSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBjYWNoZWQgJiYgY2FjaGVkW2ldXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgd2FybiQxKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IEFycmF5LmZyb20oXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZVtpbmRleF0gPSByZXQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XG4gICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmtleSA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHNsb3QuZm4oLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXMpIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gOiBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIGZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQuY2UpIHtcbiAgICBpZiAobmFtZSAhPT0gXCJkZWZhdWx0XCIpIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICBbY3JlYXRlVk5vZGUoXCJzbG90XCIsIHByb3BzLCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKV0sXG4gICAgICA2NFxuICAgICk7XG4gIH1cbiAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgU1NSLW9wdGltaXplZCBzbG90IGZ1bmN0aW9uIGRldGVjdGVkIGluIGEgbm9uLVNTUi1vcHRpbWl6ZWQgcmVuZGVyIGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIHBhcmVudCB0ZW1wbGF0ZS5gXG4gICAgKTtcbiAgICBzbG90ID0gKCkgPT4gW107XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSBmYWxzZTtcbiAgfVxuICBvcGVuQmxvY2soKTtcbiAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XG4gIGNvbnN0IHNsb3RLZXkgPSBwcm9wcy5rZXkgfHwgLy8gc2xvdCBjb250ZW50IGFycmF5IG9mIGEgZHluYW1pYyBjb25kaXRpb25hbCBzbG90IG1heSBoYXZlIGEgYnJhbmNoXG4gIC8vIGtleSBhdHRhY2hlZCBpbiB0aGUgYGNyZWF0ZVNsb3RzYCBoZWxwZXIsIHJlc3BlY3QgdGhhdFxuICB2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5O1xuICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKFxuICAgIEZyYWdtZW50LFxuICAgIHtcbiAgICAgIGtleTogKHNsb3RLZXkgJiYgIWlzU3ltYm9sKHNsb3RLZXkpID8gc2xvdEtleSA6IGBfJHtuYW1lfWApICsgLy8gIzcyNTYgZm9yY2UgZGlmZmVyZW50aWF0ZSBmYWxsYmFjayBjb250ZW50IGZyb20gYWN0dWFsIGNvbnRlbnRcbiAgICAgICghdmFsaWRTbG90Q29udGVudCAmJiBmYWxsYmFjayA/IFwiX2ZiXCIgOiBcIlwiKVxuICAgIH0sXG4gICAgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLFxuICAgIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSA/IDY0IDogLTJcbiAgKTtcbiAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xuICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgXCItc1wiXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcbiAgcmV0dXJuIHZub2Rlcy5zb21lKChjaGlsZCkgPT4ge1xuICAgIGlmICghaXNWTm9kZShjaGlsZCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgPyB2bm9kZXMgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaiwgcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChvYmopKSB7XG4gICAgd2FybiQxKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICByZXRbcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkgJiYgL1tBLVpdLy50ZXN0KGtleSkgPyBgb246JHtrZXl9YCA6IHRvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcbiAgaWYgKCFpKSByZXR1cm4gbnVsbDtcbiAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpIHJldHVybiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShpKTtcbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcbn07XG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gKFxuICAvLyBNb3ZlIFBVUkUgbWFya2VyIHRvIG5ldyBsaW5lIHRvIHdvcmthcm91bmQgY29tcGlsZXIgZGlzY2FyZGluZyBpdFxuICAvLyBkdWUgdG8gdHlwZSBhbm5vdGF0aW9uXG4gIC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAkOiAoaSkgPT4gaSxcbiAgICAkZWw6IChpKSA9PiBpLnZub2RlLmVsLFxuICAgICRkYXRhOiAoaSkgPT4gaS5kYXRhLFxuICAgICRwcm9wczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzLFxuICAgICRhdHRyczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzLFxuICAgICRzbG90czogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzLFxuICAgICRyZWZzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzLFxuICAgICRwYXJlbnQ6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXG4gICAgJHJvb3Q6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxuICAgICRob3N0OiAoaSkgPT4gaS5jZSxcbiAgICAkZW1pdDogKGkpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSxcbiAgICAkZm9yY2VVcGRhdGU6IChpKSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHtcbiAgICAgIHF1ZXVlSm9iKGkudXBkYXRlKTtcbiAgICB9KSxcbiAgICAkbmV4dFRpY2s6IChpKSA9PiBpLm4gfHwgKGkubiA9IG5leHRUaWNrLmJpbmQoaS5wcm94eSkpLFxuICAgICR3YXRjaDogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QXG4gIH0pXG4pO1xuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRcIjtcbmNvbnN0IGhhc1NldHVwQmluZGluZyA9IChzdGF0ZSwga2V5KSA9PiBzdGF0ZSAhPT0gRU1QVFlfT0JKICYmICFzdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHN0YXRlLCBrZXkpO1xuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xuICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiX19pc1Z1ZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xuICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XG4gICAgICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgIGNhc2UgMSAvKiBTRVRVUCAqLzpcbiAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICAgICAgY2FzZSAyIC8qIERBVEEgKi86XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgIGNhc2UgNCAvKiBDT05URVhUICovOlxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICAgIGNhc2UgMyAvKiBQUk9QUyAqLzpcbiAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIFNFVFVQICovO1xuICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogREFUQSAqLztcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXG4gICAgICAgIC8vIHByb3BzXG4gICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSlcbiAgICAgICkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcbiAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgfSBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xuICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XG4gICAgaWYgKHB1YmxpY0dldHRlcikge1xuICAgICAgaWYgKGtleSA9PT0gXCIkYXR0cnNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZS5hdHRycywgXCJnZXRcIiwgXCJcIik7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmICghaXNTdHJpbmcoa2V5KSB8fCAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xuICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICB3YXJuJDEoYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7a2V5fVwiIGZyb20gT3B0aW9ucyBBUEkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGtleVswXSA9PT0gXCIkXCIgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGhhcyh7XG4gICAgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfVxuICB9LCBrZXkpIHtcbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIHJldHVybiAhIWFjY2Vzc0NhY2hlW2tleV0gfHwgZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpIHx8IGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpIHx8IChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkgfHwgaGFzT3duKGN0eCwga2V5KSB8fCBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fCBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xuICAgICAgdGFyZ2V0Ll8uYWNjZXNzQ2FjaGVba2V5XSA9IDA7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oZGVzY3JpcHRvciwgXCJ2YWx1ZVwiKSkge1xuICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IudmFsdWUsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn07XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xuICAgIHdhcm4kMShcbiAgICAgIGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYFxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcbiAgfSxcbiAgaGFzKF8sIGtleSkge1xuICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gXCJfXCIgJiYgIWlzR2xvYmFsbHlBbGxvd2VkKGtleSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAga2V5XG4gICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBoYXM7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogKCkgPT4gaW5zdGFuY2VcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXG4gICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXG4gICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xuICAgICAgc2V0OiBOT09QXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIGN0eCxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gIH0gPSBpbnN0YW5jZTtcbiAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xuICBPYmplY3Qua2V5cyh0b1JhdyhzZXR1cFN0YXRlKSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3Qgd2FyblJ1bnRpbWVVc2FnZSA9IChtZXRob2QpID0+IHdhcm4kMShcbiAgYCR7bWV0aG9kfSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmBcbik7XG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVQcm9wc2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRW1pdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZU9wdGlvbnNgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lU2xvdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lU2xvdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoXCJkZWZpbmVNb2RlbFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0cykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuJDEoYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gIH1cbiAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09yRW1pdHMocHJvcHMpIHtcbiAgcmV0dXJuIGlzQXJyYXkocHJvcHMpID8gcHJvcHMucmVkdWNlKFxuICAgIChub3JtYWxpemVkLCBwKSA9PiAobm9ybWFsaXplZFtwXSA9IG51bGwsIG5vcm1hbGl6ZWQpLFxuICAgIHt9XG4gICkgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICBjb25zdCBwcm9wcyA9IG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhyYXcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fc2tpcFwiKSkgY29udGludWU7XG4gICAgbGV0IG9wdCA9IHByb3BzW2tleV07XG4gICAgaWYgKG9wdCkge1xuICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcbiAgICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcbiAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKG9wdCAmJiBkZWZhdWx0c1tgX19za2lwXyR7a2V5fWBdKSB7XG4gICAgICBvcHQuc2tpcEZhY3RvcnkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU1vZGVscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGEgfHwgYjtcbiAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSkgcmV0dXJuIGEuY29uY2F0KGIpO1xuICByZXR1cm4gZXh0ZW5kKHt9LCBub3JtYWxpemVQcm9wc09yRW1pdHMoYSksIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhiKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmICghZXhjbHVkZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjdHgpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgd2l0aEFzeW5jQ29udGV4dCBjYWxsZWQgd2l0aG91dCBhY3RpdmUgY3VycmVudCBpbnN0YW5jZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIH1cbiAgbGV0IGF3YWl0YWJsZSA9IGdldEF3YWl0YWJsZSgpO1xuICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcbiAgICBhd2FpdGFibGUgPSBhd2FpdGFibGUuY2F0Y2goKGUpID0+IHtcbiAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdHgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICB3YXJuJDEoYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XG4gICAgfVxuICB9O1xufVxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XG4gIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XG4gICAgY2FsbEhvb2sob3B0aW9ucy5iZWZvcmVDcmVhdGUsIGluc3RhbmNlLCBcImJjXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGRhdGFPcHRpb25zLFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsXG4gICAgbWV0aG9kcyxcbiAgICB3YXRjaDogd2F0Y2hPcHRpb25zLFxuICAgIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLFxuICAgIGluamVjdDogaW5qZWN0T3B0aW9ucyxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkLFxuICAgIGJlZm9yZU1vdW50LFxuICAgIG1vdW50ZWQsXG4gICAgYmVmb3JlVXBkYXRlLFxuICAgIHVwZGF0ZWQsXG4gICAgYWN0aXZhdGVkLFxuICAgIGRlYWN0aXZhdGVkLFxuICAgIGJlZm9yZURlc3Ryb3ksXG4gICAgYmVmb3JlVW5tb3VudCxcbiAgICBkZXN0cm95ZWQsXG4gICAgdW5tb3VudGVkLFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJUcmFja2VkLFxuICAgIHJlbmRlclRyaWdnZXJlZCxcbiAgICBlcnJvckNhcHR1cmVkLFxuICAgIHNlcnZlclByZWZldGNoLFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2UsXG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluamVjdE9wdGlvbnMpIHtcbiAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyk7XG4gIH1cbiAgaWYgKG1ldGhvZHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xuICAgICAgaWYgKGlzRnVuY3Rpb24obWV0aG9kSGFuZGxlcikpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGFPcHRpb25zKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBQbGFpbiBvYmplY3QgdXNhZ2UgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1Byb21pc2UoZGF0YSkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXG4gICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbiAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XG4gICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdCkgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IGlzRnVuY3Rpb24ob3B0LmdldCkgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBOT09QO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZ2V0ID09PSBOT09QKSB7XG4gICAgICAgIHdhcm4kMShgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpIDogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/ICgpID0+IHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gOiBOT09QO1xuICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBjLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucykgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpIDogcHJvdmlkZU9wdGlvbnM7XG4gICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY3JlYXRlZCkge1xuICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGhvb2suZm9yRWFjaCgoX2hvb2spID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcbiAgICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xuICBpZiAoaXNBcnJheShleHBvc2UpKSB7XG4gICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0ge30pO1xuICAgICAgZXhwb3NlLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgc2V0OiAodmFsKSA9PiBwdWJsaWNUaGlzW2tleV0gPSB2YWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XG4gICAgfVxuICB9XG4gIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xuICB9XG4gIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgfVxuICBpZiAoY29tcG9uZW50cykgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gIGlmIChkaXJlY3RpdmVzKSBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgaWYgKHNlcnZlclByZWZldGNoKSB7XG4gICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcbiAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgbGV0IGluamVjdGVkO1xuICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gb3B0KSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KFxuICAgICAgICAgIG9wdC5mcm9tIHx8IGtleSxcbiAgICAgICAgICBvcHQuZGVmYXVsdCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBpbmplY3RlZC52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgaXNBcnJheShob29rKSA/IGhvb2subWFwKChoKSA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKSA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksXG4gICAgaW5zdGFuY2UsXG4gICAgdHlwZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XG4gIGxldCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xuICBpZiAoaXNTdHJpbmcocmF3KSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcbiAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgIHtcbiAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgcmF3LmZvckVhY2goKHIpID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSA6IGN0eFtyYXcuaGFuZGxlcl07XG4gICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBiYXNlID0gaW5zdGFuY2UudHlwZTtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xuICBjb25zdCB7XG4gICAgbWl4aW5zOiBnbG9iYWxNaXhpbnMsXG4gICAgb3B0aW9uc0NhY2hlOiBjYWNoZSxcbiAgICBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH1cbiAgfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcbiAgbGV0IHJlc29sdmVkO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpIHtcbiAgICB7XG4gICAgICByZXNvbHZlZCA9IGJhc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkID0ge307XG4gICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcbiAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKFxuICAgICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpXG4gICAgICApO1xuICAgIH1cbiAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGJhc2UpKSB7XG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XG4gICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcbiAgfVxuICBpZiAobWl4aW5zKSB7XG4gICAgbWl4aW5zLmZvckVhY2goXG4gICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSBcImV4cG9zZVwiKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCBzdHJhdHMgJiYgc3RyYXRzW2tleV07XG4gICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICBkYXRhOiBtZXJnZURhdGFGbixcbiAgcHJvcHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgZW1pdHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgLy8gb2JqZWN0c1xuICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIGxpZmVjeWNsZVxuICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcbiAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxuICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcbiAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXG4gIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gIC8vIGFzc2V0c1xuICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gd2F0Y2hcbiAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxuICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxuICBpbmplY3Q6IG1lcmdlSW5qZWN0XG59O1xuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGlmICghdG8pIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgIHJldHVybiAoZXh0ZW5kKShcbiAgICAgIGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLFxuICAgICAgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb21cbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiByYXc7XG59XG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKHRvKSB7XG4gICAgaWYgKGlzQXJyYXkodG8pICYmIGlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRvLCAuLi5mcm9tXSldO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKFxuICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHModG8pLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKGZyb20gIT0gbnVsbCA/IGZyb20gOiB7fSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAoIXRvKSByZXR1cm4gZnJvbTtcbiAgaWYgKCFmcm9tKSByZXR1cm4gdG87XG4gIGNvbnN0IG1lcmdlZCA9IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIGFwcDogbnVsbCxcbiAgICBjb25maWc6IHtcbiAgICAgIGlzTmF0aXZlVGFnOiBOTyxcbiAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgIGVycm9ySGFuZGxlcjogdm9pZCAwLFxuICAgICAgd2FybkhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICB9LFxuICAgIG1peGluczogW10sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgZGlyZWN0aXZlczoge30sXG4gICAgcHJvdmlkZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG9wdGlvbnNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgcHJvcHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgZW1pdHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgfTtcbn1cbmxldCB1aWQkMSA9IDA7XG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgIGlmICghaXNGdW5jdGlvbihyb290Q29tcG9uZW50KSkge1xuICAgICAgcm9vdENvbXBvbmVudCA9IGV4dGVuZCh7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgcm9vdFByb3BzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3QgcGx1Z2luQ2xlYW51cEZucyA9IFtdO1xuICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhcHAgPSBjb250ZXh0LmFwcCA9IHtcbiAgICAgIF91aWQ6IHVpZCQxKyssXG4gICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxuICAgICAgX3Byb3BzOiByb290UHJvcHMsXG4gICAgICBfY29udGFpbmVyOiBudWxsLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfaW5zdGFuY2U6IG51bGwsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xuICAgICAgfSxcbiAgICAgIHNldCBjb25maWcodikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGZ1bmN0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbWl4aW4obWl4aW4pIHtcbiAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcbiAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xuICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIk1peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUElcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgICAgd2FybiQxKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMShgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZub2RlID0gYXBwLl9jZVZOb2RlIHx8IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XG4gICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZW5kZXIoXG4gICAgICAgICAgICAgICAgY2xvbmVWTm9kZSh2bm9kZSksXG4gICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxuSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVubW91bnQoY2xlYW51cEZuKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHR5cGVvZiBjbGVhbnVwRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHBlY3RlZCBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudCB0byBhcHAub25Vbm1vdW50KCksIGJ1dCBnb3QgJHt0eXBlb2YgY2xlYW51cEZufWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHBsdWdpbkNsZWFudXBGbnMucHVzaChjbGVhbnVwRm4pO1xuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICAgIHBsdWdpbkNsZWFudXBGbnMsXG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlLFxuICAgICAgICAgICAgMTZcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBJdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyB2YWx1ZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBydW5XaXRoQ29udGV4dChmbikge1xuICAgICAgICBjb25zdCBsYXN0QXBwID0gY3VycmVudEFwcDtcbiAgICAgICAgY3VycmVudEFwcCA9IGFwcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50QXBwID0gbGFzdEFwcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcbn1cbmxldCBjdXJyZW50QXBwID0gbnVsbDtcblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcbiAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcbiAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XG4gICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xuICAgIH1cbiAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UgfHwgY3VycmVudEFwcCkge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gY3VycmVudEFwcCA/IGN1cnJlbnRBcHAuX2NvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZSA/IGluc3RhbmNlLnBhcmVudCA9PSBudWxsID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzIDogdm9pZCAwO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0luamVjdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiAhIShjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRBcHApO1xufVxuXG5jb25zdCBpbnRlcm5hbE9iamVjdFByb3RvID0ge307XG5jb25zdCBjcmVhdGVJbnRlcm5hbE9iamVjdCA9ICgpID0+IE9iamVjdC5jcmVhdGUoaW50ZXJuYWxPYmplY3RQcm90byk7XG5jb25zdCBpc0ludGVybmFsT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IGludGVybmFsT2JqZWN0UHJvdG87XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSID0gZmFsc2UpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgYXR0cnMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxuICBpZiAoaXNTdGF0ZWZ1bCkge1xuICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xufVxuZnVuY3Rpb24gaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgd2hpbGUgKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19obXJJZCkgcmV0dXJuIHRydWU7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3Qge1xuICAgIHByb3BzLFxuICAgIGF0dHJzLFxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcbiAgKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xuICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGtlYmFiS2V5O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgaWYgKCFyYXdQcm9wcyB8fCAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiYgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdm9pZCAwIHx8IC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICB0cmlnZ2VyKGluc3RhbmNlLmF0dHJzLCBcInNldFwiLCBcIlwiKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgaWYgKHJhd1Byb3BzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XG4gICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XG4gICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICBrZXksXG4gICAgICAgIGNhc3RWYWx1ZXNba2V5XSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICFoYXNPd24oY2FzdFZhbHVlcywga2V5KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XG4gIGlmIChvcHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmICFvcHQuc2tpcEZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZS5jZSkge1xuICAgICAgICBpbnN0YW5jZS5jZS5fc2V0UHJvcChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XG4gICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgbWl4aW5Qcm9wc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gX19WVUVfT1BUSU9OU19BUElfXyAmJiBhc01peGluID8gbWl4aW5Qcm9wc0NhY2hlIDogYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3MikgPT4ge1xuICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcbiAgICAgIGlmIChrZXlzKSBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XG4gICAgfVxuICAgIHJldHVybiBFTVBUWV9BUlI7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xuICAgICAgICB3YXJuJDEoYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyYXcpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgd2FybiQxKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgIGNvbnN0IHByb3AgPSBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBleHRlbmQoe30sIG9wdCk7XG4gICAgICAgIGNvbnN0IHByb3BUeXBlID0gcHJvcC50eXBlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdFRydWUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNBcnJheShwcm9wVHlwZSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvcFR5cGUubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcHJvcFR5cGVbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBpc0Z1bmN0aW9uKHR5cGUpICYmIHR5cGUubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gXCJCb29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgc2hvdWxkQ2FzdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0VHJ1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG91bGRDYXN0ID0gaXNGdW5jdGlvbihwcm9wVHlwZSkgJiYgcHJvcFR5cGUubmFtZSA9PT0gXCJCb29sZWFuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gc2hvdWxkQ2FzdDtcbiAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9IHNob3VsZENhc3RUcnVlO1xuICAgICAgICBpZiAoc2hvdWxkQ2FzdCB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2gobm9ybWFsaXplZEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICBpZiAoa2V5WzBdICE9PSBcIiRcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XG4gIGlmIChjdG9yID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmICh0eXBlb2YgY3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGN0b3IubmFtZSB8fCBcIlwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgbmFtZSA9IGN0b3IuY29uc3RydWN0b3IgJiYgY3Rvci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBuYW1lIHx8IFwiXCI7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcbiAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XG4gIGNvbnN0IGNhbWVsaXplUHJvcHNLZXkgPSBPYmplY3Qua2V5cyhyYXdQcm9wcykubWFwKChrZXkpID0+IGNhbWVsaXplKGtleSkpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ID09IG51bGwpIGNvbnRpbnVlO1xuICAgIHZhbGlkYXRlUHJvcChcbiAgICAgIGtleSxcbiAgICAgIHJlc29sdmVkVmFsdWVzW2tleV0sXG4gICAgICBvcHQsXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHJlc29sdmVkVmFsdWVzKSA6IHJlc29sdmVkVmFsdWVzLFxuICAgICAgIWNhbWVsaXplUHJvcHNLZXkuaW5jbHVkZXMoa2V5KVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgcHJvcHMsIGlzQWJzZW50KSB7XG4gIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciwgc2tpcENoZWNrIH0gPSBwcm9wO1xuICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICB3YXJuJDEoJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcmVxdWlyZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlICYmICFza2lwQ2hlY2spIHtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoICYmICFpc1ZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCBcIlwiKTtcbiAgICAgIGlzVmFsaWQgPSB2YWxpZDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB3YXJuJDEoZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSwgcHJvcHMpKSB7XG4gICAgd2FybiQxKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gIH1cbn1cbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcIlN0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50XCJcbik7XG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIGxldCB2YWxpZDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICB9IGVsc2UgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJPYmplY3RcIikge1xuICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJBcnJheVwiKSB7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBgUHJvcCB0eXBlIFtdIGZvciBwcm9wIFwiJHtuYW1lfVwiIHdvbid0IG1hdGNoIGFueXRoaW5nLiBEaWQgeW91IG1lYW4gdG8gdXNlIHR5cGUgQXJyYXkgaW5zdGVhZD9gO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbihcIiB8IFwiKX1gO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJiBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJiAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICB9XG4gIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcbiAgfVxuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJOdW1iZXJcIikge1xuICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKChlbGVtKSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3Muc29tZSgoZWxlbSkgPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSBcImJvb2xlYW5cIik7XG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkc3RhYmxlXCI7XG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKSA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xuICBpZiAocmF3U2xvdC5fbikge1xuICAgIHJldHVybiByYXdTbG90O1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KCguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudEluc3RhbmNlICYmICghY3R4IHx8IGN0eC5yb290ID09PSBjdXJyZW50SW5zdGFuY2Uucm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcbiAgfSwgY3R4KTtcbiAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XG4gICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmIHRydWUpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xuICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBhc3NpZ25TbG90cyA9IChzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZHJlbikge1xuICAgIGlmIChvcHRpbWl6ZWQgfHwga2V5ICE9PSBcIl9cIikge1xuICAgICAgc2xvdHNba2V5XSA9IGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHNsb3RzID0gaW5zdGFuY2Uuc2xvdHMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKG9wdGltaXplZCkge1xuICAgICAgICBkZWYoc2xvdHMsIFwiX1wiLCB0eXBlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gIH1cbn07XG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XG4gIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XG4gIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgfVxuICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xuICAgIHBlcmYubWFyayhlbmRUYWcpO1xuICAgIHBlcmYubWVhc3VyZShcbiAgICAgIGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLFxuICAgICAgc3RhcnRUYWcsXG4gICAgICBlbmRUYWdcbiAgICApO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKHN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcbiAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKFwiLCBcIil9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIHByb2R1Y3Rpb24gYnVuZGxlLlxuXG5Gb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIDtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICB7XG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcbiAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBzZXREZXZ0b29sc0hvb2skMSh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5zZXJ0OiBob3N0SW5zZXJ0LFxuICAgIHJlbW92ZTogaG9zdFJlbW92ZSxcbiAgICBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsXG4gICAgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsXG4gICAgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsXG4gICAgc2V0VGV4dDogaG9zdFNldFRleHQsXG4gICAgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCxcbiAgICBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLFxuICAgIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCxcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgbmFtZXNwYWNlID0gdm9pZCAwLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcgPyBmYWxzZSA6ICEhbjIuZHluYW1pY0NoaWxkcmVuKSA9PiB7XG4gICAgaWYgKG4xID09PSBuMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICBuMSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBwcm9jZXNzRnJhZ21lbnQoXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIHByb2Nlc3NFbGVtZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgVk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8IFwiXCIpLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSkgPT4ge1xuICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuMi5lbCxcbiAgICAgIG4yLmFuY2hvclxuICAgICk7XG4gIH07XG4gIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcbiAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgICBuMi5jaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBpZiAobjIudHlwZSA9PT0gXCJzdmdcIikge1xuICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICB9IGVsc2UgaWYgKG4yLnR5cGUgPT09IFwibWF0aFwiKSB7XG4gICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRFbGVtZW50KFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoRWxlbWVudChcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBlbDtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGNvbnN0IHsgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgZGlycyB9ID0gdm5vZGU7XG4gICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KFxuICAgICAgdm5vZGUudHlwZSxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIHByb3BzICYmIHByb3BzLmlzLFxuICAgICAgcHJvcHNcbiAgICApO1xuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZSh2bm9kZSwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICB9XG4gICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwidmFsdWVcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIHByb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgbnVsbCwgcHJvcHMudmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRlZihlbCwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcbiAgICAgIGRlZihlbCwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCBwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKTtcbiAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHwgZGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldFNjb3BlSWQgPSAoZWwsIHZub2RlLCBzY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChzY29wZUlkKSB7XG4gICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XG4gICAgfVxuICAgIGlmIChzbG90U2NvcGVJZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmIHN1YlRyZWUucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgICAgICBzdWJUcmVlID0gZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlIHx8IGlzU3VzcGVuc2Uoc3ViVHJlZS50eXBlKSAmJiAoc3ViVHJlZS5zc0NvbnRlbnQgPT09IHZub2RlIHx8IHN1YlRyZWUuc3NGYWxsYmFjayA9PT0gdm5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xuICAgICAgICBzZXRTY29wZUlkKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudFZOb2RlLFxuICAgICAgICAgIHBhcmVudFZOb2RlLnNjb3BlSWQsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudC5wYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZWwuX192bm9kZSA9IG4yO1xuICAgIH1cbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XG4gICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2O1xuICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCBmYWxzZSk7XG4gICAgaWYgKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICAgIH1cbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChvbGRQcm9wcy5pbm5lckhUTUwgJiYgbmV3UHJvcHMuaW5uZXJIVE1MID09IG51bGwgfHwgb2xkUHJvcHMudGV4dENvbnRlbnQgJiYgbmV3UHJvcHMudGV4dENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZShuMiwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICApO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICAgIHBhdGNoUHJvcHMoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIpIHtcbiAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcImNsYXNzXCIsIG51bGwsIG5ld1Byb3BzLmNsYXNzLCBuYW1lc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwic3R5bGVcIiwgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMSkge1xuICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHBhdGNoUHJvcHMoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwidXBkYXRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG4gICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gKFxuICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxuICAgICAgICBvbGRWTm9kZS5lbCAmJiAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxuICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XG4gICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cbiAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgKDYgfCA2NCkpID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpIDogKFxuICAgICAgICAgIC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxuICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cbiAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG9sZFZOb2RlLFxuICAgICAgICBuZXdWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG9sZFByb3BzW2tleV0sXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0ICE9PSBwcmV2ICYmIGtleSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBvbGRQcm9wcy52YWx1ZSwgbmV3UHJvcHMudmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSBuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIC8vICM1NTIzIGRldiByb290IGZyYWdtZW50IG1heSBpbmhlcml0IGRpcmVjdGl2ZXNcbiAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4KSkge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50RW5kQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAvLyAjMTAwMDdcbiAgICAgICAgLy8gc3VjaCBmcmFnbWVudCBsaWtlIGA8PjwvPmAgd2lsbCBiZSBjb21waWxlZCBpbnRvXG4gICAgICAgIC8vIGEgZnJhZ21lbnQgd2hpY2ggZG9lc24ndCBoYXZlIGEgY2hpbGRyZW4uXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSBmYWxsYmFjayB0byBhbiBlbXB0eSBhcnJheVxuICAgICAgICBuMi5jaGlsZHJlbiB8fCBbXSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgJiYgZHluYW1pY0NoaWxkcmVuICYmIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cbiAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XG4gICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cbiAgICAgICAgICAvLyAjMjEzNCBvciBpZiBpdCdzIGEgY29tcG9uZW50IHJvb3QsIGl0IG1heSBhbHNvIGdldCBtb3ZlZCBhcm91bmRcbiAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxuICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8IHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAvKiBzaGFsbG93ICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICApKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xuICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcbiAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcbiAgICB9XG4gICAge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGZhbHNlLCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSBpbml0aWFsVk5vZGUuZWwgPSBudWxsO1xuICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0LCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xuICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCwgcm9vdCwgdHlwZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChibSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xuICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoeWRyYXRlTm9kZShcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSAmJiB0eXBlLl9fYXN5bmNIeWRyYXRlKSB7XG4gICAgICAgICAgICB0eXBlLl9fYXN5bmNIeWRyYXRlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocm9vdC5jZSkge1xuICAgICAgICAgICAgcm9vdC5jZS5faW5qZWN0Q2hpbGRTdHlsZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJUcmVlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9uSHlkcmF0ZWRBc3luY1Jvb3QgPSBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKG5vbkh5ZHJhdGVkQXN5bmNSb290KSB7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vbkh5ZHJhdGVkQXN5bmNSb290LmFzeW5jRGVwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlRm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIHByZXZUcmVlLFxuICAgICAgICAgIG5leHRUcmVlLFxuICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxuICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICAgIGNvbnN0IGVmZmVjdCA9IGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbik7XG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgY29uc3QgdXBkYXRlID0gaW5zdGFuY2UudXBkYXRlID0gZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCk7XG4gICAgY29uc3Qgam9iID0gaW5zdGFuY2Uuam9iID0gZWZmZWN0LnJ1bklmRGlydHkuYmluZChlZmZlY3QpO1xuICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIGVmZmVjdC5zY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZUpvYihqb2IpO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgIH1cbiAgICB1cGRhdGUoKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xuICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcbiAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcbiAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XG4gICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICB9O1xuICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcbiAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xuICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTI4KSB7XG4gICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoYzIgIT09IGMxKSB7XG4gICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgICBjMSxcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCkge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xuICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XG4gICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgYzFbaV0sXG4gICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMxLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICBjMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7XG4gICAgbGV0IGUyID0gbDIgLSAxO1xuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbaV07XG4gICAgICBjb25zdCBuMiA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xuICAgICAgY29uc3QgbjIgPSBjMltlMl0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaSA+IGUyKSB7XG4gICAgICB3aGlsZSAoaSA8PSBlMSkge1xuICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzMSA9IGk7XG4gICAgICBjb25zdCBzMiA9IGk7XG4gICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKSBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhdGNoZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZCA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcCkgOiBFTVBUWV9BUlI7XG4gICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZlZCkge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwpID0+IHtcbiAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgfVxuICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVlZFRyYW5zaXRpb24yID0gbW92ZVR5cGUgIT09IDIgJiYgc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uO1xuICAgIGlmIChuZWVkVHJhbnNpdGlvbjIpIHtcbiAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHJlbW92ZTIgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBsZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlMigpO1xuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlMiwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZGlycyxcbiAgICAgIGNhY2hlSW5kZXhcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjYWNoZUluZGV4ICE9IG51bGwpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5yZW5kZXJDYWNoZVtjYWNoZUluZGV4XSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgJiYgZGlycztcbiAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVubW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzUxNTRcbiAgICAgIC8vIHdoZW4gdi1vbmNlIGlzIHVzZWQgaW5zaWRlIGEgYmxvY2ssIHNldEJsb2NrVHJhY2tpbmcoLTEpIG1hcmtzIHRoZVxuICAgICAgLy8gcGFyZW50IGJsb2NrIHdpdGggaGFzT25jZTogdHJ1ZVxuICAgICAgLy8gc28gdGhhdCBpdCBkb2Vzbid0IHRha2UgdGhlIGZhc3QgcGF0aCBkdXJpbmcgdW5tb3VudCAtIG90aGVyd2lzZVxuICAgICAgLy8gY29tcG9uZW50cyBuZXN0ZWQgaW4gdi1vbmNlIGFyZSBuZXZlciB1bm1vdW50ZWQuXG4gICAgICAhZHluYW1pY0NoaWxkcmVuLmhhc09uY2UgJiYgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHwgcGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCkpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBGcmFnbWVudCAmJiBwYXRjaEZsYWcgJiAoMTI4IHwgMjU2KSB8fCAhb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgcmVtb3ZlKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkgfHwgc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJ1bm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmUgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUucGF0Y2hGbGFnID4gMCAmJiB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4ICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcbiAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVyZm9ybVJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoY3VyKTtcbiAgICAgIGhvc3RSZW1vdmUoY3VyKTtcbiAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoZW5kKTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudENvbXBvbmVudCA9IChpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgY29uc3QgeyBidW0sIHNjb3BlLCBqb2IsIHN1YlRyZWUsIHVtLCBtLCBhIH0gPSBpbnN0YW5jZTtcbiAgICBpbnZhbGlkYXRlTW91bnQobSk7XG4gICAgaW52YWxpZGF0ZU1vdW50KGEpO1xuICAgIGlmIChidW0pIHtcbiAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XG4gICAgfVxuICAgIHNjb3BlLnN0b3AoKTtcbiAgICBpZiAoam9iKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gODtcbiAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfVxuICAgIGlmICh1bSkge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJiBpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJiBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gKHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xuICAgIH1cbiAgICBjb25zdCBlbCA9IGhvc3ROZXh0U2libGluZyh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpO1xuICAgIGNvbnN0IHRlbGVwb3J0RW5kID0gZWwgJiYgZWxbVGVsZXBvcnRFbmRLZXldO1xuICAgIHJldHVybiB0ZWxlcG9ydEVuZCA/IGhvc3ROZXh0U2libGluZyh0ZWxlcG9ydEVuZCkgOiBlbDtcbiAgfTtcbiAgbGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSB8fCBudWxsLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGludGVybmFscyA9IHtcbiAgICBwOiBwYXRjaCxcbiAgICB1bTogdW5tb3VudCxcbiAgICBtOiBtb3ZlLFxuICAgIHI6IHJlbW92ZSxcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxuICAgIG86IG9wdGlvbnNcbiAgfTtcbiAgbGV0IGh5ZHJhdGU7XG4gIGxldCBoeWRyYXRlTm9kZTtcbiAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoXG4gICAgICBpbnRlcm5hbHNcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVuZGVyLFxuICAgIGh5ZHJhdGUsXG4gICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHsgdHlwZSwgcHJvcHMgfSwgY3VycmVudE5hbWVzcGFjZSkge1xuICByZXR1cm4gY3VycmVudE5hbWVzcGFjZSA9PT0gXCJzdmdcIiAmJiB0eXBlID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCBjdXJyZW50TmFtZXNwYWNlID09PSBcIm1hdGhtbFwiICYmIHR5cGUgPT09IFwiYW5ub3RhdGlvbi14bWxcIiAmJiBwcm9wcyAmJiBwcm9wcy5lbmNvZGluZyAmJiBwcm9wcy5lbmNvZGluZy5pbmNsdWRlcyhcImh0bWxcIikgPyB2b2lkIDAgOiBjdXJyZW50TmFtZXNwYWNlO1xufVxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgam9iIH0sIGFsbG93ZWQpIHtcbiAgaWYgKGFsbG93ZWQpIHtcbiAgICBlZmZlY3QuZmxhZ3MgfD0gMzI7XG4gICAgam9iLmZsYWdzIHw9IDQ7XG4gIH0gZWxzZSB7XG4gICAgZWZmZWN0LmZsYWdzICY9IH4zMjtcbiAgICBqb2IuZmxhZ3MgJj0gfjQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKSB7XG4gIHJldHVybiAoIXBhcmVudFN1c3BlbnNlIHx8IHBhcmVudFN1c3BlbnNlICYmICFwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZDtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XG4gIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xuICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIpIHtcbiAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgYzIucGF0Y2hGbGFnICE9PSAtMilcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XG4gICAgICB9XG4gICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xuICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFswXTtcbiAgbGV0IGksIGosIHUsIHYsIGM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgaWYgKGFyckkgIT09IDApIHtcbiAgICAgIGogPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcbiAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHUgPSAwO1xuICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHUgPCB2KSB7XG4gICAgICAgIGMgPSB1ICsgdiA+PiAxO1xuICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XG4gICAgICAgICAgdSA9IGMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYgPSBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgIGlmICh1ID4gMCkge1xuICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFt1XSA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHUgPSByZXN1bHQubGVuZ3RoO1xuICB2ID0gcmVzdWx0W3UgLSAxXTtcbiAgd2hpbGUgKHUtLSA+IDApIHtcbiAgICByZXN1bHRbdV0gPSB2O1xuICAgIHYgPSBwW3ZdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSkge1xuICBjb25zdCBzdWJDb21wb25lbnQgPSBpbnN0YW5jZS5zdWJUcmVlLmNvbXBvbmVudDtcbiAgaWYgKHN1YkNvbXBvbmVudCkge1xuICAgIGlmIChzdWJDb21wb25lbnQuYXN5bmNEZXAgJiYgIXN1YkNvbXBvbmVudC5hc3luY1Jlc29sdmVkKSB7XG4gICAgICByZXR1cm4gc3ViQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3Qoc3ViQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVNb3VudChob29rcykge1xuICBpZiAoaG9va3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKVxuICAgICAgaG9va3NbaV0uZmxhZ3MgfD0gODtcbiAgfVxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihcInYtc2N4XCIpO1xuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcbiAge1xuICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxufTtcblxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwicG9zdFwiIH0pIDogeyBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInN5bmNcIiB9KSA6IHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25jZSB9ID0gb3B0aW9ucztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRlZXAgIT09IHZvaWQgMCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob25jZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwib25jZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGJhc2VXYXRjaE9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgYmFzZVdhdGNoT3B0aW9ucy5vbldhcm4gPSB3YXJuJDE7XG4gIGNvbnN0IHJ1bnNJbW1lZGlhdGVseSA9IGNiICYmIGltbWVkaWF0ZSB8fCAhY2IgJiYgZmx1c2ggIT09IFwicG9zdFwiO1xuICBsZXQgc3NyQ2xlYW51cDtcbiAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgIGlmIChmbHVzaCA9PT0gXCJzeW5jXCIpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHVzZVNTUkNvbnRleHQoKTtcbiAgICAgIHNzckNsZWFudXAgPSBjdHguX193YXRjaGVySGFuZGxlcyB8fCAoY3R4Ll9fd2F0Y2hlckhhbmRsZXMgPSBbXSk7XG4gICAgfSBlbHNlIGlmICghcnVuc0ltbWVkaWF0ZWx5KSB7XG4gICAgICBjb25zdCB3YXRjaFN0b3BIYW5kbGUgPSAoKSA9PiB7XG4gICAgICB9O1xuICAgICAgd2F0Y2hTdG9wSGFuZGxlLnN0b3AgPSBOT09QO1xuICAgICAgd2F0Y2hTdG9wSGFuZGxlLnJlc3VtZSA9IE5PT1A7XG4gICAgICB3YXRjaFN0b3BIYW5kbGUucGF1c2UgPSBOT09QO1xuICAgICAgcmV0dXJuIHdhdGNoU3RvcEhhbmRsZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gIGJhc2VXYXRjaE9wdGlvbnMuY2FsbCA9IChmbiwgdHlwZSwgYXJncykgPT4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgbGV0IGlzUHJlID0gZmFsc2U7XG4gIGlmIChmbHVzaCA9PT0gXCJwb3N0XCIpIHtcbiAgICBiYXNlV2F0Y2hPcHRpb25zLnNjaGVkdWxlciA9IChqb2IpID0+IHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZsdXNoICE9PSBcInN5bmNcIikge1xuICAgIGlzUHJlID0gdHJ1ZTtcbiAgICBiYXNlV2F0Y2hPcHRpb25zLnNjaGVkdWxlciA9IChqb2IsIGlzRmlyc3RSdW4pID0+IHtcbiAgICAgIGlmIChpc0ZpcnN0UnVuKSB7XG4gICAgICAgIGpvYigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVKb2Ioam9iKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGJhc2VXYXRjaE9wdGlvbnMuYXVnbWVudEpvYiA9IChqb2IpID0+IHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGpvYi5mbGFncyB8PSA0O1xuICAgIH1cbiAgICBpZiAoaXNQcmUpIHtcbiAgICAgIGpvYi5mbGFncyB8PSAyO1xuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICAgICAgam9iLmkgPSBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHdhdGNoSGFuZGxlID0gd2F0Y2gkMShzb3VyY2UsIGNiLCBiYXNlV2F0Y2hPcHRpb25zKTtcbiAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgIGlmIChzc3JDbGVhbnVwKSB7XG4gICAgICBzc3JDbGVhbnVwLnB1c2god2F0Y2hIYW5kbGUpO1xuICAgIH0gZWxzZSBpZiAocnVuc0ltbWVkaWF0ZWx5KSB7XG4gICAgICB3YXRjaEhhbmRsZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gd2F0Y2hIYW5kbGU7XG59XG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XG4gIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSkgPyBzb3VyY2UuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gIGxldCBjYjtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgY2IgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XG4gICAgb3B0aW9ucyA9IHZhbHVlO1xuICB9XG4gIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xuICBjb25zdCByZXMgPSBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucyk7XG4gIHJlc2V0KCk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBjdXIgPSBjdHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcbiAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1vZGVsKHByb3BzLCBuYW1lLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuJDEoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBjb25zdCBjYW1lbGl6ZWROYW1lID0gY2FtZWxpemUobmFtZSk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpLnByb3BzT3B0aW9uc1swXVtjYW1lbGl6ZWROYW1lXSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aCBwcm9wIFwiJHtuYW1lfVwiIHdoaWNoIGlzIG5vdCBkZWNsYXJlZC5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgY29uc3QgaHlwaGVuYXRlZE5hbWUgPSBoeXBoZW5hdGUobmFtZSk7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBjYW1lbGl6ZWROYW1lKTtcbiAgY29uc3QgcmVzID0gY3VzdG9tUmVmKCh0cmFjaywgdHJpZ2dlcikgPT4ge1xuICAgIGxldCBsb2NhbFZhbHVlO1xuICAgIGxldCBwcmV2U2V0VmFsdWUgPSBFTVBUWV9PQko7XG4gICAgbGV0IHByZXZFbWl0dGVkVmFsdWU7XG4gICAgd2F0Y2hTeW5jRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW2NhbWVsaXplZE5hbWVdO1xuICAgICAgaWYgKGhhc0NoYW5nZWQobG9jYWxWYWx1ZSwgcHJvcFZhbHVlKSkge1xuICAgICAgICBsb2NhbFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgdHJhY2soKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0ID8gb3B0aW9ucy5nZXQobG9jYWxWYWx1ZSkgOiBsb2NhbFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbWl0dGVkVmFsdWUgPSBvcHRpb25zLnNldCA/IG9wdGlvbnMuc2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBpZiAoIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBsb2NhbFZhbHVlKSAmJiAhKHByZXZTZXRWYWx1ZSAhPT0gRU1QVFlfT0JKICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd1Byb3BzID0gaS52bm9kZS5wcm9wcztcbiAgICAgICAgaWYgKCEocmF3UHJvcHMgJiYgLy8gY2hlY2sgaWYgcGFyZW50IGhhcyBwYXNzZWQgdi1tb2RlbFxuICAgICAgICAobmFtZSBpbiByYXdQcm9wcyB8fCBjYW1lbGl6ZWROYW1lIGluIHJhd1Byb3BzIHx8IGh5cGhlbmF0ZWROYW1lIGluIHJhd1Byb3BzKSAmJiAoYG9uVXBkYXRlOiR7bmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2NhbWVsaXplZE5hbWV9YCBpbiByYXdQcm9wcyB8fCBgb25VcGRhdGU6JHtoeXBoZW5hdGVkTmFtZX1gIGluIHJhd1Byb3BzKSkpIHtcbiAgICAgICAgICBsb2NhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICAgIGkuZW1pdChgdXBkYXRlOiR7bmFtZX1gLCBlbWl0dGVkVmFsdWUpO1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgZW1pdHRlZFZhbHVlKSAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpICYmICFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgcHJldkVtaXR0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlNldFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByZXZFbWl0dGVkVmFsdWUgPSBlbWl0dGVkVmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJlc1tTeW1ib2wuaXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGxldCBpMiA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGlmIChpMiA8IDIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaTIrKyA/IG1vZGlmaWVycyB8fCBFTVBUWV9PQkogOiByZXMsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGdldE1vZGVsTW9kaWZpZXJzID0gKHByb3BzLCBtb2RlbE5hbWUpID0+IHtcbiAgcmV0dXJuIG1vZGVsTmFtZSA9PT0gXCJtb2RlbFZhbHVlXCIgfHwgbW9kZWxOYW1lID09PSBcIm1vZGVsLXZhbHVlXCIgPyBwcm9wcy5tb2RlbE1vZGlmaWVycyA6IHByb3BzW2Ake21vZGVsTmFtZX1Nb2RpZmllcnNgXSB8fCBwcm9wc1tgJHtjYW1lbGl6ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2h5cGhlbmF0ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdO1xufTtcblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcbiAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkKSByZXR1cm47XG4gIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXRzT3B0aW9ucyxcbiAgICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgICB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJiB0cnVlKSB7XG4gICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkgaW4gcHJvcHNPcHRpb25zKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpfVwiIHByb3AuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGFyZ3MgPSByYXdBcmdzO1xuICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKFwidXBkYXRlOlwiKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gaXNNb2RlbExpc3RlbmVyICYmIGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBldmVudC5zbGljZSg3KSk7XG4gIGlmIChtb2RpZmllcnMpIHtcbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCgoYSkgPT4gaXNTdHJpbmcoYSkgPyBhLnRyaW0oKSA6IGEpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGxvb3NlVG9OdW1iZXIpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgJHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnR5cGVcbiAgICAgICAgKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2Ugdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoXG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgKX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgaGFuZGxlck5hbWU7XG4gIGxldCBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpXSB8fCAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gIHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSldO1xuICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XG4gICAgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpXTtcbiAgfVxuICBpZiAoaGFuZGxlcikge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xuICBpZiAob25jZUhhbmRsZXIpIHtcbiAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcbiAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIG9uY2VIYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xuICBsZXQgbm9ybWFsaXplZCA9IHt9O1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdzIpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XG4gICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICByYXcuZm9yRWFjaCgoa2V5KSA9PiBub3JtYWxpemVkW2tleV0gPSBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcbiAgfVxuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcbiAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgXCJcIik7XG4gIHJldHVybiBoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8IGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHwgaGFzT3duKG9wdGlvbnMsIGtleSk7XG59XG5cbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcbiAgYWNjZXNzZWRBdHRycyA9IHRydWU7XG59XG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgdm5vZGUsXG4gICAgcHJveHksXG4gICAgd2l0aFByb3h5LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sXG4gICAgc2xvdHMsXG4gICAgYXR0cnMsXG4gICAgZW1pdCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyQ2FjaGUsXG4gICAgcHJvcHMsXG4gICAgZGF0YSxcbiAgICBzZXR1cFN0YXRlLFxuICAgIGN0eCxcbiAgICBpbmhlcml0QXR0cnNcbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQpIHtcbiAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XG4gICAgICBjb25zdCB0aGlzUHJveHkgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwID8gbmV3IFByb3h5KHByb3h5VG9Vc2UsIHtcbiAgICAgICAgZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBQcm9wZXJ0eSAnJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKX0nIHdhcyBhY2Nlc3NlZCB2aWEgJ3RoaXMnLiBBdm9pZCB1c2luZyAndGhpcycgaW4gdGVtcGxhdGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICB9KSA6IHByb3h5VG9Vc2U7XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyLmNhbGwoXG4gICAgICAgICAgdGhpc1Byb3h5LFxuICAgICAgICAgIHByb3h5VG9Vc2UsXG4gICAgICAgICAgcmVuZGVyQ2FjaGUsXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICBzZXR1cFN0YXRlLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgY3R4XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlcjIgPSBDb21wb25lbnQ7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcbiAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIyLmxlbmd0aCA+IDEgPyByZW5kZXIyKFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShhdHRycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICBlbWl0XG4gICAgICAgICAgfSA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH1cbiAgICAgICAgKSA6IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzID8gYXR0cnMgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEpO1xuICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9XG4gIGxldCByb290ID0gcmVzdWx0O1xuICBsZXQgc2V0Um9vdCA9IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiYgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcbiAgfVxuICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNikpIHtcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xuICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMsXG4gICAgICAgICAgICBwcm9wc09wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcbiAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xuICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0cmFBdHRycy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzICgke2V4dHJhQXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IG9yIHRlbGVwb3J0IHJvb3Qgbm9kZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoJHtldmVudEF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgUnVudGltZSBkaXJlY3RpdmUgdXNlZCBvbiBjb21wb25lbnQgd2l0aCBub24tZWxlbWVudCByb290IG5vZGUuIFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIG51bGwsIGZhbHNlLCB0cnVlKTtcbiAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcbiAgfVxuICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBDb21wb25lbnQgaW5zaWRlIDxUcmFuc2l0aW9uPiByZW5kZXJzIG5vbi1lbGVtZW50IHJvb3Qgbm9kZSB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBzZXRUcmFuc2l0aW9uSG9va3Mocm9vdCwgdm5vZGUudHJhbnNpdGlvbik7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0Um9vdCkge1xuICAgIHNldFJvb3Qocm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gcm9vdDtcbiAgfVxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuLCBmYWxzZSk7XG4gIGlmICghY2hpbGRSb290KSB7XG4gICAgcmV0dXJuIFt2bm9kZSwgdm9pZCAwXTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgPiAwICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgcmV0dXJuIGdldENoaWxkUm9vdChjaGlsZFJvb3QpO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xuICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XG4gIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcbiAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICAgIH0gZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xuICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xufTtcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4sIHJlY3Vyc2UgPSB0cnVlKSB7XG4gIGxldCBzaW5nbGVSb290O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50IHx8IGNoaWxkLmNoaWxkcmVuID09PSBcInYtaWZcIikge1xuICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVjdXJzZSAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyA+IDAgJiYgc2luZ2xlUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyU2luZ2xlUm9vdChzaW5nbGVSb290LmNoaWxkcmVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2luZ2xlUm9vdDtcbn1cbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xuICBsZXQgcmVzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIiB8fCBrZXkgPT09IFwic3R5bGVcIiB8fCBpc09uKGtleSkpIHtcbiAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XG4gICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgKDYgfCAxKSB8fCB2bm9kZS50eXBlID09PSBDb21tZW50O1xufTtcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XG4gIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XG4gIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XG4gIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgfVxuICAgIGlmICghbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHNPcHRpb25zKSB7XG4gIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcbiAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XG4gICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdXBkYXRlSE9DSG9zdEVsKHsgdm5vZGUsIHBhcmVudCB9LCBlbCkge1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmVudC5zdWJUcmVlO1xuICAgIGlmIChyb290LnN1c3BlbnNlICYmIHJvb3Quc3VzcGVuc2UuYWN0aXZlQnJhbmNoID09PSB2bm9kZSkge1xuICAgICAgcm9vdC5lbCA9IHZub2RlLmVsO1xuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gdm5vZGUpIHtcbiAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xubGV0IHN1c3BlbnNlSWQgPSAwO1xuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xuICBuYW1lOiBcIlN1c3BlbnNlXCIsXG4gIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcbiAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcbiAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXG4gIC8vIGludGVybmFscy5cbiAgX19pc1N1c3BlbnNlOiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50U3VzcGVuc2UoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5kZXBzID4gMCAmJiAhbjEuc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gICAgICAgIG4yLnN1c3BlbnNlLnZub2RlID0gbjI7XG4gICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhdGNoU3VzcGVuc2UoXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxufTtcbmNvbnN0IFN1c3BlbnNlID0gU3VzcGVuc2VJbXBsIDtcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XG4gIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XG4gICAgZXZlbnRMaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgdm5vZGUsXG4gICAgcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgYW5jaG9yLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICk7XG4gIHBhdGNoKFxuICAgIG51bGwsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgbnVsbCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkc1xuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25QZW5kaW5nXCIpO1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvbkZhbGxiYWNrXCIpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLnNzRmFsbGJhY2ssXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgbjIuZWwgPSBuMS5lbDtcbiAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xuICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XG4gIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcbiAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBzdXNwZW5zZUlkKys7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5kZXBzID0gMDtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyRXZlbnQobjIsIFwib25QZW5kaW5nXCIpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICAgIGlmIChuZXdCcmFuY2guc2hhcGVGbGFnICYgNTEyKSB7XG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IG5ld0JyYW5jaC5jb21wb25lbnQuc3VzcGVuc2VJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcbiAgICAgIH1cbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSAmJiAhaGFzV2FybmVkKSB7XG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/IFwiaW5mb1wiIDogXCJsb2dcIl0oXG4gICAgICBgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG06IG1vdmUsXG4gICAgdW06IHVubW91bnQsXG4gICAgbjogbmV4dCxcbiAgICBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgbGV0IHBhcmVudFN1c3BlbnNlSWQ7XG4gIGNvbnN0IGlzU3VzcGVuc2libGUgPSBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpO1xuICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZUlkID0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkO1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcysrO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lb3V0ID0gdm5vZGUucHJvcHMgPyB0b051bWJlcih2bm9kZS5wcm9wcy50aW1lb3V0KSA6IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIodGltZW91dCwgYFN1c3BlbnNlIHRpbWVvdXRgKTtcbiAgfVxuICBjb25zdCBpbml0aWFsQW5jaG9yID0gYW5jaG9yO1xuICBjb25zdCBzdXNwZW5zZSA9IHtcbiAgICB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBuYW1lc3BhY2UsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBkZXBzOiAwLFxuICAgIHBlbmRpbmdJZDogc3VzcGVuc2VJZCsrLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiID8gdGltZW91dCA6IC0xLFxuICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcbiAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxuICAgIGlzSW5GYWxsYmFjazogIWlzSHlkcmF0aW5nLFxuICAgIGlzSHlkcmF0aW5nLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBlZmZlY3RzOiBbXSxcbiAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlLCBzeW5jID0gZmFsc2UpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGlmICghcmVzdW1lICYmICFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZub2RlOiB2bm9kZTIsXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgcGVuZGluZ0lkLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyMlxuICAgICAgfSA9IHN1c3BlbnNlO1xuICAgICAgbGV0IGRlbGF5RW50ZXIgPSBmYWxzZTtcbiAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghcmVzdW1lKSB7XG4gICAgICAgIGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgbW92ZShcbiAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICAgICAgYW5jaG9yID09PSBpbml0aWFsQW5jaG9yID8gbmV4dChhY3RpdmVCcmFuY2gpIDogYW5jaG9yLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICBpZiAocGFyZW50Tm9kZShhY3RpdmVCcmFuY2guZWwpID09PSBjb250YWluZXIyKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQyLCBzdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XG4gICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XG4gICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNVbnJlc29sdmVkQW5jZXN0b3IgJiYgIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcbiAgICAgIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmIHBhcmVudFN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCAmJiAhc3luYykge1xuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvblJlc29sdmVcIik7XG4gICAgfSxcbiAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XG4gICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MiwgY29udGFpbmVyOiBjb250YWluZXIyLCBuYW1lc3BhY2U6IG5hbWVzcGFjZTIgfSA9IHN1c3BlbnNlO1xuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvbkZhbGxiYWNrXCIpO1xuICAgICAgY29uc3QgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmFsbGJhY2tWTm9kZSxcbiAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgbmFtZXNwYWNlMixcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbiAmJiBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIHVubW91bnQoXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICB0cnVlXG4gICAgICAgIC8vIHNob3VsZFJlbW92ZVxuICAgICAgKTtcbiAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICBtb3VudEZhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3ZlKGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpIHtcbiAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSk7XG4gICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXIyO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0LCBvcHRpbWl6ZWQyKSB7XG4gICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xuICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcbiAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xuICAgICAgfVxuICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xuICAgICAgaW5zdGFuY2UuYXN5bmNEZXAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwKTtcbiAgICAgIH0pLnRoZW4oKGFzeW5jU2V0dXBSZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xuICAgICAgICBpZiAoaHlkcmF0ZWRFbCkge1xuICAgICAgICAgIHZub2RlMi5lbCA9IGh5ZHJhdGVkRWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xuICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICB2bm9kZTIsXG4gICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxuICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXG4gICAgICAgICAgLy8gY29uc2lkZXIgdGhlIGNvbW1lbnQgcGxhY2Vob2xkZXIgY2FzZS5cbiAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZDJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlMi5lbCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZTIsIGRvUmVtb3ZlKSB7XG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3VzcGVuc2U7XG59XG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbm9kZS5wYXJlbnROb2RlLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgIG51bGwsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgdHJ1ZVxuICApO1xuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcbiAgICBub2RlLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWRcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xuICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoXG4gICAgaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW5cbiAgKTtcbiAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgbGV0IGJsb2NrO1xuICBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgb3BlbkJsb2NrKCk7XG4gICAgfVxuICAgIHMgPSBzKCk7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICBjbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5KHMpKSB7XG4gICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFzaW5nbGVDaGlsZCAmJiBzLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkICE9PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKS5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuJDEoYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcbiAgICB9XG4gICAgcyA9IHNpbmdsZUNoaWxkO1xuICB9XG4gIHMgPSBub3JtYWxpemVWTm9kZShzKTtcbiAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xuICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKChjKSA9PiBjICE9PSBzKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xuICBpZiAoc3VzcGVuc2UgJiYgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XG4gIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcbiAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgbGV0IGVsID0gYnJhbmNoLmVsO1xuICB3aGlsZSAoIWVsICYmIGJyYW5jaC5jb21wb25lbnQpIHtcbiAgICBicmFuY2ggPSBicmFuY2guY29tcG9uZW50LnN1YlRyZWU7XG4gICAgZWwgPSBicmFuY2guZWw7XG4gIH1cbiAgdm5vZGUuZWwgPSBlbDtcbiAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcbiAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSkge1xuICBjb25zdCBzdXNwZW5zaWJsZSA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlO1xuICByZXR1cm4gc3VzcGVuc2libGUgIT0gbnVsbCAmJiBzdXNwZW5zaWJsZSAhPT0gZmFsc2U7XG59XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sLmZvcihcInYtZmd0XCIpO1xuY29uc3QgVGV4dCA9IFN5bWJvbC5mb3IoXCJ2LXR4dFwiKTtcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2wuZm9yKFwidi1jbXRcIik7XG5jb25zdCBTdGF0aWMgPSBTeW1ib2wuZm9yKFwidi1zdGNcIik7XG5jb25zdCBibG9ja1N0YWNrID0gW107XG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xuICBibG9ja1N0YWNrLnB1c2goY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKTtcbn1cbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XG4gIGJsb2NrU3RhY2sucG9wKCk7XG4gIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxubGV0IGlzQmxvY2tUcmVlRW5hYmxlZCA9IDE7XG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlLCBpblZPbmNlID0gZmFsc2UpIHtcbiAgaXNCbG9ja1RyZWVFbmFibGVkICs9IHZhbHVlO1xuICBpZiAodmFsdWUgPCAwICYmIGN1cnJlbnRCbG9jayAmJiBpblZPbmNlKSB7XG4gICAgY3VycmVudEJsb2NrLmhhc09uY2UgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXR1cEJsb2NrKHZub2RlKSB7XG4gIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgPyBjdXJyZW50QmxvY2sgfHwgRU1QVFlfQVJSIDogbnVsbDtcbiAgY2xvc2VCbG9jaygpO1xuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVCYXNlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHRydWVcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICB0cnVlXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5fX3ZfaXNWTm9kZSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuMi5zaGFwZUZsYWcgJiA2ICYmIG4xLmNvbXBvbmVudCkge1xuICAgIGNvbnN0IGRpcnR5SW5zdGFuY2VzID0gaG1yRGlydHlDb21wb25lbnRzLmdldChuMi50eXBlKTtcbiAgICBpZiAoZGlydHlJbnN0YW5jZXMgJiYgZGlydHlJbnN0YW5jZXMuaGFzKG4xLmNvbXBvbmVudCkpIHtcbiAgICAgIG4xLnNoYXBlRmxhZyAmPSB+MjU2O1xuICAgICAgbjIuc2hhcGVGbGFnICY9IH41MTI7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xufVxubGV0IHZub2RlQXJnc1RyYW5zZm9ybWVyO1xuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XG4gIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG59XG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIF9jcmVhdGVWTm9kZShcbiAgICAuLi52bm9kZUFyZ3NUcmFuc2Zvcm1lciA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkgOiBhcmdzXG4gICk7XG59O1xuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7XG4gIHJlZixcbiAgcmVmX2tleSxcbiAgcmVmX2ZvclxufSkgPT4ge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlZiA9IFwiXCIgKyByZWY7XG4gIH1cbiAgcmV0dXJuIHJlZiAhPSBudWxsID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKSA/IHsgaTogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCByOiByZWYsIGs6IHJlZl9rZXksIGY6ICEhcmVmX2ZvciB9IDogcmVmIDogbnVsbDtcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEsIGlzQmxvY2tOb2RlID0gZmFsc2UsIG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uID0gZmFsc2UpIHtcbiAgY29uc3Qgdm5vZGUgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXG4gICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxuICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogbnVsbCxcbiAgICBjaGlsZHJlbixcbiAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgc3VzcGVuc2U6IG51bGwsXG4gICAgc3NDb250ZW50OiBudWxsLFxuICAgIHNzRmFsbGJhY2s6IG51bGwsXG4gICAgZGlyczogbnVsbCxcbiAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgIGVsOiBudWxsLFxuICAgIGFuY2hvcjogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGFyZ2V0U3RhcnQ6IG51bGwsXG4gICAgdGFyZ2V0QW5jaG9yOiBudWxsLFxuICAgIHN0YXRpY0NvdW50OiAwLFxuICAgIHNoYXBlRmxhZyxcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcbiAgICBhcHBDb250ZXh0OiBudWxsLFxuICAgIGN0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlXG4gIH07XG4gIGlmIChuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbikge1xuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIHZub2RlLnNoYXBlRmxhZyB8PSBpc1N0cmluZyhjaGlsZHJlbikgPyA4IDogMTY7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcbiAgICB3YXJuJDEoYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcbiAgIWlzQmxvY2tOb2RlICYmIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xuICBjdXJyZW50QmxvY2sgJiYgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cbiAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXG4gIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xuICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXG4gICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYpICYmIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxuICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxuICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gOiBfY3JlYXRlVk5vZGU7XG5mdW5jdGlvbiBfY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIGlzQmxvY2tOb2RlID0gZmFsc2UpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdHlwZSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIHZub2RlIHR5cGUgd2hlbiBjcmVhdGluZyB2bm9kZTogJHt0eXBlfS5gKTtcbiAgICB9XG4gICAgdHlwZSA9IENvbW1lbnQ7XG4gIH1cbiAgaWYgKGlzVk5vZGUodHlwZSkpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgdHJ1ZVxuICAgICAgLyogbWVyZ2VSZWY6IHRydWUgKi9cbiAgICApO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmICFpc0Jsb2NrTm9kZSAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgIGlmIChjbG9uZWQuc2hhcGVGbGFnICYgNikge1xuICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2xvbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xvbmVkLnBhdGNoRmxhZyA9IC0yO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcbiAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XG4gIH1cbiAgaWYgKHByb3BzKSB7XG4gICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xuICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpID8gMSA6IGlzU3VzcGVuc2UodHlwZSkgPyAxMjggOiBpc1RlbGVwb3J0KHR5cGUpID8gNjQgOiBpc09iamVjdCh0eXBlKSA/IDQgOiBpc0Z1bmN0aW9uKHR5cGUpID8gMiA6IDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNoYXBlRmxhZyAmIDQgJiYgaXNQcm94eSh0eXBlKSkge1xuICAgIHR5cGUgPSB0b1Jhdyh0eXBlKTtcbiAgICB3YXJuJDEoXG4gICAgICBgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgYSByZWFjdGl2ZSBvYmplY3QuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLFxuICAgICAgYFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsXG4gICAgICB0eXBlXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBzaGFwZUZsYWcsXG4gICAgaXNCbG9ja05vZGUsXG4gICAgdHJ1ZVxuICApO1xufVxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xuICByZXR1cm4gaXNQcm94eShwcm9wcykgfHwgaXNJbnRlcm5hbE9iamVjdChwcm9wcykgPyBleHRlbmQoe30sIHByb3BzKSA6IHByb3BzO1xufVxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSwgY2xvbmVUcmFuc2l0aW9uID0gZmFsc2UpIHtcbiAgY29uc3QgeyBwcm9wcywgcmVmLCBwYXRjaEZsYWcsIGNoaWxkcmVuLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcbiAgY29uc3QgY2xvbmVkID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGU6IHZub2RlLnR5cGUsXG4gICAgcHJvcHM6IG1lcmdlZFByb3BzLFxuICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcbiAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWYgPyAoXG4gICAgICAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XG4gICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxuICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcbiAgICAgIG1lcmdlUmVmICYmIHJlZiA/IGlzQXJyYXkocmVmKSA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKSA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV0gOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcbiAgICApIDogcmVmLFxuICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgY2hpbGRyZW46ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcGF0Y2hGbGFnID09PSAtMSAmJiBpc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSkgOiBjaGlsZHJlbixcbiAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcbiAgICB0YXJnZXRTdGFydDogdm5vZGUudGFyZ2V0U3RhcnQsXG4gICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXG4gICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxuICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxuICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXG4gICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cbiAgICAvLyBub3RlOiBwcmVzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXG4gICAgLy8gZmFzdCBwYXRocyBvbmx5LlxuICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudCA/IHBhdGNoRmxhZyA9PT0gLTEgPyAxNiA6IHBhdGNoRmxhZyB8IDE2IDogcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wczogdm5vZGUuZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxuICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXG4gICAgZGlyczogdm5vZGUuZGlycyxcbiAgICB0cmFuc2l0aW9uLFxuICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxuICAgIC8vIHRoZXkgKnNob3VsZCogYmUgY29waWVkIGZvciBrZXB0LWFsaXZlIHZub2Rlcy4gU28gd2UganVzdCBhbHdheXMgY29weVxuICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcbiAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxuICAgIGNvbXBvbmVudDogdm5vZGUuY29tcG9uZW50LFxuICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcbiAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXG4gICAgc3NGYWxsYmFjazogdm5vZGUuc3NGYWxsYmFjayAmJiBjbG9uZVZOb2RlKHZub2RlLnNzRmFsbGJhY2spLFxuICAgIGVsOiB2bm9kZS5lbCxcbiAgICBhbmNob3I6IHZub2RlLmFuY2hvcixcbiAgICBjdHg6IHZub2RlLmN0eCxcbiAgICBjZTogdm5vZGUuY2VcbiAgfTtcbiAgaWYgKHRyYW5zaXRpb24gJiYgY2xvbmVUcmFuc2l0aW9uKSB7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgY2xvbmVkLFxuICAgICAgdHJhbnNpdGlvbi5jbG9uZShjbG9uZWQpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcbiAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gXCIgXCIsIGZsYWcgPSAwKSB7XG4gIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xuICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gXCJcIiwgYXNCbG9jayA9IGZhbHNlKSB7XG4gIHJldHVybiBhc0Jsb2NrID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50LCBudWxsLCB0ZXh0KSkgOiBjcmVhdGVWTm9kZShDb21tZW50LCBudWxsLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XG4gIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcbiAgICAgIGNoaWxkLnNsaWNlKClcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lSWZNb3VudGVkKGNoaWxkKSB7XG4gIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCAmJiBjaGlsZC5wYXRjaEZsYWcgIT09IC0xIHx8IGNoaWxkLm1lbW8gPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XG4gIGxldCB0eXBlID0gMDtcbiAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIHR5cGUgPSAxNjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2NCkpIHtcbiAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xuICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IGZhbHNlKTtcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDMyO1xuICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xuICAgICAgaWYgKCFzbG90RmxhZyAmJiAhaXNJbnRlcm5hbE9iamVjdChjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSkge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAyO1xuICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcbiAgICB0eXBlID0gMzI7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZSA9IDE2O1xuICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSA4O1xuICAgIH1cbiAgfVxuICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xuICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcbiAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcbiAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XG4gICAgICAgIGlmIChpbmNvbWluZyAmJiBleGlzdGluZyAhPT0gaW5jb21pbmcgJiYgIShpc0FycmF5KGV4aXN0aW5nKSAmJiBleGlzdGluZy5pbmNsdWRlcyhpbmNvbWluZykpKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpIDogaW5jb21pbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSBcIlwiKSB7XG4gICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNywgW1xuICAgIHZub2RlLFxuICAgIHByZXZWTm9kZVxuICBdKTtcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xubGV0IHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xuICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgdWlkOiB1aWQrKyxcbiAgICB2bm9kZSxcbiAgICB0eXBlLFxuICAgIHBhcmVudCxcbiAgICBhcHBDb250ZXh0LFxuICAgIHJvb3Q6IG51bGwsXG4gICAgLy8gdG8gYmUgaW1tZWRpYXRlbHkgc2V0XG4gICAgbmV4dDogbnVsbCxcbiAgICBzdWJUcmVlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBlZmZlY3Q6IG51bGwsXG4gICAgdXBkYXRlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBqb2I6IG51bGwsXG4gICAgc2NvcGU6IG5ldyBFZmZlY3RTY29wZShcbiAgICAgIHRydWVcbiAgICAgIC8qIGRldGFjaGVkICovXG4gICAgKSxcbiAgICByZW5kZXI6IG51bGwsXG4gICAgcHJveHk6IG51bGwsXG4gICAgZXhwb3NlZDogbnVsbCxcbiAgICBleHBvc2VQcm94eTogbnVsbCxcbiAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXG4gICAgaWRzOiBwYXJlbnQgPyBwYXJlbnQuaWRzIDogW1wiXCIsIDAsIDBdLFxuICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxuICAgIHJlbmRlckNhY2hlOiBbXSxcbiAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICBjb21wb25lbnRzOiBudWxsLFxuICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICBwcm9wc09wdGlvbnM6IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICAvLyBlbWl0XG4gICAgZW1pdDogbnVsbCxcbiAgICAvLyB0byBiZSBzZXQgaW1tZWRpYXRlbHlcbiAgICBlbWl0dGVkOiBudWxsLFxuICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcbiAgICBwcm9wc0RlZmF1bHRzOiBFTVBUWV9PQkosXG4gICAgLy8gaW5oZXJpdEF0dHJzXG4gICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcbiAgICAvLyBzdGF0ZVxuICAgIGN0eDogRU1QVFlfT0JKLFxuICAgIGRhdGE6IEVNUFRZX09CSixcbiAgICBwcm9wczogRU1QVFlfT0JKLFxuICAgIGF0dHJzOiBFTVBUWV9PQkosXG4gICAgc2xvdHM6IEVNUFRZX09CSixcbiAgICByZWZzOiBFTVBUWV9PQkosXG4gICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxuICAgIHNldHVwQ29udGV4dDogbnVsbCxcbiAgICAvLyBzdXNwZW5zZSByZWxhdGVkXG4gICAgc3VzcGVuc2UsXG4gICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgIGFzeW5jRGVwOiBudWxsLFxuICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXG4gICAgYmM6IG51bGwsXG4gICAgYzogbnVsbCxcbiAgICBibTogbnVsbCxcbiAgICBtOiBudWxsLFxuICAgIGJ1OiBudWxsLFxuICAgIHU6IG51bGwsXG4gICAgdW06IG51bGwsXG4gICAgYnVtOiBudWxsLFxuICAgIGRhOiBudWxsLFxuICAgIGE6IG51bGwsXG4gICAgcnRnOiBudWxsLFxuICAgIHJ0YzogbnVsbCxcbiAgICBlYzogbnVsbCxcbiAgICBzcDogbnVsbFxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgfVxuICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcbiAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XG4gIGlmICh2bm9kZS5jZSkge1xuICAgIHZub2RlLmNlKGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG5sZXQgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2U7XG5sZXQgc2V0SW5TU1JTZXR1cFN0YXRlO1xue1xuICBjb25zdCBnID0gZ2V0R2xvYmFsVGhpcygpO1xuICBjb25zdCByZWdpc3Rlckdsb2JhbFNldHRlciA9IChrZXksIHNldHRlcikgPT4ge1xuICAgIGxldCBzZXR0ZXJzO1xuICAgIGlmICghKHNldHRlcnMgPSBnW2tleV0pKSBzZXR0ZXJzID0gZ1trZXldID0gW107XG4gICAgc2V0dGVycy5wdXNoKHNldHRlcik7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICBpZiAoc2V0dGVycy5sZW5ndGggPiAxKSBzZXR0ZXJzLmZvckVhY2goKHNldCkgPT4gc2V0KHYpKTtcbiAgICAgIGVsc2Ugc2V0dGVyc1swXSh2KTtcbiAgICB9O1xuICB9O1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZSA9IHJlZ2lzdGVyR2xvYmFsU2V0dGVyKFxuICAgIGBfX1ZVRV9JTlNUQU5DRV9TRVRURVJTX19gLFxuICAgICh2KSA9PiBjdXJyZW50SW5zdGFuY2UgPSB2XG4gICk7XG4gIHNldEluU1NSU2V0dXBTdGF0ZSA9IHJlZ2lzdGVyR2xvYmFsU2V0dGVyKFxuICAgIGBfX1ZVRV9TU1JfU0VUVEVSU19fYCxcbiAgICAodikgPT4gaXNJblNTUkNvbXBvbmVudFNldHVwID0gdlxuICApO1xufVxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IHByZXYgPSBjdXJyZW50SW5zdGFuY2U7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShwcmV2KTtcbiAgfTtcbn07XG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcbiAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XG59O1xuY29uc3QgaXNCdWlsdEluVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCJzbG90LGNvbXBvbmVudFwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCB7IGlzTmF0aXZlVGFnIH0pIHtcbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBpc05hdGl2ZVRhZyhuYW1lKSkge1xuICAgIHdhcm4kMShcbiAgICAgIFwiRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogXCIgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNDtcbn1cbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkge1xuICBpc1NTUiAmJiBzZXRJblNTUlNldHVwU3RhdGUoaXNTU1IpO1xuICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XG4gIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcbiAgaW5pdFByb3BzKGluc3RhbmNlLCBwcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IpO1xuICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWwgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikgOiB2b2lkIDA7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShmYWxzZSk7XG4gIHJldHVybiBzZXR1cFJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGluc3RhbmNlLnByb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH1cbiAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xuICBpZiAoc2V0dXApIHtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID0gc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsO1xuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIHNldHVwLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAwLFxuICAgICAgW1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLFxuICAgICAgICBzZXR1cENvbnRleHRcbiAgICAgIF1cbiAgICApO1xuICAgIGNvbnN0IGlzQXN5bmNTZXR1cCA9IGlzUHJvbWlzZShzZXR1cFJlc3VsdCk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHJlc2V0KCk7XG4gICAgaWYgKChpc0FzeW5jU2V0dXAgfHwgaW5zdGFuY2Uuc3ApICYmICFpc0FzeW5jV3JhcHBlcihpbnN0YW5jZSkpIHtcbiAgICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmNTZXR1cCkge1xuICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xuICAgICAgaWYgKGlzU1NSKSB7XG4gICAgICAgIHJldHVybiBzZXR1cFJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGluc3RhbmNlLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCA9IHNldHVwUmVzdWx0O1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaW5zdGFuY2Uuc3VzcGVuc2UpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gQ29tcG9uZW50Lm5hbWUpICE9IG51bGwgPyBfYSA6IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYENvbXBvbmVudCA8JHtuYW1lfT46IHNldHVwIGZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSwgYnV0IG5vIDxTdXNwZW5zZT4gYm91bmRhcnkgd2FzIGZvdW5kIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHRyZWUuIEEgY29tcG9uZW50IHdpdGggYXN5bmMgc2V0dXAoKSBtdXN0IGJlIG5lc3RlZCBpbiBhIDxTdXNwZW5zZT4gaW4gb3JkZXIgdG8gYmUgcmVuZGVyZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwUmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICB3YXJuJDEoXG4gICAgICBgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gXG4gICAgKTtcbiAgfVxuICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xufVxubGV0IGNvbXBpbGU7XG5sZXQgaW5zdGFsbFdpdGhQcm94eTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XG4gIGNvbXBpbGUgPSBfY29tcGlsZTtcbiAgaW5zdGFsbFdpdGhQcm94eSA9IChpKSA9PiB7XG4gICAgaWYgKGkucmVuZGVyLl9yYykge1xuICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xuICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBDb21wb25lbnQudGVtcGxhdGUgfHwgX19WVUVfT1BUSU9OU19BUElfXyAmJiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XG4gICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcbiAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoXG4gICAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgICAgICAgICAgIGRlbGltaXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgIGNvbXBvbmVudENvbXBpbGVyT3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyID0gQ29tcG9uZW50LnJlbmRlciB8fCBOT09QO1xuICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XG4gICAgICBpbnN0YWxsV2l0aFByb3h5KGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgdHJ1ZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgdHJ5IHtcbiAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcbiAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQxKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb246IGAsIENvbXBvbmVudCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBhdHRyc1Byb3h5SGFuZGxlcnMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwgXCJcIik7XG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICB9LFxuICBzZXQoKSB7XG4gICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0gOiB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwgXCJcIik7XG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkge1xuICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLnNsb3RzLCB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCBleHBvc2UgPSAoZXhwb3NlZCkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICB3YXJuJDEoYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9zZWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZXhwb3NlZFR5cGUgPSB0eXBlb2YgZXhwb3NlZDtcbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWYoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJyZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7ZXhwb3NlZFR5cGV9LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGxldCBhdHRyc1Byb3h5O1xuICAgIGxldCBzbG90c1Byb3h5O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzUHJveHkgfHwgKGF0dHJzUHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycykpO1xuICAgICAgfSxcbiAgICAgIGdldCBzbG90cygpIHtcbiAgICAgICAgcmV0dXJuIHNsb3RzUHJveHkgfHwgKHNsb3RzUHJveHkgPSBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSk7XG4gICAgICB9LFxuICAgICAgZ2V0IGVtaXQoKSB7XG4gICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyczogbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRyc1Byb3h5SGFuZGxlcnMpLFxuICAgICAgc2xvdHM6IGluc3RhbmNlLnNsb3RzLFxuICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcbiAgICAgIGV4cG9zZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmV4cG9zZVByb3h5IHx8IChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xuICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0IHx8IGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5zdGFuY2UucHJveHk7XG4gIH1cbn1cbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgXCJcIik7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIDogQ29tcG9uZW50Lm5hbWUgfHwgaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWU7XG59XG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XG4gIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xuICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xuICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfVxuICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBuYW1lID0gaW5mZXJGcm9tUmVnaXN0cnkoXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRzIHx8IGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHNcbiAgICApIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XG4gIH1cbiAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XG59XG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiBcIl9fdmNjT3B0c1wiIGluIHZhbHVlO1xufVxuXG5jb25zdCBjb21wdXRlZCA9IChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xuICBjb25zdCBjID0gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNJblNTUkNvbXBvbmVudFNldHVwKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKGkgJiYgaS5hcHBDb250ZXh0LmNvbmZpZy53YXJuUmVjdXJzaXZlQ29tcHV0ZWQpIHtcbiAgICAgIGMuX3dhcm5SZWN1cnNpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYztcbn07XG5cbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xuICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGwgPT09IDIpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsID4gMykge1xuICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIH0gZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xuICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMzYmE3NzZcIiB9O1xuICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzE2NzdmZlwiIH07XG4gIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogXCJjb2xvcjojZjUyMjJkXCIgfTtcbiAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojZWIyZjk2XCIgfTtcbiAgY29uc3QgZm9ybWF0dGVyID0ge1xuICAgIF9fdnVlX2N1c3RvbV9mb3JtYXR0ZXI6IHRydWUsXG4gICAgaGVhZGVyKG9iaikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXCJkaXZcIiwgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZihvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIC8vIGF2b2lkIGRlYnVnZ2VyIGFjY2Vzc2luZyB2YWx1ZSBhZmZlY3RpbmcgYmVoYXZpb3JcbiAgICAgICAgICBmb3JtYXRWYWx1ZShcIl92YWx1ZVwiIGluIG9iaiA/IG9iai5fdmFsdWUgOiBvYmopLFxuICAgICAgICAgIGA+YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhY3RpdmVcIiA6IFwiUmVhY3RpdmVcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWRvbmx5XCIgOiBcIlJlYWRvbmx5XCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgXCI+XCJcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgaGFzQm9keShvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XG4gICAgfSxcbiAgICBib2R5KG9iaikge1xuICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwicHJvcHNcIiwgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJzZXR1cFwiLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJkYXRhXCIsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiY29tcHV0ZWRcIik7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJpbmplY3RcIik7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiaW5qZWN0ZWRcIiwgaW5qZWN0ZWQpKTtcbiAgICB9XG4gICAgYmxvY2tzLnB1c2goW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHt9LFxuICAgICAgW1xuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyBcIjtvcGFjaXR5OjAuNjZcIlxuICAgICAgICB9LFxuICAgICAgICBcIiQgKGludGVybmFsKTogXCJcbiAgICAgIF0sXG4gICAgICBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGluc3RhbmNlIH1dXG4gICAgXSk7XG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xuICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCB7fV07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdHlsZTogXCJsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbVwiIH0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJjb2xvcjojNDc2NTgyXCJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcInBhZGRpbmctbGVmdDoxLjI1ZW1cIlxuICAgICAgICB9LFxuICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCBrZXkgKyBcIjogXCJdLFxuICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxuICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgXTtcbiAgfVxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIG51bWJlclN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgIHJldHVybiBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcbiAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XG4gICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XG4gICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XG4gICAgaWYgKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpIHx8IGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZSgobSkgPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcbiAgICBpZiAoaXNTaGFsbG93KHYpKSB7XG4gICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xuICAgIH1cbiAgICBpZiAodi5lZmZlY3QpIHtcbiAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xuICAgIH1cbiAgICByZXR1cm4gYFJlZmA7XG4gIH1cbiAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xuICBpZiAoY2FjaGVkICYmIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmV0ID0gcmVuZGVyKCk7XG4gIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xuICByZXQuY2FjaGVJbmRleCA9IGluZGV4O1xuICByZXR1cm4gY2FjaGVbaW5kZXhdID0gcmV0O1xufVxuZnVuY3Rpb24gaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pIHtcbiAgY29uc3QgcHJldiA9IGNhY2hlZC5tZW1vO1xuICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc0NoYW5nZWQocHJldltpXSwgbWVtb1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgdmVyc2lvbiA9IFwiMy41LjEzXCI7XG5jb25zdCB3YXJuID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHdhcm4kMSA6IE5PT1A7XG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0gRXJyb3JUeXBlU3RyaW5ncyQxIDtcbmNvbnN0IGRldnRvb2xzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0cnVlID8gZGV2dG9vbHMkMSA6IHZvaWQgMDtcbmNvbnN0IHNldERldnRvb2xzSG9vayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHJ1ZSA/IHNldERldnRvb2xzSG9vayQxIDogTk9PUDtcbmNvbnN0IF9zc3JVdGlscyA9IHtcbiAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UsXG4gIHNldHVwQ29tcG9uZW50LFxuICByZW5kZXJDb21wb25lbnRSb290LFxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsXG4gIGlzVk5vZGU6IGlzVk5vZGUsXG4gIG5vcm1hbGl6ZVZOb2RlLFxuICBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSxcbiAgZW5zdXJlVmFsaWRWTm9kZSxcbiAgcHVzaFdhcm5pbmdDb250ZXh0LFxuICBwb3BXYXJuaW5nQ29udGV4dFxufTtcbmNvbnN0IHNzclV0aWxzID0gX3NzclV0aWxzIDtcbmNvbnN0IHJlc29sdmVGaWx0ZXIgPSBudWxsO1xuY29uc3QgY29tcGF0VXRpbHMgPSBudWxsO1xuY29uc3QgRGVwcmVjYXRpb25UeXBlcyA9IG51bGw7XG5cbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgQ29tbWVudCwgRGVwcmVjYXRpb25UeXBlcywgRXJyb3JDb2RlcywgRXJyb3JUeXBlU3RyaW5ncywgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGFzc2VydE51bWJlciwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVFbGVtZW50QmxvY2ssIGNyZWF0ZUJhc2VWTm9kZSBhcyBjcmVhdGVFbGVtZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVQcm9wc1Jlc3RQcm94eSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lTW9kZWwsIGRlZmluZU9wdGlvbnMsIGRlZmluZVByb3BzLCBkZWZpbmVTbG90cywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBoYXNJbmplY3Rpb25Db250ZXh0LCBoeWRyYXRlT25JZGxlLCBoeWRyYXRlT25JbnRlcmFjdGlvbiwgaHlkcmF0ZU9uTWVkaWFRdWVyeSwgaHlkcmF0ZU9uVmlzaWJsZSwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc01lbW9TYW1lLCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZURlZmF1bHRzLCBtZXJnZU1vZGVscywgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQXR0cnMsIHVzZUlkLCB1c2VNb2RlbCwgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRlbXBsYXRlUmVmLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QsIHdpdGhBc3luY0NvbnRleHQsIHdpdGhDdHgsIHdpdGhEZWZhdWx0cywgd2l0aERpcmVjdGl2ZXMsIHdpdGhNZW1vLCB3aXRoU2NvcGVJZCB9O1xuIiwiLyoqXG4qIEB2dWUvcnVudGltZS1kb20gdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgd2FybiwgaCwgQmFzZVRyYW5zaXRpb24sIGFzc2VydE51bWJlciwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIGdldEN1cnJlbnRJbnN0YW5jZSwgb25CZWZvcmVVcGRhdGUsIHF1ZXVlUG9zdEZsdXNoQ2IsIG9uTW91bnRlZCwgd2F0Y2gsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCBjYW1lbGl6ZSwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGRlZmluZUNvbXBvbmVudCwgbmV4dFRpY2ssIHVucmVmLCBjcmVhdGVWTm9kZSwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgVGV4dCwgaXNSdW50aW1lT25seSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgZXh0ZW5kLCBpc09iamVjdCwgdG9OdW1iZXIsIGlzQXJyYXksIE5PT1AsIGlzU3RyaW5nLCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNTeW1ib2wsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc0Z1bmN0aW9uLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIGlzUGxhaW5PYmplY3QsIGhhc093biwgRU1QVFlfT0JKLCBsb29zZVRvTnVtYmVyLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpbnZva2VBcnJheUZucywgaXNIVE1MVGFnLCBpc1NWR1RhZywgaXNNYXRoTUxUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmxldCBwb2xpY3kgPSB2b2lkIDA7XG5jb25zdCB0dCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnRydXN0ZWRUeXBlcztcbmlmICh0dCkge1xuICB0cnkge1xuICAgIHBvbGljeSA9IC8qIEBfX1BVUkVfXyAqLyB0dC5jcmVhdGVQb2xpY3koXCJ2dWVcIiwge1xuICAgICAgY3JlYXRlSFRNTDogKHZhbCkgPT4gdmFsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEVycm9yIGNyZWF0aW5nIHRydXN0ZWQgdHlwZXMgcG9saWN5OiAke2V9YCk7XG4gIH1cbn1cbmNvbnN0IHVuc2FmZVRvVHJ1c3RlZEhUTUwgPSBwb2xpY3kgPyAodmFsKSA9PiBwb2xpY3kuY3JlYXRlSFRNTCh2YWwpIDogKHZhbCkgPT4gdmFsO1xuY29uc3Qgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBtYXRobWxOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyogQF9fUFVSRV9fICovIGRvYy5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5jb25zdCBub2RlT3BzID0ge1xuICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XG4gIH0sXG4gIHJlbW92ZTogKGNoaWxkKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogKHRhZywgbmFtZXNwYWNlLCBpcywgcHJvcHMpID0+IHtcbiAgICBjb25zdCBlbCA9IG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZykgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBkb2MuY3JlYXRlRWxlbWVudE5TKG1hdGhtbE5TLCB0YWcpIDogaXMgPyBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHsgaXMgfSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcgPT09IFwic2VsZWN0XCIgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gIGNyZWF0ZUNvbW1lbnQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIH0sXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0sXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgcXVlcnlTZWxlY3RvcjogKHNlbGVjdG9yKSA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgfSxcbiAgLy8gX19VTlNBRkVfX1xuICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBuYW1lc3BhY2UsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcbiAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IHVuc2FmZVRvVHJ1c3RlZEhUTUwoXG4gICAgICAgIG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiID8gYDxtYXRoPiR7Y29udGVudH08L21hdGg+YCA6IGNvbnRlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIikge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLy8gZmlyc3RcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgLy8gbGFzdFxuICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICBdO1xuICB9XG59O1xuXG5jb25zdCBUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG5jb25zdCBBTklNQVRJT04gPSBcImFuaW1hdGlvblwiO1xuY29uc3QgdnRjS2V5ID0gU3ltYm9sKFwiX3Z0Y1wiKTtcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBjc3M6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnNcbik7XG5jb25zdCBkZWNvcmF0ZSQxID0gKHQpID0+IHtcbiAgdC5kaXNwbGF5TmFtZSA9IFwiVHJhbnNpdGlvblwiO1xuICB0LnByb3BzID0gVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycztcbiAgcmV0dXJuIHQ7XG59O1xuY29uc3QgVHJhbnNpdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBkZWNvcmF0ZSQxKFxuICAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKVxuKTtcbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xuICBpZiAoaXNBcnJheShob29rKSkge1xuICAgIGhvb2suZm9yRWFjaCgoaDIpID0+IGgyKC4uLmFyZ3MpKTtcbiAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgaG9vayguLi5hcmdzKTtcbiAgfVxufTtcbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xuICByZXR1cm4gaG9vayA/IGlzQXJyYXkoaG9vaykgPyBob29rLnNvbWUoKGgyKSA9PiBoMi5sZW5ndGggPiAxKSA6IGhvb2subGVuZ3RoID4gMSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcbiAgY29uc3QgYmFzZVByb3BzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XG4gICAgICBiYXNlUHJvcHNba2V5XSA9IHJhd1Byb3BzW2tleV07XG4gICAgfVxuICB9XG4gIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGJhc2VQcm9wcztcbiAgfVxuICBjb25zdCB7XG4gICAgbmFtZSA9IFwidlwiLFxuICAgIHR5cGUsXG4gICAgZHVyYXRpb24sXG4gICAgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCxcbiAgICBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLFxuICAgIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsXG4gICAgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCxcbiAgICBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2BcbiAgfSA9IHJhd1Byb3BzO1xuICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XG4gIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xuICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcbiAgY29uc3Qge1xuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkVudGVyQ2FuY2VsbGVkLFxuICAgIG9uTGVhdmUsXG4gICAgb25MZWF2ZUNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsXG4gICAgb25BcHBlYXIgPSBvbkVudGVyLFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZFxuICB9ID0gYmFzZVByb3BzO1xuICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUsIGlzQ2FuY2VsbGVkKSA9PiB7XG4gICAgZWwuX2VudGVyQ2FuY2VsbGVkID0gaXNDYW5jZWxsZWQ7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9O1xuICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xuICAgIGVsLl9pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xuICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xuICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhob29rKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgZW50ZXJEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XG4gICAgb25CZWZvcmVFbnRlcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJGcm9tQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcbiAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcbiAgICBvbkxlYXZlKGVsLCBkb25lKSB7XG4gICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgIGlmICghZWwuX2VudGVyQ2FuY2VsbGVkKSB7XG4gICAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgfVxuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgaWYgKCFlbC5faXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhvbkxlYXZlKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgbGVhdmVEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZSwgW2VsLCByZXNvbHZlXSk7XG4gICAgfSxcbiAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSwgdm9pZCAwLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xuICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgcmV0dXJuIFtuLCBuXTtcbiAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHJlcywgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIChlbFt2dGNLZXldIHx8IChlbFt2dGNLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkpLmFkZChjbHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5kZWxldGUoY2xzKTtcbiAgICBpZiAoIV92dGMuc2l6ZSkge1xuICAgICAgZWxbdnRjS2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH0pO1xufVxubGV0IGVuZElkID0gMDtcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcbiAgY29uc3QgaWQgPSBlbC5fZW5kSWQgPSArK2VuZElkO1xuICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcbiAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGV4cGxpY2l0VGltZW91dCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICB9XG4gIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArIFwiZW5kXCI7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG4gICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCBcIlwiKS5zcGxpdChcIiwgXCIpO1xuICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcbiAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xuICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgbGV0IHR5cGUgPSBudWxsO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0ID8gVFJBTlNJVElPTiA6IEFOSU1BVElPTiA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZSA/IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aCA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KFxuICAgIGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdGltZW91dCxcbiAgICBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xufVxuZnVuY3Rpb24gdG9NcyhzKSB7XG4gIGlmIChzID09PSBcImF1dG9cIikgcmV0dXJuIDA7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZShcIixcIiwgXCIuXCIpKSAqIDFlMztcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsW3Z0Y0tleV07XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHZhbHVlID0gKHZhbHVlID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc10gOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICB9IGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IHZTaG93T3JpZ2luYWxEaXNwbGF5ID0gU3ltYm9sKFwiX3ZvZFwiKTtcbmNvbnN0IHZTaG93SGlkZGVuID0gU3ltYm9sKFwiX3ZzaFwiKTtcbmNvbnN0IHZTaG93ID0ge1xuICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA9IGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHJldHVybjtcbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcbiAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICB9XG59O1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgdlNob3cubmFtZSA9IFwic2hvd1wiO1xufVxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWxbdlNob3dPcmlnaW5hbERpc3BsYXldIDogXCJub25lXCI7XG4gIGVsW3ZTaG93SGlkZGVuXSA9ICF2YWx1ZTtcbn1cbmZ1bmN0aW9uIGluaXRWU2hvd0ZvclNTUigpIHtcbiAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQ1NTX1ZBUl9URVhUID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkNTU19WQVJfVEVYVFwiIDogXCJcIik7XG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXBkYXRlVGVsZXBvcnRzID0gaW5zdGFuY2UudXQgPSAodmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSkpID0+IHtcbiAgICBBcnJheS5mcm9tKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtdi1vd25lcj1cIiR7aW5zdGFuY2UudWlkfVwiXWApXG4gICAgKS5mb3JFYWNoKChub2RlKSA9PiBzZXRWYXJzT25Ob2RlKG5vZGUsIHZhcnMpKTtcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbnN0YW5jZS5nZXRDc3NWYXJzID0gKCkgPT4gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgfVxuICBjb25zdCBzZXRWYXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICAgIGlmIChpbnN0YW5jZS5jZSkge1xuICAgICAgc2V0VmFyc09uTm9kZShpbnN0YW5jZS5jZSwgdmFycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIHZhcnMpO1xuICAgIH1cbiAgICB1cGRhdGVUZWxlcG9ydHModmFycyk7XG4gIH07XG4gIG9uQmVmb3JlVXBkYXRlKCgpID0+IHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKHNldFZhcnMpO1xuICB9KTtcbiAgb25Nb3VudGVkKCgpID0+IHtcbiAgICB3YXRjaChzZXRWYXJzLCBOT09QLCB7IGZsdXNoOiBcInBvc3RcIiB9KTtcbiAgICBjb25zdCBvYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHNldFZhcnMpO1xuICAgIG9iLm9ic2VydmUoaW5zdGFuY2Uuc3ViVHJlZS5lbC5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICBvblVubW91bnRlZCgoKSA9PiBvYi5kaXNjb25uZWN0KCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xuICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xuICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcbiAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XG4gICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgfVxuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB2bm9kZS5lbCkge1xuICAgIHNldFZhcnNPbk5vZGUodm5vZGUuZWwsIHZhcnMpO1xuICB9IGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xuICB9IGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFN0YXRpYykge1xuICAgIGxldCB7IGVsLCBhbmNob3IgfSA9IHZub2RlO1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgc2V0VmFyc09uTm9kZShlbCwgdmFycyk7XG4gICAgICBpZiAoZWwgPT09IGFuY2hvcikgYnJlYWs7XG4gICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VmFyc09uTm9kZShlbCwgdmFycykge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIGxldCBjc3NUZXh0ID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xuICAgICAgY3NzVGV4dCArPSBgLS0ke2tleX06ICR7dmFyc1trZXldfTtgO1xuICAgIH1cbiAgICBzdHlsZVtDU1NfVkFSX1RFWFRdID0gY3NzVGV4dDtcbiAgfVxufVxuXG5jb25zdCBkaXNwbGF5UkUgPSAvKF58OylcXHMqZGlzcGxheVxccyo6LztcbmZ1bmN0aW9uIHBhdGNoU3R5bGUoZWwsIHByZXYsIG5leHQpIHtcbiAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgY29uc3QgaXNDc3NTdHJpbmcgPSBpc1N0cmluZyhuZXh0KTtcbiAgbGV0IGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gZmFsc2U7XG4gIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xuICAgIGlmIChwcmV2KSB7XG4gICAgICBpZiAoIWlzU3RyaW5nKHByZXYpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBwcmV2U3R5bGUgb2YgcHJldi5zcGxpdChcIjtcIikpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBwcmV2U3R5bGUuc2xpY2UoMCwgcHJldlN0eWxlLmluZGV4T2YoXCI6XCIpKS50cmltKCk7XG4gICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgaWYgKGtleSA9PT0gXCJkaXNwbGF5XCIpIHtcbiAgICAgICAgaGFzQ29udHJvbGxlZERpc3BsYXkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQ3NzU3RyaW5nKSB7XG4gICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICBjb25zdCBjc3NWYXJUZXh0ID0gc3R5bGVbQ1NTX1ZBUl9URVhUXTtcbiAgICAgICAgaWYgKGNzc1ZhclRleHQpIHtcbiAgICAgICAgICBuZXh0ICs9IFwiO1wiICsgY3NzVmFyVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcbiAgICAgICAgaGFzQ29udHJvbGxlZERpc3BsYXkgPSBkaXNwbGF5UkUudGVzdChuZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgfVxuICBpZiAodlNob3dPcmlnaW5hbERpc3BsYXkgaW4gZWwpIHtcbiAgICBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gPSBoYXNDb250cm9sbGVkRGlzcGxheSA/IHN0eWxlLmRpc3BsYXkgOiBcIlwiO1xuICAgIGlmIChlbFt2U2hvd0hpZGRlbl0pIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHNlbWljb2xvblJFID0gL1teXFxcXF07XFxzKiQvO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcbiAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIHZhbC5mb3JFYWNoKCh2KSA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPT0gbnVsbCkgdmFsID0gXCJcIjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKHNlbWljb2xvblJFLnRlc3QodmFsKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBVbmV4cGVjdGVkIHNlbWljb2xvbiBhdCB0aGUgZW5kIG9mICcke25hbWV9JyBzdHlsZSB2YWx1ZTogJyR7dmFsfSdgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcbiAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgaHlwaGVuYXRlKHByZWZpeGVkKSxcbiAgICAgICAgICB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgXCJcIiksXG4gICAgICAgICAgXCJpbXBvcnRhbnRcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgcHJlZml4ZXMgPSBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiXTtcbmNvbnN0IHByZWZpeENhY2hlID0ge307XG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlLCByYXdOYW1lKSB7XG4gIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xuICBpZiAobmFtZSAhPT0gXCJmaWx0ZXJcIiAmJiBuYW1lIGluIHN0eWxlKSB7XG4gICAgcmV0dXJuIHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZTtcbiAgfVxuICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xuICAgIGlmIChwcmVmaXhlZCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdOYW1lO1xufVxuXG5jb25zdCB4bGlua05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSwgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KSkge1xuICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoXCJ4bGluazpcIikpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAga2V5LFxuICAgICAgICBpc0Jvb2xlYW4gPyBcIlwiIDogaXNTeW1ib2wodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIHBhcmVudENvbXBvbmVudCwgYXR0ck5hbWUpIHtcbiAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBlbFtrZXldID0ga2V5ID09PSBcImlubmVySFRNTFwiID8gdW5zYWZlVG9UcnVzdGVkSFRNTCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWU7XG4gIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiB0YWcgIT09IFwiUFJPR1JFU1NcIiAmJiAvLyBjdXN0b20gZWxlbWVudHMgbWF5IHVzZSBfdmFsdWUgaW50ZXJuYWxseVxuICAhdGFnLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFnID09PSBcIk9QVElPTlwiID8gZWwuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIiA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IChcbiAgICAgIC8vICMxMTY0NzogdmFsdWUgc2hvdWxkIGJlIHNldCBhcyBlbXB0eSBzdHJpbmcgZm9yIG51bGwgYW5kIHVuZGVmaW5lZCxcbiAgICAgIC8vIGJ1dCA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+IHNob3VsZCBiZSBzZXQgYXMgJ29uJy5cbiAgICAgIGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIiA/IFwib25cIiA6IFwiXCJcbiAgICApIDogU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlIHx8ICEoXCJfdmFsdWVcIiBpbiBlbCkpIHtcbiAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBuZWVkUmVtb3ZlID0gZmFsc2U7XG4gIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xuICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdmFsdWUgPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFuZWVkUmVtb3ZlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke3RhZy50b0xvd2VyQ2FzZSgpfT46IHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbmVlZFJlbW92ZSAmJiBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUgfHwga2V5KTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmNvbnN0IHZlaUtleSA9IFN5bWJvbChcIl92ZWlcIik7XG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XG4gIGNvbnN0IGludm9rZXJzID0gZWxbdmVpS2V5XSB8fCAoZWxbdmVpS2V5XSA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XG4gIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcbiAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICBjb25zdCBpbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKFxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2FuaXRpemVFdmVudFZhbHVlKG5leHRWYWx1ZSwgcmF3TmFtZSkgOiBuZXh0VmFsdWUsXG4gICAgICAgIGluc3RhbmNlXG4gICAgICApO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XG4gICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBtO1xuICAgIHdoaWxlIChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xuICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZXZlbnQgPSBuYW1lWzJdID09PSBcIjpcIiA/IG5hbWUuc2xpY2UoMykgOiBoeXBoZW5hdGUobmFtZS5zbGljZSgyKSk7XG4gIHJldHVybiBbZXZlbnQsIG9wdGlvbnNdO1xufVxubGV0IGNhY2hlZE5vdyA9IDA7XG5jb25zdCBwID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4oKCkgPT4gY2FjaGVkTm93ID0gMCksIGNhY2hlZE5vdyA9IERhdGUubm93KCkpO1xuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xuICAgIGlmICghZS5fdnRzKSB7XG4gICAgICBlLl92dHMgPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAoZS5fdnRzIDw9IGludm9rZXIuYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNSxcbiAgICAgIFtlXVxuICAgICk7XG4gIH07XG4gIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcbiAgcmV0dXJuIGludm9rZXI7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUV2ZW50VmFsdWUodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB3YXJuKFxuICAgIGBXcm9uZyB0eXBlIHBhc3NlZCBhcyBldmVudCBoYW5kbGVyIHRvICR7cHJvcE5hbWV9IC0gZGlkIHlvdSBmb3JnZXQgQCBvciA6IGluIGZyb250IG9mIHlvdXIgcHJvcD9cbkV4cGVjdGVkIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucywgcmVjZWl2ZWQgdHlwZSAke3R5cGVvZiB2YWx1ZX0uYFxuICApO1xuICByZXR1cm4gTk9PUDtcbn1cbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XG4gICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZS5tYXAoXG4gICAgICAoZm4pID0+IChlMikgPT4gIWUyLl9zdG9wcGVkICYmIGZuICYmIGZuKGUyKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IGlzTmF0aXZlT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gbG93ZXJjYXNlIGxldHRlclxua2V5LmNoYXJDb2RlQXQoMikgPiA5NiAmJiBrZXkuY2hhckNvZGVBdCgyKSA8IDEyMztcbmNvbnN0IHBhdGNoUHJvcCA9IChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgY29uc3QgaXNTVkcgPSBuYW1lc3BhY2UgPT09IFwic3ZnXCI7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleVswXSA9PT0gXCIuXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCB0cnVlKSA6IGtleVswXSA9PT0gXCJeXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCBmYWxzZSkgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcbiAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlKTtcbiAgICBpZiAoIWVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpICYmIChrZXkgPT09IFwidmFsdWVcIiB8fCBrZXkgPT09IFwiY2hlY2tlZFwiIHx8IGtleSA9PT0gXCJzZWxlY3RlZFwiKSkge1xuICAgICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcsIHBhcmVudENvbXBvbmVudCwga2V5ICE9PSBcInZhbHVlXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAvLyAjMTEwODEgZm9yY2Ugc2V0IHByb3BzIGZvciBwb3NzaWJsZSBhc3luYyBjdXN0b20gZWxlbWVudFxuICAgIGVsLl9pc1Z1ZUNFICYmICgvW0EtWl0vLnRlc3Qoa2V5KSB8fCAhaXNTdHJpbmcobmV4dFZhbHVlKSlcbiAgKSB7XG4gICAgcGF0Y2hET01Qcm9wKGVsLCBjYW1lbGl6ZSQxKGtleSksIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50LCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIGlmIChrZXkgPT09IFwidHJ1ZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImZhbHNlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl9mYWxzZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH1cbiAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XG4gIGlmIChpc1NWRykge1xuICAgIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoa2V5IGluIGVsICYmIGlzTmF0aXZlT24oa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInNwZWxsY2hlY2tcIiB8fCBrZXkgPT09IFwiZHJhZ2dhYmxlXCIgfHwga2V5ID09PSBcInRyYW5zbGF0ZVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZm9ybVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwibGlzdFwiICYmIGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ3aWR0aFwiIHx8IGtleSA9PT0gXCJoZWlnaHRcIikge1xuICAgIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWU7XG4gICAgaWYgKHRhZyA9PT0gXCJJTUdcIiB8fCB0YWcgPT09IFwiVklERU9cIiB8fCB0YWcgPT09IFwiQ0FOVkFTXCIgfHwgdGFnID09PSBcIlNPVVJDRVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc05hdGl2ZU9uKGtleSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXkgaW4gZWw7XG59XG5cbmNvbnN0IFJFTU9WQUwgPSB7fTtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zLCBfY3JlYXRlQXBwKSB7XG4gIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgaWYgKGlzUGxhaW5PYmplY3QoQ29tcCkpIGV4dGVuZChDb21wLCBleHRyYU9wdGlvbnMpO1xuICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XG4gICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIF9jcmVhdGVBcHApO1xuICAgIH1cbiAgfVxuICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XG4gIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xufVxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKG9wdGlvbnMsIGV4dHJhT3B0aW9ucykgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zLCBjcmVhdGVTU1JBcHApO1xufTtcbmNvbnN0IEJhc2VDbGFzcyA9IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xufTtcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZGVmLCBfcHJvcHMgPSB7fSwgX2NyZWF0ZUFwcCA9IGNyZWF0ZUFwcCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGVmID0gX2RlZjtcbiAgICB0aGlzLl9wcm9wcyA9IF9wcm9wcztcbiAgICB0aGlzLl9jcmVhdGVBcHAgPSBfY3JlYXRlQXBwO1xuICAgIHRoaXMuX2lzVnVlQ0UgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hcHAgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX25vbmNlID0gdGhpcy5fZGVmLm5vbmNlO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBfY3JlYXRlQXBwICE9PSBjcmVhdGVBcHApIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoX2RlZi5zaGFkb3dSb290ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXIpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5fcGFyc2VTbG90cygpO1xuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkge1xuICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgIHRoaXMuX3NldFBhcmVudCgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nUmVzb2x2ZSkge1xuICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gcGFyZW50Ll9wZW5kaW5nUmVzb2x2ZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0UGFyZW50KHBhcmVudCA9IHRoaXMuX3BhcmVudCkge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XG4gICAgICB0aGlzLl9pbnN0YW5jZS5wcm92aWRlcyA9IHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYikge1xuICAgICAgICAgIHRoaXMuX29iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwICYmIHRoaXMuX2FwcC51bm1vdW50KCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkgdGhpcy5faW5zdGFuY2UuY2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2FwcCA9IHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcbiAgICovXG4gIF9yZXNvbHZlRGVmKCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzb2x2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX29iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG11dGF0aW9ucykge1xuICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChkZWYsIGlzQXN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdHlsZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkN1c3RvbSBlbGVtZW50IHN0eWxlIGluamVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gdXNpbmcgc2hhZG93Um9vdDogZmFsc2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW91bnQoZGVmKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IGFzeW5jRGVmKCkudGhlbihcbiAgICAgICAgKGRlZikgPT4gcmVzb2x2ZSh0aGlzLl9kZWYgPSBkZWYsIHRydWUpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIF9tb3VudChkZWYpIHtcbiAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAhZGVmLm5hbWUpIHtcbiAgICAgIGRlZi5uYW1lID0gXCJWdWVFbGVtZW50XCI7XG4gICAgfVxuICAgIHRoaXMuX2FwcCA9IHRoaXMuX2NyZWF0ZUFwcChkZWYpO1xuICAgIGlmIChkZWYuY29uZmlndXJlQXBwKSB7XG4gICAgICBkZWYuY29uZmlndXJlQXBwKHRoaXMuX2FwcCk7XG4gICAgfVxuICAgIHRoaXMuX2FwcC5fY2VWTm9kZSA9IHRoaXMuX2NyZWF0ZVZOb2RlKCk7XG4gICAgdGhpcy5fYXBwLm1vdW50KHRoaXMuX3Jvb3QpO1xuICAgIGNvbnN0IGV4cG9zZWQgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5leHBvc2VkO1xuICAgIGlmICghZXhwb3NlZCkgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9zZWQpIHtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIC8vIHVud3JhcCByZWYgdG8gYmUgY29uc2lzdGVudCB3aXRoIHB1YmxpYyBpbnN0YW5jZSBiZWhhdmlvclxuICAgICAgICAgIGdldDogKCkgPT4gdW5yZWYoZXhwb3NlZFtrZXldKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKGBFeHBvc2VkIHByb3BlcnR5IFwiJHtrZXl9XCIgYWxyZWFkeSBleGlzdHMgb24gY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9yZXNvbHZlUHJvcHMoZGVmKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgIGNvbnN0IGRlY2xhcmVkUHJvcEtleXMgPSBpc0FycmF5KHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSBcIl9cIiAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGRlY2xhcmVkUHJvcEtleXMubWFwKGNhbWVsaXplJDEpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0QXR0cihrZXkpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJkYXRhLXYtXCIpKSByZXR1cm47XG4gICAgY29uc3QgaGFzID0gdGhpcy5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICBsZXQgdmFsdWUgPSBoYXMgPyB0aGlzLmdldEF0dHJpYnV0ZShrZXkpIDogUkVNT1ZBTDtcbiAgICBjb25zdCBjYW1lbEtleSA9IGNhbWVsaXplJDEoa2V5KTtcbiAgICBpZiAoaGFzICYmIHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2NhbWVsS2V5XSkge1xuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX3NldFByb3AoY2FtZWxLZXksIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldFByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BzW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcbiAgICAgIGlmICh2YWwgPT09IFJFTU9WQUwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Byb3BzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xuICAgICAgICBpZiAoa2V5ID09PSBcImtleVwiICYmIHRoaXMuX2FwcCkge1xuICAgICAgICAgIHRoaXMuX2FwcC5fY2VWTm9kZS5rZXkgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xuICAgICAgICBjb25zdCBvYiA9IHRoaXMuX29iO1xuICAgICAgICBvYiAmJiBvYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgb2IgJiYgb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGUoKSB7XG4gICAgcmVuZGVyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuX3Jvb3QpO1xuICB9XG4gIF9jcmVhdGVWTm9kZSgpIHtcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgYmFzZVByb3BzLm9uVm5vZGVNb3VudGVkID0gYmFzZVByb3BzLm9uVm5vZGVVcGRhdGVkID0gdGhpcy5fcmVuZGVyU2xvdHMuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZChiYXNlUHJvcHMsIHRoaXMuX3Byb3BzKSk7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdm5vZGUuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuY2UgPSB0aGlzO1xuICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IChuZXdTdHlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFxuICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGV4dGVuZCh7IGRldGFpbDogYXJncyB9LCBhcmdzWzBdKSA6IHsgZGV0YWlsOiBhcmdzIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goaHlwaGVuYXRlKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBfYXBwbHlTdHlsZXMoc3R5bGVzLCBvd25lcikge1xuICAgIGlmICghc3R5bGVzKSByZXR1cm47XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICBpZiAob3duZXIgPT09IHRoaXMuX2RlZiB8fCB0aGlzLl9zdHlsZUNoaWxkcmVuLmhhcyhvd25lcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5hZGQob3duZXIpO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHRoaXMuX25vbmNlO1xuICAgIGZvciAobGV0IGkgPSBzdHlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBpZiAobm9uY2UpIHMuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgcy50ZXh0Q29udGVudCA9IHN0eWxlc1tpXTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5wcmVwZW5kKHMpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgICAgaWYgKG93bmVyLl9faG1ySWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hpbGRTdHlsZXMpIHRoaXMuX2NoaWxkU3R5bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChvd25lci5fX2htcklkKTtcbiAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2hpbGRTdHlsZXMuc2V0KG93bmVyLl9faG1ySWQsIGVudHJ5ID0gW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRvd1Jvb3QgaXMgZmFsc2VcbiAgICovXG4gIF9wYXJzZVNsb3RzKCkge1xuICAgIGNvbnN0IHNsb3RzID0gdGhpcy5fc2xvdHMgPSB7fTtcbiAgICBsZXQgbjtcbiAgICB3aGlsZSAobiA9IHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBuLm5vZGVUeXBlID09PSAxICYmIG4uZ2V0QXR0cmlidXRlKFwic2xvdFwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIChzbG90c1tzbG90TmFtZV0gfHwgKHNsb3RzW3Nsb3ROYW1lXSA9IFtdKSkucHVzaChuKTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRvd1Jvb3QgaXMgZmFsc2VcbiAgICovXG4gIF9yZW5kZXJTbG90cygpIHtcbiAgICBjb25zdCBvdXRsZXRzID0gKHRoaXMuX3RlbGVwb3J0VGFyZ2V0IHx8IHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzbG90XCIpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSB0aGlzLl9pbnN0YW5jZS50eXBlLl9fc2NvcGVJZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGxldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSBvdXRsZXRzW2ldO1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBvLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fc2xvdHNbc2xvdE5hbWVdO1xuICAgICAgY29uc3QgcGFyZW50ID0gby5wYXJlbnROb2RlO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIGNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoc2NvcGVJZCAmJiBuLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjb3BlSWQgKyBcIi1zXCI7XG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG4sIDEpO1xuICAgICAgICAgICAgbi5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkID0gd2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG8uZmlyc3RDaGlsZCkgcGFyZW50Lmluc2VydEJlZm9yZShvLmZpcnN0Q2hpbGQsIG8pO1xuICAgICAgfVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG8pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaW5qZWN0Q2hpbGRTdHlsZShjb21wKSB7XG4gICAgdGhpcy5fYXBwbHlTdHlsZXMoY29tcC5zdHlsZXMsIGNvbXApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZW1vdmVDaGlsZFN0eWxlKGNvbXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5kZWxldGUoY29tcCk7XG4gICAgICBpZiAodGhpcy5fY2hpbGRTdHlsZXMgJiYgY29tcC5fX2htcklkKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0eWxlcyA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChjb21wLl9faG1ySWQpO1xuICAgICAgICBpZiAob2xkU3R5bGVzKSB7XG4gICAgICAgICAgb2xkU3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgIG9sZFN0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1c2VIb3N0KGNhbGxlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCBlbCA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNlO1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gZWw7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FsbGVkIHdpdGhvdXQgYW4gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYWxsZXIgfHwgXCJ1c2VIb3N0XCJ9IGNhbiBvbmx5IGJlIHVzZWQgaW4gY29tcG9uZW50cyBkZWZpbmVkIHZpYSBkZWZpbmVDdXN0b21FbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2hhZG93Um9vdCgpIHtcbiAgY29uc3QgZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdXNlSG9zdChcInVzZVNoYWRvd1Jvb3RcIikgOiB1c2VIb3N0KCk7XG4gIHJldHVybiBlbCAmJiBlbC5zaGFkb3dSb290O1xufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9IFwiJHN0eWxlXCIpIHtcbiAge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcbiAgICBpZiAoIW1vZCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIHJldHVybiBtb2Q7XG4gIH1cbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtb3ZlQ2JLZXkgPSBTeW1ib2woXCJfbW92ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuY29uc3QgZGVjb3JhdGUgPSAodCkgPT4ge1xuICBkZWxldGUgdC5wcm9wcy5tb2RlO1xuICByZXR1cm4gdDtcbn07XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0gLyogQF9fUFVSRV9fICovIGRlY29yYXRlKHtcbiAgbmFtZTogXCJUcmFuc2l0aW9uR3JvdXBcIixcbiAgcHJvcHM6IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9KSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICBsZXQgcHJldkNoaWxkcmVuO1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBvblVwZGF0ZWQoKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8IFwidlwifS1tb3ZlYDtcbiAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKFxuICAgICAgICBwcmV2Q2hpbGRyZW5bMF0uZWwsXG4gICAgICAgIGluc3RhbmNlLnZub2RlLmVsLFxuICAgICAgICBtb3ZlQ2xhc3NcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gYy5lbDtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiO1xuICAgICAgICBjb25zdCBjYiA9IGVsW21vdmVDYktleV0gPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICAgICAgICBlbFttb3ZlQ2JLZXldID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcbiAgICAgIHByZXZDaGlsZHJlbiA9IFtdO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5lbCAmJiBjaGlsZC5lbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgY3NzVHJhbnNpdGlvblByb3BzLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoXG4gICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkLnR5cGUgIT09IFRleHQpIHtcbiAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xuICBjb25zdCBlbCA9IGMuZWw7XG4gIGlmIChlbFttb3ZlQ2JLZXldKSB7XG4gICAgZWxbbW92ZUNiS2V5XSgpO1xuICB9XG4gIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgIGVsW2VudGVyQ2JLZXldKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcbiAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gXCIwc1wiO1xuICAgIHJldHVybiBjO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9KTtcbiAgfVxuICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xuICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICByZXR1cm4gaGFzVHJhbnNmb3JtO1xufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbXCJvblVwZGF0ZTptb2RlbFZhbHVlXCJdIHx8IGZhbHNlO1xuICByZXR1cm4gaXNBcnJheShmbikgPyAodmFsdWUpID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSk7XG4gIH1cbn1cbmNvbnN0IGFzc2lnbktleSA9IFN5bWJvbChcIl9hc3NpZ25cIik7XG5jb25zdCB2TW9kZWxUZXh0ID0ge1xuICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSA9PT0gXCJudW1iZXJcIjtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpIHJldHVybjtcbiAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdFRvTnVtYmVyKSB7XG4gICAgICAgIGRvbVZhbHVlID0gbG9vc2VUb051bWJlcihkb21WYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbFthc3NpZ25LZXldKGRvbVZhbHVlKTtcbiAgICB9KTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWxhenkpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgIH1cbiAgfSxcbiAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAoZWwuY29tcG9zaW5nKSByZXR1cm47XG4gICAgY29uc3QgZWxWYWx1ZSA9IChudW1iZXIgfHwgZWwudHlwZSA9PT0gXCJudW1iZXJcIikgJiYgIS9eMFxcZC8udGVzdChlbC52YWx1ZSkgPyBsb29zZVRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAoZWxWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09IFwicmFuZ2VcIikge1xuICAgICAgaWYgKGxhenkgJiYgdmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG59O1xuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XG4gIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XG4gICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XG4gICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsW2Fzc2lnbktleV07XG4gICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XG4gICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxuICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gIGxldCBjaGVja2VkO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSByZXR1cm47XG4gICAgY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcbiAgfVxuICBpZiAoZWwuY2hlY2tlZCAhPT0gY2hlY2tlZCkge1xuICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGVsW2Fzc2lnbktleV0oZ2V0VmFsdWUoZWwpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKS5tYXAoXG4gICAgICAgIChvKSA9PiBudW1iZXIgPyBsb29zZVRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pXG4gICAgICApO1xuICAgICAgZWxbYXNzaWduS2V5XShcbiAgICAgICAgZWwubXVsdGlwbGUgPyBpc1NldE1vZGVsID8gbmV3IFNldChzZWxlY3RlZFZhbCkgOiBzZWxlY3RlZFZhbCA6IHNlbGVjdGVkVmFsWzBdXG4gICAgICApO1xuICAgICAgZWwuX2Fzc2lnbmluZyA9IHRydWU7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGVsLl9hc3NpZ25pbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAvLyA8b3B0aW9uPnMuXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBpZiAoIWVsLl9hc3NpZ25pbmcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgY29uc3QgaXNBcnJheVZhbHVlID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5VmFsdWUgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSB0eXBlb2Ygb3B0aW9uVmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25UeXBlID09PSBcInN0cmluZ1wiIHx8IG9wdGlvblR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5zb21lKCh2KSA9PiBTdHJpbmcodikgPT09IFN0cmluZyhvcHRpb25WYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHJldHVybiBcIl92YWx1ZVwiIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gIGNvbnN0IGtleSA9IGNoZWNrZWQgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xuICB9LFxuICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgIGVsLnRhZ05hbWUsXG4gICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICApO1xuICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gIHN0b3A6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICBzZWxmOiAoZSkgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgY3RybDogKGUpID0+ICFlLmN0cmxLZXksXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXG4gIGFsdDogKGUpID0+ICFlLmFsdEtleSxcbiAgbWV0YTogKGUpID0+ICFlLm1ldGFLZXksXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gIG1pZGRsZTogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgcmlnaHQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhNb2RzIHx8IChmbi5fd2l0aE1vZHMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xuICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKSByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gIH0pO1xufTtcbmNvbnN0IGtleU5hbWVzID0ge1xuICBlc2M6IFwiZXNjYXBlXCIsXG4gIHNwYWNlOiBcIiBcIixcbiAgdXA6IFwiYXJyb3ctdXBcIixcbiAgbGVmdDogXCJhcnJvdy1sZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gIGRvd246IFwiYXJyb3ctZG93blwiLFxuICBkZWxldGU6IFwiYmFja3NwYWNlXCJcbn07XG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhLZXlzIHx8IChmbi5fd2l0aEtleXMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIShcImtleVwiIGluIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgIGlmIChtb2RpZmllcnMuc29tZShcbiAgICAgIChrKSA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXlcbiAgICApKSB7XG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xubGV0IHJlbmRlcmVyO1xubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xuICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcbiAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uID8gcmVuZGVyZXIgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlcmVyO1xufVxuY29uc3QgcmVuZGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XG59O1xuY29uc3QgaHlkcmF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcbn07XG5jb25zdCBjcmVhdGVBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSB7XG4gIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwic3ZnXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgY29udGFpbmVyIGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudCkge1xuICAgIHJldHVybiBcIm1hdGhtbFwiO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNOYXRpdmVUYWdcIiwge1xuICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpIHx8IGlzTWF0aE1MVGFnKHRhZyksXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc0N1c3RvbUVsZW1lbnRcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cbi0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXG4tIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1zZmNgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lci5tb2RlID09PSBcImNsb3NlZFwiKSB7XG4gICAgd2FybihcbiAgICAgIGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICB9XG59IDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB1c2VIb3N0LCB1c2VTaGFkb3dSb290LCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcbiogdnVlIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4gfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuXG5mdW5jdGlvbiBpbml0RGV2KCkge1xuICB7XG4gICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xuICB9XG59XG5cbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGluaXREZXYoKTtcbn1cbmNvbnN0IGNvbXBpbGUgPSAoKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihcbiAgICAgIGBSdW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNvbXBpbGUgfTtcbiIsImZ1bmN0aW9uIG5vb3AoKSB7IH1cblxuZXhwb3J0IHsgbm9vcCB9O1xuIiwiZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgeyBpc1ByaW1pdGl2ZSB9O1xuIiwiZnVuY3Rpb24gaXNUeXBlZEFycmF5KHgpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmICEoeCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cblxuZXhwb3J0IHsgaXNUeXBlZEFycmF5IH07XG4iLCJmdW5jdGlvbiBnZXRTeW1ib2xzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkuZmlsdGVyKHN5bWJvbCA9PiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpKTtcbn1cblxuZXhwb3J0IHsgZ2V0U3ltYm9scyB9O1xuIiwiZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAnW29iamVjdCBVbmRlZmluZWRdJyA6ICdbb2JqZWN0IE51bGxdJztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCB7IGdldFRhZyB9O1xuIiwiY29uc3QgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5jb25zdCBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcbmNvbnN0IG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuY29uc3QgYm9vbGVhblRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcbmNvbnN0IGFyZ3VtZW50c1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuY29uc3Qgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5jb25zdCBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xuY29uc3QgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5jb25zdCBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcbmNvbnN0IGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcbmNvbnN0IGZ1bmN0aW9uVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbmNvbnN0IGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbmNvbnN0IG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuY29uc3QgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuY29uc3QgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuY29uc3QgdWludDhBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbmNvbnN0IHVpbnQ4Q2xhbXBlZEFycmF5VGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJztcbmNvbnN0IHVpbnQxNkFycmF5VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJztcbmNvbnN0IHVpbnQzMkFycmF5VGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcbmNvbnN0IGJpZ1VpbnQ2NEFycmF5VGFnID0gJ1tvYmplY3QgQmlnVWludDY0QXJyYXldJztcbmNvbnN0IGludDhBcnJheVRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nO1xuY29uc3QgaW50MTZBcnJheVRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJztcbmNvbnN0IGludDMyQXJyYXlUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XSc7XG5jb25zdCBiaWdJbnQ2NEFycmF5VGFnID0gJ1tvYmplY3QgQmlnSW50NjRBcnJheV0nO1xuY29uc3QgZmxvYXQzMkFycmF5VGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc7XG5jb25zdCBmbG9hdDY0QXJyYXlUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJztcblxuZXhwb3J0IHsgYXJndW1lbnRzVGFnLCBhcnJheUJ1ZmZlclRhZywgYXJyYXlUYWcsIGJpZ0ludDY0QXJyYXlUYWcsIGJpZ1VpbnQ2NEFycmF5VGFnLCBib29sZWFuVGFnLCBkYXRhVmlld1RhZywgZGF0ZVRhZywgZXJyb3JUYWcsIGZsb2F0MzJBcnJheVRhZywgZmxvYXQ2NEFycmF5VGFnLCBmdW5jdGlvblRhZywgaW50MTZBcnJheVRhZywgaW50MzJBcnJheVRhZywgaW50OEFycmF5VGFnLCBtYXBUYWcsIG51bWJlclRhZywgb2JqZWN0VGFnLCByZWdleHBUYWcsIHNldFRhZywgc3RyaW5nVGFnLCBzeW1ib2xUYWcsIHVpbnQxNkFycmF5VGFnLCB1aW50MzJBcnJheVRhZywgdWludDhBcnJheVRhZywgdWludDhDbGFtcGVkQXJyYXlUYWcgfTtcbiIsImltcG9ydCB7IGdldFN5bWJvbHMgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL2dldFN5bWJvbHMubWpzJztcbmltcG9ydCB7IGdldFRhZyB9IGZyb20gJy4uL2NvbXBhdC9faW50ZXJuYWwvZ2V0VGFnLm1qcyc7XG5pbXBvcnQgeyB1aW50MzJBcnJheVRhZywgdWludDE2QXJyYXlUYWcsIHVpbnQ4Q2xhbXBlZEFycmF5VGFnLCB1aW50OEFycmF5VGFnLCBzeW1ib2xUYWcsIHN0cmluZ1RhZywgc2V0VGFnLCByZWdleHBUYWcsIG9iamVjdFRhZywgbnVtYmVyVGFnLCBtYXBUYWcsIGludDMyQXJyYXlUYWcsIGludDE2QXJyYXlUYWcsIGludDhBcnJheVRhZywgZmxvYXQ2NEFycmF5VGFnLCBmbG9hdDMyQXJyYXlUYWcsIGRhdGVUYWcsIGJvb2xlYW5UYWcsIGRhdGFWaWV3VGFnLCBhcnJheUJ1ZmZlclRhZywgYXJyYXlUYWcsIGFyZ3VtZW50c1RhZyB9IGZyb20gJy4uL2NvbXBhdC9faW50ZXJuYWwvdGFncy5tanMnO1xuaW1wb3J0IHsgaXNQcmltaXRpdmUgfSBmcm9tICcuLi9wcmVkaWNhdGUvaXNQcmltaXRpdmUubWpzJztcbmltcG9ydCB7IGlzVHlwZWRBcnJheSB9IGZyb20gJy4uL3ByZWRpY2F0ZS9pc1R5cGVkQXJyYXkubWpzJztcblxuZnVuY3Rpb24gY2xvbmVEZWVwV2l0aChvYmosIGNsb25lVmFsdWUpIHtcbiAgICByZXR1cm4gY2xvbmVEZWVwV2l0aEltcGwob2JqLCB1bmRlZmluZWQsIG9iaiwgbmV3IE1hcCgpLCBjbG9uZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlVG9DbG9uZSwga2V5VG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2sgPSBuZXcgTWFwKCksIGNsb25lVmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZhbHVlPy4odmFsdWVUb0Nsb25lLCBrZXlUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjayk7XG4gICAgaWYgKGNsb25lZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvQ2xvbmU7XG4gICAgfVxuICAgIGlmIChzdGFjay5oYXModmFsdWVUb0Nsb25lKSkge1xuICAgICAgICByZXR1cm4gc3RhY2suZ2V0KHZhbHVlVG9DbG9uZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHZhbHVlVG9DbG9uZS5sZW5ndGgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlVG9DbG9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmVEZWVwV2l0aEltcGwodmFsdWVUb0Nsb25lW2ldLCBpLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odmFsdWVUb0Nsb25lLCAnaW5kZXgnKSkge1xuICAgICAgICAgICAgcmVzdWx0LmluZGV4ID0gdmFsdWVUb0Nsb25lLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHZhbHVlVG9DbG9uZSwgJ2lucHV0JykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlVG9DbG9uZS5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWVUb0Nsb25lLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlZ0V4cCh2YWx1ZVRvQ2xvbmUuc291cmNlLCB2YWx1ZVRvQ2xvbmUuZmxhZ3MpO1xuICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWVUb0Nsb25lLmxhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHZhbHVlVG9DbG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlLCBrZXksIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVUb0Nsb25lKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlLCB1bmRlZmluZWQsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvQ2xvbmUuc3ViYXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlVG9DbG9uZSkuY29uc3RydWN0b3IpKHZhbHVlVG9DbG9uZS5sZW5ndGgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlVG9DbG9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmVEZWVwV2l0aEltcGwodmFsdWVUb0Nsb25lW2ldLCBpLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVUb0Nsb25lLnNsaWNlKDApO1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGFWaWV3KHZhbHVlVG9DbG9uZS5idWZmZXIuc2xpY2UoMCksIHZhbHVlVG9DbG9uZS5ieXRlT2Zmc2V0LCB2YWx1ZVRvQ2xvbmUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsZShbdmFsdWVUb0Nsb25lXSwgdmFsdWVUb0Nsb25lLm5hbWUsIHtcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlVG9DbG9uZS50eXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEJsb2IoW3ZhbHVlVG9DbG9uZV0sIHsgdHlwZTogdmFsdWVUb0Nsb25lLnR5cGUgfSk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgdmFsdWVUb0Nsb25lLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gdmFsdWVUb0Nsb25lLm1lc3NhZ2U7XG4gICAgICAgIHJlc3VsdC5uYW1lID0gdmFsdWVUb0Nsb25lLm5hbWU7XG4gICAgICAgIHJlc3VsdC5zdGFjayA9IHZhbHVlVG9DbG9uZS5zdGFjaztcbiAgICAgICAgcmVzdWx0LmNhdXNlID0gdmFsdWVUb0Nsb25lLmNhdXNlO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlVG9DbG9uZSA9PT0gJ29iamVjdCcgJiYgaXNDbG9uZWFibGVPYmplY3QodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZVRvQ2xvbmUpKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlVG9DbG9uZTtcbn1cbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlLCBvYmplY3RUb0Nsb25lID0gdGFyZ2V0LCBzdGFjaywgY2xvbmVWYWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmtleXMoc291cmNlKSwgLi4uZ2V0U3ltYm9scyhzb3VyY2UpXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciA9PSBudWxsIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2xvbmVEZWVwV2l0aEltcGwoc291cmNlW2tleV0sIGtleSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDbG9uZWFibGVPYmplY3Qob2JqZWN0KSB7XG4gICAgc3dpdGNoIChnZXRUYWcob2JqZWN0KSkge1xuICAgICAgICBjYXNlIGFyZ3VtZW50c1RhZzpcbiAgICAgICAgY2FzZSBhcnJheVRhZzpcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgY2FzZSBib29sZWFuVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgZmxvYXQzMkFycmF5VGFnOlxuICAgICAgICBjYXNlIGZsb2F0NjRBcnJheVRhZzpcbiAgICAgICAgY2FzZSBpbnQ4QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgaW50MTZBcnJheVRhZzpcbiAgICAgICAgY2FzZSBpbnQzMkFycmF5VGFnOlxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugb2JqZWN0VGFnOlxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgY2FzZSB1aW50OEFycmF5VGFnOlxuICAgICAgICBjYXNlIHVpbnQ4Q2xhbXBlZEFycmF5VGFnOlxuICAgICAgICBjYXNlIHVpbnQxNkFycmF5VGFnOlxuICAgICAgICBjYXNlIHVpbnQzMkFycmF5VGFnOiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGNsb25lRGVlcFdpdGgsIGNsb25lRGVlcFdpdGhJbXBsLCBjb3B5UHJvcGVydGllcyB9O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwV2l0aEltcGwgfSBmcm9tICcuL2Nsb25lRGVlcFdpdGgubWpzJztcblxuZnVuY3Rpb24gY2xvbmVEZWVwKG9iaikge1xuICAgIHJldHVybiBjbG9uZURlZXBXaXRoSW1wbChvYmosIHVuZGVmaW5lZCwgb2JqLCBuZXcgTWFwKCksIHVuZGVmaW5lZCk7XG59XG5cbmV4cG9ydCB7IGNsb25lRGVlcCB9O1xuIiwiZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICBjb25zdCBoYXNPYmplY3RQcm90b3R5cGUgPSBwcm90byA9PT0gbnVsbCB8fFxuICAgICAgICBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pID09PSBudWxsO1xuICAgIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnQgeyBpc1BsYWluT2JqZWN0IH07XG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vcHJlZGljYXRlL2lzUGxhaW5PYmplY3QubWpzJztcblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBjb25zdCBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKFtdLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2VWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2Uoe30sIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHNvdXJjZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IHsgbWVyZ2UgfTtcbiIsImZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKG90aGVyKSk7XG59XG5cbmV4cG9ydCB7IGVxIH07XG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9pc1BsYWluT2JqZWN0Lm1qcyc7XG5pbXBvcnQgeyBnZXRTeW1ib2xzIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRTeW1ib2xzLm1qcyc7XG5pbXBvcnQgeyBnZXRUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL2dldFRhZy5tanMnO1xuaW1wb3J0IHsgZnVuY3Rpb25UYWcsIHJlZ2V4cFRhZywgc3ltYm9sVGFnLCBkYXRlVGFnLCBib29sZWFuVGFnLCBudW1iZXJUYWcsIHN0cmluZ1RhZywgb2JqZWN0VGFnLCBlcnJvclRhZywgZGF0YVZpZXdUYWcsIGFycmF5QnVmZmVyVGFnLCBmbG9hdDY0QXJyYXlUYWcsIGZsb2F0MzJBcnJheVRhZywgYmlnSW50NjRBcnJheVRhZywgaW50MzJBcnJheVRhZywgaW50MTZBcnJheVRhZywgaW50OEFycmF5VGFnLCBiaWdVaW50NjRBcnJheVRhZywgdWludDMyQXJyYXlUYWcsIHVpbnQxNkFycmF5VGFnLCB1aW50OENsYW1wZWRBcnJheVRhZywgdWludDhBcnJheVRhZywgYXJyYXlUYWcsIHNldFRhZywgbWFwVGFnLCBhcmd1bWVudHNUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL3RhZ3MubWpzJztcbmltcG9ydCB7IGVxIH0gZnJvbSAnLi4vY29tcGF0L3V0aWwvZXEubWpzJztcblxuZnVuY3Rpb24gaXNFcXVhbFdpdGgoYSwgYiwgYXJlVmFsdWVzRXF1YWwpIHtcbiAgICByZXR1cm4gaXNFcXVhbFdpdGhJbXBsKGEsIGIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJlVmFsdWVzRXF1YWwpO1xufVxuZnVuY3Rpb24gaXNFcXVhbFdpdGhJbXBsKGEsIGIsIHByb3BlcnR5LCBhUGFyZW50LCBiUGFyZW50LCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhcmVWYWx1ZXNFcXVhbChhLCBiLCBwcm9wZXJ0eSwgYVBhcmVudCwgYlBhcmVudCwgc3RhY2spO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09IHR5cGVvZiBiKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiIHx8IE9iamVjdC5pcyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG59XG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSB7XG4gICAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGFUYWcgPSBnZXRUYWcoYSk7XG4gICAgbGV0IGJUYWcgPSBnZXRUYWcoYik7XG4gICAgaWYgKGFUYWcgPT09IGFyZ3VtZW50c1RhZykge1xuICAgICAgICBhVGFnID0gb2JqZWN0VGFnO1xuICAgIH1cbiAgICBpZiAoYlRhZyA9PT0gYXJndW1lbnRzVGFnKSB7XG4gICAgICAgIGJUYWcgPSBvYmplY3RUYWc7XG4gICAgfVxuICAgIGlmIChhVGFnICE9PSBiVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChhVGFnKSB7XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICAgICAgICBjYXNlIG51bWJlclRhZzoge1xuICAgICAgICAgICAgY29uc3QgeCA9IGEudmFsdWVPZigpO1xuICAgICAgICAgICAgY29uc3QgeSA9IGIudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIGVxKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgYm9vbGVhblRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuaXMoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKTtcbiAgICAgICAgY2FzZSByZWdleHBUYWc6IHtcbiAgICAgICAgICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGZ1bmN0aW9uVGFnOiB7XG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFjayA9IHN0YWNrID8/IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhU3RhY2sgPSBzdGFjay5nZXQoYSk7XG4gICAgY29uc3QgYlN0YWNrID0gc3RhY2suZ2V0KGIpO1xuICAgIGlmIChhU3RhY2sgIT0gbnVsbCAmJiBiU3RhY2sgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYVN0YWNrID09PSBiO1xuICAgIH1cbiAgICBzdGFjay5zZXQoYSwgYik7XG4gICAgc3RhY2suc2V0KGIsIGEpO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAoYVRhZykge1xuICAgICAgICAgICAgY2FzZSBtYXBUYWc6IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWlzRXF1YWxXaXRoSW1wbCh2YWx1ZSwgYi5nZXQoa2V5KSwga2V5LCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHNldFRhZzoge1xuICAgICAgICAgICAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFWYWx1ZXMgPSBBcnJheS5mcm9tKGEudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJWYWx1ZXMgPSBBcnJheS5mcm9tKGIudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVmFsdWUgPSBhVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGJWYWx1ZXMuZmluZEluZGV4KGJWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNFcXVhbFdpdGhJbXBsKGFWYWx1ZSwgYlZhbHVlLCB1bmRlZmluZWQsIGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYlZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQ4QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQ4Q2xhbXBlZEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50MTZBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGJpZ1VpbnQ2NEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBpbnQ4QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGludDE2QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGludDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGJpZ0ludDY0QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGZsb2F0MzJBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgZmxvYXQ2NEFycmF5VGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlcihhKSAhPT0gQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxXaXRoSW1wbChhW2ldLCBiW2ldLCBpLCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChuZXcgVWludDhBcnJheShhKSwgbmV3IFVpbnQ4QXJyYXkoYiksIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoIHx8IGEuYnl0ZU9mZnNldCAhPT0gYi5ieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChuZXcgVWludDhBcnJheShhKSwgbmV3IFVpbnQ4QXJyYXkoYiksIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGVycm9yVGFnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBvYmplY3RUYWc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmVFcXVhbEluc3RhbmNlcyA9IGFyZU9iamVjdHNFcXVhbChhLmNvbnN0cnVjdG9yLCBiLmNvbnN0cnVjdG9yLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpO1xuICAgICAgICAgICAgICAgIGlmICghYXJlRXF1YWxJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhS2V5cyA9IFsuLi5PYmplY3Qua2V5cyhhKSwgLi4uZ2V0U3ltYm9scyhhKV07XG4gICAgICAgICAgICAgICAgY29uc3QgYktleXMgPSBbLi4uT2JqZWN0LmtleXMoYiksIC4uLmdldFN5bWJvbHMoYildO1xuICAgICAgICAgICAgICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcEtleSA9IGFLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhUHJvcCA9IGFbcHJvcEtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihiLCBwcm9wS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJQcm9wID0gYltwcm9wS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsV2l0aEltcGwoYVByb3AsIGJQcm9wLCBwcm9wS2V5LCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzdGFjay5kZWxldGUoYSk7XG4gICAgICAgIHN0YWNrLmRlbGV0ZShiKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGlzRXF1YWxXaXRoIH07XG4iLCJpbXBvcnQgeyBpc0VxdWFsV2l0aCB9IGZyb20gJy4vaXNFcXVhbFdpdGgubWpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9mdW5jdGlvbi9ub29wLm1qcyc7XG5cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBpc0VxdWFsV2l0aChhLCBiLCBub29wKTtcbn1cblxuZXhwb3J0IHsgaXNFcXVhbCB9O1xuIiwiaW1wb3J0IHsgQW55U2NoZW1hIH0gZnJvbSBcImFqdlwiO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gXCJAc2luY2xhaXIvdHlwZWJveFwiO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0c0Zyb21TY2hlbWEoc2NoZW1hOiBBbnlTY2hlbWEpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyB8fCB7fTtcbiAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSA/IHNjaGVtYS5yZXF1aXJlZCA6IFtdO1xuXG4gIGNvbnNvbGUubG9nKFwiZ2V0RGVmYXVsdHNGcm9tU2NoZW1hXCIpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIHJlc3VsdFtrZXldID0ge1xuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkUHJvcHMuaW5jbHVkZXMoa2V5KSxcbiAgICAgIHZhbHVlOiB2YWx1ZS5kZWZhdWx0ID8/IFwiXCIsXG4gICAgfTtcbiAgICBpZiAoXCJub2RlVHlwZVwiIGluIHZhbHVlKSB7XG4gICAgICByZXN1bHRba2V5XS50eXBlID0gdmFsdWUubm9kZVR5cGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hKFxuICBzY2hlbWE6IFRTY2hlbWFcbik6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBwYXNzd29yZD86IGJvb2xlYW4gfT4ge1xuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBwYXNzd29yZD86IGJvb2xlYW4gfT4gPSB7fTtcbiAgY29uc3QgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICBjb25zdCByZXF1aXJlZFByb3BzID0gQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpID8gc2NoZW1hLnJlcXVpcmVkIDogW107XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgfVxuICAgIGNvbnN0IGlzUGFzc3dvcmQgPSB2YWx1ZS5mb3JtYXQgPT09IFwicGFzc3dvcmRcIjtcblxuICAgIHJlc3VsdFtrZXldID0ge1xuICAgICAgdHlwZTogaXNQYXNzd29yZCA/IFwicGFzc3dvcmRcIiA6IFwidGV4dFwiLFxuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkUHJvcHMuaW5jbHVkZXMoa2V5KSxcbiAgICAgIHZhbHVlOiB2YWx1ZS5kZWZhdWx0ID8/IFwiXCIsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZFBhdHRlcm5XaXRoUFdEKHBhdHRlcm46IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IG9yaWdpbmFsID0gbmV3IFJlZ0V4cChgXiR7cGF0dGVybn0kYCk7XG4gIGNvbnN0IHB3ZCA9IC9eX19QV0RfXyQvO1xuICBjb25zdCBjb21iaW5lZCA9IG5ldyBSZWdFeHAoYCg/OiR7b3JpZ2luYWwuc291cmNlfXwke3B3ZC5zb3VyY2V9KWApO1xuICByZXR1cm4gY29tYmluZWQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXRjaFBhc3N3b3JkUGF0dGVybnMoc2NoZW1hOiBUU2NoZW1hKTogdm9pZCB7XG4gIGlmICghKFwicHJvcGVydGllc1wiIGluIHNjaGVtYSkpIHJldHVybjtcblxuICBjb25zdCBwcm9wcyA9IChzY2hlbWEgYXMgYW55KS5wcm9wZXJ0aWVzO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgIGNvbnN0IHByb3AgPSB2YWx1ZSBhcyBhbnk7XG5cbiAgICBpZiAocHJvcC5mb3JtYXQgPT09IFwicGFzc3dvcmRcIiAmJiB0eXBlb2YgcHJvcC5wYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcm9wLnBhdHRlcm4gPSBleHRlbmRQYXR0ZXJuV2l0aFBXRChwcm9wLnBhdHRlcm4pO1xuICAgICAgcHJvcC5taW5MZW5ndGggPSAwOyAvLyBvcHRpb25hbDogYWxsb3cgXCJfX1BXRF9fXCJcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0RGVmYXVsdHNGcm9tU2NoZW1hLFxuICBnZXRDcmVkZW50aWFsc0Zyb21TY2hlbWEsXG4gIHBhdGNoUGFzc3dvcmRQYXR0ZXJucyxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKTtcbn1cbmV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGdldEVzbUV4cG9ydE5hbWU7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgfHwgKGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSBVc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9ICgwLCBjb2RlXzEuXykgYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSAoMCwgY29kZV8xLl8pIGBcXG5gO1xuY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IGNvZGVfMS5uaWwgfTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGU7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICB2YWx1ZShuYW1lT3JQcmVmaXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gKF9hID0gdmFsdWUua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5yZWY7XG4gICAgICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAodnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KTtcbiAgICAgICAgICAgIGlmIChfbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aDtcbiAgICAgICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmO1xuICAgICAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleCB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHZzLmdldChrZXlPclJlZik7XG4gICAgfVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUsIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZV8xLl8pIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZSA9IFZhbHVlU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3IgPSBleHBvcnRzLmFuZCA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5vcGVyYXRvcnMgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY29uc3Qgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGNvZGVfMiA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0ckNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0ckNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuZ2V0UHJvcGVydHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdleHBDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIucmVnZXhwQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5OYW1lOyB9IH0pO1xudmFyIHNjb3BlXzIgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZU5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZU5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YXJLaW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi52YXJLaW5kczsgfSB9KTtcbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAgIEdUOiBuZXcgY29kZV8xLl9Db2RlKFwiPlwiKSxcbiAgICBHVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI+PVwiKSxcbiAgICBMVDogbmV3IGNvZGVfMS5fQ29kZShcIjxcIiksXG4gICAgTFRFOiBuZXcgY29kZV8xLl9Db2RlKFwiPD1cIiksXG4gICAgRVE6IG5ldyBjb2RlXzEuX0NvZGUoXCI9PT1cIiksXG4gICAgTkVROiBuZXcgY29kZV8xLl9Db2RlKFwiIT09XCIpLFxuICAgIE5PVDogbmV3IGNvZGVfMS5fQ29kZShcIiFcIiksXG4gICAgT1I6IG5ldyBjb2RlXzEuX0NvZGUoXCJ8fFwiKSxcbiAgICBBTkQ6IG5ldyBjb2RlXzEuX0NvZGUoXCImJlwiKSxcbiAgICBBREQ6IG5ldyBjb2RlXzEuX0NvZGUoXCIrXCIpLFxufTtcbmNsYXNzIE5vZGUge1xuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKF9uYW1lcywgX2NvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCByaHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgfVxuICAgIHJlbmRlcih7IGVzNSwgX24gfSkge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YDtcbiAgICAgICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yaHMpXG4gICAgICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5zaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RzO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB7fSA6IHsgLi4udGhpcy5saHMubmFtZXMgfTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpO1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIG9wLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cyk7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX247XG4gICAgfVxufVxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubik7XG4gICAgICAgICAgICBlbHNlIGlmIChuKVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpO1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uO1xuICAgIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbn1cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRWxzZS5raW5kID0gXCJlbHNlXCI7XG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBub2Rlcykge1xuICAgICAgICBzdXBlcihub2Rlcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7IC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgICAgIGxldCBlID0gdGhpcy5lbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IG5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbHNlID0gKF9hID0gdGhpcy5lbHNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5JZi5raW5kID0gXCJpZlwiO1xuY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkZvci5raW5kID0gXCJmb3JcIjtcbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmcm9tLCB0byB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29wLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhc3luYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFzeW5jID0gYXN5bmM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRnVuYy5raW5kID0gXCJmdW5jXCI7XG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuUmV0dXJuLmtpbmQgPSBcInJldHVyblwiO1xuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOb2RlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuQ2F0Y2gua2luZCA9IFwiY2F0Y2hcIjtcbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GaW5hbGx5LmtpbmQgPSBcImZpbmFsbHlcIjtcbmNsYXNzIENvZGVHZW4ge1xuICAgIGNvbnN0cnVjdG9yKGV4dFNjb3BlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSh7IHBhcmVudDogZXh0U2NvcGUgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cyk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gICAgc2NvcGVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpO1xuICAgICAgICB2cy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRTY29wZVZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gICAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIF9kZWYodmFyS2luZCwgbmFtZU9yUHJlZml4LCByaHMsIGNvbnN0YW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KVxuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJocztcbiAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGNvbnN0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBsZXQobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gICAgdmFyKG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnQgY29kZVxuICAgIGFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSk7XG4gICAgfVxuICAgIC8vIGArPWAgY29kZVxuICAgIGFkZChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgZXhwb3J0cy5vcGVyYXRvcnMuQURELCByaHMpKTtcbiAgICB9XG4gICAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICAgIGNvZGUoYykge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgYygpO1xuICAgICAgICBlbHNlIGlmIChjICE9PSBjb2RlXzEubmlsKVxuICAgICAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgIG9iamVjdCguLi5rZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcIntcIl07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCIsXCIpO1xuICAgICAgICAgICAgY29kZS5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiOlwiKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmFkZENvZGVBcmcpKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsICgwLCBjb2RlXzEuXykgYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsICgwLCBjb2RlXzEuXykgYCR7YXJyfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGZvckJvZHkobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAgIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgICBmb3JJbihuYW1lT3JQcmVmaXgsIG9iaiwgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsICgwLCBjb2RlXzEuXykgYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6ICgwLCBjb2RlXzEuXykgYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogKDAsIGNvZGVfMS5fKSBgJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApO1xufVxuZnVuY3Rpb24gcGFyKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8geCA6ICgwLCBjb2RlXzEuXykgYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgIGlmIChwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZTtcbmZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcykge1xuICAgIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgICAgICAgOiBpc051bWJlclxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/ICgwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcCk7XG59XG5leHBvcnRzLmdldEVycm9yUGF0aCA9IGdldEVycm9yUGF0aDtcbmZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBtb2RlID0gaXQub3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBpZiAoIW1vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWA7XG4gICAgaWYgKG1vZGUgPT09IHRydWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKTtcbn1cbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gY2hlY2tTdHJpY3RNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0cikgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJ9XWApLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtzY2hQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8ICgwLCBjb2RlZ2VuXzEuXykgYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IERhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSkoaXQsIHR5cGVzWzBdKSk7XG4gICAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGVja1R5cGVzO1xufVxuZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZTtcbmNvbnN0IENPRVJDSUJMRSA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXMsIGNvZXJjZVR5cGVzKSB7XG4gICAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgICAgIDogW107XG59XG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT4gZ2VuXG4gICAgICAgICAgICAuYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICAgICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuLmVsc2UoKTtcbiAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgIGdlbi5lbmRJZigpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6ICgwLCBjb2RlZ2VuXzEubm90KShjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5hbmQpKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/ICgwLCBjb2RlZ2VuXzEuXykgYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9ICgwLCB1dGlsXzEudG9IYXNoKShkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImA7XG4gICAgICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogKDAsIGNvZGVnZW5fMS5fKSBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLmFuZCkoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYX19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBzY2hlbWEsIFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgICAgICBzY2hlbWFDb2RlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICAgICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPSAkeygwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5mdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiAoMCwgY29kZWdlbl8xLl8pIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+ICgwLCBjb2RlZ2VuXzEuYW5kKShub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgO1xufVxuZXhwb3J0cy5pc093blByb3BlcnR5ID0gaXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kO1xufVxuZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IHByb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLm9yKShjb25kLCAoMCwgY29kZWdlbl8xLm5vdCkoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGE7XG4gICAgY29uc3QgdmFsQ3h0ID0gW1xuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmNvbnN0IG5ld1JlZ0V4cCA9ICgwLCBjb2RlZ2VuXzEuXykgYG5ldyBSZWdFeHBgO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIGNvbnN0IHsgcmVnRXhwIH0gPSBvcHRzLmNvZGU7XG4gICAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAgICAgIGtleTogcngudG9TdHJpbmcoKSxcbiAgICAgICAgcmVmOiByeCxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZWdFeHAuY29kZSA9PT0gXCJuZXcgUmVnRXhwXCIgPyBuZXdSZWdFeHAgOiAoMCwgdXRpbF8yLnVzZUZ1bmMpKGdlbiwgcmVnRXhwKX0oJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKTtcbiAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgICAgaWYgKCFtZXJnZWQpXG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfWAsICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCA6IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IG5hbWVzXzEuZGVmYXVsdC5zZWxmO1xuICAgICAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke19hd2FpdH0keygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSgoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKSwgZXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGZ1bmNLZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICAoMCwgZXJyb3JzXzEuZXh0ZW5kRXJyb3JzKShjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHJlc3VsdCkgfSk7XG59XG5mdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgICByZXR1cm4gKCFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgICAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PiBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5leHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IHZhbGlkU2NoZW1hVHlwZTtcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKHsgc2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRoIH0sIGRlZiwga2V5d29yZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IHZhbGlkYXRlS2V5d29yZFVzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5d29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFN1YnNjaGVtYShpdCwgeyBrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZiB9KSB7XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHsoMCwgdXRpbF8xLmVzY2FwZUZyYWdtZW50KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICAgICAgICBlcnJTY2hlbWFQYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJyk7XG59XG5leHBvcnRzLmdldFN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCBpdCwgeyBkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lIH0pIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZ2VuIH0gPSBpdDtcbiAgICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyb3JQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEsIGJhc2VJZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCwgdXJpUmVzb2x2ZXIgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZTtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERhdGEgPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdm9pZCAwO1xuY29uc3QgYm9vbFNjaGVtYV8xID0gcmVxdWlyZShcIi4vYm9vbFNjaGVtYVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBkYXRhVHlwZV8yID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBrZXl3b3JkXzEgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuY29uc3Qgc3Vic2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zdWJzY2hlbWFcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+ICgwLCBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEpKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApO1xuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKTtcbiAgICAgICAgICAgIGdlbi5jb2RlKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/ICgwLCBjb2RlZ2VuXzEuXykgYCwgJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9PXt9YCA6IGNvZGVnZW5fMS5uaWx9fT17fWA7XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpIHtcbiAgICBnZW4uaWYobmFtZXNfMS5kZWZhdWx0LnZhbEN4dCwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cywgZ2VuIH0gPSBpdDtcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICAgICAgY2hlY2tOb0RlZmF1bHQoaXQpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAwKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXNldEV2YWx1YXRlZChpdCk7XG4gICAgICAgIHR5cGVBbmRLZXl3b3JkcyhpdCk7XG4gICAgICAgIHJldHVyblJlc3VsdHMoaXQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0KSB7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/ICgwLCBjb2RlZ2VuXzEuXykgYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYSkoaXQsIHZhbGlkKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHsgc2NoZW1hLCBzZWxmIH0pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBnZW4sIG9wdHMgfSA9IGl0O1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgIHVwZGF0ZUNvbnRleHQoaXQpO1xuICAgIGNoZWNrQXN5bmNTY2hlbWEoaXQpO1xuICAgIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KTtcbiAgICAvLyBUT0RPIHZhclxuICAgIGdlbi52YXIodmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgICgwLCB1dGlsXzEuY2hlY2tVbmtub3duUnVsZXMpKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykoaXQuc2NoZW1hKTtcbiAgICBjb25zdCBjaGVja2VkVHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiAoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQpIHtcbiAgICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXTtcbiAgICBpZiAoc2NoSWQpXG4gICAgICAgIGl0LmJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGA7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiBzY2hlbWFFbnYucm9vdCB9KTtcbiAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtWYWxpZGF0aW9uRXJyb3J9KCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9KWApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcyk7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoISgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXApKHNjaGVtYSwgZ3JvdXApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUpKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgICgwLCBkYXRhVHlwZV8yLnJlcG9ydFR5cGVFcnJvcikoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIG9wdHM6IHsgdXNlRGVmYXVsdHMgfSwgfSA9IGl0O1xuICAgIGlmICh1c2VEZWZhdWx0cylcbiAgICAgICAgKDAsIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMpKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbmFycm93U2NoZW1hVHlwZXMoaXQsIHR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHMpIHtcbiAgICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQsIHRzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbDtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgd2l0aFR5cGVzKSB7XG4gICAgY29uc3QgdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1R5cGUod2l0aFR5cGVzLCB0KSlcbiAgICAgICAgICAgIHRzLnB1c2godCk7XG4gICAgICAgIGVsc2UgaWYgKHdpdGhUeXBlcy5pbmNsdWRlcyhcImludGVnZXJcIikgJiYgdCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRzLnB1c2goXCJpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBpdC5kYXRhVHlwZXMgPSB0cztcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcyk7XG59XG5jbGFzcyBLZXl3b3JkQ3h0IHtcbiAgICBjb25zdHJ1Y3RvcihpdCwgZGVmLCBrZXl3b3JkKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UpKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoISgwLCBrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7KDAsIGNvZGVnZW5fMS5vcikodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgKDAsIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQpKHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudCk7XG4gICAgfVxuICAgIG9rKGNvbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGNvbmQpO1xuICAgIH1cbiAgICBzZXRQYXJhbXMob2JqLCBhc3NpZ24pIHtcbiAgICAgICAgaWYgKGFzc2lnbilcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb2JqO1xuICAgIH1cbiAgICBibG9jayRkYXRhKHZhbGlkLCBjb2RlQmxvY2ssICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZCk7XG4gICAgICAgICAgICBjb2RlQmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrJGRhdGEodmFsaWQgPSBjb2RlZ2VuXzEubmlsLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYgfSA9IHRoaXM7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSh3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZXMpKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY2hlbWEoYXBwbCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0gKDAsIHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSkodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgICgwLCBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFEYXRhKShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZSkoc3Vic2NoZW1hLCBhcHBsKTtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSB7IC4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q29udGV4dDtcbiAgICB9XG4gICAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB0b05hbWUpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB2YWxpZCkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIGNvZGVnZW5fMS5OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuS2V5d29yZEN4dCA9IEtleXdvcmRDeHQ7XG5mdW5jdGlvbiBrZXl3b3JkQ29kZShpdCwga2V5d29yZCwgZGVmLCBydWxlVHlwZSkge1xuICAgIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpO1xuICAgIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICAoMCwga2V5d29yZF8xLm1hY3JvS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxufVxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgeyBkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnIgfSkge1xuICAgIGxldCBqc29uUG9pbnRlcjtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgICAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICAgIGRhdGEgPSBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBjb25zdCB1cCA9ICttYXRjaGVzWzFdO1xuICAgICAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwID4gZGF0YUxldmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpO1xuICAgICAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgaWYgKCFqc29uUG9pbnRlcilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBsZXQgZXhwciA9IGRhdGE7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBkYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoKDAsIHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKShzZWdtZW50KSl9YDtcbiAgICAgICAgICAgIGV4cHIgPSAoMCwgY29kZWdlbl8xLl8pIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc29sdmVyLCBiYXNlSWQsIHJlZiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YCk7XG4gICAgICAgIHRoaXMubWlzc2luZ1JlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICAgICAgdGhpcy5taXNzaW5nU2NoZW1hID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkocmVzb2x2ZXIsIHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZSkoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKCgwLCByZXNvbHZlXzEuaW5saW5lUmVmKShzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSAoMCwgcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKTtcbiAgICBsZXQgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVsoMCwgdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQpKHBhcnQpXTtcbiAgICAgICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gcGFydFNjaGVtYTtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEhFWCA9IHtcbiAgMDogMCxcbiAgMTogMSxcbiAgMjogMixcbiAgMzogMyxcbiAgNDogNCxcbiAgNTogNSxcbiAgNjogNixcbiAgNzogNyxcbiAgODogOCxcbiAgOTogOSxcbiAgYTogMTAsXG4gIEE6IDEwLFxuICBiOiAxMSxcbiAgQjogMTEsXG4gIGM6IDEyLFxuICBDOiAxMixcbiAgZDogMTMsXG4gIEQ6IDEzLFxuICBlOiAxNCxcbiAgRTogMTQsXG4gIGY6IDE1LFxuICBGOiAxNVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSEVYXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIRVggfSA9IHJlcXVpcmUoJy4vc2NvcGVkQ2hhcnMnKVxuXG5jb25zdCBJUFY0X1JFRyA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdVxuXG5mdW5jdGlvbiBub3JtYWxpemVJUHY0IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJy4nKSA8IDMpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY0OiBmYWxzZSB9IH1cbiAgY29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2goSVBWNF9SRUcpIHx8IFtdXG4gIGNvbnN0IFthZGRyZXNzXSA9IG1hdGNoZXNcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICByZXR1cm4geyBob3N0OiBzdHJpcExlYWRpbmdaZXJvcyhhZGRyZXNzLCAnLicpLCBpc0lQVjQ6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBaZXJvPWZhbHNlXVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQsIGtlZXBaZXJvID0gZmFsc2UpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBzdHJpcCA9IHRydWVcbiAgZm9yIChjb25zdCBjIG9mIGlucHV0KSB7XG4gICAgaWYgKEhFWFtjXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKGMgIT09ICcwJyAmJiBzdHJpcCA9PT0gdHJ1ZSkgc3RyaXAgPSBmYWxzZVxuICAgIGlmICghc3RyaXApIGFjYyArPSBjXG4gIH1cbiAgaWYgKGtlZXBaZXJvICYmIGFjYy5sZW5ndGggPT09IDApIGFjYyA9ICcwJ1xuICByZXR1cm4gYWNjXG59XG5cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBpc1pvbmUgPSBmYWxzZVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWUgKCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNab25lID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoKSkgeyBicmVhayB9XG4gICAgICB0b2tlbkNvdW50KytcbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBpZiAodG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpIC0gMSA+PSAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBpc1pvbmUgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgZXNjYXBlZEhvc3QsIGlzSVBWNjogdHJ1ZSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBMZWFkaW5nWmVyb3MgKHN0ciwgdG9rZW4pIHtcbiAgbGV0IG91dCA9ICcnXG4gIGxldCBza2lwID0gdHJ1ZVxuICBjb25zdCBsID0gc3RyLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGMgPSBzdHJbaV1cbiAgICBpZiAoYyA9PT0gJzAnICYmIHNraXApIHtcbiAgICAgIGlmICgoaSArIDEgPD0gbCAmJiBzdHJbaSArIDFdID09PSB0b2tlbikgfHwgaSArIDEgPT09IGwpIHtcbiAgICAgICAgb3V0ICs9IGNcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjID09PSB0b2tlbikge1xuICAgICAgICBza2lwID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgICBvdXQgKz0gY1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuY29uc3QgUkRTMSA9IC9eXFwuXFwuP1xcLy91XG5jb25zdCBSRFMyID0gL15cXC9cXC4oPzpcXC98JCkvdVxuY29uc3QgUkRTMyA9IC9eXFwvXFwuXFwuKD86XFwvfCQpL3VcbmNvbnN0IFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS91XG5cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChpbnB1dCkge1xuICBjb25zdCBvdXRwdXQgPSBbXVxuXG4gIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCAnJylcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgJy8nKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCAnLycpXG4gICAgICBvdXRwdXQucG9wKClcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnLicgfHwgaW5wdXQgPT09ICcuLicpIHtcbiAgICAgIGlucHV0ID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW0gPSBpbnB1dC5tYXRjaChSRFM1KVxuICAgICAgaWYgKGltKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpbVswXVxuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKVxuICAgICAgICBvdXRwdXQucHVzaChzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgKGNvbXBvbmVudHMsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudHMuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnNjaGVtZSA9IGZ1bmMoY29tcG9uZW50cy5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSBmdW5jKGNvbXBvbmVudHMudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5ob3N0ID0gZnVuYyhjb21wb25lbnRzLmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5wYXRoID0gZnVuYyhjb21wb25lbnRzLnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMucXVlcnkgPSBmdW5jKGNvbXBvbmVudHMucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBmdW5jKGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnRzKSB7XG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGhvc3QgPSB1bmVzY2FwZShjb21wb25lbnRzLmhvc3QpXG4gICAgY29uc3QgaXBWNHJlcyA9IG5vcm1hbGl6ZUlQdjQoaG9zdClcblxuICAgIGlmIChpcFY0cmVzLmlzSVBWNCkge1xuICAgICAgaG9zdCA9IGlwVjRyZXMuaG9zdFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2NihpcFY0cmVzLmhvc3QpXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50cy5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBub3JtYWxpemVJUHY0LFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBVVUlEX1JFRyA9IC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuZnVuY3Rpb24gaXNTZWN1cmUgKHdzQ29tcG9uZW50cykge1xuICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ3dzcydcbn1cblxuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnRzKSB7XG4gIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudHMpIHtcbiAgY29uc3Qgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09ICcnKSB7XG4gICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICBjb21wb25lbnRzLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIE5PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgLy8gYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gIC8vIGFuZCBub3QgdGhlIEhUVFAgc3BlYy5cblxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1BhcnNlICh3c0NvbXBvbmVudHMpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cylcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWRcbiAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnRzKSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSAnJykge1xuICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gKHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICBjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnRzLnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5XG4gICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGlmICghdXJuQ29tcG9uZW50cy5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50cy5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudHNcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJuQ29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnRzLm5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgIHVybkNvbXBvbmVudHMubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnRzLm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXVxuICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudHMubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV1cblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHNcbiAgY29uc3QgbnNzID0gdXJuQ29tcG9uZW50cy5uc3NcbiAgdXJpQ29tcG9uZW50cy5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzXG4gIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3NcbiAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhVVVJRF9SRUcudGVzdCh1dWlkQ29tcG9uZW50cy51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudHMpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzXG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuY29uc3QgaHR0cCA9IHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCBodHRwcyA9IHtcbiAgc2NoZW1lOiAnaHR0cHMnLFxuICBkb21haW5Ib3N0OiBodHRwLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCB3cyA9IHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufVxuXG5jb25zdCB3c3MgPSB7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn1cblxuY29uc3QgdXJuID0ge1xuICBzY2hlbWU6ICd1cm4nLFxuICBwYXJzZTogdXJuUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJuU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IHVybnV1aWQgPSB7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IFNDSEVNRVMgPSB7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTQ0hFTUVTXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBub3JtYWxpemVJUHY2LCBub3JtYWxpemVJUHY0LCByZW1vdmVEb3RTZWdtZW50cywgcmVjb21wb3NlQXV0aG9yaXR5LCBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyB9ID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKVxuY29uc3QgU0NIRU1FUyA9IHJlcXVpcmUoJy4vbGliL3NjaGVtZXMnKVxuXG5mdW5jdGlvbiBub3JtYWxpemUgKHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9XG4gIHJldHVybiB1cmlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZSAoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucylcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKVxuICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVkLCB7IC4uLnNjaGVtZWxlc3NPcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzIChiYXNlLCByZWxhdGl2ZSwgb3B0aW9ucywgc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgY29uc3QgdGFyZ2V0ID0ge31cbiAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcbiAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZVxuICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGhcbiAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gJy8nICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgIH1cbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydFxuICAgIH1cbiAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWVcbiAgfVxuXG4gIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG5mdW5jdGlvbiBlcXVhbCAodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaUEgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQSA9IHVuZXNjYXBlKHVyaUEpXG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlBLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlBID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiB1cmlCID09PSAnc3RyaW5nJykge1xuICAgIHVyaUIgPSB1bmVzY2FwZSh1cmlCKVxuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQiwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQiA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUIsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB1cmlBLnRvTG93ZXJDYXNlKCkgPT09IHVyaUIudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNtcHRzLCBvcHRzKSB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB7XG4gICAgaG9zdDogY21wdHMuaG9zdCxcbiAgICBzY2hlbWU6IGNtcHRzLnNjaGVtZSxcbiAgICB1c2VyaW5mbzogY21wdHMudXNlcmluZm8sXG4gICAgcG9ydDogY21wdHMucG9ydCxcbiAgICBwYXRoOiBjbXB0cy5wYXRoLFxuICAgIHF1ZXJ5OiBjbXB0cy5xdWVyeSxcbiAgICBuaWQ6IGNtcHRzLm5pZCxcbiAgICBuc3M6IGNtcHRzLm5zcyxcbiAgICB1dWlkOiBjbXB0cy51dWlkLFxuICAgIGZyYWdtZW50OiBjbXB0cy5mcmFnbWVudCxcbiAgICByZWZlcmVuY2U6IGNtcHRzLnJlZmVyZW5jZSxcbiAgICByZXNvdXJjZU5hbWU6IGNtcHRzLnJlc291cmNlTmFtZSxcbiAgICBzZWN1cmU6IGNtcHRzLnNlY3VyZSxcbiAgICBlcnJvcjogJydcbiAgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKVxuXG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghb3B0aW9ucy5za2lwRXNjYXBlKSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSBlc2NhcGUoY29tcG9uZW50cy5wYXRoKVxuXG4gICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnRzLnBhdGggPSBjb21wb25lbnRzLnBhdGguc3BsaXQoJyUzQScpLmpvaW4oJzonKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSB1bmVzY2FwZShjb21wb25lbnRzLnBhdGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lLCAnOicpXG4gIH1cblxuICBjb25zdCBhdXRob3JpdHkgPSByZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cylcbiAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4Jykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8vJylcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpXG5cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8nKVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcyA9IGNvbXBvbmVudHMucGF0aFxuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpXG4gICAgfVxuXG4gICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvL3UsICcvJTJGJykgLy8gZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChzKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCc/JywgY29tcG9uZW50cy5xdWVyeSlcbiAgfVxuXG4gIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnIycsIGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKVxufVxuXG5jb25zdCBoZXhMb29rVXAgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMjcgfSwgKF92LCBrKSA9PiAvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShrKSkpXG5cbmZ1bmN0aW9uIG5vblNpbXBsZURvbWFpbiAodmFsdWUpIHtcbiAgbGV0IGNvZGUgPSAwXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGNvZGUgPiAxMjYgfHwgaGV4TG9va1VwW2NvZGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW14jLzo/XSspOik/KD86XFwvXFwvKCg/OihbXiMvP0BdKilAKT8oXFxbW14jLz9cXF1dK1xcXXxbXiMvOj9dKikoPzo6KFxcZCopKT8pKT8oW14jP10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxbXFxuXFxyXSkqKSk/L3VcblxuZnVuY3Rpb24gcGFyc2UgKHVyaSwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHNjaGVtZTogdW5kZWZpbmVkLFxuICAgIHVzZXJpbmZvOiB1bmRlZmluZWQsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIHBhdGg6ICcnLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnQ6IHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IGdvdEVuY29kaW5nID0gdXJpLmluZGV4T2YoJyUnKSAhPT0gLTFcbiAgbGV0IGlzSVAgPSBmYWxzZVxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09ICdzdWZmaXgnKSB1cmkgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArICc6JyA6ICcnKSArICcvLycgKyB1cmlcblxuICBjb25zdCBtYXRjaGVzID0gdXJpLm1hdGNoKFVSSV9QQVJTRSlcblxuICBpZiAobWF0Y2hlcykge1xuICAgIC8vIHN0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgcGFyc2VkLnNjaGVtZSA9IG1hdGNoZXNbMV1cbiAgICBwYXJzZWQudXNlcmluZm8gPSBtYXRjaGVzWzNdXG4gICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVzWzRdXG4gICAgcGFyc2VkLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMClcbiAgICBwYXJzZWQucGF0aCA9IG1hdGNoZXNbNl0gfHwgJydcbiAgICBwYXJzZWQucXVlcnkgPSBtYXRjaGVzWzddXG4gICAgcGFyc2VkLmZyYWdtZW50ID0gbWF0Y2hlc1s4XVxuXG4gICAgLy8gZml4IHBvcnQgbnVtYmVyXG4gICAgaWYgKGlzTmFOKHBhcnNlZC5wb3J0KSkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBtYXRjaGVzWzVdXG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgY29uc3QgaXB2NHJlc3VsdCA9IG5vcm1hbGl6ZUlQdjQocGFyc2VkLmhvc3QpXG4gICAgICBpZiAoaXB2NHJlc3VsdC5pc0lQVjQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlwdjZyZXN1bHQgPSBub3JtYWxpemVJUHY2KGlwdjRyZXN1bHQuaG9zdClcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2cmVzdWx0Lmhvc3QudG9Mb3dlckNhc2UoKVxuICAgICAgICBpc0lQID0gaXB2NnJlc3VsdC5pc0lQVjZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NHJlc3VsdC5ob3N0XG4gICAgICAgIGlzSVAgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucG9ydCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkICYmICFwYXJzZWQucGF0aCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdzYW1lLWRvY3VtZW50J1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnYWJzb2x1dGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAndXJpJ1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gcGFyc2VkLnJlZmVyZW5jZSkge1xuICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgaXMgbm90IGEgJyArIG9wdGlvbnMucmVmZXJlbmNlICsgJyByZWZlcmVuY2UuJ1xuICAgIH1cblxuICAgIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAvLyBpZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICBpZiAocGFyc2VkLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSAmJiBpc0lQID09PSBmYWxzZSAmJiBub25TaW1wbGVEb21haW4ocGFyc2VkLmhvc3QpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSBVUkwuZG9tYWluVG9BU0NJSShwYXJzZWQuaG9zdC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJOiBcIiArIGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBJUkkgLT4gVVJJXG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWVIYW5kbGVyIHx8IChzY2hlbWVIYW5kbGVyICYmICFzY2hlbWVIYW5kbGVyLnNraXBOb3JtYWxpemUpKSB7XG4gICAgICBpZiAoZ290RW5jb2RpbmcgJiYgcGFyc2VkLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5zY2hlbWUgPSB1bmVzY2FwZShwYXJzZWQuc2NoZW1lKVxuICAgICAgfVxuICAgICAgaWYgKGdvdEVuY29kaW5nICYmIHBhcnNlZC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLmhvc3QgPSB1bmVzY2FwZShwYXJzZWQuaG9zdClcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IGVzY2FwZSh1bmVzY2FwZShwYXJzZWQucGF0aCkpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLmZyYWdtZW50KSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudHMsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVyaSA9IHJlcXVpcmUoXCJmYXN0LXVyaVwiKTtcbnVyaS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgdXJpXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3VyaVwiKTtcbmNvbnN0IGRlZmF1bHRSZWdFeHAgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTtcbmRlZmF1bHRSZWdFeHAuY29kZSA9IFwibmV3IFJlZ0V4cFwiO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3gsIF95LCBfeiwgXzA7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgY29uc3QgcmVnRXhwID0gKF9jID0gKF9iID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnRXhwKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVnRXhwO1xuICAgIGNvbnN0IHVyaVJlc29sdmVyID0gKF9kID0gby51cmlSZXNvbHZlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdXJpXzEuZGVmYXVsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfZiA9IChfZSA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2ggPSAoX2cgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2sgPSAoX2ogPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBzKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfbSA9IChfbCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBzKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9wID0gKF9vID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogcykgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwIH0gOiB7IG9wdGltaXplLCByZWdFeHAgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX3EgPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX3IgPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9zID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF90ID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF91ID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF92ID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF93ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF94ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3kgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3kgIT09IHZvaWQgMCA/IF95IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF96ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfeiAhPT0gdm9pZCAwID8gX3ogOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoXzAgPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF8wICE9PSB2b2lkIDAgPyBfMCA6IHRydWUsXG4gICAgICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9ICgwLCBydWxlc18xLmdldFJ1bGVzKSgpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKTtcbiAgICAgICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0cy5mb3JtYXRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3Jkcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICAgICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKTtcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHQ7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBsZXQgX2RhdGFSZWZTY2hlbWEgPSAkZGF0YVJlZlNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hID0geyAuLi4kZGF0YVJlZlNjaGVtYSB9O1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhICYmICRkYXRhKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRLZXl3b3JkKGt3ZE9yRGVmLCBkZWYgLy8gZGVwcmVjYXRlZFxuICAgICkge1xuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpO1xuICAgICAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYuc2NoZW1hVHlwZSksXG4gICAgICAgIH07XG4gICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hLCBiYXNlSWQpO1xuICAgICAgICBzY2ggPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzIH0pO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKTtcbiAgICAgICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgICAgICAgaWYgKGJhc2VJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBfY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSB7XG4gICAgICAgIGlmIChzY2gubWV0YSlcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc2NoLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlO1xuICAgIH1cbiAgICBfY29tcGlsZU1ldGFTY2hlbWEoc2NoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzO1xuICAgICAgICB9XG4gICAgfVxufVxuQWp2LlZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0O1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IHJlZl9lcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoY2hlY2tPcHRzLCBvcHRpb25zLCBtc2csIGxvZyA9IFwiZXJyb3JcIikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBrZXk7XG4gICAgICAgIGlmIChvcHQgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY2hFbnYoa2V5UmVmKSB7XG4gICAga2V5UmVmID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsICgwLCBjb2RlZ2VuXzEuXykgYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2gpIH0gOiB7IHJlZjogc2NoIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQsIHNjaCkge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgICAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwgeyByZWY6IHNjaC52YWxpZGF0ZSB9KVxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpfWApO1xuICAgICAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KTsgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KCgwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApO1xuICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgICAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxlT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKVxuICAgICAgICAgICAgICAgIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVjczJsZW5ndGg7XG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVjczJsZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHVjczJsZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIHV0aWxfMS51c2VGdW5jKShjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/ICgwLCBjb2RlZ2VuXzEuXykgYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiAoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBwcm9wZXJ0aWVzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0UHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEoY29kZWdlbl8xLm5pbCwgbG9vcEFsbFJlcXVpcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpIHtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBwcm9wIH0pO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLm5vUHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuZXF1YWwuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXTtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4oaSwgaikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdyb25nVHlwZSA9ICgwLCBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKShpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KGl0ZW0sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosICgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hIH0gPSBjeHQ7XG4gICAgICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7KDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX0gIT09ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBsZXQgZXFsO1xuICAgICAgICBjb25zdCBnZXRFcWwgPSAoKSA9PiAoZXFsICE9PSBudWxsICYmIGVxbCAhPT0gdm9pZCAwID8gZXFsIDogKGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpKSk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcygoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoY3h0LCBleHRyYUl0ZW1zLCBzY2hBcnIgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID4gJHtpfWAsICgpID0+IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSwgdmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaCkge1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGggfSA9IGl0O1xuICAgICAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+ICgwLCBpdGVtc18xLnZhbGlkYXRlVHVwbGUpKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgICgwLCBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcykoY3h0LCBwcmVmaXhJdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkID8gKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaW4sIG1heCB9KTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBsZXQgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkLCBibG9jaykge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIF92YWxpZCk7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcGVydHl9ICYmICgkeygwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkUHJvcDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlXzEuaXNPd25Qcm9wZXJ0eSkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKShkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEubm90KShkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5IH0pO1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLlN0cixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQuY29kZShuZXcgdmFsaWRhdGVfMS5LZXl3b3JkQ3h0KGl0LCBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgKDAsIHV0aWxfMS50b0hhc2gpKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID0gb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gKDAsIHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZSkoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVyblByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsICgwLCBjb2RlZ2VuXzEuXykgYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIik7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKTtcbiAgICAgICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgdmFsaWRhdGVJZigpO1xuICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2UgfSk7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gICAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQsIHJ1bGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgkZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEub3IpKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm10KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEucmVnZXhwQ29kZSkoZm10RGVmKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LnZhbGlkYXRlYF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfSgke2RhdGF9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0udGVzdCgke2RhdGF9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgZm9ybWF0ID0gW2Zvcm1hdF8xLmRlZmF1bHRdO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IERpc2NyRXJyb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lIH0pO1xuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3AgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mTWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgaWYgKChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guJHJlZikgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gc2NoLiRyZWY7XG4gICAgICAgICAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoaXQuc2VsZiwgaXQuc2NoZW1hRW52LnJvb3QsIGl0LmJhc2VJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2ggPSBzY2guc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaXNzaW5nUmVmRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMuQWp2ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2ID0gQWp2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYoZ2V0VGltZSh0cnVlKSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSh0cnVlKSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICBcImlzby10aW1lXCI6IGZtdERlZihnZXRUaW1lKCksIGNvbXBhcmVJc29UaW1lKSxcbiAgICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKCksIGNvbXBhcmVJc29EYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSQvLFxuICAgIGlwdjY6IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pLFxuICAgIHJlZ2V4LFxuICAgIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgICB1dWlkOiAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaSxcbiAgICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gICAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gICAgXCJqc29uLXBvaW50ZXJcIjogL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLyxcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gICAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAgIC8vIGJ5dGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL2lzLWJhc2U2NFxuICAgIGJ5dGUsXG4gICAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gICAgaW50MzI6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzIgfSxcbiAgICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgICBpbnQ2NDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NCB9LFxuICAgIC8vIEMtdHlwZSBmbG9hdFxuICAgIGZsb2F0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIEMtdHlwZSBkb3VibGVcbiAgICBkb3VibGU6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgLy8gdW5jaGVja2VkIHN0cmluZyBwYXlsb2FkXG4gICAgYmluYXJ5OiB0cnVlLFxufTtcbmV4cG9ydHMuZmFzdEZvcm1hdHMgPSB7XG4gICAgLi4uZXhwb3J0cy5mdWxsRm9ybWF0cyxcbiAgICBkYXRlOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLywgY29tcGFyZURhdGUpLFxuICAgIHRpbWU6IGZtdERlZigvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkdCg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlRGF0ZVRpbWUpLFxuICAgIFwiaXNvLXRpbWVcIjogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlSXNvVGltZSksXG4gICAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSwgY29tcGFyZUlzb0RhdGVUaW1lKSxcbiAgICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gICAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAgIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn07XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5mdWxsRm9ybWF0cyk7XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAgIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBtYXRjaGVzID0gREFURS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxLCBkMikge1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGQxIDwgZDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQoPzpcXC5cXGQrKT8pKHp8KFsrLV0pKFxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pPyQvaTtcbmZ1bmN0aW9uIGdldFRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGltZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFRJTUUuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhyID0gK21hdGNoZXNbMV07XG4gICAgICAgIGNvbnN0IG1pbiA9ICttYXRjaGVzWzJdO1xuICAgICAgICBjb25zdCBzZWMgPSArbWF0Y2hlc1szXTtcbiAgICAgICAgY29uc3QgdHogPSBtYXRjaGVzWzRdO1xuICAgICAgICBjb25zdCB0elNpZ24gPSBtYXRjaGVzWzVdID09PSBcIi1cIiA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgdHpIID0gKyhtYXRjaGVzWzZdIHx8IDApO1xuICAgICAgICBjb25zdCB0ek0gPSArKG1hdGNoZXNbN10gfHwgMCk7XG4gICAgICAgIGlmICh0ekggPiAyMyB8fCB0ek0gPiA1OSB8fCAoc3RyaWN0VGltZVpvbmUgJiYgIXR6KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGhyIDw9IDIzICYmIG1pbiA8PSA1OSAmJiBzZWMgPCA2MClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBsZWFwIHNlY29uZFxuICAgICAgICBjb25zdCB1dGNNaW4gPSBtaW4gLSB0ek0gKiB0elNpZ247XG4gICAgICAgIGNvbnN0IHV0Y0hyID0gaHIgLSB0ekggKiB0elNpZ24gLSAodXRjTWluIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuICh1dGNIciA9PT0gMjMgfHwgdXRjSHIgPT09IC0xKSAmJiAodXRjTWluID09PSA1OSB8fCB1dGNNaW4gPT09IC0xKSAmJiBzZWMgPCA2MTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUoczEsIHMyKSB7XG4gICAgaWYgKCEoczEgJiYgczIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHQxID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCB0MiA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMyKS52YWx1ZU9mKCk7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0MSAtIHQyO1xufVxuZnVuY3Rpb24gY29tcGFyZUlzb1RpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZ2V0RGF0ZVRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICBjb25zdCB0aW1lID0gZ2V0VGltZShzdHJpY3RUaW1lWm9uZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgICAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZDEgPSBuZXcgRGF0ZShkdDEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCBkMiA9IG5ldyBEYXRlKGR0MikudmFsdWVPZigpO1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZDEgLSBkMjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJc29EYXRlVGltZShkdDEsIGR0Mikge1xuICAgIGlmICghKGR0MSAmJiBkdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IFtkMSwgdDFdID0gZHQxLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IFtkMiwgdDJdID0gZHQyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmVEYXRlKGQxLCBkMik7XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXMgfHwgY29tcGFyZVRpbWUodDEsIHQyKTtcbn1cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuY29uc3QgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgICAvLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sICsgb3B0aW9uYWwgcHJvdG9jb2wgKyByZXF1aXJlZCBcIi5cIlxuICAgIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuY29uc3QgQllURSA9IC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kL2dtO1xuZnVuY3Rpb24gYnl0ZShzdHIpIHtcbiAgICBCWVRFLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIEJZVEUudGVzdChzdHIpO1xufVxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKTtcbmNvbnN0IE1BWF9JTlQzMiA9IDIgKiogMzEgLSAxO1xuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnQ2NCh2YWx1ZSkge1xuICAgIC8vIEpTT04gYW5kIGphdmFzY3JpcHQgbWF4IEludCBpcyAyKio1Mywgc28gYW55IGludCB0aGF0IHBhc3NlcyBpc0ludGVnZXIgaXMgdmFsaWQgZm9yIEludDY0XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovO1xuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gICAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB2b2lkIDA7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgZm9ybWF0TWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgZm9ybWF0TWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmQ3h0ID0gbmV3IGFqdl8xLktleXdvcmRDeHQoaXQsIHNlbGYuUlVMRVMuYWxsLmZvcm1hdC5kZWZpbml0aW9uLCBcImZvcm1hdFwiKTtcbiAgICAgICAgaWYgKGZDeHQuJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10c31bJHtmQ3h0LnNjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9ICE9IFwib2JqZWN0XCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdH0gaW5zdGFuY2VvZiBSZWdFeHBgLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShmb3JtYXQpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29tcGFyZUNvZGUoZm10KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUNvZGUoZm10KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgKDAsIGxpbWl0XzEuZGVmYXVsdCkoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gKDAsIGNvZGVnZW5fMS5fKSBgcmVxdWlyZShcImFqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0c1wiKS4ke2V4cG9ydE5hbWV9YCk7XG4gICAgZm9yIChjb25zdCBmIG9mIGxpc3QpXG4gICAgICAgIGFqdi5hZGRGb3JtYXQoZiwgZnNbZl0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZm9ybWF0c1BsdWdpbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdHNQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGVcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2Vycm9yc1wiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IGtleXdvcmQgPSBcImVycm9yTWVzc2FnZVwiO1xuY29uc3QgdXNlZCA9IG5ldyBhanZfMS5OYW1lKFwiZW1Vc2VkXCIpO1xuY29uc3QgS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMgPSB7XG4gICAgcmVxdWlyZWQ6IFwibWlzc2luZ1Byb3BlcnR5XCIsXG4gICAgZGVwZW5kZW5jaWVzOiBcInByb3BlcnR5XCIsXG4gICAgZGVwZW5kZW50UmVxdWlyZWQ6IFwicHJvcGVydHlcIixcbn07XG5jb25zdCBJTlRFUlBPTEFUSU9OID0gL1xcJFxce1tefV0rXFx9LztcbmNvbnN0IElOVEVSUE9MQVRJT05fUkVQTEFDRSA9IC9cXCRcXHsoW159XSspXFx9L2c7XG5jb25zdCBFTVBUWV9TVFIgPSAvXlwiXCJcXHMqXFwrXFxzKnxcXHMqXFwrXFxzKlwiXCIkL2c7XG5mdW5jdGlvbiBlcnJvck1lc3NhZ2Uob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcIm9iamVjdFwiXSxcbiAgICAgICAgcG9zdDogdHJ1ZSxcbiAgICAgICAgY29kZShjeHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VQYXRoID0gY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpO1xuICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPiAwYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2t3ZFByb3BFcnJvcnMsIGt3ZEVycm9yc10gPSBrZXl3b3JkRXJyb3JzQ29uZmlnKHNjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrd2RFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzS2V5d29yZEVycm9ycyhrd2RFcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa3dkUHJvcEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NoaWxkRXJyb3JzKGNoaWxkRXJyb3JzQ29uZmlnKHNjaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hNZXNzYWdlID0gdHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiID8gc2NoIDogc2NoLl87XG4gICAgICAgICAgICAgICAgaWYgKHNjaE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBbGxFcnJvcnMoc2NoTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVVzZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2hpbGRFcnJvcnNDb25maWcoeyBwcm9wZXJ0aWVzLCBpdGVtcyB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzW3BdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMuaXRlbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5pdGVtc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24ga2V5d29yZEVycm9yc0NvbmZpZyhlbVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wRXJyb3JzO1xuICAgICAgICAgICAgICAgIGxldCBlcnJvcnM7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGVtU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBcInByb3BlcnRpZXNcIiB8fCBrID09PSBcIml0ZW1zXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga3dkU2NoID0gZW1TY2hlbWFba107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga3dkU2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BFcnJvcnMgfHwgKHByb3BFcnJvcnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNYXAgPSAocHJvcEVycm9yc1trXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBrd2RTY2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyTWFwW3BdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgfHwgKGVycm9ycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yc1trXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcHJvcEVycm9ycywgZXJyb3JzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkRXJyb3JzKGt3ZEVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZEVycnMgPSBnZW4uY29uc3QoXCJlbUVycm9yc1wiLCBhanZfMS5zdHJpbmdpZnkoa3dkRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdldFRlbXBsYXRlc0NvZGUoa3dkRXJyb3JzLCBzY2hlbWEpKTtcbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGdlbi5pZihtYXRjaEtleXdvcmRFcnJvcihlcnIsIGt3ZEVycnMpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2t3ZEVycnN9WyR7ZXJyfS5rZXl3b3JkXS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2luZ2xlRXJyb3IgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW4ubGV0KFwibWVzc2FnZVwiLCBhanZfMS5fIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc0Vycm9ycyA9IGdlbi5sZXQoXCJwYXJhbXNFcnJvcnNcIiwgYWp2XzEuXyBgW11gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9vcEVycm9ycygoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYobWVzc2FnZSwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHttZXNzYWdlfSArPSAke3R5cGVvZiBzaW5nbGVFcnJvciA9PSBcInN0cmluZ1wiID8gc2luZ2xlRXJyb3IgOiBcIjtcIn1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uY29kZShhanZfMS5fIGAke21lc3NhZ2V9ICs9ICR7ZXJyTWVzc2FnZShrZXkpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7cGFyYW1zRXJyb3JzfS5jb25jYXQoJHtrd2RFcnJzfVske2tleX1dKWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7IG1lc3NhZ2UsIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtwYXJhbXNFcnJvcnN9fWAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb29wRXJyb3JzKChrZXkpID0+IGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2t3ZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb29wRXJyb3JzKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2t3ZEVycnN9WyR7a2V5fV0ubGVuZ3RoYCwgKCkgPT4gYm9keShrZXkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVyck1lc3NhZ2Uoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGAke2tleX0gaW4gJHt0ZW1wbGF0ZXN9ID8gJHt0ZW1wbGF0ZXN9WyR7a2V5fV0oKSA6ICR7c2NoZW1hVmFsdWV9WyR7a2V5fV1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga3dkRXJycyA9IGdlbi5jb25zdChcImVtRXJyb3JzXCIsIGFqdl8xLnN0cmluZ2lmeShrd2RQcm9wRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzQ29kZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlc0NvZGUucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGVtcGxhdGVzQ29kZShrd2RQcm9wRXJyb3JzW2tdLCBzY2hlbWFba10pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdlbi5vYmplY3QoLi4udGVtcGxhdGVzQ29kZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZFByb3BQYXJhbXMgPSBnZW4uc2NvcGVWYWx1ZShcIm9ialwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGFqdl8xLnN0cmluZ2lmeShLRVlXT1JEX1BST1BFUlRZX1BBUkFNUyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFBhcmFtID0gZ2VuLmxldChcImVtUHJvcFBhcmFtc1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNFcnJvcnMgPSBnZW4ubGV0KFwiZW1QYXJhbXNFcnJvcnNcIik7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHByb3BQYXJhbSwgYWp2XzEuXyBgJHtrd2RQcm9wUGFyYW1zfVske2Vycn0ua2V5d29yZF1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtlcnJ9LmtleXdvcmRdWyR7ZXJyfS5wYXJhbXNbJHtwcm9wUGFyYW19XV1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHBhcmFtc0Vycm9ycywgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5mb3JJbihcImtleVByb3BcIiwgYWp2XzEuXyBgJHtrd2RFcnJzfVske2tleX1dYCwgKGtleVByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtrZXl9XVske2tleVByb3B9XWApO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9Lmxlbmd0aGAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcGwgPSBnZW4uY29uc3QoXCJ0bXBsXCIsIGFqdl8xLl8gYCR7dGVtcGxhdGVzfVske2tleX1dICYmICR7dGVtcGxhdGVzfVske2tleX1dWyR7a2V5UHJvcH1dYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhanZfMS5fIGAke3RtcGx9ID8gJHt0bXBsfSgpIDogJHtzY2hlbWFWYWx1ZX1bJHtrZXl9XVske2tleVByb3B9XWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke3BhcmFtc0Vycm9yc319YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRFcnJvcnMoY2hpbGRFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gY2hpbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcyAmJiAhaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc09iaiA9IGFqdl8xLl8gYHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCJgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXJyID0gYWp2XzEuXyBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFcnJzID0gZ2VuLmxldChcImVtRXJyb3JzXCIpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEt3ZDtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRQcm9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IGdlbi5sZXQoXCJ0ZW1wbGF0ZXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzICYmIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkS3dkID0gZ2VuLmxldChcImVtQ2hpbGRLd2RcIik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc09iaik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FyciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRLd2QsIGFqdl8xLnN0ciBgaXRlbXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChwcm9wcywgc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjaGlsZEt3ZCwgYWp2XzEuc3RyIGBwcm9wZXJ0aWVzYCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3AgPSBhanZfMS5fIGBbJHtjaGlsZEt3ZH1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLml0ZW1zYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoaXNPYmosIGNvZGVnZW5fMS5ub3QoaXNBcnIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQocHJvcHMsIHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLnByb3BlcnRpZXNgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIChjaGlsZCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtjaGlsZEVycnN9WyR7Y2hpbGR9XS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBjaGlsZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2NoaWxkRXJyc31bJHtrZXl9XS5sZW5ndGhgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWp2XzEuXyBgJHtrZXl9IGluICR7dGVtcGxhdGVzfSA/ICR7dGVtcGxhdGVzfVske2tleX1dKCkgOiAke3NjaGVtYVZhbHVlfSR7Y2hpbGRQcm9wfVske2tleX1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtjaGlsZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oYWp2XzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfS0xXS5pbnN0YW5jZVBhdGhgLCBhanZfMS5fIGAke2luc3RhbmNlUGF0aH0gKyBcIi9cIiArICR7a2V5fS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWApO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0KGNoaWxkcmVuLCBtc2dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRFcnJzLCBhanZfMS5zdHJpbmdpZnkoY2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0ZW1wbGF0ZXMsIGdldFRlbXBsYXRlc0NvZGUoY2hpbGRyZW4sIG1zZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQWxsRXJyb3JzKHNjaE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hBbnlFcnJvcihlcnIpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2VycnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7ZXJyc30ubGVuZ3RoYCwgKCkgPT4gZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRlbXBsYXRlRXhwcihzY2hNZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2VycnN9fWAsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVXNlZEVycm9ycygpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYoYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtlcnJzfS5wdXNoKCR7ZXJyfSlgKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGVycnMpLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBhanZfMS5fIGAke2VycnN9Lmxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSAke2luc3RhbmNlUGF0aH1gLCBhanZfMS5fIGAke2Vycn0ua2V5d29yZCBpbiAke2t3ZEVycnN9YCwgXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXRjaCB0aGUgZW5kIG9mIHRoZSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYC9eXFxcXC9bXlxcXFwvXSokLy50ZXN0KCR7ZXJyfS5zY2hlbWFQYXRoLnNsaWNlKCR7aXQuZXJyU2NoZW1hUGF0aC5sZW5ndGh9KSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoLmluZGV4T2YoJHtpbnN0YW5jZVBhdGh9KSA9PT0gMGApLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVnZXggPSBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiAvXlxcLyhbXi9dKikoPzpcXC98JCkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYWp2XzEuXyBgbmV3IFJlZ0V4cChcIl5cXFxcXFwvKFteL10qKSg/OlxcXFxcXC98JClcIilgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGdlbi5jb25zdChcImVtTWF0Y2hlc1wiLCBhanZfMS5fIGAke2NoaWxkUmVnZXh9LmV4ZWMoJHtlcnJ9Lmluc3RhbmNlUGF0aC5zbGljZSgke2luc3RhbmNlUGF0aH0ubGVuZ3RoKSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBnZW4uY29uc3QoXCJlbUNoaWxkXCIsIGFqdl8xLl8gYCR7bWF0Y2hlc30gJiYgJHttYXRjaGVzfVsxXS5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpYCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihhanZfMS5fIGAke2NoaWxkfSAhPT0gdW5kZWZpbmVkICYmICR7Y2hpbGR9IGluICR7Y2hpbGRFcnJzfWAsICgpID0+IHRoZW5Cb2R5KGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaEFueUVycm9yKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuYW5kKGFqdl8xLl8gYCR7ZXJyfS5rZXl3b3JkICE9PSAke2tleXdvcmR9YCwgYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgY29kZWdlbl8xLm9yKGFqdl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09ICR7aW5zdGFuY2VQYXRofWAsIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aC5pbmRleE9mKCR7aW5zdGFuY2VQYXRofSkgPT09IDBgLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoWyR7aW5zdGFuY2VQYXRofS5sZW5ndGhdID09PSBcIi9cImApKSwgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoWyR7aXQuZXJyU2NoZW1hUGF0aH0ubGVuZ3RoXSA9PT0gXCIvXCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlc0NvZGUoa2V5cywgbXNncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlc0NvZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4ga2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBtc2dzW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNDb2RlLnB1c2goW2ssIHRlbXBsYXRlRnVuYyhtc2cpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLnRlbXBsYXRlc0NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVFeHByKG1zZykge1xuICAgICAgICAgICAgICAgIGlmICghSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5zdHJpbmdpZnkobXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlXzEuc2FmZVN0cmluZ2lmeShtc2cpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKElOVEVSUE9MQVRJT05fUkVQTEFDRSwgKF9zLCBwdHIpID0+IGBcIiArIEpTT04uc3RyaW5naWZ5KCR7dmFsaWRhdGVfMS5nZXREYXRhKHB0ciwgaXQpfSkgKyBcImApXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKEVNUFRZX1NUUiwgXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVGdW5jKG1zZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGBmdW5jdGlvbigpe3JldHVybiAke3RlbXBsYXRlRXhwcihtc2cpfX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXRhU2NoZW1hOiB7XG4gICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdMaXN0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdPck1hcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHsgJHJlZjogXCIjLyRkZWZzL3N0cmluZ09yTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJGRlZnM6IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5nT3JNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgYW55T2Y6IFt7IHR5cGU6IFwic3RyaW5nXCIgfSwgeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfV0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJpbmdMaXN0OiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5jb25zdCBhanZFcnJvcnMgPSAoYWp2LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIWFqdi5vcHRzLmFsbEVycm9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LWVycm9yczogQWp2IG9wdGlvbiBhbGxFcnJvcnMgbXVzdCBiZSB0cnVlXCIpO1xuICAgIGlmIChhanYub3B0cy5qc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi1lcnJvcnM6IGFqdiBvcHRpb24ganNQcm9wZXJ0eVN5bnRheCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWp2LmFkZEtleXdvcmQoZXJyb3JNZXNzYWdlKG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG5tb2R1bGUuZXhwb3J0cyA9IGFqdkVycm9ycztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgQWp2LCB7IE9wdGlvbnMsIEVycm9yT2JqZWN0LCBFcnJvcnNUZXh0T3B0aW9ucyB9IGZyb20gXCJhanZcIjtcbmltcG9ydCBhZGRGb3JtYXRzIGZyb20gXCJhanYtZm9ybWF0c1wiO1xuaW1wb3J0IGFkZEVycm9ycyBmcm9tIFwiYWp2LWVycm9yc1wiO1xuaW1wb3J0IFR5cGVkSW5wdXRTY2hlbWEgZnJvbSBcIi4vc2NoZW1hcy90eXBlZC1pbnB1dFwiO1xuaW1wb3J0IE1lc3NhZ2VTY2hlbWEgZnJvbSBcIi4vc2NoZW1hcy9tZXNzYWdlXCI7XG5cbmNsYXNzIFZhbGlkYXRvclNlcnZpY2Uge1xuICBhanY6IEFqdjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogT3B0aW9ucykge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENPTlNUUlVDVE9SIE9GIFZBTElEQVRPUiBTRVJWSUNFXCIpO1xuICAgIHRoaXMuYWp2ID0gbmV3IEFqdih7XG4gICAgICBhbGxFcnJvcnM6IHRydWUsXG4gICAgICB1c2VEZWZhdWx0czogXCJlbXB0eVwiLFxuICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlRm9ybWF0czogdHJ1ZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGNvZXJjZVR5cGVzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKHRoaXMuYWp2LnNjaGVtYXMpO1xuXG4gICAgLy8gTk9URTogdGhpcyBwbHVnaW4gZW5hYmxlcyB1c2VycyB0byB1c2UgZm9ybWF0cyBrZXl3b3JkXG4gICAgYWRkRm9ybWF0cyh0aGlzLmFqdik7XG5cbiAgICAvLyBOT1RFOyB0aGlzIHBsdWdpbiBlbmFibGVzIHVzZXJzIHRvIGRlY2xhcmUgY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gICAgYWRkRXJyb3JzKHRoaXMuYWp2KTtcblxuICAgIHRoaXMuYWp2LmFkZEtleXdvcmQoXCJub2RlVHlwZVwiKTtcbiAgfVxuXG4gIGNyZWF0ZVZhbGlkYXRvcihzY2hlbWE6IEFueVNjaGVtYSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENSRUFURVZBTElEQVRPUlwiKTtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmFqdi5zY2hlbWFzKTtcbiAgICByZXR1cm4gdGhpcy5hanYuY29tcGlsZShzY2hlbWEpO1xuICB9XG5cbiAgcmVzZXRDYWNoZSgpIHtcbiAgICB0aGlzLmFqdi5jYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgZXJyb3JzKFxuICAgIGVycm9ycz86IEVycm9yT2JqZWN0W10gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM/OiBFcnJvcnNUZXh0T3B0aW9uc1xuICApIHtcbiAgICByZXR1cm4gdGhpcy5hanYuZXJyb3JzVGV4dChlcnJvcnMsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfTtcbiIsImltcG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi4vdmFsaWRhdG9yLXNlcnZpY2VcIjtcbi8vIE5PVEU6IHNpbmdsZXRvbiB0byB1c2UgYWp2IGNhY2hpbmcgZmVhdHVyZXNcbmNvbnN0IHZhbGlkYXRvclNlcnZpY2UgPSBuZXcgVmFsaWRhdG9yU2VydmljZSgpO1xuXG5leHBvcnQgeyB2YWxpZGF0b3JTZXJ2aWNlIH07XG4iLCJ2YXIgaGFzRXhjYXBlID0gL34vXG52YXIgZXNjYXBlTWF0Y2hlciA9IC9+WzAxXS9nXG5mdW5jdGlvbiBlc2NhcGVSZXBsYWNlciAobSkge1xuICBzd2l0Y2ggKG0pIHtcbiAgICBjYXNlICd+MSc6IHJldHVybiAnLydcbiAgICBjYXNlICd+MCc6IHJldHVybiAnfidcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGlsZGUgZXNjYXBlOiAnICsgbSlcbn1cblxuZnVuY3Rpb24gdW50aWxkZSAoc3RyKSB7XG4gIGlmICghaGFzRXhjYXBlLnRlc3Qoc3RyKSkgcmV0dXJuIHN0clxuICByZXR1cm4gc3RyLnJlcGxhY2UoZXNjYXBlTWF0Y2hlciwgZXNjYXBlUmVwbGFjZXIpXG59XG5cbmZ1bmN0aW9uIHNldHRlciAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICB2YXIgcGFydFxuICB2YXIgaGFzTmV4dFBhcnRcblxuICBmb3IgKHZhciBwID0gMSwgbGVuID0gcG9pbnRlci5sZW5ndGg7IHAgPCBsZW47KSB7XG4gICAgaWYgKHBvaW50ZXJbcF0gPT09ICdjb25zdHJ1Y3RvcicgfHwgcG9pbnRlcltwXSA9PT0gJ3Byb3RvdHlwZScgfHwgcG9pbnRlcltwXSA9PT0gJ19fcHJvdG9fXycpIHJldHVybiBvYmpcblxuICAgIHBhcnQgPSB1bnRpbGRlKHBvaW50ZXJbcCsrXSlcbiAgICBoYXNOZXh0UGFydCA9IGxlbiA+IHBcblxuICAgIGlmICh0eXBlb2Ygb2JqW3BhcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gc3VwcG9ydCBzZXR0aW5nIG9mIC8tXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIHBhcnQgPT09ICctJykge1xuICAgICAgICBwYXJ0ID0gb2JqLmxlbmd0aFxuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0IG5lc3RlZCBvYmplY3RzL2FycmF5IHdoZW4gc2V0dGluZyB2YWx1ZXNcbiAgICAgIGlmIChoYXNOZXh0UGFydCkge1xuICAgICAgICBpZiAoKHBvaW50ZXJbcF0gIT09ICcnICYmIHBvaW50ZXJbcF0gPCBJbmZpbml0eSkgfHwgcG9pbnRlcltwXSA9PT0gJy0nKSBvYmpbcGFydF0gPSBbXVxuICAgICAgICBlbHNlIG9ialtwYXJ0XSA9IHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNOZXh0UGFydCkgYnJlYWtcbiAgICBvYmogPSBvYmpbcGFydF1cbiAgfVxuXG4gIHZhciBvbGRWYWx1ZSA9IG9ialtwYXJ0XVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG9ialtwYXJ0XVxuICBlbHNlIG9ialtwYXJ0XSA9IHZhbHVlXG4gIHJldHVybiBvbGRWYWx1ZVxufVxuXG5mdW5jdGlvbiBjb21waWxlUG9pbnRlciAocG9pbnRlcikge1xuICBpZiAodHlwZW9mIHBvaW50ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcG9pbnRlciA9IHBvaW50ZXIuc3BsaXQoJy8nKVxuICAgIGlmIChwb2ludGVyWzBdID09PSAnJykgcmV0dXJuIHBvaW50ZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLicpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb2ludGVyKSkge1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwb2ludGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwYXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLiBNdXN0IGJlIG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlci4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRlclxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4nKVxufVxuXG5mdW5jdGlvbiBnZXQgKG9iaiwgcG9pbnRlcikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIHZhciBsZW4gPSBwb2ludGVyLmxlbmd0aFxuICBpZiAobGVuID09PSAxKSByZXR1cm4gb2JqXG5cbiAgZm9yICh2YXIgcCA9IDE7IHAgPCBsZW47KSB7XG4gICAgb2JqID0gb2JqW3VudGlsZGUocG9pbnRlcltwKytdKV1cbiAgICBpZiAobGVuID09PSBwKSByZXR1cm4gb2JqXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlciBmb3Igc2V0LicpXG4gIHJldHVybiBzZXR0ZXIob2JqLCBwb2ludGVyLCB2YWx1ZSlcbn1cblxuZnVuY3Rpb24gY29tcGlsZSAocG9pbnRlcikge1xuICB2YXIgY29tcGlsZWQgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGdldChvYmplY3QsIGNvbXBpbGVkKVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAob2JqZWN0LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldChvYmplY3QsIGNvbXBpbGVkLCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5nZXQgPSBnZXRcbmV4cG9ydHMuc2V0ID0gc2V0XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTAwJVwiPlxuICAgIDxOb2RlUmVkTm9kZUZvcm0gOm5vZGU9XCJsb2NhbE5vZGVcIiA6ZXJyb3JzPVwiZXJyb3JzXCIgc3R5bGU9XCJ3aWR0aDogMTAwJVwiIC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IHZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi92YWxpZGF0b3JcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbnBvaW50ZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIk5vZGVSZWRWdWVBcHBcIixcbiAgcHJvcHM6IHtcbiAgICBub2RlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbE5vZGU6IHRoaXMubm9kZSxcbiAgICAgIGVycm9yczoge30sXG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlTW91bnQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IodGhpcy5sb2NhbE5vZGUpO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5sb2NhbE5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgdGhpcy4kd2F0Y2goXG4gICAgICAgICgpID0+IHRoaXMubG9jYWxOb2RlW3Byb3BdLFxuICAgICAgICAobmV3VmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICB7IGRlZXA6IHRydWUgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuX2RlZi5jcmVkZW50aWFsc1twcm9wXS50eXBlID09PSBcInBhc3N3b3JkXCIgJiZcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF1cbiAgICAgICkge1xuICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1twcm9wXSA9IFwiX19QV0RfX1wiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiR3YXRjaChcbiAgICAgICAgKCkgPT4gdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbcHJvcF0sXG4gICAgICAgIChuZXdWYWwsIG9sZFZhbCkgPT4ge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHNbcHJvcF0udHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgICAgICBuZXdWYWwgIT09IG9sZFZhbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF0gPSAhIW5ld1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVbm1vdW50KCkge1xuICAgICQoXCIjbm9kZS1kaWFsb2ctb2tcIik/LnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSkucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAkKFwiI25vZGUtY29uZmlnLWRpYWxvZy1va1wiKVxuICAgICAgPy5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpXG4gICAgICAucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAkKFwiI3JlZC11aS13b3Jrc3BhY2VcIikuZ2V0KDApLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJcIik7XG4gICAgLy8gJChcIiNyZWQtdWktd29ya3NwYWNlLWNoYXJ0IHN2Z1wiKVxuICAgIC8vICAgLmdldCgwKVxuICAgIC8vICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG5cbiAgICAvLyBOT1RFOiBtdXN0IHNldCBjcmVkZW50aWFscyBwcm9wIHRvIHVuZGVmaW5lZCB0byBhdm9pZCB1cGRhdGluZyBpdCB0byBfX1BXRF9fIGluIHRoZSBzZXJ2ZXJcbiAgICBPYmplY3Qua2V5cyh0aGlzLmxvY2FsTm9kZS5fZGVmLmNyZWRlbnRpYWxzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHNbcHJvcF0udHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdICYmXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdID09PSBcIl9fUFdEX19cIlxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdG9yKHRoaXMubG9jYWxOb2RlKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy52YWxpZGF0b3IuZXJyb3JzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycy5yZWR1Y2UoKGFjYywgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zdCBlcnJvclZhbHVlID0ganNvbnBvaW50ZXIuZ2V0KFxuICAgICAgICAgICAgdGhpcy5sb2NhbE5vZGUsXG4gICAgICAgICAgICBlcnJvci5pbnN0YW5jZVBhdGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVycm9yLnBhcmVudFNjaGVtYS5mb3JtYXQgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICAgICAgZXJyb3JWYWx1ZSA9PT0gXCJfX1BXRF9fXCJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBcInBhc3N3b3JkIGZpZWxkcyB3aXRoIHZhbHVlIGVxdWFsIHRvIF9fUFdEX18gc2hvdWxkIG5vdCBiZSBhbiBlcnJvclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYG5vZGUke2Vycm9yLmluc3RhbmNlUGF0aC5yZXBsYWNlQWxsKFwiL1wiLCBcIi5cIil9YDtcbiAgICAgICAgICAgIGFjY1trZXldID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgJChcIiNub2RlLWRpYWxvZy1va1wiKT8ucHJvcChcImRpc2FibGVkXCIsIHRydWUpLmFkZENsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQoXCIjbm9kZS1jb25maWctZGlhbG9nLW9rXCIpXG4gICAgICAgICAgPy5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgICAuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJChcIiNyZWQtdWktd29ya3NwYWNlXCIpXG4gICAgICAgICAgLmdldCgwKVxuICAgICAgICAgIC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiLCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgLy8gJChcIiNyZWQtdWktd29ya3NwYWNlLWNoYXJ0IHN2Z1wiKVxuICAgICAgICAvLyAgIC5nZXQoMClcbiAgICAgICAgLy8gICAuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKFwiI25vZGUtZGlhbG9nLW9rXCIpLnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSkucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJChcIiNub2RlLWNvbmZpZy1kaWFsb2ctb2tcIilcbiAgICAgICAgICAucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgICAkKFwiI3JlZC11aS13b3Jrc3BhY2VcIikuZ2V0KDApLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJcIik7XG4gICAgICAgIC8vICQoXCIjcmVkLXVpLXdvcmtzcGFjZS1jaGFydCBzdmdcIilcbiAgICAgICAgLy8gICAuZ2V0KDApXG4gICAgICAgIC8vICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuLm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlIHtcbiAgY29sb3I6IHZhcigtLXJlZC11aS1mb3JtLWlucHV0LWJvcmRlci1lcnJvci1jb2xvcik7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCVcIj5cbiAgICA8aW5wdXRcbiAgICAgIHJlZj1cImlucHV0RmllbGRcIlxuICAgICAgOnR5cGU9XCJ0eXBlXCJcbiAgICAgIDp2YWx1ZT1cImludGVybmFsVmFsdWVcIlxuICAgICAgOnBsYWNlaG9sZGVyPVwicGxhY2Vob2xkZXJcIlxuICAgICAgQGlucHV0PVwib25JbnB1dFwiXG4gICAgICBAZm9jdXM9XCJvbkZvY3VzXCJcbiAgICAgIEBibHVyPVwib25CbHVyXCJcbiAgICAgIHN0eWxlPVwiZmxleDogMTsgd2lkdGg6IDEwMCVcIlxuICAgIC8+XG4gICAgPGRpdiB2LWlmPVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcInRleHRcIixcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXCJ0ZXh0XCIsIFwicGFzc3dvcmRcIl0uaW5jbHVkZXModmFsdWUpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiLCBcImlucHV0XCJdLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnRlcm5hbFZhbHVlOiBcIlwiLFxuICAgICAgc2VjcmV0UGF0dGVybjogXCIqKioqKioqKioqKioqXCIsXG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlTW91bnQoKSB7XG4gICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLm9uQmx1cigpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25JbnB1dChldmVudCkge1xuICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCB0aGlzLmludGVybmFsVmFsdWUpO1xuICAgICAgdGhpcy4kZW1pdChcImlucHV0XCIsIHRoaXMuaW50ZXJuYWxWYWx1ZSk7XG4gICAgfSxcbiAgICBvbkZvY3VzKCkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnR5cGUgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPT09IHRoaXMuc2VjcmV0UGF0dGVyblxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IFwiXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJsdXIoKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSBcInBhc3N3b3JkXCIgJiYgdGhpcy52YWx1ZSA9PT0gXCJfX1BXRF9fXCIpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdGhpcy5zZWNyZXRQYXR0ZXJuO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCJjb25zdCBUWVBFRF9JTlBVVF9UWVBFUyA9IFtcbiAgXCJtc2dcIixcbiAgXCJmbG93XCIsXG4gIFwiZ2xvYmFsXCIsXG4gIFwic3RyXCIsXG4gIFwibnVtXCIsXG4gIFwiYm9vbFwiLFxuICBcImpzb25cIixcbiAgXCJiaW5cIixcbiAgXCJyZVwiLFxuICBcImpzb25hdGFcIixcbiAgXCJkYXRlXCIsXG4gIFwiZW52XCIsXG4gIFwibm9kZVwiLFxuICBcImNyZWRcIixcbl07XG5cbmV4cG9ydCB7IFRZUEVEX0lOUFVUX1RZUEVTIH07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgcmVmPVwidHlwZWRJbnB1dFwiXG4gICAgICBjbGFzcz1cIm5vZGUtcmVkLXR5cGVkLWlucHV0XCJcbiAgICAgIHN0eWxlPVwiZmxleDogMTsgd2lkdGg6IDEwMCVcIlxuICAgIC8+XG4gICAgPGRpdiB2LWlmPVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBUWVBFRF9JTlBVVF9UWVBFUyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoIXR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm9wICd2YWx1ZScgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1ZhbGlkID1cbiAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSAmJlxuICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikgJiZcbiAgICAgICAgICB0eXBlb2Ygb2JqLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgdHlwZW9mIG9iai50eXBlID09PSBcInN0cmluZ1wiO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIlZhbGlkYXRpb24gZmFpbGVkIGZvciBwcm9wICd2YWx1ZSc6IEl0IG11c3QgYmUgYW4gb2JqZWN0IHdpdGggJ3ZhbHVlJyBhbmQgJ3R5cGUnIHByb3BlcnRpZXMgYmVpbmcgc3RyaW5ncy5cIixcbiAgICAgICAgICAgIG9ialxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuICAgIH0sXG4gICAgdHlwZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogKCkgPT4gVFlQRURfSU5QVVRfVFlQRVMsXG4gICAgfSxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCJdLFxuICBjb21wdXRlZDoge1xuICAgIGlzUHJvdmlkZWRWYWx1ZVR5cGVWYWxpZCgpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnZhbHVlLnR5cGU7XG4gICAgICBjb25zdCB0eXBlcyA9IHRoaXMudHlwZXM7XG5cbiAgICAgIHJldHVybiB0eXBlcy5pbmNsdWRlcyh0eXBlKTtcbiAgICB9LFxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzUHJvdmlkZWRWYWx1ZVR5cGVWYWxpZDoge1xuICAgICAgaGFuZGxlcihuZXdWYWx1ZSkge1xuICAgICAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFZhbGlkYXRpb24gZmFpbGVkOiB0aGlzLnZhbHVlLnR5cGUgKCR7dGhpcy52YWx1ZS50eXBlfSkgbXVzdCBiZSBvbmUgb2YgdGhlIHByb3ZpZGVkIHR5cGVzICgke3RoaXMudHlwZXN9KS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IHRoaXMuJHJlZnMudHlwZWRJbnB1dDtcbiAgICB0aGlzLiRpbnB1dCA9ICQoaW5wdXRFbGVtZW50KS50eXBlZElucHV0KHtcbiAgICAgIGRlZmF1bHQ6IHRoaXMudmFsdWUudHlwZSB8fCB0aGlzLnR5cGVzWzBdLFxuICAgICAgdHlwZXM6IHRoaXMudHlwZXMsXG4gICAgfSk7XG5cbiAgICB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidmFsdWVcIiwgdGhpcy52YWx1ZS52YWx1ZSB8fCBcIlwiKTtcbiAgICB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidHlwZVwiLCB0aGlzLnZhbHVlLnR5cGUgfHwgdGhpcy50eXBlc1swXSk7XG5cbiAgICAvLyBOT1RFOiB3aGVuIHR5cGVkIGlucHV0IGlzIGp1c3QgYSB0ZXh0IGlucHV0LCBpdCBpc24ndCBlbWl0aW5nIGNoYW5nZSB3aGlsZSB0eXBpbmcgYmVjYXVzZSBpdCBpcyB1cGRhdGluZyB0aGUgdmFsdWUgaW4gYSBoaWRkZW4gaW5wdXRcbiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShpbnB1dEVsZW1lbnQsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJ2YWx1ZVwiXSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH0pO1xuXG4gICAgLy8gTk9URTogdGhpcyBlbWl0cyBjaGFuZ2VzIHRvIGFsbCB0eXBlcyB0aGF0IGxvc2UgZm9jdXMgd2hlbiBjaG9vc2luZyBhIHZhbHVlLCBidXQgdGV4dCBpbnB1dHNcbiAgICB0aGlzLiRpbnB1dC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfSk7XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZXJyb3IobmV3VmFsKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldERpdiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgXCIucmVkLXVpLXR5cGVkSW5wdXQtY29udGFpbmVyXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG5ld1ZhbCkge1xuICAgICAgICAgIHRhcmdldERpdi5jbGFzc0xpc3QuYWRkKFwiaW5wdXQtZXJyb3JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJpbnB1dC1lcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidmFsdWVcIik7XG4gICAgICBjb25zdCBuZXdUeXBlID0gdGhpcy4kaW5wdXQudHlwZWRJbnB1dChcInR5cGVcIik7XG4gICAgICBpZiAodGhpcy52YWx1ZS52YWx1ZSAhPT0gbmV3VmFsdWUgfHwgdGhpcy52YWx1ZS50eXBlICE9PSBuZXdUeXBlKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJ1cGRhdGU6dmFsdWVcIiwge1xuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICB0eXBlOiBuZXdUeXBlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCVcIj5cbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiA6aWQ9XCJpbnB1dElkXCIgc3R5bGU9XCJ3aWR0aDogMTAwJVwiIC8+XG4gICAgPGRpdiB2LWlmPVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpbnB1dFByZWZpeCgpIHtcbiAgICAgIHJldHVybiBcIm5vZGUtaW5wdXQtXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSk7XG4gICAgfSxcbiAgICBpbnB1dElkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRQcmVmaXggKyBcIi1cIiArIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBSRUQuZWRpdG9yLnByZXBhcmVDb25maWdOb2RlU2VsZWN0KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMudmFsdWUsXG4gICAgICB0aGlzLnR5cGUsXG4gICAgICB0aGlzLmlucHV0UHJlZml4XG4gICAgKTtcblxuICAgIGNvbnN0IGlucHV0ID0gJChcIiNcIiArIHRoaXMuaW5wdXRJZCk7XG4gICAgaW5wdXQub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCBpbnB1dC52YWwoKSk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC52YWwodGhpcy52YWx1ZSB8fCBcIl9BRERfXCIpO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCVcIj5cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIHJlZj1cInNlbGVjdElucHV0XCJcbiAgICAgIGNsYXNzPVwibm9kZS1pbnB1dC1zZWxlY3RcIlxuICAgICAgc3R5bGU9XCJ3aWR0aDogMTAwJVwiXG4gICAgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nIHwgQXJyYXksXG4gICAgb3B0aW9uczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm9wICdvcHRpb25zJyBtdXN0IGJlIGFuIGFycmF5LlwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbHVlLmV2ZXJ5KChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNPYmplY3QgPSB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBpdGVtICE9PSBudWxsO1xuICAgICAgICAgIGlmICghaXNPYmplY3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpICYmXG4gICAgICAgICAgICBpdGVtLmhhc093blByb3BlcnR5KFwibGFiZWxcIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpdGVtLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICB0eXBlb2YgaXRlbS5sYWJlbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiVmFsaWRhdGlvbiBmYWlsZWQgZm9yIHByb3AgJ29wdGlvbnMnOiBFYWNoIGl0ZW0gbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCAndmFsdWUnIGFuZCAnbGFiZWwnIHByb3BlcnRpZXMgYmVpbmcgc3RyaW5ncy5cIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBtdWx0aXBsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSB0aGlzLiRyZWZzLnNlbGVjdElucHV0O1xuICAgIGNvbnN0ICRzZWxlY3RJbnB1dCA9ICQoaW5wdXRFbGVtZW50KTtcbiAgICAkc2VsZWN0SW5wdXQudHlwZWRJbnB1dCh7XG4gICAgICB0eXBlczogW1xuICAgICAgICB7XG4gICAgICAgICAgbXVsdGlwbGU6IHRoaXMubXVsdGlwbGUsXG4gICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcblxuICAgICRzZWxlY3RJbnB1dC50eXBlZElucHV0KFxuICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuam9pbihcIixcIikgOiB0aGlzLnZhbHVlXG4gICAgKTtcbiAgICAkc2VsZWN0SW5wdXQub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLm11bHRpcGxlXG4gICAgICAgID8gJHNlbGVjdElucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiKT8uc3BsaXQoXCIsXCIpXG4gICAgICAgIDogJHNlbGVjdElucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiKTtcbiAgICAgIHRoaXMuJGVtaXQoXCJ1cGRhdGU6dmFsdWVcIiwgbmV3VmFsdWUpO1xuICAgIH0pO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJlZj1cImNvbnRhaW5lckRpdlwiIGNsYXNzPVwibm9kZS10ZXh0LWVkaXRvci1jb250YWluZXJcIj5cbiAgICA8ZGl2IHJlZj1cImVkaXRvckRpdlwiIDppZD1cImVkaXRvcklkXCIgY2xhc3M9XCJub2RlLXRleHQtZWRpdG9yXCI+PC9kaXY+XG4gICAgPGRpdiB2LXNob3c9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGxhbmd1YWdlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcImpzb25cIixcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWRMYW5ndWFnZXMgPSBbXG4gICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgXCJqc29uXCIsXG4gICAgICAgICAgXCJqYXZhc2NyaXB0XCIsXG4gICAgICAgICAgXCJodG1sXCIsXG4gICAgICAgICAgXCJjc3NcIixcbiAgICAgICAgICBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJzcWxcIixcbiAgICAgICAgICBcInlhbWxcIixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGFsbG93ZWRMYW5ndWFnZXMuaW5jbHVkZXModmFsdWUpO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgW05vZGVSZWRFZGl0b3JDb21wb25lbnRdIEludmFsaWQgQUNFIGVkaXRvciBtb2RlIHByb3A6IFwiJHt2YWx1ZX1cIi4gYCArXG4gICAgICAgICAgICAgIGBFeHBlY3RlZCBvbmUgb2Y6ICR7YWxsb3dlZExhbmd1YWdlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgZWRpdG9yOiBudWxsLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JJZDogXCJub2RlLXJlZC1lZGl0b3ItXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSksXG4gICAgfTtcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLm1vdW50RWRpdG9yKCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtb3VudEVkaXRvcigpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyRWwgPSB0aGlzLiRyZWZzLmNvbnRhaW5lckRpdjtcbiAgICAgICAgY29uc3QgZWRpdG9yRWwgPSB0aGlzLiRyZWZzLmVkaXRvckRpdjtcblxuICAgICAgICBpZiAoY29udGFpbmVyRWwgJiYgZWRpdG9yRWwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5saW5lSGVpZ2h0ID0gY29udGFpbmVyRWwuc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgaW5saW5lV2lkdGggPSBjb250YWluZXJFbC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgIGlmIChpbmxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUuaGVpZ2h0ID0gaW5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUud2lkdGggPSBpbmxpbmVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRWRpdG9ySW5zdGFuY2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIltOb2RlUmVkRWRpdG9ySW5wdXRdIEVycm9yIHNldHRpbmcgaW5pdGlhbCBlZGl0b3Igc3R5bGU6XCIsXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUVkaXRvckluc3RhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIltOb2RlUmVkRWRpdG9ySW5wdXRdIENvbnRhaW5lciBvciBFZGl0b3IgZGl2IHJlZnMgbm90IGZvdW5kIG9uIG1vdW50LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVFZGl0b3JJbnN0YW5jZSgpIHtcbiAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UgPSBSRUQuZWRpdG9yLmNyZWF0ZUVkaXRvcih7XG4gICAgICAgIGlkOiB0aGlzLmVkaXRvcklkLFxuICAgICAgICBtb2RlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5nZXRTZXNzaW9uKCkub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmVkaXRvckluc3RhbmNlLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZVVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9ySW5zdGFuY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgZWRpdG9yIGZvciBJRCAke3RoaXMuZWRpdG9ySWR9OmAsIGVycik7XG4gICAgICB9XG4gICAgICB0aGlzLmVkaXRvckluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgeyBjcmVhdGVBcHAsIENvbXBvbmVudCwgQXBwLCBkZWZpbmVDb21wb25lbnQgfSBmcm9tIFwidnVlXCI7XG5pbXBvcnQgeyBjbG9uZURlZXAsIGlzRXF1YWwsIG1lcmdlIH0gZnJvbSBcImVzLXRvb2xraXRcIjtcbmltcG9ydCB7IEFueVNjaGVtYSwgVmFsaWRhdGVGdW5jdGlvbiB9IGZyb20gXCJhanZcIjtcbmltcG9ydCB7XG4gIGdldERlZmF1bHRzRnJvbVNjaGVtYSxcbiAgZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hLFxuICBwYXRjaFBhc3N3b3JkUGF0dGVybnMsXG59IGZyb20gXCIuLi91dGlsc1wiO1xuXG5pbXBvcnQgTm9kZVJlZFZ1ZUFwcCBmcm9tIFwiLi9BcHAudnVlXCI7XG5pbXBvcnQgTm9kZVJlZElucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZElucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRUeXBlZElucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZFR5cGVkSW5wdXQudnVlXCI7XG5pbXBvcnQgTm9kZVJlZENvbmZpZ0lucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZENvbmZpZ0lucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRTZWxlY3RJbnB1dCBmcm9tIFwiLi9jb21wb25lbnRzL05vZGVSZWRTZWxlY3RJbnB1dC52dWVcIjtcbmltcG9ydCBOb2RlUmVkRWRpdG9ySW5wdXQgZnJvbSBcIi4vY29tcG9uZW50cy9Ob2RlUmVkRWRpdG9ySW5wdXQudnVlXCI7XG5cbmltcG9ydCB7IHZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi92YWxpZGF0b3JcIjtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZVJlZFZ1ZUFwcChcbiAgbm9kZTogYW55LFxuICBmb3JtOiBDb21wb25lbnQsXG4gIHZhbGlkYXRvcjogVmFsaWRhdGVGdW5jdGlvbiB8ICgoKSA9PiBib29sZWFuKVxuKTogQXBwPEVsZW1lbnQ+IHtcbiAgY29uc3QgYXBwID0gY3JlYXRlQXBwKE5vZGVSZWRWdWVBcHAsIHtcbiAgICBub2RlLFxuICAgIHZhbGlkYXRvcixcbiAgfSk7XG5cbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRJbnB1dFwiLCBOb2RlUmVkSW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZFR5cGVkSW5wdXRcIiwgTm9kZVJlZFR5cGVkSW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZENvbmZpZ0lucHV0XCIsIE5vZGVSZWRDb25maWdJbnB1dCk7XG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkU2VsZWN0SW5wdXRcIiwgTm9kZVJlZFNlbGVjdElucHV0KTtcbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRFZGl0b3JJbnB1dFwiLCBOb2RlUmVkRWRpdG9ySW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZE5vZGVGb3JtXCIsIGZvcm0pO1xuICByZXR1cm4gYXBwO1xufVxuXG5mdW5jdGlvbiBtb3VudEFwcChcbiAgbm9kZTogYW55LFxuICBmb3JtOiBDb21wb25lbnQsXG4gIHZhbGlkYXRvcjogVmFsaWRhdGVGdW5jdGlvbiB8ICgoKSA9PiBib29sZWFuKVxuKSB7XG4gICQoXCIjYXBwXCIpLmVtcHR5KCk7XG4gIG5vZGUuX25ld1N0YXRlID0gY2xvbmVEZWVwKG5vZGUpO1xuICBub2RlLl9hcHAgPSBjcmVhdGVOb2RlUmVkVnVlQXBwKG5vZGUuX25ld1N0YXRlLCBmb3JtLCB2YWxpZGF0b3IpO1xuICBub2RlLl9hcHAubW91bnQoXCIjYXBwXCIpO1xufVxuXG5mdW5jdGlvbiB1bm1vdW50QXBwKG5vZGU6IGFueSkge1xuICBpZiAobm9kZS5fYXBwKSB7XG4gICAgbm9kZS5fYXBwLnVubW91bnQoKTtcbiAgICBub2RlLl9hcHAgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVTdGF0ZShub2RlOiBhbnkpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgY3JlZGVudGlhbHM6IHt9LFxuICB9O1xuICBPYmplY3Qua2V5cyhub2RlLl9kZWYuZGVmYXVsdHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBzdGF0ZVtwcm9wXSA9IG5vZGVbcHJvcF07XG4gIH0pO1xuICBPYmplY3Qua2V5cyhub2RlLl9kZWYuY3JlZGVudGlhbHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBzdGF0ZS5jcmVkZW50aWFsc1twcm9wXSA9IG5vZGUuY3JlZGVudGlhbHNbcHJvcF07XG5cbiAgICBpZiAobm9kZS5fZGVmLmNyZWRlbnRpYWxzW3Byb3BdLnR5cGUgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgc3RhdGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF0gPVxuICAgICAgICBub2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdIHx8IGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VzKG86IFJlY29yZDxhbnksIGFueT4sIG46IFJlY29yZDxhbnksIGFueT4pIHtcbiAgY29uc3QgY2hhbmdlcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBjb25zdCBfbyA9IG9bcHJvcF07XG4gICAgY29uc3QgX24gPSBuW3Byb3BdO1xuXG4gICAgaWYgKHR5cGVvZiBfbyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgX2NoYW5nZXMgPSBnZXRDaGFuZ2VzKF9vLCBfbik7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoX2NoYW5nZXMpLmxlbmd0aCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gX2NoYW5nZXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNFcXVhbChfbywgX24pKSB7XG4gICAgICBjaGFuZ2VzW3Byb3BdID0gX287XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY2hhbmdlcztcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVwcmVzZW50aW5nIGEgYnV0dG9uIGNvbmZpZ3VyYXRpb24gZm9yIGEgbm9kZS5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlQnV0dG9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG9nZ2xlIC0gVGV4dCB0byBkaXNwbGF5IHdoZW4gdG9nZ2xpbmcgdGhlIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gb25jbGljayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IGJvb2xlYW59IFtlbmFibGVkXSAtIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidXR0b24gc2hvdWxkIGJlXG4gKiAgIGVuYWJsZWQuIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnV0dG9uIHNob3VsZCBiZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IGJvb2xlYW59IFt2aXNpYmxlXSAtIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidXR0b24gc2hvdWxkIGJlXG4gKiAgIHZpc2libGUuIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnV0dG9uIHNob3VsZCBiZSB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmludGVyZmFjZSBJTm9kZUJ1dHRvbiB7XG4gIHRvZ2dsZTogc3RyaW5nO1xuICBvbmNsaWNrOiAoKSA9PiB2b2lkO1xuICBlbmFibGVkPzogKCkgPT4gYm9vbGVhbjtcbiAgdmlzaWJsZT86ICgpID0+IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIE5vZGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBub2RlIHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSBUaGUgY2F0ZWdvcnkgdGhpcyBub2RlIGJlbG9uZ3MgdG8gaW4gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXSAtIFRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpbiBoZXggZm9ybWF0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXSAtIFRoZSBpY29uIHRvIGRpc3BsYXkgZm9yIHRoaXMgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbGFiZWxdIC0gVGhlIGxhYmVsIHRvIGRpc3BsYXkgb24gdGhlIG5vZGUuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2lucHV0c10gLSBOdW1iZXIgb2YgaW5wdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW291dHB1dHNdIC0gTnVtYmVyIG9mIG91dHB1dCBwb3J0cyB0aGUgbm9kZSBzaG91bGQgaGF2ZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbcGFsZXR0ZUxhYmVsXSAtIFRoZSBsYWJlbCB0byBzaG93IGluIHRoZSBwYWxldHRlLiBDYW4gYmUgYSBzdGF0aWMgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtsYWJlbFN0eWxlXSAtIENTUyBzdHlsZSB0byBhcHBseSB0byB0aGUgbm9kZSBsYWJlbC4gQ2FuIGJlIGEgc3RhdGljIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbaW5wdXRMYWJlbHNdIC0gTGFiZWxzIGZvciB0aGUgaW5wdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW291dHB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBvdXRwdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge1wibGVmdFwifFwicmlnaHRcIn0gW2FsaWduXSAtIEFsaWdubWVudCBvZiB0aGUgbm9kZSBjb250ZW50LlxuICogQHByb3BlcnR5IHtJTm9kZUJ1dHRvbn0gW2J1dHRvbl0gLSBDb25maWd1cmF0aW9uIGZvciBhIGJ1dHRvbiBvbiB0aGUgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZUFkZF0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcGFsZXR0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZVJlbW92ZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge0NvbXBvbmVudH0gZm9ybSAtIFRoZSBmb3JtIGNvbXBvbmVudCB0byB1c2UgZm9yIGNvbmZpZ3VyaW5nIHRoZSBub2RlLlxuICogQHByb3BlcnR5IHtBbnlTY2hlbWF9IFtzY2hlbWFdIC0gU2NoZW1hIGRlZmluaXRpb24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmludGVyZmFjZSBJTm9kZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgY29sb3I/OiBzdHJpbmc7XG4gIGljb24/OiBzdHJpbmc7XG4gIGxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGlucHV0cz86IG51bWJlcjtcbiAgb3V0cHV0cz86IG51bWJlcjtcbiAgcGFsZXR0ZUxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGxhYmVsU3R5bGU/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgaW5wdXRMYWJlbHM/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgb3V0cHV0TGFiZWxzPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGFsaWduPzogXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG4gIGJ1dHRvbj86IElOb2RlQnV0dG9uO1xuICBvblBhbGV0dGVBZGQ/OiAoKSA9PiB2b2lkO1xuICBvblBhbGV0dGVSZW1vdmU/OiAoKSA9PiB2b2lkO1xuICBmb3JtOiBDb21wb25lbnQ7XG4gIHNjaGVtYT86IEFueVNjaGVtYTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyBhIG5vZGUgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVGhpcyBpcyBhIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZFxuICogdG8gcmVnaXN0ZXIgdGhlIG5vZGUgd2l0aCBhIHNwZWNpZmljIHR5cGUgYXQgcnVudGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZUNvbmZpZyAtIFRoZSBzdGF0aWMgY29uZmlndXJhdGlvbiBzaGFyZWQgYnkgYWxsIG5vZGVzIG9mIHRoaXMga2luZFxuICogQHBhcmFtIHtzdHJpbmd9IFtub2RlQ29uZmlnLmNhdGVnb3J5PVwidW5kZWZpbmVkXCJdIC0gVGhlIGNhdGVnb3J5IHRoaXMgbm9kZSBiZWxvbmdzIHRvIGluIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25vZGVDb25maWcuY29sb3I9XCIjRkZGRkZGXCJdIC0gVGhlIGNvbG9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGluIGhleCBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbm9kZUNvbmZpZy5pY29uXSAtIFRoZSBpY29uIHRvIGRpc3BsYXkgZm9yIHRoaXMgbm9kZVxuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLmxhYmVsXSAtIFRoZSBsYWJlbCB0byBkaXNwbGF5IG9uIHRoZSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW25vZGVDb25maWcuaW5wdXRzPTBdIC0gTnVtYmVyIG9mIGlucHV0IHBvcnRzIHRoZSBub2RlIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge251bWJlcn0gW25vZGVDb25maWcub3V0cHV0cz0wXSAtIE51bWJlciBvZiBvdXRwdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5wYWxldHRlTGFiZWxdIC0gVGhlIGxhYmVsIHRvIHNob3cgaW4gdGhlIHBhbGV0dGVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5sYWJlbFN0eWxlXSAtIENTUyBzdHlsZSB0byBhcHBseSB0byB0aGUgbm9kZSBsYWJlbFxuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLmlucHV0TGFiZWxzXSAtIExhYmVscyBmb3IgdGhlIGlucHV0IHBvcnRzXG4gKiBAcGFyYW0geyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW25vZGVDb25maWcub3V0cHV0TGFiZWxzXSAtIExhYmVscyBmb3IgdGhlIG91dHB1dCBwb3J0c1xuICogQHBhcmFtIHtcImxlZnRcInxcInJpZ2h0XCJ9IFtub2RlQ29uZmlnLmFsaWduPVwibGVmdFwiXSAtIEFsaWdubWVudCBvZiB0aGUgbm9kZSBjb250ZW50XG4gKiBAcGFyYW0ge0lOb2RlQnV0dG9ufSBbbm9kZUNvbmZpZy5idXR0b25dIC0gQ29uZmlndXJhdGlvbiBmb3IgYSBidXR0b24gb24gdGhlIG5vZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW25vZGVDb25maWcub25QYWxldHRlQWRkXSAtIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBub2RlIGlzIGFkZGVkIHRvIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtub2RlQ29uZmlnLm9uUGFsZXR0ZVJlbW92ZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhbGV0dGVcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBub2RlQ29uZmlnLmZvcm0gLSBUaGUgZm9ybSBjb21wb25lbnQgdG8gdXNlIGZvciBjb25maWd1cmluZyB0aGUgbm9kZVxuICogQHBhcmFtIHtBbnlTY2hlbWF9IFtub2RlQ29uZmlnLnNjaGVtYV0gLSBTY2hlbWEgZGVmaW5pdGlvbiBmb3IgdmFsaWRhdGlvblxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbih0eXBlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+fSAtIEEgZnVuY3Rpb24gdGhhdCByZWdpc3RlcnMgdGhlIG5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGVcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKG9wdGlvbnM6IE9taXQ8SU5vZGUsIFwidHlwZVwiPikge1xuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbm9kZSB0eXBlIHdpdGggdGhlIE5vZGUtUkVEIHJ1bnRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgaWRlbnRpZmllciBmb3IgdGhlIG5vZGVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiByZWdpc3RyYXRpb24gaXMgY29tcGxldGVcbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlcmUgaXMgYSBuZXR3b3JrIGVycm9yIG9yIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBlcnJvciBzdGF0dXNcbiAgICovXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAodHlwZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9ucmcvbm9kZXMvJHt0eXBlfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gZ2V0RGVmYXVsdHNGcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICBpZiAoZGVmYXVsdHMuY3JlZGVudGlhbHMpIGRlbGV0ZSBkZWZhdWx0cy5jcmVkZW50aWFscztcbiAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hKFxuICAgICAgICBzY2hlbWEucHJvcGVydGllcy5jcmVkZW50aWFsc1xuICAgICAgKTtcblxuICAgICAgY29uc29sZS5sb2coXCJkZWZhdWx0c1wiLCBkZWZhdWx0cyk7XG4gICAgICBjb25zb2xlLmxvZyhcImNyZWRlbnRpYWxzXCIsIGNyZWRlbnRpYWxzKTtcblxuICAgICAgUkVELm5vZGVzLnJlZ2lzdGVyVHlwZSh0eXBlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICBjcmVkZW50aWFscyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBvbmVkaXRwcmVwYXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gdmFsaWRhdG9yU2VydmljZS5jcmVhdGVWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgICAgICAgICBtb3VudEFwcCh0aGlzLCBvcHRpb25zLmZvcm0sIHZhbGlkYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZWRpdHNhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcztcbiAgICAgICAgICB1bm1vdW50QXBwKG5vZGUpO1xuXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBnZXROb2RlU3RhdGUobm9kZS5fbmV3U3RhdGUpO1xuICAgICAgICAgIGNvbnN0IG9sZFN0YXRlID0gZ2V0Tm9kZVN0YXRlKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VzKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9ICEhT2JqZWN0LmtleXMoY2hhbmdlcyk/Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWNoYW5nZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuX2RlZi5kZWZhdWx0cz8uW3Byb3BdPy50eXBlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZENvbmZpZ05vZGVJZCA9IG5vZGVbcHJvcF07XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NvbmZpZ05vZGVJZCA9IG5vZGUuX25ld1N0YXRlW3Byb3BdO1xuICAgICAgICAgICAgICBpZiAob2xkQ29uZmlnTm9kZUlkICE9PSBuZXdDb25maWdOb2RlSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRDb25maWdOb2RlID0gUkVELm5vZGVzLm5vZGUob2xkQ29uZmlnTm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQ29uZmlnTm9kZSAmJiBvbGRDb25maWdOb2RlLl9kZWYuY2F0ZWdvcnkgPT09IFwiY29uZmlnXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGVJbmRleCA9IG9sZENvbmZpZ05vZGUudXNlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICAgICAoX25vZGUpID0+IF9ub2RlLmlkID09PSBub2RlLmlkXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ29uZmlnTm9kZS51c2Vycy5zcGxpY2UocGFyZW50Tm9kZUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuX2RlZi5kZWZhdWx0cz8uW3Byb3BdPy50eXBlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlQ29uZmlnTm9kZUlkID0gbm9kZS5fbmV3U3RhdGVbcHJvcF07XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlQ29uZmlnTm9kZSA9IFJFRC5ub2Rlcy5ub2RlKG5ld1N0YXRlQ29uZmlnTm9kZUlkKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlQ29uZmlnTm9kZSAmJlxuICAgICAgICAgICAgICAgIG5ld1N0YXRlQ29uZmlnTm9kZS5fZGVmLmNhdGVnb3J5ID09PSBcImNvbmZpZ1wiXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGVJbmRleCA9IG5ld1N0YXRlQ29uZmlnTm9kZS51c2Vycy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAoX25vZGUpID0+IF9ub2RlLmlkID09PSBub2RlLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgbmV3U3RhdGVDb25maWdOb2RlLnVzZXJzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtZXJnZShub2RlLCBuZXdTdGF0ZSk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlZCxcbiAgICAgICAgICAgIGhpc3Rvcnk6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHQ6IFwiZWRpdFwiLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBsaW5rczogW10sXG4gICAgICAgICAgICAgICAgZGlydHk6IFJFRC5ub2Rlcy5kaXJ0eSgpLFxuICAgICAgICAgICAgICAgIGNoYW5nZWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uZWRpdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVubW91bnRBcHAodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZWRpdGRlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVubW91bnRBcHAodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ucGFsZXR0ZWFkZDogb3B0aW9ucy5vblBhbGV0dGVBZGQsXG4gICAgICAgIG9ucGFsdHRlcmVtb3ZlOiBvcHRpb25zLm9uUGFsZXR0ZVJlbW92ZSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBub2RlIHR5cGUgJHt0eXBlfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyVHlwZSwgSU5vZGUsIElOb2RlQnV0dG9uIH07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IE5hbWU8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5uYW1lXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm5hbWUnXVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwibmFtZVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBIb3N0bmFtZTwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmhvc3RcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuaG9zdCddXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCJob3N0bmFtZVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiTm9kZVJlZE5vZGVGb3JtXCIsXG4gIHByb3BzOiB7XG4gICAgbm9kZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBlcnJvcnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsIi8vIE5PVEU6IHRoaXMgZmlsZSBpcyBwcm92aWRlZCBieSB0aGUgdXNlclxuLy8gTk9URTsgdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBucmdcbmltcG9ydCB7IHJlZ2lzdGVyVHlwZSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL2NsaWVudFwiO1xuaW1wb3J0IGZvcm0gZnJvbSBcIi4vRm9ybS52dWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgcmVnaXN0ZXJUeXBlKHtcbiAgY2F0ZWdvcnk6IFwiY29uZmlnXCIsXG4gIGNvbG9yOiBcIiNhNmJiY2ZcIixcbiAgZm9ybTogZm9ybSxcbn0pO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBVc2VybmFtZTwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmNyZWRlbnRpYWxzLnVzZXJuYW1lXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmNyZWRlbnRpYWxzLnVzZXJuYW1lJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBQYXNzd29yZDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmNyZWRlbnRpYWxzLnBhc3N3b3JkXCJcbiAgICAgICAgdHlwZT1cInBhc3N3b3JkXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmNyZWRlbnRpYWxzLnBhc3N3b3JkJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBQYXNzd29yZCAyPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY3JlZGVudGlhbHMucGFzc3dvcmQyXCJcbiAgICAgICAgdHlwZT1cInBhc3N3b3JkXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmNyZWRlbnRpYWxzLnBhc3N3b3JkMiddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5UeXBlZCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFR5cGVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUubXlQcm9wZXJ0eVwiXG4gICAgICAgIDp0eXBlcz1cInR5cGVzXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm15UHJvcGVydHknXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+VHlwZWQgSW5wdXQgMjwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFR5cGVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUubXlQcm9wZXJ0eTJcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUubXlQcm9wZXJ0eTInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+Q29uZmlnIElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkQ29uZmlnSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUucmVtb3RlU2VydmVyXCJcbiAgICAgICAgdHlwZT1cInJlbW90ZS1zZXJ2ZXJcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUucmVtb3RlU2VydmVyJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPkNvbmZpZyBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZENvbmZpZ0lucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmFub3RoZXJSZW1vdGVTZXJ2ZXJcIlxuICAgICAgICB0eXBlPVwicmVtb3RlLXNlcnZlclwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5hbm90aGVyUmVtb3RlU2VydmVyJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmNvdW50cnlcIlxuICAgICAgICA6b3B0aW9ucz1cImNvdW50cmllc1wiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jb3VudHJ5J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPk11bHRpU2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuZnJ1aXRcIlxuICAgICAgICA6b3B0aW9ucz1cImZydWl0c1wiXG4gICAgICAgIG11bHRpcGxlXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5mcnVpdCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5TZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5udW1iZXJcIlxuICAgICAgICA6b3B0aW9ucz1cIm51bWJlcnNcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUubnVtYmVyJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLm9iamVjdFwiXG4gICAgICAgIDpvcHRpb25zPVwib2JqZWN0c1wiXG4gICAgICAgIG11bHRpcGxlXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5vYmplY3QnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+U2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuYXJyYXlcIlxuICAgICAgICA6b3B0aW9ucz1cImFycmF5c1wiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5hcnJheSddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5FZGl0b3Igd2l0aCBkZWZhdWx0IGhlaWdodCAyMDBweCBhbmQgSlNPTjwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZEVkaXRvcklucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmpzb250ZXN0XCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmpzb250ZXN0J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPkVkaXRvciB3aXRoIGN1c3RvbSBoZWlnaHQgYW5kIENTUzwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZEVkaXRvcklucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmNzc3Rlc3RcIlxuICAgICAgICBsYW5ndWFnZT1cImNzc1wiXG4gICAgICAgIHN0eWxlPVwiaGVpZ2h0OiAxMDBweFwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jc3N0ZXN0J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIk5vZGVSZWROb2RlRm9ybVwiLFxuICBwcm9wczoge1xuICAgIG5vZGU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG4gICAgZXJyb3JzOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiAoKSA9PiAoe30pLFxuICAgIH0sXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGVzOiBbXCJzdHJcIiwgXCJtc2dcIiwgXCJub2RlXCJdLFxuICAgICAgY291bnRyaWVzOiBbXG4gICAgICAgIHsgdmFsdWU6IFwidXNhXCIsIGxhYmVsOiBcInVzYVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwiYXJnZW50aW5hXCIsIGxhYmVsOiBcImFyZ2VudGluYVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwiYnJhc2lsXCIsIGxhYmVsOiBcImJyYXNpbFwiIH0sXG4gICAgICBdLFxuICAgICAgZnJ1aXRzOiBbXG4gICAgICAgIHsgdmFsdWU6IFwiYXBwbGVcIiwgbGFiZWw6IFwiYXBwbGVcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcIm1lbG9uXCIsIGxhYmVsOiBcIm1lbG9uXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJyYXNwYmVycnlcIiwgbGFiZWw6IFwicmFzcGJlcnJ5XCIgfSxcbiAgICAgIF0sXG4gICAgICBudW1iZXJzOiBbXG4gICAgICAgIHsgdmFsdWU6IFwiMVwiLCBsYWJlbDogXCIxXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCIyXCIsIGxhYmVsOiBcIjJcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcIjNcIiwgbGFiZWw6IFwiM1wiIH0sXG4gICAgICBdLFxuICAgICAgb2JqZWN0czogW1xuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeSh7IHRlc3Q6IFwiYVwiIH0pLCBsYWJlbDogXCJhXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoeyB0ZXN0OiBcImJcIiB9KSwgbGFiZWw6IFwiYlwiIH0sXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KHsgdGVzdDogXCJjXCIgfSksIGxhYmVsOiBcImNcIiB9LFxuICAgICAgXSxcbiAgICAgIGFycmF5czogW1xuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeShbXCJhXCJdKSwgbGFiZWw6IFwiYVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KFtcImJcIl0pLCBsYWJlbDogXCJiXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoW1wiY1wiXSksIGxhYmVsOiBcImNcIiB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiLy8gTk9URTogdGhpcyBmaWxlIGlzIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4vLyBOT1RFOyB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IG5yZ1xuaW1wb3J0IHsgcmVnaXN0ZXJUeXBlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvY2xpZW50XCI7XG5pbXBvcnQgZm9ybSBmcm9tIFwiLi9Gb3JtLnZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCByZWdpc3RlclR5cGUoe1xuICBjYXRlZ29yeTogXCJmdW5jdGlvblwiLFxuICBjb2xvcjogXCIjRkZGRkZGXCIsXG4gIGlucHV0czogMSxcbiAgb3V0cHV0czogMSxcbiAgaWNvbjogXCJ2dWUucG5nXCIsXG4gIGZvcm0sXG4gIG9uUGFsZXR0ZUFkZDogKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiTk9ERSBUWVBFIFJFR0lTVEVSRUQgT04gVEhFIFBBTEVUVEVcIik7XG4gIH0sXG59KTtcbiIsIi8vIE5PVEU6IHRoaXMgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgbnJnIHVzaW5nIGEgdGVtcGxhdGVcbmltcG9ydCByZW1vdGVTZXJ2ZXIgZnJvbSBcIi4vbm9kZXMvcmVtb3RlLXNlcnZlci9jbGllbnRcIjtcbmltcG9ydCB5b3VyTm9kZSBmcm9tIFwiLi9ub2Rlcy95b3VyLW5vZGUvY2xpZW50XCI7XG5cbi8vIFRPRE86IGlzIHRoZXJlIGEgdXNlIGNhc2UgZm9yIGNvbnRyb2xsaW5nIHRoZSBvcmRlciBub2RlcyBpbiB0aGUgZWRpdG9yIGFyZSByZWdpc3RlcmVkP1xuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJOb2RlcygpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbcmVtb3RlU2VydmVyKFwicmVtb3RlLXNlcnZlclwiKSwgeW91ck5vZGUoXCJ5b3VyLW5vZGVcIildKTtcbiAgICBjb25zb2xlLmxvZyhcIkFsbCBub2RlIHR5cGVzIHJlZ2lzdGVyZWQgaW4gcGFyYWxsZWxcIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlZ2lzdGVyaW5nIG5vZGUgdHlwZXM6XCIsIGVycm9yKTtcbiAgfVxufVxuXG5yZWdpc3Rlck5vZGVzKCk7XG4iXSwibmFtZXMiOlsibWFwIiwiaGFzT3duUHJvcGVydHkiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWYiLCJ3YXJuIiwiY29tcHV0ZWQiLCJ0eXBlIiwic2VsZiIsInJlYWRvbmx5Iiwid2F0Y2giLCJlZmZlY3QiLCJzY29wZSIsInAiLCJpZCIsInZlcnNpb24iLCJyZWYiLCJyZXNvbHZlIiwiaCIsImNyZWF0ZUFwcCIsInJlcXVpcmVkIiwidHlwZXMiLCJyZW1vdmUyIiwicmVtb3ZlIiwiaXNNb2RlbExpc3RlbmVyIiwiZW1pdCIsIm5hbWVzIiwiaXNCb29sZWFuIiwiY2FtZWxpemUkMSIsInN0YWNrIiwicHJvcGVydGllcyIsImNvZGUiLCJyZXF1aXJlJCQwIiwiVXNlZFZhbHVlU3RhdGUiLCJwcmVmaXhlcyIsImRlZiIsInJlcXVpcmUkJDEiLCJub3QiLCJpdGVtcyIsInJ1bGVzIiwia2V5d29yZCIsIlR5cGUiLCJuYW1lc18xIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwiRGF0YVR5cGUiLCJkYXRhVHlwZSIsInBhdHRlcm4iLCJ2YWxpZGF0ZSIsImVycm9ycyIsIl9hIiwic3Vic2NoZW1hIiwiZXF1YWwiLCJ0cmF2ZXJzZSIsImpzb25TY2hlbWFUcmF2ZXJzZU1vZHVsZSIsImxpbWl0IiwicmVxdWlyZSQkNSIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3IiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJyZXF1aXJlJCQxMCIsImJ1ZmZlciIsInVyaSIsImZhc3RVcmkiLCJmYXN0VXJpTW9kdWxlIiwidXJpXzEiLCJBanYiLCIkc2NoZW1hIiwiZGVmaW5pdGlvbnMiLCJmb3JtYXQiLCJjb3JlXzEiLCJjb3JlIiwidWNzMmxlbmd0aF8xIiwidWNzMmxlbmd0aCIsImVxdWFsXzEiLCJ2YWxpZGF0aW9uXzEiLCJ2YWxpZGF0aW9uIiwicHJlZml4SXRlbXMiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwiYXBwbGljYXRvciIsImZvcm1hdF8yIiwiRGlzY3JFcnJvciIsIm9uZU9mIiwiYWp2IiwiYWRkRm9ybWF0cyIsImZvcm1hdHMiLCJjb21waWxlIiwianNvbnBvaW50ZXIiLCJfc2ZjX21haW4iLCJfaG9pc3RlZF8xIiwiX29wZW5CbG9jayIsIl9jcmVhdGVFbGVtZW50QmxvY2siLCJfY3JlYXRlVk5vZGUiLCJfaG9pc3RlZF8yIiwiX2NyZWF0ZUVsZW1lbnRWTm9kZSIsIl9ob2lzdGVkXzMiLCJfdG9EaXNwbGF5U3RyaW5nIiwiX2NyZWF0ZUNvbW1lbnRWTm9kZSIsImlzT2JqZWN0IiwiX3dpdGhEaXJlY3RpdmVzIiwiZm9ybSIsIiQiLCJkZWZhdWx0cyIsIl9jcmVhdGVUZXh0Vk5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0E7QUFBQTtBQUVBLFdBQVMsUUFBUSxLQUFLO0FBQ2QsVUFBQUEsT0FBNkIsdUJBQUEsT0FBTyxJQUFJO0FBQzlDLGVBQVcs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QTtBQUFBLFVBQ3BCLE9BQU8sT0FBTSxPQUFBLGNBQUE7QUFBQTs7Ozs7QUN2SHRCLFFBQUEsV0FBZSxhQUFhO0FBQUEsSUFDMUIsVUFBVTtBQUFBLElBQ1YsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ047QUFBQSxJQUNBLGNBQWMsTUFBTTtBQUNsQixjQUFRLElBQUkscUNBQXFDO0FBQUEsSUFBQTtBQUFBLEVBRXJELENBQUM7QUNWRCxpQkFBZSxnQkFBZ0I7QUFDekIsUUFBQTtBQUNJLFlBQUEsUUFBUSxJQUFJLENBQUMsYUFBYSxlQUFlLEdBQUcsU0FBUyxXQUFXLENBQUMsQ0FBQztBQUN4RSxjQUFRLElBQUksdUNBQXVDO0FBQUEsYUFDNUMsT0FBTztBQUNOLGNBQUEsTUFBTSxpQ0FBaUMsS0FBSztBQUFBLElBQUE7QUFBQSxFQUV4RDtBQUVBLGdCQUFjOzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5Ml19
  
  //# sourceURL=src/client.js
  </script>
