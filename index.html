<script type="text/html" data-template-name="remote-server">
  <div id="app"></div>
</script>

<script type="text/html" data-template-name="your-node">
  <div id="app"></div>
</script>

<style>
.node-red-vue-input-error-message{
  color:var(--red-ui-form-input-border-error-color)
}

.form-row label{
  width: 100% !important
}
</style>

<!-- TODO: create a /core/client lib and change to ts -->
<script type="text/javascript">var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function($$1) {
  "use strict";
  /**
  * @vue/shared v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map2[key] = 1;
    return (val) => val in map2;
  }
  const EMPTY_OBJ = Object.freeze({});
  const EMPTY_ARR = Object.freeze([]);
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
  const isArray = Array.isArray;
  const isMap = (val) => toTypeString(val) === "[object Map]";
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const isRef$1 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray(val) && !isPlainObject$1(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i = "") => {
    var _a;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
    );
  };
  /**
  * @vue/reactivity v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function warn$2(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else {
        warn$2(`cannot run an inactive effect scope.`);
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        this.effects.length = 0;
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        if (activeSub !== this) {
          warn$2(
            "Active effect was not restored correctly - this is likely a Vue internal bug."
          );
        }
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed = false) {
    sub.flags |= 8;
    if (isComputed) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    const dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
      computed2.flags &= -3;
      return;
    }
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subsHead === link) {
      dep.subsHead = nextSub;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      {
        this.subsHead = void 0;
      }
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      if (activeSub.onTrack) {
        activeSub.onTrack(
          extend(
            {
              effect: activeSub
            },
            debugInfo
          )
        );
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (true) {
          for (let head = this.subsHead; head; head = head.nextSub) {
            if (head.sub.onTrigger && !(head.sub.flags & 8)) {
              head.sub.onTrigger(
                extend(
                  {
                    effect: head.sub
                  },
                  debugInfo
                )
              );
            }
          }
        }
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l = computed2.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      if (link.dep.subsHead === void 0) {
        link.dep.subsHead = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    "Object iterate"
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    "Map keys iterate"
  );
  const ARRAY_ITERATE_KEY = Symbol(
    "Array iterate"
  );
  function track(target, type2, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      {
        dep.track({
          target,
          type: type2,
          key
        });
      }
    }
  }
  function trigger(target, type2, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger({
            target,
            type: type2,
            key,
            newValue,
            oldValue,
            oldTarget
          });
        }
      }
    };
    startBatch();
    if (type2 === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type2) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn, thisArg) {
      return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  function hasOwnProperty(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      if (key === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty;
        }
      }
      const res = Reflect.get(
        target,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver
      );
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(
        target,
        key,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      {
        warn$2(
          `Set operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key) {
      {
        warn$2(
          `Delete operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type2) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        warn$2(
          `${capitalize(type2)} operation ${key}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
          return this;
        },
        delete(key) {
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          } else {
            checkIdentityKeys(target, has, key);
          }
          const oldValue = get ? get.call(target, key) : void 0;
          const result = target.delete(key);
          if (hadKey) {
            trigger(target, "delete", key, void 0, oldValue);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const oldTarget = isMap(target) ? new Map(target) : new Set(target);
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0,
              oldTarget
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
      const type2 = toRawType(target);
      warn$2(
        `Reactive ${type2} contains both the raw and reactive versions of the same object${type2 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      {
        warn$2(
          `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
            target
          )}`
        );
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject(value) ? readonly(value) : value;
  function isRef(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
      activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      } else {
        warn$2("Write operation failed: computed value is readonly");
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    } else if (!failSilently) {
      warn$2(
        `onWatcherCleanup() was called when there was no active watcher to associate with.`
      );
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const warnInvalidSource = (s) => {
      (options.onWarn || warn$2)(
        `Invalid watch source: `,
        s,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction(s)) {
          return call ? call(s, 2) : s();
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope2 = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope2 && scope2.active) {
        remove(scope2.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    {
      effect2.onTrack = options.onTrack;
      effect2.onTrigger = options.onTrigger;
    }
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$1(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a) => {
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
  };
  function callWithErrorHandling(fn, instance, type2, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type2);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type2, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type2, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type2);
        });
      }
      return res;
    }
    if (isArray(fn)) {
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
      }
      return values;
    } else {
      warn$1(
        `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
      );
    }
  }
  function handleError(err, instance, type2, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = ErrorTypeStrings$1[type2];
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
    {
      const info = ErrorTypeStrings$1[type2];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  const RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id2) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    const check = (job) => checkRecursiveUpdates(seen, job);
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (check(job)) {
            continue;
          }
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs(seen);
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    const count = seen.get(fn) || 0;
    if (count > RECURSION_LIMIT) {
      const instance = fn.i;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    }
    seen.set(fn, count + 1);
    return false;
  }
  let isHmrUpdating = false;
  const hmrDirtyComponents = /* @__PURE__ */ new Map();
  {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  const map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id2 = instance.type.__hmrId;
    let record = map.get(id2);
    if (!record) {
      createRecord(id2, instance.type);
      record = map.get(id2);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id2, initialDef) {
    if (map.has(id2)) {
      return false;
    }
    map.set(id2, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component2) {
    return isClassComponent(component2) ? component2.__vccOpts : component2;
  }
  function rerender(id2, newRender) {
    const record = map.get(id2);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id2, newComp) {
    const record = map.get(id2);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (let i = 0; i < instances.length; i++) {
      const instance = instances[i];
      const oldComp = normalizeClassComponent(instance.type);
      let dirtyInstances = hmrDirtyComponents.get(oldComp);
      if (!dirtyInstances) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
      }
      dirtyInstances.add(instance);
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        dirtyInstances.add(instance);
        instance.ceReload(newComp.styles);
        dirtyInstances.delete(instance);
      } else if (instance.parent) {
        queueJob(() => {
          isHmrUpdating = true;
          instance.parent.update();
          isHmrUpdating = false;
          dirtyInstances.delete(instance);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
      if (instance.root.ce && instance !== instance.root) {
        instance.root.ce._removeChildStyle(oldComp);
      }
    }
    queuePostFlushCb(() => {
      hmrDirtyComponents.clear();
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return (id2, arg) => {
      try {
        return fn(id2, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  let devtools$1;
  let buffer = [];
  let devtoolsNotInstalled = false;
  function emit$1(event, ...args) {
    if (devtools$1) {
      devtools$1.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version2) {
    emit$1("app:init", app, version2, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:added"
    /* COMPONENT_ADDED */
  );
  const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:updated"
    /* COMPONENT_UPDATED */
  );
  const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
    /* COMPONENT_REMOVED */
  );
  const devtoolsComponentRemoved = (component2) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools$1.cleanupBuffer(component2)) {
      _devtoolsComponentRemoved(component2);
    }
  };
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function createDevtoolsComponentHook(hook) {
    return (component2) => {
      emit$1(
        hook,
        component2.appContext.app,
        component2.uid,
        component2.parent ? component2.parent.uid : void 0,
        component2
      );
    };
  }
  const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:start"
    /* PERFORMANCE_START */
  );
  const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:end"
    /* PERFORMANCE_END */
  );
  function createDevtoolsPerformanceHook(hook) {
    return (component2, type2, time) => {
      emit$1(hook, component2.appContext.app, component2.uid, component2, type2, time);
    };
  }
  function devtoolsComponentEmit(component2, event, params) {
    emit$1(
      "component:emit",
      component2.appContext.app,
      component2,
      event,
      params
    );
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type2) => type2.__isTeleport;
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
      {
        if (hasOwn(rawSetupState, key) && !isRef(rawSetupState[key])) {
          warn$1(
            `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
          );
        }
        if (knownTemplateRefs.has(rawSetupState[key])) {
          return false;
        }
      }
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray(existing) && remove(existing, refValue);
            } else {
              if (!isArray(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else {
            warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else {
        warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
      }
    }
  }
  getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type2, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type2, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type2, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
    const injected = injectHook(
      type2,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type2], injected);
    }, target);
  }
  function injectHook(type2, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type2] || (target[type2] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type2, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type2].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve$1(instance[type2] || Component[type2], name) || // global registration
        resolve$1(instance.appContext[type2], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (warnMissing && !res) {
        const extra = `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.`;
        warn$1(`Failed to resolve ${type2.slice(0, -1)}: ${name}${extra}`);
      }
      return res;
    } else {
      warn$1(
        `resolve${capitalize(type2.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve$1(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => shallowReadonly(i.props),
      $attrs: (i) => shallowReadonly(i.attrs),
      $slots: (i) => shallowReadonly(i.slots),
      $refs: (i) => shallowReadonly(i.refs),
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $host: (i) => i.ce,
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => {
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    })
  );
  const isReservedPrefix = (key) => key === "_" || key === "$";
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
          markAttrsAccessed();
        } else if (key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
      // to infinite warning loop
      key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
              key
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type2, key) => {
      if (cache[key]) {
        warn$1(`${type2} property "${key}" is already defined in ${cache[key]}.`);
      } else {
        cache[key] = type2;
      }
    };
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          {
            Object.defineProperty(ctx, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          }
          {
            checkDuplicateProperties("Methods", key);
          }
        } else {
          warn$1(
            `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (!isReservedPrefix(key[0])) {
              Object.defineProperty(ctx, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get === NOOP) {
          warn$1(`Computed property "${key}" has no getter.`);
        }
        const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
          warn$1(
            `Write operation failed: computed property "${key}" is readonly.`
          );
        };
        const c = computed({
          get,
          set
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
      {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type2) {
    callWithAsyncErrorHandling(
      isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type2
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction(handler)) {
        {
          watch(getter, handler);
        }
      } else {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        } else {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else {
      warn$1(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction(to) ? to.call(this, this) : to,
        isFunction(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray(to) && isArray(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          }
          return app;
        },
        component(name, component2) {
          {
            validateComponentName(name, context.config);
          }
          if (!component2) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn$1(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component2;
          return app;
        },
        directive(name, directive) {
          {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn$1(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              context.reload = () => {
                render(
                  cloneVNode(vnode),
                  rootContainer,
                  namespace
                );
              };
            }
            {
              render(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getComponentPublicInstance(vnode.component);
          } else {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        onUnmount(cleanupFn) {
          if (typeof cleanupFn !== "function") {
            warn$1(
              `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
            );
          }
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render(null, app._container);
            {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            warn$1(
              `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
            );
          }
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) {
      {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else {
        warn$1(`injection "${String(key)}" not found.`);
      }
    } else {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId) return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys) needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn$1(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type2 = propType[index];
              const typeName = isFunction(type2) && type2.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    } else {
      warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
    for (const key in options) {
      let opt = options[key];
      if (opt == null) continue;
      validateProp(
        key,
        resolvedValues[key],
        opt,
        shallowReadonly(resolvedValues),
        !camelizePropsKey.includes(key)
      );
    }
  }
  function validateProp(name, value, prop, props, isAbsent) {
    const { type: type2, required: required2, validator, skipCheck } = prop;
    if (required2 && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required2) {
      return;
    }
    if (type2 != null && type2 !== true && !skipCheck) {
      let isValid = false;
      const types2 = isArray(type2) ? type2 : [type2];
      const expectedTypes = [];
      for (let i = 0; i < types2.length && !isValid; i++) {
        const { valid, expectedType } = assertType(value, types2[i]);
        expectedTypes.push(expectedType || "");
        isValid = valid;
      }
      if (!isValid) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  const isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type2) {
    let valid;
    const expectedType = getType(type2);
    if (expectedType === "null") {
      valid = value === null;
    } else if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type2;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else {
      valid = value instanceof type2;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type2) {
    if (type2 === "String") {
      return `"${value}"`;
    } else if (type2 === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type2) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type2.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1(
          `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        {
          warn$1(
            `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type2, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type2 = children._;
      if (type2) {
        if (isHmrUpdating) {
          assignSlots(slots, children, optimized);
          trigger(instance, "set", "$slots");
        } else if (optimized && type2 === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  let supported;
  let perf;
  function startMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type2}-${instance.uid}`);
    }
    {
      devtoolsPerfStart(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type2}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(
        `<${formatComponentName(instance, instance.type)}> ${type2}`,
        startTag,
        endTag
      );
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    {
      devtoolsPerfEnd(instance, type2, isSupported() ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type2, ref: ref3, shapeFlag } = n2;
      switch (type2) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type2.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else {
            warn$1("Invalid VNode type:", type2, `(${typeof type2})`);
          }
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      {
        def(el, "__vnode", vnode, true);
        def(el, "__vueParentComponent", parentComponent, true);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      {
        el.__vnode = n2;
      }
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (
        // #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048
      ) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        {
          startMeasure(instance, `init`);
        }
        setupComponent(instance, false, optimized);
        {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        if (isHmrUpdating) initialVNode.el = null;
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent, root, type: type2 } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root.ce) {
              root.ce._injectChildStyle(type2);
            }
            {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
          {
            devtoolsComponentUpdated(instance);
          }
          {
            popWarningContext();
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type2, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type2.move(vnode, container, anchor, internals);
        return;
      }
      if (type2 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type2 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type: type2,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type: type2, el, anchor, transition } = vnode;
      if (type2 === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type2 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope: scope2, job, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope2.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    return {
      render,
      hydrate,
      createApp: createAppAPI(render)
    };
  }
  function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
    return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watch(source, cb, options) {
    if (!isFunction(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const baseWatchOptions = extend({}, options);
    baseWatchOptions.onWarn = warn$1;
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance, type2, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
            warn$1(
              `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event))}" prop.`
            );
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction(validator)) {
            const isValid = validator(...rawArgs);
            if (!isValid) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    {
      devtoolsComponentEmit(instance, event, args);
    }
    {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event
          )}" instead of "${event}".`
        );
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  let accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render.call(
            thisProxy,
            proxyToUse,
            renderCache,
            true ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render2.length > 1 ? render2(
            true ? shallowReadonly(props) : props,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render2(
            true ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      setTransitionHooks(root, vnode.transition);
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  const isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component: component2 } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component2.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type2) => type2.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type2, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && n1.component) {
      const dirtyInstances = hmrDirtyComponents.get(n2.type);
      if (dirtyInstances && dirtyInstances.has(n1.component)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
      }
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...args
    );
  };
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type2,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type2.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = createVNodeWithArgsTransform;
  function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
      if (!type2) {
        warn$1(`Invalid vnode type when creating vnode: ${type2}.`);
      }
      type2 = Comment;
    }
    if (isVNode(type2)) {
      const cloned = cloneVNode(
        type2,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type2)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type2)) {
      type2 = type2.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction(type2) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type2)) {
      type2 = toRaw(type2);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type2
      );
    }
    return createBaseVNode(
      type2,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type2 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type2 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type2 = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type2 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type2 = 16;
        children = [createTextVNode(children)];
      } else {
        type2 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type2;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type2 = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type: type2,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type2, appContext),
      emitsOptions: normalizeEmitsOptions(type2, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type2.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = createDevRenderContext(instance);
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key])) setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set) => set(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names2 = Object.keys(Component.components);
        for (let i = 0; i < names2.length; i++) {
          validateComponentName(names2[i], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names2 = Object.keys(Component.directives);
        for (let i = 0; i < names2.length; i++) {
          validateDirectiveName(names2[i]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          shallowReadonly(instance.props),
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name = (_a = Component.name) != null ? _a : "Anonymous";
            warn$1(
              `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  const isRuntimeOnly = () => true;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!Component.render && instance.render === NOOP && !isSSR) {
      if (Component.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function: `, Component);
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      markAttrsAccessed();
      track(target, "get", "");
      return target[key];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  };
  function getSlotsProxy(instance) {
    return new Proxy(instance.slots, {
      get(target, key) {
        track(instance, "get", "$slots");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray(exposed)) {
              exposedType = "array";
            } else if (isRef(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    {
      let attrsProxy;
      let slotsProxy;
      return Object.freeze({
        get attrs() {
          return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
        },
        get slots() {
          return slotsProxy || (slotsProxy = getSlotsProxy(instance));
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    {
      const i = getCurrentInstance();
      if (i && i.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      __vue_custom_formatter: true,
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            // avoid debugger accessing value affecting behavior
            formatValue("_value" in obj ? obj._value : obj),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed2 = extractKeys(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type2, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type2
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type2) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type2)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type2) {
      const opts = Comp[type2];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type2)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type2))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  const version = "3.5.13";
  const warn = warn$1;
  /**
  * @vue/runtime-dom v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
      warn(`Error creating trusted types policy: ${e}`);
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id2) {
      el.setAttribute(id2, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const vtcKey = Symbol("_vtc");
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const semicolonRE = /[^\\];\s*$/;
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null) val = "";
      {
        if (semicolonRE.test(val)) {
          warn(
            `Unexpected semicolon at the end of '${name}' style value: '${val}'`
          );
        }
      }
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type2 = typeof el[key];
      if (type2 === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type2 === "string") {
        value = "";
        needRemove = true;
      } else if (type2 === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (!needRemove) {
        warn(
          `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e
        );
      }
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = sanitizeEventValue(nextValue, rawName);
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          sanitizeEventValue(nextValue, rawName),
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function sanitizeEventValue(value, propName) {
    if (isFunction(value) || isArray(value)) {
      return value;
    }
    warn(
      `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
    );
    return NOOP;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
    ) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component2 = app._component;
      if (!isFunction(component2) && !component2.render && !component2.template) {
        component2.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn(msg);
          return compilerOptions;
        },
        set() {
          warn(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }
  /**
  * vue v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  {
    initDev();
  }
  function noop() {
  }
  function isPrimitive(value) {
    return value == null || typeof value !== "object" && typeof value !== "function";
  }
  function isTypedArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }
  function getSymbols(object) {
    return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
  }
  function getTag(value) {
    if (value == null) {
      return value === void 0 ? "[object Undefined]" : "[object Null]";
    }
    return Object.prototype.toString.call(value);
  }
  const regexpTag = "[object RegExp]";
  const stringTag = "[object String]";
  const numberTag = "[object Number]";
  const booleanTag = "[object Boolean]";
  const argumentsTag = "[object Arguments]";
  const symbolTag = "[object Symbol]";
  const dateTag = "[object Date]";
  const mapTag = "[object Map]";
  const setTag = "[object Set]";
  const arrayTag = "[object Array]";
  const functionTag = "[object Function]";
  const arrayBufferTag = "[object ArrayBuffer]";
  const objectTag = "[object Object]";
  const errorTag = "[object Error]";
  const dataViewTag = "[object DataView]";
  const uint8ArrayTag = "[object Uint8Array]";
  const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
  const uint16ArrayTag = "[object Uint16Array]";
  const uint32ArrayTag = "[object Uint32Array]";
  const bigUint64ArrayTag = "[object BigUint64Array]";
  const int8ArrayTag = "[object Int8Array]";
  const int16ArrayTag = "[object Int16Array]";
  const int32ArrayTag = "[object Int32Array]";
  const bigInt64ArrayTag = "[object BigInt64Array]";
  const float32ArrayTag = "[object Float32Array]";
  const float64ArrayTag = "[object Float64Array]";
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack2 = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack2);
    if (cloned != null) {
      return cloned;
    }
    if (isPrimitive(valueToClone)) {
      return valueToClone;
    }
    if (stack2.has(valueToClone)) {
      return stack2.get(valueToClone);
    }
    if (Array.isArray(valueToClone)) {
      const result = new Array(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
      }
      if (Object.hasOwn(valueToClone, "index")) {
        result.index = valueToClone.index;
      }
      if (Object.hasOwn(valueToClone, "input")) {
        result.input = valueToClone.input;
      }
      return result;
    }
    if (valueToClone instanceof Date) {
      return new Date(valueToClone.getTime());
    }
    if (valueToClone instanceof RegExp) {
      const result = new RegExp(valueToClone.source, valueToClone.flags);
      result.lastIndex = valueToClone.lastIndex;
      return result;
    }
    if (valueToClone instanceof Map) {
      const result = /* @__PURE__ */ new Map();
      stack2.set(valueToClone, result);
      for (const [key, value] of valueToClone) {
        result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (valueToClone instanceof Set) {
      const result = /* @__PURE__ */ new Set();
      stack2.set(valueToClone, result);
      for (const value of valueToClone) {
        result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
      return valueToClone.subarray();
    }
    if (isTypedArray(valueToClone)) {
      const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i = 0; i < valueToClone.length; i++) {
        result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
      }
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
      return valueToClone.slice(0);
    }
    if (valueToClone instanceof DataView) {
      const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof File !== "undefined" && valueToClone instanceof File) {
      const result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Blob) {
      const result = new Blob([valueToClone], { type: valueToClone.type });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Error) {
      const result = new valueToClone.constructor();
      stack2.set(valueToClone, result);
      result.message = valueToClone.message;
      result.name = valueToClone.name;
      result.stack = valueToClone.stack;
      result.cause = valueToClone.cause;
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
      const result = Object.create(Object.getPrototypeOf(valueToClone));
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack2, cloneValue) {
    const keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor == null || descriptor.writable) {
        target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack2, cloneValue);
      }
    }
  }
  function isCloneableObject(object) {
    switch (getTag(object)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  function isPlainObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
    if (!hasObjectPrototype) {
      return false;
    }
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function merge(target, source) {
    const sourceKeys = Object.keys(source);
    for (let i = 0; i < sourceKeys.length; i++) {
      const key = sourceKeys[i];
      const sourceValue = source[key];
      const targetValue = target[key];
      if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge([], sourceValue);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          target[key] = merge(targetValue, sourceValue);
        } else {
          target[key] = merge({}, sourceValue);
        }
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function isEqualWith(a, b, areValuesEqual) {
    return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  function isEqualWithImpl(a, b, property, aParent, bParent, stack2, areValuesEqual) {
    const result = areValuesEqual(a, b, property, aParent, bParent, stack2);
    if (result !== void 0) {
      return result;
    }
    if (typeof a === typeof b) {
      switch (typeof a) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined": {
          return a === b;
        }
        case "number": {
          return a === b || Object.is(a, b);
        }
        case "function": {
          return a === b;
        }
        case "object": {
          return areObjectsEqual(a, b, stack2, areValuesEqual);
        }
      }
    }
    return areObjectsEqual(a, b, stack2, areValuesEqual);
  }
  function areObjectsEqual(a, b, stack2, areValuesEqual) {
    if (Object.is(a, b)) {
      return true;
    }
    let aTag = getTag(a);
    let bTag = getTag(b);
    if (aTag === argumentsTag) {
      aTag = objectTag;
    }
    if (bTag === argumentsTag) {
      bTag = objectTag;
    }
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case stringTag:
        return a.toString() === b.toString();
      case numberTag: {
        const x = a.valueOf();
        const y = b.valueOf();
        return eq(x, y);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a.valueOf(), b.valueOf());
      case regexpTag: {
        return a.source === b.source && a.flags === b.flags;
      }
      case functionTag: {
        return a === b;
      }
    }
    stack2 = stack2 ?? /* @__PURE__ */ new Map();
    const aStack = stack2.get(a);
    const bStack = stack2.get(b);
    if (aStack != null && bStack != null) {
      return aStack === b;
    }
    stack2.set(a, b);
    stack2.set(b, a);
    try {
      switch (aTag) {
        case mapTag: {
          if (a.size !== b.size) {
            return false;
          }
          for (const [key, value] of a.entries()) {
            if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case setTag: {
          if (a.size !== b.size) {
            return false;
          }
          const aValues = Array.from(a.values());
          const bValues = Array.from(b.values());
          for (let i = 0; i < aValues.length; i++) {
            const aValue = aValues[i];
            const index = bValues.findIndex((bValue) => {
              return isEqualWithImpl(aValue, bValue, void 0, a, b, stack2, areValuesEqual);
            });
            if (index === -1) {
              return false;
            }
            bValues.splice(index, 1);
          }
          return true;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer !== "undefined" && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0; i < a.length; i++) {
            if (!isEqualWithImpl(a[i], b[i], i, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case arrayBufferTag: {
          if (a.byteLength !== b.byteLength) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
        }
        case dataViewTag: {
          if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
        }
        case errorTag: {
          return a.name === b.name && a.message === b.message;
        }
        case objectTag: {
          const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack2, areValuesEqual) || isPlainObject(a) && isPlainObject(b);
          if (!areEqualInstances) {
            return false;
          }
          const aKeys = [...Object.keys(a), ...getSymbols(a)];
          const bKeys = [...Object.keys(b), ...getSymbols(b)];
          if (aKeys.length !== bKeys.length) {
            return false;
          }
          for (let i = 0; i < aKeys.length; i++) {
            const propKey = aKeys[i];
            const aProp = a[propKey];
            if (!Object.hasOwn(b, propKey)) {
              return false;
            }
            const bProp = b[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        default: {
          return false;
        }
      }
    } finally {
      stack2.delete(a);
      stack2.delete(b);
    }
  }
  function isEqual(a, b) {
    return isEqualWith(a, b, noop);
  }
  function getDefaultsFromSchema(schema) {
    const result = {};
    const properties2 = schema.properties || {};
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    console.log("getDefaultsFromSchema");
    for (const [key, value] of Object.entries(properties2)) {
      console.log(key);
      console.log(value);
      result[key] = {
        required: requiredProps.includes(key),
        value: value.default ?? ""
      };
      if ("nodeType" in value) {
        result[key].type = value.nodeType;
      }
    }
    return result;
  }
  function getCredentialsFromSchema(schema) {
    const result = {};
    const properties2 = schema.properties || {};
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    for (const [key, value] of Object.entries(properties2)) {
      console.log(value);
      const isPassword = value.format === "password";
      result[key] = {
        type: isPassword ? "password" : "text",
        required: requiredProps.includes(key),
        value: value.default ?? ""
      };
    }
    return result;
  }
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var ajv = { exports: {} };
  var core$1 = {};
  var validate = {};
  var boolSchema = {};
  var errors = {};
  var codegen = {};
  var code$1 = {};
  var hasRequiredCode$1;
  function requireCode$1() {
    if (hasRequiredCode$1) return code$1;
    hasRequiredCode$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
      class _CodeOrName {
      }
      exports._CodeOrName = _CodeOrName;
      exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class Name extends _CodeOrName {
        constructor(s) {
          super();
          if (!exports.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      exports.Name = Name;
      class _Code extends _CodeOrName {
        constructor(code2) {
          super();
          this._items = typeof code2 === "string" ? [code2] : code2;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a;
          return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
        }
        get names() {
          var _a;
          return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
            if (c instanceof Name)
              names2[c.str] = (names2[c.str] || 0) + 1;
            return names2;
          }, {});
        }
      }
      exports._Code = _Code;
      exports.nil = new _Code("");
      function _(strs, ...args) {
        const code2 = [strs[0]];
        let i = 0;
        while (i < args.length) {
          addCodeArg(code2, args[i]);
          code2.push(strs[++i]);
        }
        return new _Code(code2);
      }
      exports._ = _;
      const plus = new _Code("+");
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i = 0;
        while (i < args.length) {
          expr.push(plus);
          addCodeArg(expr, args[i]);
          expr.push(plus, safeStringify(strs[++i]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports.str = str;
      function addCodeArg(code2, arg) {
        if (arg instanceof _Code)
          code2.push(...arg._items);
        else if (arg instanceof Name)
          code2.push(arg);
        else
          code2.push(interpolate(arg));
      }
      exports.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i = 1;
        while (i < expr.length - 1) {
          if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
            if (res !== void 0) {
              expr.splice(i - 1, 3, res);
              continue;
            }
            expr[i++] = "+";
          }
          i++;
        }
      }
      function mergeExprItems(a, b) {
        if (b === '""')
          return a;
        if (a === '""')
          return b;
        if (typeof a == "string") {
          if (b instanceof Name || a[a.length - 1] !== '"')
            return;
          if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
          if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
          return;
        }
        if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
          return `"${a}${b.slice(1)}`;
        return;
      }
      function strConcat(c1, c2) {
        return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
      }
      exports.strConcat = strConcat;
      function interpolate(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
      }
      function stringify(x) {
        return new _Code(safeStringify(x));
      }
      exports.stringify = stringify;
      function safeStringify(x) {
        return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
      }
      exports.getProperty = getProperty;
      function getEsmExportName(key) {
        if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
          return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
      }
      exports.getEsmExportName = getEsmExportName;
      function regexpCode(rx) {
        return new _Code(rx.toString());
      }
      exports.regexpCode = regexpCode;
    })(code$1);
    return code$1;
  }
  var scope = {};
  var hasRequiredScope;
  function requireScope() {
    if (hasRequiredScope) return scope;
    hasRequiredScope = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
      const code_1 = requireCode$1();
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`);
          this.value = name.value;
        }
      }
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
      exports.varKinds = {
        const: new code_1.Name("const"),
        let: new code_1.Name("let"),
        var: new code_1.Name("var")
      };
      class Scope {
        constructor({ prefixes: prefixes2, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes2;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_1.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a, _b;
          if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      }
      exports.Scope = Scope;
      class ValueScopeName extends code_1.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
        }
      }
      exports.ValueScopeName = ValueScopeName;
      const line = (0, code_1._)`\n`;
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name = this.toName(nameOrPrefix);
          const { prefix } = name;
          const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
          let vs = this._values[prefix];
          if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs.set(valueKey, name);
          const s = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s.length;
          s[itemIndex] = value.ref;
          name.setValue(value, { property: prefix, itemIndex });
          return name;
        }
        getValue(prefix, keyOrRef) {
          const vs = this._values[prefix];
          if (!vs)
            return;
          return vs.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_1._)`${scopeName}${name.scopePath}`;
          });
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(values, (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code2 = code_1.nil;
          for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs.forEach((name) => {
              if (nameSet.has(name))
                return;
              nameSet.set(name, UsedValueState.Started);
              let c = valueCode(name);
              if (c) {
                const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                code2 = (0, code_1._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
              } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
              } else {
                throw new ValueError(name);
              }
              nameSet.set(name, UsedValueState.Completed);
            });
          }
          return code2;
        }
      }
      exports.ValueScope = ValueScope;
    })(scope);
    return scope;
  }
  var hasRequiredCodegen;
  function requireCodegen() {
    if (hasRequiredCodegen) return codegen;
    hasRequiredCodegen = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
      const code_1 = requireCode$1();
      const scope_1 = requireScope();
      var code_2 = requireCode$1();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = requireScope();
      Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports.operators = {
        GT: new code_1._Code(">"),
        GTE: new code_1._Code(">="),
        LT: new code_1._Code("<"),
        LTE: new code_1._Code("<="),
        EQ: new code_1._Code("==="),
        NEQ: new code_1._Code("!=="),
        NOT: new code_1._Code("!"),
        OR: new code_1._Code("||"),
        AND: new code_1._Code("&&"),
        ADD: new code_1._Code("+")
      };
      class Node {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      }
      class Def extends Node {
        constructor(varKind, name, rhs) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.rhs = rhs;
        }
        render({ es5, _n }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (!names2[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
        }
      }
      class Assign extends Node {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n }) {
          return `${this.lhs} = ${this.rhs};` + _n;
        }
        optimizeNames(names2, constants) {
          if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names2, constants);
          return this;
        }
        get names() {
          const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
          return addExprNames(names2, this.rhs);
        }
      }
      class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
        }
      }
      class Label extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          return `${this.label}:` + _n;
        }
      }
      class Break extends Node {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n;
        }
      }
      class Throw extends Node {
        constructor(error) {
          super();
          this.error = error;
        }
        render({ _n }) {
          return `throw ${this.error};` + _n;
        }
        get names() {
          return this.error.names;
        }
      }
      class AnyCode extends Node {
        constructor(code2) {
          super();
          this.code = code2;
        }
        render({ _n }) {
          return `${this.code};` + _n;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names2, constants) {
          this.code = optimizeExpr(this.code, names2, constants);
          return this;
        }
        get names() {
          return this.code instanceof code_1._CodeOrName ? this.code.names : {};
        }
      }
      class ParentNode extends Node {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i = nodes.length;
          while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
              nodes.splice(i, 1, ...n);
            else if (n)
              nodes[i] = n;
            else
              nodes.splice(i, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names2, constants) {
          const { nodes } = this;
          let i = nodes.length;
          while (i--) {
            const n = nodes[i];
            if (n.optimizeNames(names2, constants))
              continue;
            subtractNames(names2, n.names);
            nodes.splice(i, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      }
      class Root extends ParentNode {
      }
      class Else extends BlockNode {
      }
      Else.kind = "else";
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code2 = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code2 += "else " + this.else.render(opts);
          return code2;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e = this.else;
          if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
          }
          if (e) {
            if (cond === false)
              return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
              return this;
            return new If(not2(cond), e instanceof If ? [e] : e.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names2, constants) {
          var _a;
          this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
          if (!(super.optimizeNames(names2, constants) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          addExprNames(names2, this.condition);
          if (this.else)
            addNames(names2, this.else.names);
          return names2;
        }
      }
      If.kind = "if";
      class For extends BlockNode {
      }
      For.kind = "for";
      class ForLoop extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iteration = optimizeExpr(this.iteration, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from, to) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.from = from;
          this.to = to;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name, from, to } = this;
          return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
        }
        get names() {
          const names2 = addExprNames(super.names, this.from);
          return addExprNames(names2, this.to);
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names2, constants) {
          if (!super.optimizeNames(names2, constants))
            return;
          this.iterable = optimizeExpr(this.iterable, names2, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super();
          this.name = name;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      }
      Func.kind = "func";
      class Return extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      }
      Return.kind = "return";
      class Try extends BlockNode {
        render(opts) {
          let code2 = "try" + super.render(opts);
          if (this.catch)
            code2 += this.catch.render(opts);
          if (this.finally)
            code2 += this.finally.render(opts);
          return code2;
        }
        optimizeNodes() {
          var _a, _b;
          super.optimizeNodes();
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names2, constants) {
          var _a, _b;
          super.optimizeNames(names2, constants);
          (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
          return this;
        }
        get names() {
          const names2 = super.names;
          if (this.catch)
            addNames(names2, this.catch.names);
          if (this.finally)
            addNames(names2, this.finally.names);
          return names2;
        }
      }
      class Catch extends BlockNode {
        constructor(error) {
          super();
          this.error = error;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      }
      Catch.kind = "catch";
      class Finally extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      }
      Finally.kind = "finally";
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(prefix) {
          return this._scope.name(prefix);
        }
        // reserves unique name in the external scope
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value);
          const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
          vs.add(name);
          return name;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name.str] = rhs;
          this._leafNode(new Def(varKind, name, rhs));
          return name;
        }
        // `const` declaration (`var` in es5 mode)
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        // `var` declaration with optional assignment
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        // assignment code
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        // `+=` code
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
        }
        // appends passed SafeExpr to code or executes Block
        code(c) {
          if (typeof c == "function")
            c();
          else if (c !== code_1.nil)
            this._leafNode(new AnyCode(c));
          return this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...keyValues) {
          const code2 = ["{"];
          for (const [key, value] of keyValues) {
            if (code2.length > 1)
              code2.push(",");
            code2.push(key);
            if (key !== value || this.opts.es5) {
              code2.push(":");
              (0, code_1.addCodeArg)(code2, value);
            }
          }
          code2.push("}");
          return new code_1._Code(code2);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new Else());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        // `for` statement for a range of values
        forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
              this.var(name, (0, code_1._)`${arr}[${i}]`);
              forBody(name);
            });
          }
          return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
          }
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(For);
        }
        // `label` statement
        label(label) {
          return this._leafNode(new Label(label));
        }
        // `break` statement
        break(label) {
          return this._leafNode(new Break(label));
        }
        // `return` statement
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        // `try` statement
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        // `throw` statement
        throw(error) {
          return this._leafNode(new Throw(error));
        }
        // start self-balancing block
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        // end the current self-balancing block
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(name, args = code_1.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n = 1) {
          while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N1, N2) {
          const n = this._currNode;
          if (n instanceof N1 || N2 && n instanceof N2) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
        }
        _elseNode(node) {
          const n = this._currNode;
          if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns = this._nodes;
          return ns[ns.length - 1];
        }
        set _currNode(node) {
          const ns = this._nodes;
          ns[ns.length - 1] = node;
        }
      }
      exports.CodeGen = CodeGen;
      function addNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) + (from[n] || 0);
        return names2;
      }
      function addExprNames(names2, from) {
        return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
      }
      function optimizeExpr(expr, names2, constants) {
        if (expr instanceof code_1.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_1._Code(expr._items.reduce((items2, c) => {
          if (c instanceof code_1.Name)
            c = replaceName(c);
          if (c instanceof code_1._Code)
            items2.push(...c._items);
          else
            items2.push(c);
          return items2;
        }, []));
        function replaceName(n) {
          const c = constants[n.str];
          if (c === void 0 || names2[n.str] !== 1)
            return n;
          delete names2[n.str];
          return c;
        }
        function canOptimize(e) {
          return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
        }
      }
      function subtractNames(names2, from) {
        for (const n in from)
          names2[n] = (names2[n] || 0) - (from[n] || 0);
      }
      function not2(x) {
        return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
      }
      exports.not = not2;
      const andCode = mappend(exports.operators.AND);
      function and(...args) {
        return args.reduce(andCode);
      }
      exports.and = and;
      const orCode = mappend(exports.operators.OR);
      function or(...args) {
        return args.reduce(orCode);
      }
      exports.or = or;
      function mappend(op) {
        return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
      }
      function par(x) {
        return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
      }
    })(codegen);
    return codegen;
  }
  var util = {};
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil) return util;
    hasRequiredUtil = 1;
    Object.defineProperty(util, "__esModule", { value: true });
    util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
    const codegen_1 = requireCodegen();
    const code_1 = requireCode$1();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    util.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    util.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules2 = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules2[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    util.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules2) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules2[key])
          return true;
      return false;
    }
    util.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    util.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
    }
    util.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    util.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    util.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    util.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    util.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    util.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    util.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items2) => gen.var("items", items2)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    util.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
    }
    util.setEvaluated = setEvaluated;
    const snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    util.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (util.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    util.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    util.checkStrictMode = checkStrictMode;
    return util;
  }
  var names = {};
  var hasRequiredNames;
  function requireNames() {
    if (hasRequiredNames) return names;
    hasRequiredNames = 1;
    Object.defineProperty(names, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const names$1 = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    names.default = names$1;
    return names;
  }
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const names_1 = requireNames();
      exports.keywordError = {
        message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
      };
      exports.keyword$DataError = {
        message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
      };
      function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen, errObj);
        } else {
          returnErrors(it, (0, codegen_1._)`[${errObj}]`);
        }
      }
      exports.reportError = reportError;
      function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
        const { it } = cxt;
        const { gen, compositeRule, allErrors } = it;
        const errObj = errorObjectCode(cxt, error, errorPaths);
        addError(gen, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it, names_1.default.vErrors);
        }
      }
      exports.reportExtraError = reportExtraError;
      function resetErrorsCount(gen, errsCount) {
        gen.assign(names_1.default.errors, errsCount);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
      }
      exports.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen.name("err");
        gen.forRange("i", errsCount, names_1.default.errors, (i) => {
          gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
          gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
          gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
          if (it.opts.verbose) {
            gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
            gen.assign((0, codegen_1._)`${err}.data`, data);
          }
        });
      }
      exports.extendErrors = extendErrors;
      function addError(gen, errObj) {
        const err = gen.const("err", errObj);
        gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
        gen.code((0, codegen_1._)`${names_1.default.errors}++`);
      }
      function returnErrors(it, errs) {
        const { gen, validateName, schemaEnv } = it;
        if (schemaEnv.$async) {
          gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
          gen.return(false);
        }
      }
      const E = {
        keyword: new codegen_1.Name("keyword"),
        schemaPath: new codegen_1.Name("schemaPath"),
        // also used in JTD errors
        params: new codegen_1.Name("params"),
        propertyName: new codegen_1.Name("propertyName"),
        message: new codegen_1.Name("message"),
        schema: new codegen_1.Name("schema"),
        parentSchema: new codegen_1.Name("parentSchema")
      };
      function errorObjectCode(cxt, error, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return (0, codegen_1._)`{}`;
        return errorObject(cxt, error, errorPaths);
      }
      function errorObject(cxt, error, errorPaths = {}) {
        const { gen, it } = cxt;
        const keyValues = [
          errorInstancePath(it, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error, keyValues);
        return gen.object(...keyValues);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
        return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
        if (schemaPath) {
          schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
        }
        return [E.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword: keyword2, data, schemaValue, it } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it;
        keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
        if (opts.messages) {
          keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
        }
        if (propertyName)
          keyValues.push([E.propertyName, propertyName]);
      }
    })(errors);
    return errors;
  }
  var hasRequiredBoolSchema;
  function requireBoolSchema() {
    if (hasRequiredBoolSchema) return boolSchema;
    hasRequiredBoolSchema = 1;
    Object.defineProperty(boolSchema, "__esModule", { value: true });
    boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
    const errors_1 = requireErrors();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    boolSchema.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
    return boolSchema;
  }
  var dataType = {};
  var rules = {};
  var hasRequiredRules;
  function requireRules() {
    if (hasRequiredRules) return rules;
    hasRequiredRules = 1;
    Object.defineProperty(rules, "__esModule", { value: true });
    rules.getRules = rules.isJSONType = void 0;
    const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    const jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    rules.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    rules.getRules = getRules;
    return rules;
  }
  var applicability = {};
  var hasRequiredApplicability;
  function requireApplicability() {
    if (hasRequiredApplicability) return applicability;
    hasRequiredApplicability = 1;
    Object.defineProperty(applicability, "__esModule", { value: true });
    applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type2) {
      const group = self2.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    applicability.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    applicability.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    applicability.shouldUseRule = shouldUseRule;
    return applicability;
  }
  var hasRequiredDataType;
  function requireDataType() {
    if (hasRequiredDataType) return dataType;
    hasRequiredDataType = 1;
    Object.defineProperty(dataType, "__esModule", { value: true });
    dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
    const rules_1 = requireRules();
    const applicability_1 = requireApplicability();
    const errors_1 = requireErrors();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (dataType.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    dataType.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    dataType.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types2) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types2, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    dataType.coerceAndCheckDataType = coerceAndCheckDataType;
    const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types2, coerceTo) {
      const { gen, data, opts } = it;
      const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType2) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType2}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    dataType.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t in types2)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    dataType.checkDataTypes = checkDataTypes;
    const typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    dataType.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
    return dataType;
  }
  var defaults = {};
  var hasRequiredDefaults;
  function requireDefaults() {
    if (hasRequiredDefaults) return defaults;
    hasRequiredDefaults = 1;
    Object.defineProperty(defaults, "__esModule", { value: true });
    defaults.assignDefaults = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    function assignDefaults(it, ty) {
      const { properties: properties2, items: items2 } = it.schema;
      if (ty === "object" && properties2) {
        for (const key in properties2) {
          assignDefault(it, key, properties2[key].default);
        }
      } else if (ty === "array" && Array.isArray(items2)) {
        items2.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    defaults.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
    return defaults;
  }
  var keyword = {};
  var code = {};
  var hasRequiredCode;
  function requireCode() {
    if (hasRequiredCode) return code;
    hasRequiredCode = 1;
    Object.defineProperty(code, "__esModule", { value: true });
    code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const names_1 = requireNames();
    const util_2 = requireUtil();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    code.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
      return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    code.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    code.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    code.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    code.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    code.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    code.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    code.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p2]));
    }
    code.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    code.callValidateCode = callValidateCode;
    const newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern2) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern2, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
      });
    }
    code.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword: keyword2, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    code.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword: keyword2, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    code.validateUnion = validateUnion;
    return code;
  }
  var hasRequiredKeyword;
  function requireKeyword() {
    if (hasRequiredKeyword) return keyword;
    hasRequiredKeyword = 1;
    Object.defineProperty(keyword, "__esModule", { value: true });
    keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const code_1 = requireCode();
    const errors_1 = requireErrors();
    function macroKeywordCode(cxt, def2) {
      const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
      const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    keyword.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def2) {
      var _a;
      const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def2);
      const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
      const validateRef = useKeyword(gen, keyword2, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def2.errors === false) {
          assignValid();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def2.async ? validateAsync() : validateSync();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def2.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def2 && !$data || def2.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
      }
      function reportErrs(errors2) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
      }
    }
    keyword.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def2) {
      if (def2.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    keyword.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
      if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def2.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def2.validateSchema) {
        const valid = def2.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    keyword.validateKeywordUsage = validateKeywordUsage;
    return keyword;
  }
  var subschema = {};
  var hasRequiredSubschema;
  function requireSubschema() {
    if (hasRequiredSubschema) return subschema;
    hasRequiredSubschema = 1;
    Object.defineProperty(subschema, "__esModule", { value: true });
    subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    subschema.getSubschema = getSubschema;
    function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema2.propertyName = propertyName;
      }
      if (dataTypes)
        subschema2.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema2.data = _nextData;
        subschema2.dataLevel = it.dataLevel + 1;
        subschema2.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema2.parentData = it.data;
        subschema2.dataNames = [...it.dataNames, _nextData];
      }
    }
    subschema.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema2.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema2.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema2.allErrors = allErrors;
      subschema2.jtdDiscriminator = jtdDiscriminator;
      subschema2.jtdMetadata = jtdMetadata;
    }
    subschema.extendSubschemaMode = extendSubschemaMode;
    return subschema;
  }
  var resolve = {};
  var fastDeepEqual;
  var hasRequiredFastDeepEqual;
  function requireFastDeepEqual() {
    if (hasRequiredFastDeepEqual) return fastDeepEqual;
    hasRequiredFastDeepEqual = 1;
    fastDeepEqual = function equal2(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
    return fastDeepEqual;
  }
  var jsonSchemaTraverse = { exports: {} };
  var hasRequiredJsonSchemaTraverse;
  function requireJsonSchemaTraverse() {
    if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
    hasRequiredJsonSchemaTraverse = 1;
    var traverse2 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse2.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse2.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse2.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse2.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse2.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse2.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse2.keywords || opts.allKeys && !(key in traverse2.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    return jsonSchemaTraverse.exports;
  }
  var hasRequiredResolve;
  function requireResolve() {
    if (hasRequiredResolve) return resolve;
    hasRequiredResolve = 1;
    Object.defineProperty(resolve, "__esModule", { value: true });
    resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
    const util_1 = requireUtil();
    const equal2 = requireFastDeepEqual();
    const traverse2 = requireJsonSchemaTraverse();
    const SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit2 = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit2 === true)
        return !hasRef(schema);
      if (!limit2)
        return false;
      return countKeys(schema) <= limit2;
    }
    resolve.inlineRef = inlineRef;
    const REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize) {
      if (normalize !== false)
        id2 = normalizeId(id2);
      const p2 = resolver.parse(id2);
      return _getFullPath(resolver, p2);
    }
    resolve.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    resolve._getFullPath = _getFullPath;
    const TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    resolve.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    resolve.resolveUrl = resolveUrl;
    const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref2) {
          const _resolve = this.opts.uriResolver.resolve;
          ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
          if (schemaRefs.has(ref2))
            throw ambiguos(ref2);
          schemaRefs.add(ref2);
          let schOrRef = this.refs[ref2];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref2);
          } else if (ref2 !== normalizeId(fullPath)) {
            if (ref2[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref2], ref2);
              localRefs[ref2] = sch;
            } else {
              this.refs[ref2] = fullPath;
            }
          }
          return ref2;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref2) {
        if (sch2 !== void 0 && !equal2(sch1, sch2))
          throw ambiguos(ref2);
      }
      function ambiguos(ref2) {
        return new Error(`reference "${ref2}" resolves to more than one schema`);
      }
    }
    resolve.getSchemaRefs = getSchemaRefs;
    return resolve;
  }
  var hasRequiredValidate;
  function requireValidate() {
    if (hasRequiredValidate) return validate;
    hasRequiredValidate = 1;
    Object.defineProperty(validate, "__esModule", { value: true });
    validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
    const boolSchema_1 = requireBoolSchema();
    const dataType_1 = requireDataType();
    const applicability_1 = requireApplicability();
    const dataType_2 = requireDataType();
    const defaults_1 = requireDefaults();
    const keyword_1 = requireKeyword();
    const subschema_1 = requireSubschema();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const resolve_1 = requireResolve();
    const util_1 = requireUtil();
    const errors_1 = requireErrors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    validate.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
      schemaKeywords(it, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items: items2 }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items2 instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
    }
    function schemaKeywords(it, types2, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types2);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types2) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types2);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types2);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types2) {
      if (!types2.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types2;
        return;
      }
      types2.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types2);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules2 = it.self.RULES.all;
      for (const keyword2 in rules2) {
        const rule = rules2[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    class KeywordCxt {
      constructor(it, def2, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword2;
        this.data = it.data;
        this.schema = it.schema[keyword2];
        this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
        this.schemaType = def2.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def2;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
          }
        }
        if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def: def2 } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def2.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def: def2, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def2.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema2, appl);
        const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    }
    validate.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword2, def2, ruleType) {
      const cxt = new KeywordCxt(it, def2, keyword2);
      if ("code" in def2) {
        def2.code(cxt, ruleType);
      } else if (cxt.$data && def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      } else if ("macro" in def2) {
        (0, keyword_1.macroKeywordCode)(cxt, def2);
      } else if (def2.compile || def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    validate.getData = getData;
    return validate;
  }
  var validation_error = {};
  var hasRequiredValidation_error;
  function requireValidation_error() {
    if (hasRequiredValidation_error) return validation_error;
    hasRequiredValidation_error = 1;
    Object.defineProperty(validation_error, "__esModule", { value: true });
    class ValidationError extends Error {
      constructor(errors2) {
        super("validation failed");
        this.errors = errors2;
        this.ajv = this.validation = true;
      }
    }
    validation_error.default = ValidationError;
    return validation_error;
  }
  var ref_error = {};
  var hasRequiredRef_error;
  function requireRef_error() {
    if (hasRequiredRef_error) return ref_error;
    hasRequiredRef_error = 1;
    Object.defineProperty(ref_error, "__esModule", { value: true });
    const resolve_1 = requireResolve();
    class MissingRefError extends Error {
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    }
    ref_error.default = MissingRefError;
    return ref_error;
  }
  var compile = {};
  var hasRequiredCompile;
  function requireCompile() {
    if (hasRequiredCompile) return compile;
    hasRequiredCompile = 1;
    Object.defineProperty(compile, "__esModule", { value: true });
    compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
    const codegen_1 = requireCodegen();
    const validation_error_1 = requireValidation_error();
    const names_1 = requireNames();
    const resolve_1 = requireResolve();
    const util_1 = requireUtil();
    const validate_1 = requireValidate();
    class SchemaEnv {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    }
    compile.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items: items2 } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items2 instanceof codegen_1.Name ? void 0 : items2,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items2 instanceof codegen_1.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    compile.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref2) {
      var _a;
      ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
      const schOrFunc = root.refs[ref2];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve2.call(this, root, ref2);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    compile.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    compile.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve2(root, ref2) {
      let sch;
      while (typeof (sch = this.refs[ref2]) == "string")
        ref2 = sch;
      return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    function resolveSchema(root, ref2) {
      const p2 = this.opts.uriResolver.parse(ref2);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref2)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    compile.resolveSchema = resolveSchema;
    const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
    return compile;
  }
  const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
  const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
  const type$1 = "object";
  const required$1 = ["$data"];
  const properties$2 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
  const additionalProperties$1 = false;
  const require$$9 = {
    $id: $id$1,
    description,
    type: type$1,
    required: required$1,
    properties: properties$2,
    additionalProperties: additionalProperties$1
  };
  var uri = {};
  var fastUri = { exports: {} };
  var scopedChars;
  var hasRequiredScopedChars;
  function requireScopedChars() {
    if (hasRequiredScopedChars) return scopedChars;
    hasRequiredScopedChars = 1;
    const HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    scopedChars = {
      HEX
    };
    return scopedChars;
  }
  var utils;
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils;
    hasRequiredUtils = 1;
    const { HEX } = requireScopedChars();
    const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(IPV4_REG) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer2 = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer2.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer2);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer2.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer2.push(cursor);
          continue;
        }
      }
      if (buffer2.length) {
        if (isZone) {
          output.zone = buffer2.join("");
        } else if (endIpv6) {
          address.push(buffer2.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer2));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    const RDS1 = /^\.\.?\//u;
    const RDS2 = /^\/\.(?:\/|$)/u;
    const RDS3 = /^\/\.\.(?:\/|$)/u;
    const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    utils = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
    return utils;
  }
  var schemes;
  var hasRequiredSchemes;
  function requireSchemes() {
    if (hasRequiredSchemes) return schemes;
    hasRequiredSchemes = 1;
    const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    const http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    const https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    const ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    const wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    const urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    const urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    const SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    schemes = SCHEMES;
    return schemes;
  }
  var hasRequiredFastUri;
  function requireFastUri() {
    if (hasRequiredFastUri) return fastUri.exports;
    hasRequiredFastUri = 1;
    const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils();
    const SCHEMES = requireSchemes();
    function normalize(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse(uri2, options), options);
      } else if (typeof uri2 === "object") {
        uri2 = parse(serialize(uri2, options), options);
      }
      return uri2;
    }
    function resolve2(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal2(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code2 = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code2 = value.charCodeAt(i);
        if (code2 > 126 || hexLookUp[code2]) {
          return true;
        }
      }
      return false;
    }
    const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri2, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri2.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
      const matches = uri2.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    const fastUri$1 = {
      SCHEMES,
      normalize,
      resolve: resolve2,
      resolveComponents,
      equal: equal2,
      serialize,
      parse
    };
    fastUri.exports = fastUri$1;
    fastUri.exports.default = fastUri$1;
    fastUri.exports.fastUri = fastUri$1;
    return fastUri.exports;
  }
  var hasRequiredUri;
  function requireUri() {
    if (hasRequiredUri) return uri;
    hasRequiredUri = 1;
    Object.defineProperty(uri, "__esModule", { value: true });
    const uri$1 = requireFastUri();
    uri$1.code = 'require("ajv/dist/runtime/uri").default';
    uri.default = uri$1;
    return uri;
  }
  var hasRequiredCore$1;
  function requireCore$1() {
    if (hasRequiredCore$1) return core$1;
    hasRequiredCore$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
      var validate_1 = requireValidate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = requireCodegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      const validation_error_1 = requireValidation_error();
      const ref_error_1 = requireRef_error();
      const rules_1 = requireRules();
      const compile_1 = requireCompile();
      const codegen_2 = requireCodegen();
      const resolve_1 = requireResolve();
      const dataType_1 = requireDataType();
      const util_1 = requireUtil();
      const $dataRefSchema = require$$9;
      const uri_1 = requireUri();
      const defaultRegExp = (str, flags) => new RegExp(str, flags);
      defaultRegExp.code = "new RegExp";
      const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
      const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]);
      const removedOptions = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      };
      const deprecatedOptions = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      };
      const MAX_EXPRESSION = 200;
      function requiredOptions(o) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        const s = o.strict;
        const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
        const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
        const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
        const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
        return {
          strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
          strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
          strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
          strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
          strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
          code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
          loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
          loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
          meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
          messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
          inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
          schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
          addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
          validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
          validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
          unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
          int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
          uriResolver
        };
      }
      class Ajv2 {
        constructor(opts = {}) {
          this.schemas = {};
          this.refs = {};
          this.formats = {};
          this._compilations = /* @__PURE__ */ new Set();
          this._loading = {};
          this._cache = /* @__PURE__ */ new Map();
          opts = this.opts = { ...opts, ...requiredOptions(opts) };
          const { es5, lines } = this.opts.code;
          this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
          this.logger = getLogger(opts.logger);
          const formatOpt = opts.validateFormats;
          opts.validateFormats = false;
          this.RULES = (0, rules_1.getRules)();
          checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
          checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
          this._metaOpts = getMetaSchemaOptions.call(this);
          if (opts.formats)
            addInitialFormats.call(this);
          this._addVocabularies();
          this._addDefaultMetaSchema();
          if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
          if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
          addInitialSchemas.call(this);
          opts.validateFormats = formatOpt;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data, meta, schemaId } = this.opts;
          let _dataRefSchema = $dataRefSchema;
          if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
          }
          if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
        }
        defaultMeta() {
          const { meta, schemaId } = this.opts;
          return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
        }
        validate(schemaKeyRef, data) {
          let v;
          if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
              throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
          } else {
            v = this.compile(schemaKeyRef);
          }
          const valid = v(data);
          if (!("$async" in v))
            this.errors = v.errors;
          return valid;
        }
        compile(schema, _meta) {
          const sch = this._addSchema(schema, _meta);
          return sch.validate || this._compileSchemaEnv(sch);
        }
        compileAsync(schema, meta) {
          if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
          }
          const { loadSchema } = this.opts;
          return runCompileAsync.call(this, schema, meta);
          async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          }
          async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
              await runCompileAsync.call(this, { $ref }, true);
            }
          }
          async function _compileAsync(sch) {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_1.default))
                throw e;
              checkLoaded.call(this, e);
              await loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          }
          function checkLoaded({ missingSchema: ref2, missingRef }) {
            if (this.refs[ref2]) {
              throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
            }
          }
          async function loadMissingSchema(ref2) {
            const _schema = await _loadSchema.call(this, ref2);
            if (!this.refs[ref2])
              await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref2])
              this.addSchema(_schema, ref2, meta);
          }
          async function _loadSchema(ref2) {
            const p2 = this._loading[ref2];
            if (p2)
              return p2;
            try {
              return await (this._loading[ref2] = loadSchema(ref2));
            } finally {
              delete this._loading[ref2];
            }
          }
        }
        // Adds schema to the instance
        addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
          if (Array.isArray(schema)) {
            for (const sch of schema)
              this.addSchema(sch, void 0, _meta, _validateSchema);
            return this;
          }
          let id2;
          if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id2 = schema[schemaId];
            if (id2 !== void 0 && typeof id2 != "string") {
              throw new Error(`schema ${schemaId} must be string`);
            }
          }
          key = (0, resolve_1.normalizeId)(key || id2);
          this._checkUnique(key);
          this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
          return this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
          this.addSchema(schema, key, true, _validateSchema);
          return this;
        }
        //  Validate schema against its meta-schema
        validateSchema(schema, throwOrLogError) {
          if (typeof schema == "boolean")
            return true;
          let $schema2;
          $schema2 = schema.$schema;
          if ($schema2 !== void 0 && typeof $schema2 != "string") {
            throw new Error("$schema must be a string");
          }
          $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
          if (!$schema2) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
          }
          const valid = this.validate($schema2, schema);
          if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(message);
            else
              throw new Error(message);
          }
          return valid;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(keyRef) {
          let sch;
          while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
          if (sch === void 0) {
            const { schemaId } = this.opts;
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
              return;
            this.refs[keyRef] = sch;
          }
          return sch.validate || this._compileSchemaEnv(sch);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(schemaKeyRef) {
          if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
          }
          switch (typeof schemaKeyRef) {
            case "undefined":
              this._removeAllSchemas(this.schemas);
              this._removeAllSchemas(this.refs);
              this._cache.clear();
              return this;
            case "string": {
              const sch = getSchEnv.call(this, schemaKeyRef);
              if (typeof sch == "object")
                this._cache.delete(sch.schema);
              delete this.schemas[schemaKeyRef];
              delete this.refs[schemaKeyRef];
              return this;
            }
            case "object": {
              const cacheKey = schemaKeyRef;
              this._cache.delete(cacheKey);
              let id2 = schemaKeyRef[this.opts.schemaId];
              if (id2) {
                id2 = (0, resolve_1.normalizeId)(id2);
                delete this.schemas[id2];
                delete this.refs[id2];
              }
              return this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(definitions2) {
          for (const def2 of definitions2)
            this.addKeyword(def2);
          return this;
        }
        addKeyword(kwdOrDef, def2) {
          let keyword2;
          if (typeof kwdOrDef == "string") {
            keyword2 = kwdOrDef;
            if (typeof def2 == "object") {
              this.logger.warn("these parameters are deprecated, see docs for addKeyword");
              def2.keyword = keyword2;
            }
          } else if (typeof kwdOrDef == "object" && def2 === void 0) {
            def2 = kwdOrDef;
            keyword2 = def2.keyword;
            if (Array.isArray(keyword2) && !keyword2.length) {
              throw new Error("addKeywords: keyword must be string or non-empty array");
            }
          } else {
            throw new Error("invalid addKeywords parameters");
          }
          checkKeyword.call(this, keyword2, def2);
          if (!def2) {
            (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
            return this;
          }
          keywordMetaschema.call(this, def2);
          const definition = {
            ...def2,
            type: (0, dataType_1.getJSONTypes)(def2.type),
            schemaType: (0, dataType_1.getJSONTypes)(def2.schemaType)
          };
          (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
          return this;
        }
        getKeyword(keyword2) {
          const rule = this.RULES.all[keyword2];
          return typeof rule == "object" ? rule.definition : !!rule;
        }
        // Remove keyword
        removeKeyword(keyword2) {
          const { RULES } = this;
          delete RULES.keywords[keyword2];
          delete RULES.all[keyword2];
          for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
            if (i >= 0)
              group.rules.splice(i, 1);
          }
          return this;
        }
        // Add format
        addFormat(name, format2) {
          if (typeof format2 == "string")
            format2 = new RegExp(format2);
          this.formats[name] = format2;
          return this;
        }
        errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
          if (!errors2 || errors2.length === 0)
            return "No errors";
          return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
        }
        $dataMetaSchema(metaSchema, keywordsJsonPointers) {
          const rules2 = this.RULES.all;
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1);
            let keywords = metaSchema;
            for (const seg of segments)
              keywords = keywords[seg];
            for (const key in rules2) {
              const rule = rules2[key];
              if (typeof rule != "object")
                continue;
              const { $data } = rule.definition;
              const schema = keywords[key];
              if ($data && schema)
                keywords[key] = schemaOrData(schema);
            }
          }
          return metaSchema;
        }
        _removeAllSchemas(schemas, regex) {
          for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
              if (typeof sch == "string") {
                delete schemas[keyRef];
              } else if (sch && !sch.meta) {
                this._cache.delete(sch.schema);
                delete schemas[keyRef];
              }
            }
          }
        }
        _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
          let id2;
          const { schemaId } = this.opts;
          if (typeof schema == "object") {
            id2 = schema[schemaId];
          } else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            else if (typeof schema != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let sch = this._cache.get(schema);
          if (sch !== void 0)
            return sch;
          baseId = (0, resolve_1.normalizeId)(id2 || baseId);
          const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
          sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
          this._cache.set(sch.schema, sch);
          if (addSchema && !baseId.startsWith("#")) {
            if (baseId)
              this._checkUnique(baseId);
            this.refs[baseId] = sch;
          }
          if (validateSchema)
            this.validateSchema(schema, true);
          return sch;
        }
        _checkUnique(id2) {
          if (this.schemas[id2] || this.refs[id2]) {
            throw new Error(`schema with key or id "${id2}" already exists`);
          }
        }
        _compileSchemaEnv(sch) {
          if (sch.meta)
            this._compileMetaSchema(sch);
          else
            compile_1.compileSchema.call(this, sch);
          if (!sch.validate)
            throw new Error("ajv implementation error");
          return sch.validate;
        }
        _compileMetaSchema(sch) {
          const currentOpts = this.opts;
          this.opts = this._metaOpts;
          try {
            compile_1.compileSchema.call(this, sch);
          } finally {
            this.opts = currentOpts;
          }
        }
      }
      Ajv2.ValidationError = validation_error_1.default;
      Ajv2.MissingRefError = ref_error_1.default;
      exports.default = Ajv2;
      function checkOptions(checkOpts, options, msg, log = "error") {
        for (const key in checkOpts) {
          const opt = key;
          if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
        }
      }
      function getSchEnv(keyRef) {
        keyRef = (0, resolve_1.normalizeId)(keyRef);
        return this.schemas[keyRef] || this.refs[keyRef];
      }
      function addInitialSchemas() {
        const optsSchemas = this.opts.schemas;
        if (!optsSchemas)
          return;
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats() {
        for (const name in this.opts.formats) {
          const format2 = this.opts.formats[name];
          if (format2)
            this.addFormat(name, format2);
        }
      }
      function addInitialKeywords(defs) {
        if (Array.isArray(defs)) {
          this.addVocabulary(defs);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const keyword2 in defs) {
          const def2 = defs[keyword2];
          if (!def2.keyword)
            def2.keyword = keyword2;
          this.addKeyword(def2);
        }
      }
      function getMetaSchemaOptions() {
        const metaOpts = { ...this.opts };
        for (const opt of META_IGNORE_OPTIONS)
          delete metaOpts[opt];
        return metaOpts;
      }
      const noLogs = { log() {
      }, warn() {
      }, error() {
      } };
      function getLogger(logger) {
        if (logger === false)
          return noLogs;
        if (logger === void 0)
          return console;
        if (logger.log && logger.warn && logger.error)
          return logger;
        throw new Error("logger must implement log, warn and error methods");
      }
      const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
      function checkKeyword(keyword2, def2) {
        const { RULES } = this;
        (0, util_1.eachItem)(keyword2, (kwd) => {
          if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
          if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
        });
        if (!def2)
          return;
        if (def2.$data && !("code" in def2 || "validate" in def2)) {
          throw new Error('$data keyword must have "code" or "validate" function');
        }
      }
      function addRule(keyword2, definition, dataType2) {
        var _a;
        const post = definition === null || definition === void 0 ? void 0 : definition.post;
        if (dataType2 && post)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES } = this;
        let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.rules.push(ruleGroup);
        }
        RULES.keywords[keyword2] = true;
        if (!definition)
          return;
        const rule = {
          keyword: keyword2,
          definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
          }
        };
        if (definition.before)
          addBeforeRule.call(this, ruleGroup, rule, definition.before);
        else
          ruleGroup.rules.push(rule);
        RULES.all[keyword2] = rule;
        (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
      }
      function addBeforeRule(ruleGroup, rule, before) {
        const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
        if (i >= 0) {
          ruleGroup.rules.splice(i, 0, rule);
        } else {
          ruleGroup.rules.push(rule);
          this.logger.warn(`rule ${before} is not defined`);
        }
      }
      function keywordMetaschema(def2) {
        let { metaSchema } = def2;
        if (metaSchema === void 0)
          return;
        if (def2.$data && this.opts.$data)
          metaSchema = schemaOrData(metaSchema);
        def2.validateSchema = this.compile(metaSchema, true);
      }
      const $dataRef = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function schemaOrData(schema) {
        return { anyOf: [schema, $dataRef] };
      }
    })(core$1);
    return core$1;
  }
  var draft7 = {};
  var core = {};
  var id = {};
  var hasRequiredId;
  function requireId() {
    if (hasRequiredId) return id;
    hasRequiredId = 1;
    Object.defineProperty(id, "__esModule", { value: true });
    const def2 = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    id.default = def2;
    return id;
  }
  var ref = {};
  var hasRequiredRef;
  function requireRef() {
    if (hasRequiredRef) return ref;
    hasRequiredRef = 1;
    Object.defineProperty(ref, "__esModule", { value: true });
    ref.callRef = ref.getValidate = void 0;
    const ref_error_1 = requireRef_error();
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const compile_1 = requireCompile();
    const util_1 = requireUtil();
    const def2 = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    ref.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items2, it.items, codegen_1.Name);
          }
        }
      }
    }
    ref.callRef = callRef;
    ref.default = def2;
    return ref;
  }
  var hasRequiredCore;
  function requireCore() {
    if (hasRequiredCore) return core;
    hasRequiredCore = 1;
    Object.defineProperty(core, "__esModule", { value: true });
    const id_1 = requireId();
    const ref_1 = requireRef();
    const core$12 = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    core.default = core$12;
    return core;
  }
  var validation = {};
  var limitNumber = {};
  var hasRequiredLimitNumber;
  function requireLimitNumber() {
    if (hasRequiredLimitNumber) return limitNumber;
    hasRequiredLimitNumber = 1;
    Object.defineProperty(limitNumber, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const ops = codegen_1.operators;
    const KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    const error = {
      message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    limitNumber.default = def2;
    return limitNumber;
  }
  var multipleOf = {};
  var hasRequiredMultipleOf;
  function requireMultipleOf() {
    if (hasRequiredMultipleOf) return multipleOf;
    hasRequiredMultipleOf = 1;
    Object.defineProperty(multipleOf, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    const def2 = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    multipleOf.default = def2;
    return multipleOf;
  }
  var limitLength = {};
  var ucs2length = {};
  var hasRequiredUcs2length;
  function requireUcs2length() {
    if (hasRequiredUcs2length) return ucs2length;
    hasRequiredUcs2length = 1;
    Object.defineProperty(ucs2length, "__esModule", { value: true });
    function ucs2length$1(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    ucs2length.default = ucs2length$1;
    ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
    return ucs2length;
  }
  var hasRequiredLimitLength;
  function requireLimitLength() {
    if (hasRequiredLimitLength) return limitLength;
    hasRequiredLimitLength = 1;
    Object.defineProperty(limitLength, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const ucs2length_1 = requireUcs2length();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode, it } = cxt;
        const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    limitLength.default = def2;
    return limitLength;
  }
  var pattern = {};
  var hasRequiredPattern;
  function requirePattern() {
    if (hasRequiredPattern) return pattern;
    hasRequiredPattern = 1;
    Object.defineProperty(pattern, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    const def2 = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    pattern.default = def2;
    return pattern;
  }
  var limitProperties = {};
  var hasRequiredLimitProperties;
  function requireLimitProperties() {
    if (hasRequiredLimitProperties) return limitProperties;
    hasRequiredLimitProperties = 1;
    Object.defineProperty(limitProperties, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    limitProperties.default = def2;
    return limitProperties;
  }
  var required = {};
  var hasRequiredRequired;
  function requireRequired() {
    if (hasRequiredRequired) return required;
    hasRequiredRequired = 1;
    Object.defineProperty(required, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    const def2 = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    required.default = def2;
    return required;
  }
  var limitItems = {};
  var hasRequiredLimitItems;
  function requireLimitItems() {
    if (hasRequiredLimitItems) return limitItems;
    hasRequiredLimitItems = 1;
    Object.defineProperty(limitItems, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message({ keyword: keyword2, schemaCode }) {
        const comp = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    const def2 = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword: keyword2, data, schemaCode } = cxt;
        const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    limitItems.default = def2;
    return limitItems;
  }
  var uniqueItems = {};
  var equal = {};
  var hasRequiredEqual;
  function requireEqual() {
    if (hasRequiredEqual) return equal;
    hasRequiredEqual = 1;
    Object.defineProperty(equal, "__esModule", { value: true });
    const equal$1 = requireFastDeepEqual();
    equal$1.code = 'require("ajv/dist/runtime/equal").default';
    equal.default = equal$1;
    return equal;
  }
  var hasRequiredUniqueItems;
  function requireUniqueItems() {
    if (hasRequiredUniqueItems) return uniqueItems;
    hasRequiredUniqueItems = 1;
    Object.defineProperty(uniqueItems, "__esModule", { value: true });
    const dataType_1 = requireDataType();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    const def2 = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    uniqueItems.default = def2;
    return uniqueItems;
  }
  var _const = {};
  var hasRequired_const;
  function require_const() {
    if (hasRequired_const) return _const;
    hasRequired_const = 1;
    Object.defineProperty(_const, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    const def2 = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    _const.default = def2;
    return _const;
  }
  var _enum = {};
  var hasRequired_enum;
  function require_enum() {
    if (hasRequired_enum) return _enum;
    hasRequired_enum = 1;
    Object.defineProperty(_enum, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const equal_1 = requireEqual();
    const error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    const def2 = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    _enum.default = def2;
    return _enum;
  }
  var hasRequiredValidation;
  function requireValidation() {
    if (hasRequiredValidation) return validation;
    hasRequiredValidation = 1;
    Object.defineProperty(validation, "__esModule", { value: true });
    const limitNumber_1 = requireLimitNumber();
    const multipleOf_1 = requireMultipleOf();
    const limitLength_1 = requireLimitLength();
    const pattern_1 = requirePattern();
    const limitProperties_1 = requireLimitProperties();
    const required_1 = requireRequired();
    const limitItems_1 = requireLimitItems();
    const uniqueItems_1 = requireUniqueItems();
    const const_1 = require_const();
    const enum_1 = require_enum();
    const validation$1 = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    validation.default = validation$1;
    return validation;
  }
  var applicator = {};
  var additionalItems = {};
  var hasRequiredAdditionalItems;
  function requireAdditionalItems() {
    if (hasRequiredAdditionalItems) return additionalItems;
    hasRequiredAdditionalItems = 1;
    Object.defineProperty(additionalItems, "__esModule", { value: true });
    additionalItems.validateAdditionalItems = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    const def2 = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items: items2 } = parentSchema;
        if (!Array.isArray(items2)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items2);
      }
    };
    function validateAdditionalItems(cxt, items2) {
      const { gen, schema, data, keyword: keyword2, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items2.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items2.length, len, (i) => {
          cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    additionalItems.validateAdditionalItems = validateAdditionalItems;
    additionalItems.default = def2;
    return additionalItems;
  }
  var prefixItems = {};
  var items = {};
  var hasRequiredItems;
  function requireItems() {
    if (hasRequiredItems) return items;
    hasRequiredItems = 1;
    Object.defineProperty(items, "__esModule", { value: true });
    items.validateTuple = void 0;
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const code_1 = requireCode();
    const def2 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    items.validateTuple = validateTuple;
    items.default = def2;
    return items;
  }
  var hasRequiredPrefixItems;
  function requirePrefixItems() {
    if (hasRequiredPrefixItems) return prefixItems;
    hasRequiredPrefixItems = 1;
    Object.defineProperty(prefixItems, "__esModule", { value: true });
    const items_1 = requireItems();
    const def2 = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    prefixItems.default = def2;
    return prefixItems;
  }
  var items2020 = {};
  var hasRequiredItems2020;
  function requireItems2020() {
    if (hasRequiredItems2020) return items2020;
    hasRequiredItems2020 = 1;
    Object.defineProperty(items2020, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const code_1 = requireCode();
    const additionalItems_1 = requireAdditionalItems();
    const error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    const def2 = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems: prefixItems2 } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems2)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    items2020.default = def2;
    return items2020;
  }
  var contains = {};
  var hasRequiredContains;
  function requireContains() {
    if (hasRequiredContains) return contains;
    hasRequiredContains = 1;
    Object.defineProperty(contains, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    const def2 = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    contains.default = def2;
    return contains;
  }
  var dependencies = {};
  var hasRequiredDependencies;
  function requireDependencies() {
    if (hasRequiredDependencies) return dependencies;
    hasRequiredDependencies = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const code_1 = requireCode();
      exports.error = {
        message: ({ params: { property, depsCount, deps } }) => {
          const property_ies = depsCount === 1 ? "property" : "properties";
          return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
        },
        params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        // TODO change to reference
      };
      const def2 = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: exports.error,
        code(cxt) {
          const [propDeps, schDeps] = splitDependencies(cxt);
          validatePropertyDeps(cxt, propDeps);
          validateSchemaDeps(cxt, schDeps);
        }
      };
      function splitDependencies({ schema }) {
        const propertyDeps = {};
        const schemaDeps = {};
        for (const key in schema) {
          if (key === "__proto__")
            continue;
          const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
          deps[key] = schema[key];
        }
        return [propertyDeps, schemaDeps];
      }
      function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
        const { gen, data, it } = cxt;
        if (Object.keys(propertyDeps).length === 0)
          return;
        const missing = gen.let("missing");
        for (const prop in propertyDeps) {
          const deps = propertyDeps[prop];
          if (deps.length === 0)
            continue;
          const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
          cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", ")
          });
          if (it.allErrors) {
            gen.if(hasProperty, () => {
              for (const depProp of deps) {
                (0, code_1.checkReportMissingProp)(cxt, depProp);
              }
            });
          } else {
            gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
      }
      exports.validatePropertyDeps = validatePropertyDeps;
      function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
        const { gen, data, keyword: keyword2, it } = cxt;
        const valid = gen.name("valid");
        for (const prop in schemaDeps) {
          if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
            continue;
          gen.if(
            (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
            () => {
              const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
              cxt.mergeValidEvaluated(schCxt, valid);
            },
            () => gen.var(valid, true)
            // TODO var
          );
          cxt.ok(valid);
        }
      }
      exports.validateSchemaDeps = validateSchemaDeps;
      exports.default = def2;
    })(dependencies);
    return dependencies;
  }
  var propertyNames = {};
  var hasRequiredPropertyNames;
  function requirePropertyNames() {
    if (hasRequiredPropertyNames) return propertyNames;
    hasRequiredPropertyNames = 1;
    Object.defineProperty(propertyNames, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    const def2 = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    propertyNames.default = def2;
    return propertyNames;
  }
  var additionalProperties = {};
  var hasRequiredAdditionalProperties;
  function requireAdditionalProperties() {
    if (hasRequiredAdditionalProperties) return additionalProperties;
    hasRequiredAdditionalProperties = 1;
    Object.defineProperty(additionalProperties, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const names_1 = requireNames();
    const util_1 = requireUtil();
    const error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    const def2 = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors2) {
          const subschema2 = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors2 === false) {
            Object.assign(subschema2, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema2, valid);
        }
      }
    };
    additionalProperties.default = def2;
    return additionalProperties;
  }
  var properties$1 = {};
  var hasRequiredProperties;
  function requireProperties() {
    if (hasRequiredProperties) return properties$1;
    hasRequiredProperties = 1;
    Object.defineProperty(properties$1, "__esModule", { value: true });
    const validate_1 = requireValidate();
    const code_1 = requireCode();
    const util_1 = requireUtil();
    const additionalProperties_1 = requireAdditionalProperties();
    const def2 = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties2 = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (properties2.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties2) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    properties$1.default = def2;
    return properties$1;
  }
  var patternProperties = {};
  var hasRequiredPatternProperties;
  function requirePatternProperties() {
    if (hasRequiredPatternProperties) return patternProperties;
    hasRequiredPatternProperties = 1;
    Object.defineProperty(patternProperties, "__esModule", { value: true });
    const code_1 = requireCode();
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const util_2 = requireUtil();
    const def2 = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    patternProperties.default = def2;
    return patternProperties;
  }
  var not = {};
  var hasRequiredNot;
  function requireNot() {
    if (hasRequiredNot) return not;
    hasRequiredNot = 1;
    Object.defineProperty(not, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    not.default = def2;
    return not;
  }
  var anyOf = {};
  var hasRequiredAnyOf;
  function requireAnyOf() {
    if (hasRequiredAnyOf) return anyOf;
    hasRequiredAnyOf = 1;
    Object.defineProperty(anyOf, "__esModule", { value: true });
    const code_1 = requireCode();
    const def2 = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    anyOf.default = def2;
    return anyOf;
  }
  var oneOf = {};
  var hasRequiredOneOf;
  function requireOneOf() {
    if (hasRequiredOneOf) return oneOf;
    hasRequiredOneOf = 1;
    Object.defineProperty(oneOf, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    const def2 = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    oneOf.default = def2;
    return oneOf;
  }
  var allOf = {};
  var hasRequiredAllOf;
  function requireAllOf() {
    if (hasRequiredAllOf) return allOf;
    hasRequiredAllOf = 1;
    Object.defineProperty(allOf, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    allOf.default = def2;
    return allOf;
  }
  var _if = {};
  var hasRequired_if;
  function require_if() {
    if (hasRequired_if) return _if;
    hasRequired_if = 1;
    Object.defineProperty(_if, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const util_1 = requireUtil();
    const error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    const def2 = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
            else
              cxt.setParams({ ifClause: keyword2 });
          };
        }
      }
    };
    function hasSchema(it, keyword2) {
      const schema = it.schema[keyword2];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    _if.default = def2;
    return _if;
  }
  var thenElse = {};
  var hasRequiredThenElse;
  function requireThenElse() {
    if (hasRequiredThenElse) return thenElse;
    hasRequiredThenElse = 1;
    Object.defineProperty(thenElse, "__esModule", { value: true });
    const util_1 = requireUtil();
    const def2 = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: keyword2, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
      }
    };
    thenElse.default = def2;
    return thenElse;
  }
  var hasRequiredApplicator;
  function requireApplicator() {
    if (hasRequiredApplicator) return applicator;
    hasRequiredApplicator = 1;
    Object.defineProperty(applicator, "__esModule", { value: true });
    const additionalItems_1 = requireAdditionalItems();
    const prefixItems_1 = requirePrefixItems();
    const items_1 = requireItems();
    const items2020_1 = requireItems2020();
    const contains_1 = requireContains();
    const dependencies_1 = requireDependencies();
    const propertyNames_1 = requirePropertyNames();
    const additionalProperties_1 = requireAdditionalProperties();
    const properties_1 = requireProperties();
    const patternProperties_1 = requirePatternProperties();
    const not_1 = requireNot();
    const anyOf_1 = requireAnyOf();
    const oneOf_1 = requireOneOf();
    const allOf_1 = requireAllOf();
    const if_1 = require_if();
    const thenElse_1 = requireThenElse();
    function getApplicator(draft2020 = false) {
      const applicator2 = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator2.push(prefixItems_1.default, items2020_1.default);
      else
        applicator2.push(additionalItems_1.default, items_1.default);
      applicator2.push(contains_1.default);
      return applicator2;
    }
    applicator.default = getApplicator;
    return applicator;
  }
  var format$1 = {};
  var format = {};
  var hasRequiredFormat$1;
  function requireFormat$1() {
    if (hasRequiredFormat$1) return format;
    hasRequiredFormat$1 = 1;
    Object.defineProperty(format, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    const def2 = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    format.default = def2;
    return format;
  }
  var hasRequiredFormat;
  function requireFormat() {
    if (hasRequiredFormat) return format$1;
    hasRequiredFormat = 1;
    Object.defineProperty(format$1, "__esModule", { value: true });
    const format_1 = requireFormat$1();
    const format2 = [format_1.default];
    format$1.default = format2;
    return format$1;
  }
  var metadata = {};
  var hasRequiredMetadata;
  function requireMetadata() {
    if (hasRequiredMetadata) return metadata;
    hasRequiredMetadata = 1;
    Object.defineProperty(metadata, "__esModule", { value: true });
    metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
    metadata.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    metadata.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
    return metadata;
  }
  var hasRequiredDraft7;
  function requireDraft7() {
    if (hasRequiredDraft7) return draft7;
    hasRequiredDraft7 = 1;
    Object.defineProperty(draft7, "__esModule", { value: true });
    const core_1 = requireCore();
    const validation_1 = requireValidation();
    const applicator_1 = requireApplicator();
    const format_1 = requireFormat();
    const metadata_1 = requireMetadata();
    const draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    draft7.default = draft7Vocabularies;
    return draft7;
  }
  var discriminator = {};
  var types = {};
  var hasRequiredTypes;
  function requireTypes() {
    if (hasRequiredTypes) return types;
    hasRequiredTypes = 1;
    Object.defineProperty(types, "__esModule", { value: true });
    types.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (types.DiscrError = DiscrError = {}));
    return types;
  }
  var hasRequiredDiscriminator;
  function requireDiscriminator() {
    if (hasRequiredDiscriminator) return discriminator;
    hasRequiredDiscriminator = 1;
    Object.defineProperty(discriminator, "__esModule", { value: true });
    const codegen_1 = requireCodegen();
    const types_1 = requireTypes();
    const compile_1 = requireCompile();
    const ref_error_1 = requireRef_error();
    const util_1 = requireUtil();
    const error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    const def2 = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf: oneOf2 } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf2)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf2.length; i++) {
            let sch = oneOf2[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref2 = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    discriminator.default = def2;
    return discriminator;
  }
  const $schema = "http://json-schema.org/draft-07/schema#";
  const $id = "http://json-schema.org/draft-07/schema#";
  const title = "Core schema meta-schema";
  const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
  const type = ["object", "boolean"];
  const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
  const require$$3 = {
    $schema,
    $id,
    title,
    definitions,
    type,
    properties,
    "default": true
  };
  var hasRequiredAjv;
  function requireAjv() {
    if (hasRequiredAjv) return ajv.exports;
    hasRequiredAjv = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
      const core_1 = requireCore$1();
      const draft7_1 = requireDraft7();
      const discriminator_1 = requireDiscriminator();
      const draft7MetaSchema = require$$3;
      const META_SUPPORT_DATA = ["/properties"];
      const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      class Ajv2 extends core_1.default {
        _addVocabularies() {
          super._addVocabularies();
          draft7_1.default.forEach((v) => this.addVocabulary(v));
          if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
        }
        _addDefaultMetaSchema() {
          super._addDefaultMetaSchema();
          if (!this.opts.meta)
            return;
          const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
          this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
          this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
        }
      }
      exports.Ajv = Ajv2;
      module.exports = exports = Ajv2;
      module.exports.Ajv = Ajv2;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = Ajv2;
      var validate_1 = requireValidate();
      Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
        return validate_1.KeywordCxt;
      } });
      var codegen_1 = requireCodegen();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return codegen_1._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return codegen_1.str;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return codegen_1.stringify;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return codegen_1.nil;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return codegen_1.Name;
      } });
      Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
        return codegen_1.CodeGen;
      } });
      var validation_error_1 = requireValidation_error();
      Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
        return validation_error_1.default;
      } });
      var ref_error_1 = requireRef_error();
      Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
        return ref_error_1.default;
      } });
    })(ajv, ajv.exports);
    return ajv.exports;
  }
  var ajvExports = requireAjv();
  const Ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
  var dist$1 = { exports: {} };
  var formats = {};
  var hasRequiredFormats;
  function requireFormats() {
    if (hasRequiredFormats) return formats;
    hasRequiredFormats = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
      function fmtDef(validate2, compare) {
        return { validate: validate2, compare };
      }
      exports.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: fmtDef(date, compareDate),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: fmtDef(getTime(true), compareTime),
        "date-time": fmtDef(getDateTime(true), compareDateTime),
        "iso-time": fmtDef(getTime(), compareIsoTime),
        "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: uri2,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte,
        // signed 32 bit integer
        int32: { type: "number", validate: validateInt32 },
        // signed 64 bit integer
        int64: { type: "number", validate: validateInt64 },
        // C-type float
        float: { type: "number", validate: validateNumber },
        // C-type double
        double: { type: "number", validate: validateNumber },
        // hint to the UI to hide input strings
        password: true,
        // unchecked string payload
        binary: true
      };
      exports.fastFormats = {
        ...exports.fullFormats,
        date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
        time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
        "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
        "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
        "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      };
      exports.formatNames = Object.keys(exports.fullFormats);
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function date(str) {
        const matches = DATE.exec(str);
        if (!matches)
          return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function compareDate(d1, d2) {
        if (!(d1 && d2))
          return void 0;
        if (d1 > d2)
          return 1;
        if (d1 < d2)
          return -1;
        return 0;
      }
      const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
      function getTime(strictTimeZone) {
        return function time(str) {
          const matches = TIME.exec(str);
          if (!matches)
            return false;
          const hr = +matches[1];
          const min = +matches[2];
          const sec = +matches[3];
          const tz = matches[4];
          const tzSign = matches[5] === "-" ? -1 : 1;
          const tzH = +(matches[6] || 0);
          const tzM = +(matches[7] || 0);
          if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
            return false;
          if (hr <= 23 && min <= 59 && sec < 60)
            return true;
          const utcMin = min - tzM * tzSign;
          const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
          return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
        };
      }
      function compareTime(s1, s2) {
        if (!(s1 && s2))
          return void 0;
        const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
        const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
        if (!(t1 && t2))
          return void 0;
        return t1 - t2;
      }
      function compareIsoTime(t1, t2) {
        if (!(t1 && t2))
          return void 0;
        const a1 = TIME.exec(t1);
        const a2 = TIME.exec(t2);
        if (!(a1 && a2))
          return void 0;
        t1 = a1[1] + a1[2] + a1[3];
        t2 = a2[1] + a2[2] + a2[3];
        if (t1 > t2)
          return 1;
        if (t1 < t2)
          return -1;
        return 0;
      }
      const DATE_TIME_SEPARATOR = /t|\s/i;
      function getDateTime(strictTimeZone) {
        const time = getTime(strictTimeZone);
        return function date_time(str) {
          const dateTime = str.split(DATE_TIME_SEPARATOR);
          return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
        };
      }
      function compareDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const d1 = new Date(dt1).valueOf();
        const d2 = new Date(dt2).valueOf();
        if (!(d1 && d2))
          return void 0;
        return d1 - d2;
      }
      function compareIsoDateTime(dt1, dt2) {
        if (!(dt1 && dt2))
          return void 0;
        const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
        const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
        const res = compareDate(d1, d2);
        if (res === void 0)
          return void 0;
        return res || compareTime(t1, t2);
      }
      const NOT_URI_FRAGMENT = /\/|:/;
      const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function uri2(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function byte(str) {
        BYTE.lastIndex = 0;
        return BYTE.test(str);
      }
      const MIN_INT32 = -2147483648;
      const MAX_INT32 = 2 ** 31 - 1;
      function validateInt32(value) {
        return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
      }
      function validateInt64(value) {
        return Number.isInteger(value);
      }
      function validateNumber() {
        return true;
      }
      const Z_ANCHOR = /[^\\]\\Z/;
      function regex(str) {
        if (Z_ANCHOR.test(str))
          return false;
        try {
          new RegExp(str);
          return true;
        } catch (e) {
          return false;
        }
      }
    })(formats);
    return formats;
  }
  var limit = {};
  var hasRequiredLimit;
  function requireLimit() {
    if (hasRequiredLimit) return limit;
    hasRequiredLimit = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatLimitDefinition = void 0;
      const ajv_1 = requireAjv();
      const codegen_1 = requireCodegen();
      const ops = codegen_1.operators;
      const KWDs = {
        formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      const error = {
        message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
      };
      exports.formatLimitDefinition = {
        keyword: Object.keys(KWDs),
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
          const { opts, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
          if (fCxt.$data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
          }
          function validateFormat() {
            const format2 = fCxt.schema;
            const fmtDef = self2.formats[format2];
            if (!fmtDef || fmtDef === true)
              return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
              throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
              key: format2,
              ref: fmtDef,
              code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
            });
            cxt.fail$data(compareCode(fmt));
          }
          function compareCode(fmt) {
            return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const formatLimitPlugin = (ajv2) => {
        ajv2.addKeyword(exports.formatLimitDefinition);
        return ajv2;
      };
      exports.default = formatLimitPlugin;
    })(limit);
    return limit;
  }
  var hasRequiredDist$1;
  function requireDist$1() {
    if (hasRequiredDist$1) return dist$1.exports;
    hasRequiredDist$1 = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      const formats_1 = requireFormats();
      const limit_1 = requireLimit();
      const codegen_1 = requireCodegen();
      const fullName = new codegen_1.Name("fullFormats");
      const fastName = new codegen_1.Name("fastFormats");
      const formatsPlugin = (ajv2, opts = { keywords: true }) => {
        if (Array.isArray(opts)) {
          addFormats2(ajv2, opts, formats_1.fullFormats, fullName);
          return ajv2;
        }
        const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
        const list = opts.formats || formats_1.formatNames;
        addFormats2(ajv2, list, formats2, exportName);
        if (opts.keywords)
          (0, limit_1.default)(ajv2);
        return ajv2;
      };
      formatsPlugin.get = (name, mode = "full") => {
        const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
        const f = formats2[name];
        if (!f)
          throw new Error(`Unknown format "${name}"`);
        return f;
      };
      function addFormats2(ajv2, list, fs, exportName) {
        var _a;
        var _b;
        (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
        for (const f of list)
          ajv2.addFormat(f, fs[f]);
      }
      module.exports = exports = formatsPlugin;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = formatsPlugin;
    })(dist$1, dist$1.exports);
    return dist$1.exports;
  }
  var distExports$1 = requireDist$1();
  const addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports$1);
  var dist = { exports: {} };
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist.exports;
    hasRequiredDist = 1;
    (function(module, exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      const ajv_1 = requireAjv();
      const codegen_1 = requireCodegen();
      const code_1 = requireCode$1();
      const validate_1 = requireValidate();
      const errors_1 = requireErrors();
      const names_1 = requireNames();
      const keyword2 = "errorMessage";
      const used = new ajv_1.Name("emUsed");
      const KEYWORD_PROPERTY_PARAMS = {
        required: "missingProperty",
        dependencies: "property",
        dependentRequired: "property"
      };
      const INTERPOLATION = /\$\{[^}]+\}/;
      const INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
      const EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
      function errorMessage(options) {
        return {
          keyword: keyword2,
          schemaType: ["string", "object"],
          post: true,
          code(cxt) {
            const { gen, data, schema, schemaValue, it } = cxt;
            if (it.createErrors === false)
              return;
            const sch = schema;
            const instancePath = codegen_1.strConcat(names_1.default.instancePath, it.errorPath);
            gen.if(ajv_1._`${names_1.default.errors} > 0`, () => {
              if (typeof sch == "object") {
                const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
                if (kwdErrors)
                  processKeywordErrors(kwdErrors);
                if (kwdPropErrors)
                  processKeywordPropErrors(kwdPropErrors);
                processChildErrors(childErrorsConfig(sch));
              }
              const schMessage = typeof sch == "string" ? sch : sch._;
              if (schMessage)
                processAllErrors(schMessage);
              if (!options.keepErrors)
                removeUsedErrors();
            });
            function childErrorsConfig({ properties: properties2, items: items2 }) {
              const errors2 = {};
              if (properties2) {
                errors2.props = {};
                for (const p2 in properties2)
                  errors2.props[p2] = [];
              }
              if (items2) {
                errors2.items = {};
                for (let i = 0; i < items2.length; i++)
                  errors2.items[i] = [];
              }
              return errors2;
            }
            function keywordErrorsConfig(emSchema) {
              let propErrors;
              let errors2;
              for (const k in emSchema) {
                if (k === "properties" || k === "items")
                  continue;
                const kwdSch = emSchema[k];
                if (typeof kwdSch == "object") {
                  propErrors || (propErrors = {});
                  const errMap = propErrors[k] = {};
                  for (const p2 in kwdSch)
                    errMap[p2] = [];
                } else {
                  errors2 || (errors2 = {});
                  errors2[k] = [];
                }
              }
              return [propErrors, errors2];
            }
            function processKeywordErrors(kwdErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
              const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              const { singleError } = options;
              if (singleError) {
                const message = gen.let("message", ajv_1._`""`);
                const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
                loopErrors((key) => {
                  gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                  gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                  gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
                });
                errors_1.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
              } else {
                loopErrors((key) => errors_1.reportError(cxt, {
                  message: errMessage(key),
                  params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
                }));
              }
              function loopErrors(body) {
                gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
              }
              function errMessage(key) {
                return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
              }
            }
            function processKeywordPropErrors(kwdPropErrors) {
              const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
              const templatesCode = [];
              for (const k in kwdPropErrors) {
                templatesCode.push([
                  k,
                  getTemplatesCode(kwdPropErrors[k], schema[k])
                ]);
              }
              const templates = gen.const("templates", gen.object(...templatesCode));
              const kwdPropParams = gen.scopeValue("obj", {
                ref: KEYWORD_PROPERTY_PARAMS,
                code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
              });
              const propParam = gen.let("emPropParams");
              const paramsErrors = gen.let("emParamsErrors");
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
                gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
                gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
              }));
              gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
                gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
                gen.if(ajv_1._`${paramsErrors}.length`, () => {
                  const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                  errors_1.reportError(cxt, {
                    message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                    params: ajv_1._`{errors: ${paramsErrors}}`
                  });
                });
              }));
            }
            function processChildErrors(childErrors) {
              const { props, items: items2 } = childErrors;
              if (!props && !items2)
                return;
              const isObj = ajv_1._`typeof ${data} == "object"`;
              const isArr = ajv_1._`Array.isArray(${data})`;
              const childErrs = gen.let("emErrors");
              let childKwd;
              let childProp;
              const templates = gen.let("templates");
              if (props && items2) {
                childKwd = gen.let("emChildKwd");
                gen.if(isObj);
                gen.if(isArr, () => {
                  init(items2, schema.items);
                  gen.assign(childKwd, ajv_1.str`items`);
                }, () => {
                  init(props, schema.properties);
                  gen.assign(childKwd, ajv_1.str`properties`);
                });
                childProp = ajv_1._`[${childKwd}]`;
              } else if (items2) {
                gen.if(isArr);
                init(items2, schema.items);
                childProp = ajv_1._`.items`;
              } else if (props) {
                gen.if(codegen_1.and(isObj, codegen_1.not(isArr)));
                init(props, schema.properties);
                childProp = ajv_1._`.properties`;
              }
              gen.forOf("err", names_1.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
                errors_1.reportError(cxt, {
                  message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                  params: ajv_1._`{errors: ${childErrs}[${key}]}`
                });
                gen.assign(ajv_1._`${names_1.default.vErrors}[${names_1.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
              }));
              gen.endIf();
              function init(children, msgs) {
                gen.assign(childErrs, ajv_1.stringify(children));
                gen.assign(templates, getTemplatesCode(children, msgs));
              }
            }
            function processAllErrors(schMessage) {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
              gen.if(ajv_1._`${errs}.length`, () => errors_1.reportError(cxt, {
                message: templateExpr(schMessage),
                params: ajv_1._`{errors: ${errs}}`
              }));
            }
            function removeUsedErrors() {
              const errs = gen.const("emErrs", ajv_1._`[]`);
              gen.forOf("err", names_1.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
              gen.assign(names_1.default.vErrors, errs).assign(names_1.default.errors, ajv_1._`${errs}.length`);
            }
            function matchKeywordError(err, kwdErrs) {
              return codegen_1.and(
                ajv_1._`${err}.keyword !== ${keyword2}`,
                ajv_1._`!${err}.${used}`,
                ajv_1._`${err}.instancePath === ${instancePath}`,
                ajv_1._`${err}.keyword in ${kwdErrs}`,
                // TODO match the end of the string?
                ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,
                ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`
              );
            }
            function ifMatchesChildError(err, childErrs, thenBody) {
              gen.if(codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
                const childRegex = gen.scopeValue("pattern", {
                  ref: /^\/([^/]*)(?:\/|$)/,
                  code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
                });
                const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
                const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
                gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
              });
            }
            function matchAnyError(err) {
              return codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, codegen_1.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_1.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it.errSchemaPath}.length] === "/"`);
            }
            function getTemplatesCode(keys, msgs) {
              const templatesCode = [];
              for (const k in keys) {
                const msg = msgs[k];
                if (INTERPOLATION.test(msg))
                  templatesCode.push([k, templateFunc(msg)]);
              }
              return gen.object(...templatesCode);
            }
            function templateExpr(msg) {
              if (!INTERPOLATION.test(msg))
                return ajv_1.stringify(msg);
              return new code_1._Code(code_1.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_1.getData(ptr, it)}) + "`).replace(EMPTY_STR, ""));
            }
            function templateFunc(msg) {
              return ajv_1._`function(){return ${templateExpr(msg)}}`;
            }
          },
          metaSchema: {
            anyOf: [
              { type: "string" },
              {
                type: "object",
                properties: {
                  properties: { $ref: "#/$defs/stringMap" },
                  items: { $ref: "#/$defs/stringList" },
                  required: { $ref: "#/$defs/stringOrMap" },
                  dependencies: { $ref: "#/$defs/stringOrMap" }
                },
                additionalProperties: { type: "string" }
              }
            ],
            $defs: {
              stringMap: {
                type: "object",
                additionalProperties: { type: "string" }
              },
              stringOrMap: {
                anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
              },
              stringList: { type: "array", items: { type: "string" } }
            }
          }
        };
      }
      const ajvErrors = (ajv2, options = {}) => {
        if (!ajv2.opts.allErrors)
          throw new Error("ajv-errors: Ajv option allErrors must be true");
        if (ajv2.opts.jsPropertySyntax) {
          throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
        }
        return ajv2.addKeyword(errorMessage(options));
      };
      exports.default = ajvErrors;
      module.exports = ajvErrors;
      module.exports.default = ajvErrors;
    })(dist, dist.exports);
    return dist.exports;
  }
  var distExports = requireDist();
  const addErrors = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
  class ValidatorService {
    constructor(options) {
      __publicField(this, "ajv");
      this.ajv = new Ajv({
        allErrors: true,
        useDefaults: "empty",
        verbose: true,
        validateFormats: true,
        strict: true,
        coerceTypes: true,
        ...options
      });
      console.log(this.ajv.schemas);
      addFormats(this.ajv);
      addErrors(this.ajv);
      this.ajv.addKeyword("nodeType");
    }
    createValidator(schema) {
      return this.ajv.compile(schema);
    }
    resetCache() {
      this.ajv.cache.clear();
    }
    errors(errors2, options) {
      return this.ajv.errorsText(errors2, options);
    }
  }
  const validatorService = new ValidatorService();
  var jsonpointer$1 = {};
  var hasRequiredJsonpointer;
  function requireJsonpointer() {
    if (hasRequiredJsonpointer) return jsonpointer$1;
    hasRequiredJsonpointer = 1;
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p2 = 1, len = pointer.length; p2 < len; ) {
        if (pointer[p2] === "constructor" || pointer[p2] === "prototype" || pointer[p2] === "__proto__") return obj;
        part = untilde(pointer[p2++]);
        hasNextPart = len > p2;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p2] !== "" && pointer[p2] < Infinity || pointer[p2] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p2 = 1; p2 < len; ) {
        obj = obj[untilde(pointer[p2++])];
        if (len === p2) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile2(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    jsonpointer$1.get = get;
    jsonpointer$1.set = set;
    jsonpointer$1.compile = compile2;
    return jsonpointer$1;
  }
  var jsonpointerExports = requireJsonpointer();
  const jsonpointer = /* @__PURE__ */ getDefaultExportFromCjs(jsonpointerExports);
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$7 = {
    name: "NodeRedVueApp",
    props: {
      node: {
        type: Object,
        required: true
      },
      validator: {
        type: Function,
        required: true
      },
      disableSaveButtonOnError: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    data() {
      return {
        localNode: this.node,
        errors: {}
      };
    },
    beforeMount() {
      this.validator(this.localNode);
      Object.keys(this.localNode._def.defaults).forEach((prop) => {
        this.$watch(
          () => this.localNode[prop],
          (newVal) => {
            this.validate();
          },
          { deep: true }
        );
      });
      Object.keys(this.localNode._def.credentials).forEach((prop) => {
        if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`]) {
          this.localNode.credentials[prop] = "__PWD__";
        }
        this.$watch(
          () => this.localNode.credentials[prop],
          (newVal, oldVal) => {
            this.validate();
            if (this.localNode._def.credentials[prop].type === "password" && newVal !== oldVal) {
              this.localNode.credentials[`has_${prop}`] = !!newVal;
            }
          },
          { deep: true }
        );
      });
    },
    beforeUnmount() {
      var _a, _b;
      if (this.disableSaveButtonOnError) {
        (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", false).removeClass("disabled");
        (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", false).removeClass("disabled");
        $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
      }
      Object.keys(this.localNode._def.credentials).forEach((prop) => {
        if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`] && this.localNode.credentials[prop] === "__PWD__") {
          this.localNode.credentials[prop] = void 0;
        }
      });
    },
    methods: {
      validate() {
        var _a, _b;
        const valid = this.validator(this.localNode);
        if (!valid) {
          const errors2 = this.validator.errors;
          this.errors = errors2.reduce((acc, error) => {
            const errorValue = jsonpointer.get(
              this.localNode,
              error.instancePath
            );
            if (error.parentSchema.format === "password" && errorValue === "__PWD__") {
              console.log(
                "password fields with value equal to __PWD__ should not be an error"
              );
              return acc;
            } else {
              const key = `node${error.instancePath.replaceAll("/", ".")}`;
              acc[key] = error.message;
              return acc;
            }
          }, {});
        } else {
          this.errors = {};
        }
        if (this.disableSaveButtonOnError) {
          if (Object.keys(this.errors).length) {
            (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", true).addClass("disabled");
            (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", true).addClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "none", "important");
          } else {
            $("#node-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#node-config-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
          }
        }
      }
    }
  };
  const _hoisted_1$7 = { style: { "width": "100%" } };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedNodeForm = resolveComponent("NodeRedNodeForm");
    return openBlock(), createElementBlock("div", _hoisted_1$7, [
      createVNode(_component_NodeRedNodeForm, {
        node: $data.localNode,
        errors: $data.errors,
        style: { "width": "100%" }
      }, null, 8, ["node", "errors"])
    ]);
  }
  const NodeRedVueApp = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
  const _sfc_main$6 = {
    props: {
      value: String,
      type: {
        type: String,
        default: "text"
      },
      placeholder: String,
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value", "input"],
    data() {
      return {
        internalValue: "",
        secretPattern: "*************"
      };
    },
    beforeMount() {
      this.internalValue = this.value;
      this.onBlur();
    },
    methods: {
      onInput(event) {
        this.internalValue = event.target.value;
        this.$emit("update:value", this.internalValue);
        this.$emit("input", this.internalValue);
      },
      onFocus() {
        if (this.type === "password" && this.internalValue === this.secretPattern) {
          this.internalValue = "";
        }
      },
      onBlur() {
        if (this.type === "password" && this.value === "__PWD__") {
          this.internalValue = this.secretPattern;
        }
      }
    }
  };
  const _hoisted_1$6 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$6 = ["type", "value", "placeholder"];
  const _hoisted_3$4 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$6, [
      createBaseVNode("input", {
        ref: "inputField",
        type: $props.type,
        value: $data.internalValue,
        placeholder: $props.placeholder,
        onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
        onFocus: _cache[1] || (_cache[1] = (...args) => $options.onFocus && $options.onFocus(...args)),
        onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
        style: { "flex": "1", "width": "100%" }
      }, null, 40, _hoisted_2$6),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$4, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedInput = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
  const TYPED_INPUT_TYPES = [
    "msg",
    "flow",
    "global",
    "str",
    "num",
    "bool",
    "json",
    "bin",
    "re",
    "jsonata",
    "date",
    "env",
    "node",
    "cred"
  ];
  const _sfc_main$5 = {
    props: {
      value: {
        type: Object,
        required: true,
        validator: function(obj) {
          if (false) {
            console.warn(
              "[WARN] Invalid value for 'value' property. It must be an object."
            );
            return false;
          }
          const isValid = typeof (obj == null ? void 0 : obj.value) === "string" && typeof (obj == null ? void 0 : obj.type) === "string";
          if (!isValid) {
            console.warn(
              "[WARN] Invalid value for 'value' property. It must be an object with 'value' and 'type' properties being strings.",
              obj
            );
          }
          return isValid;
        }
      },
      types: {
        type: Array,
        default: () => TYPED_INPUT_TYPES
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    computed: {
      isProvidedValueTypeValid() {
        const type2 = this.value.type;
        const types2 = this.types;
        return types2.includes(type2);
      }
    },
    watch: {
      isProvidedValueTypeValid: {
        handler(newValue) {
          if (!newValue) {
            console.warn(
              `Validation failed: this.value.type (${this.value.type}) must be one of the provided types (${this.types}).`
            );
          }
        },
        immediate: true
      }
    },
    mounted() {
      const inputElement = this.$refs.typedInput;
      this.$input = $(inputElement).typedInput({
        default: this.value.type || this.types[0],
        types: this.types
      });
      this.$input.typedInput("value", this.value.value || "");
      this.$input.typedInput("type", this.value.type || this.types[0]);
      this.$nextTick(() => {
        const observer = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            if (mutation.attributeName === "value") {
              this.onChange();
            }
          }
        });
        observer.observe(inputElement, {
          attributes: true,
          attributeFilter: ["value"]
        });
        this._observer = observer;
      });
      this.$input.on("change", () => {
        this.onChange();
      });
    },
    watch: {
      error(newVal) {
        this.$nextTick(() => {
          const targetDiv = this.$el.querySelector(
            ".red-ui-typedInput-container"
          );
          if (newVal) {
            targetDiv.classList.add("input-error");
          } else {
            targetDiv.classList.remove("input-error");
          }
        });
      }
    },
    methods: {
      onChange() {
        const newValue = this.$input.typedInput("value");
        const newType = this.$input.typedInput("type");
        if (this.value.value !== newValue || this.value.type !== newType) {
          this.$emit("update:value", {
            value: newValue,
            type: newType
          });
        }
      }
    }
  };
  const _hoisted_1$5 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$5 = {
    type: "text",
    ref: "typedInput",
    class: "node-red-typed-input",
    style: { "flex": "1", "width": "100%" }
  };
  const _hoisted_3$3 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$5, [
      createBaseVNode("input", _hoisted_2$5, null, 512),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$3, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedTypedInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
  const _sfc_main$4 = {
    props: {
      value: String,
      type: String,
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    computed: {
      inputPrefix() {
        return "node-input-" + Math.random().toString(36).substring(2, 9);
      },
      inputId() {
        return this.inputPrefix + "-" + this.value;
      }
    },
    mounted() {
      RED.editor.prepareConfigNodeSelect(
        this,
        this.value,
        this.type,
        this.inputPrefix
      );
      const input = $("#" + this.inputId);
      input.on("change", () => {
        this.$emit("update:value", input.val());
      });
      input.val(this.value || "_ADD_");
    }
  };
  const _hoisted_1$4 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$4 = ["id"];
  const _hoisted_3$2 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$4, [
      createBaseVNode("input", {
        type: "text",
        id: $options.inputId,
        style: { "width": "100%" }
      }, null, 8, _hoisted_2$4),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$2, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedConfigInput = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
  const _sfc_main$3 = {
    props: {
      value: String | Array,
      options: {
        type: Array,
        required: true,
        validator: function(value) {
          if (!Array.isArray(value)) {
            console.warn(
              "[WARN] Invalid value for 'options' property. It must be an array."
            );
            return false;
          }
          const isValid = value.every((item) => {
            const isObject2 = typeof item === "object" && item !== null;
            if (!isObject2) return false;
            return item.hasOwnProperty("value") && item.hasOwnProperty("label") && typeof item.value === "string" && typeof item.label === "string";
          });
          if (!isValid) {
            console.warn(
              "[WARN] Invalid value for 'options' property. Each item must be an object with 'value' and 'label' properties being strings.",
              value
            );
          }
          return isValid;
        }
      },
      multiple: {
        type: Boolean,
        default: false
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    mounted() {
      const inputElement = this.$refs.selectInput;
      const $selectInput = $(inputElement);
      $selectInput.typedInput({
        types: [
          {
            multiple: this.multiple,
            options: this.options
          }
        ]
      });
      $selectInput.typedInput(
        "value",
        Array.isArray(this.value) ? this.value.join(",") : this.value
      );
      $selectInput.on("change", () => {
        var _a;
        const newValue = this.multiple ? (_a = $selectInput.typedInput("value")) == null ? void 0 : _a.split(",") : $selectInput.typedInput("value");
        this.$emit("update:value", newValue);
      });
    }
  };
  const _hoisted_1$3 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
  const _hoisted_2$3 = {
    type: "text",
    ref: "selectInput",
    class: "node-input-select",
    style: { "width": "100%" }
  };
  const _hoisted_3$1 = {
    key: 0,
    class: "node-red-vue-input-error-message"
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$3, [
      createBaseVNode("input", _hoisted_2$3, null, 512),
      $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$1, toDisplayString($props.error), 1)) : createCommentVNode("", true)
    ]);
  }
  const NodeRedSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
  const _sfc_main$2 = {
    props: {
      value: String,
      language: {
        type: String,
        default: "abap",
        validator: function(value) {
          const allowedLanguages = [
            "abap",
            "apex",
            "azcli",
            "bat",
            "bicep",
            "cameligo",
            "clojure",
            "coffee",
            "cpp",
            "csharp",
            "csp",
            "css",
            "cypher",
            "dart",
            "dockerfile",
            "ecl",
            "elixir",
            "flow9",
            "freemarker2",
            "fsharp",
            "go",
            "graphql",
            "handlebars",
            "hcl",
            "html",
            "ini",
            "java",
            "javascript",
            "julia",
            "kotlin",
            "less",
            "lexon",
            "liquid",
            "lua",
            "m3",
            "markdown",
            "mdx",
            "mips",
            "msdax",
            "mysql",
            "objective-c",
            "pascal",
            "pascaligo",
            "perl",
            "pgsql",
            "php",
            "pla",
            "postiats",
            "powerquery",
            "powershell",
            "protobuf",
            "pub",
            "python",
            "qsharp",
            "r",
            "razor",
            "redis",
            "redshift",
            "restructuredtext",
            "ruby",
            "rust",
            "sb",
            "scala",
            "scheme",
            "scss",
            "shell",
            "solidity",
            "sophia",
            "sparql",
            "sql",
            "st",
            "swift",
            "systemverilog",
            "tcl",
            "twig",
            "typescript",
            "typespec",
            "vb",
            "wgsl",
            "xml",
            "yaml"
          ];
          const isValid = allowedLanguages.includes(value);
          if (!isValid) {
            console.warn(
              `[WARN]: Invalid value for 'type' property: "${value}". Expected one of: ${allowedLanguages.join(", ")}`
            );
          }
          return isValid;
        }
      },
      error: {
        type: String,
        default: ""
      }
    },
    emits: ["update:value"],
    editor: null,
    data() {
      return {
        editorId: "node-red-editor-" + Math.random().toString(36).substring(2, 9)
      };
    },
    mounted() {
      this.mountEditor();
    },
    methods: {
      mountEditor() {
        this.$nextTick(() => {
          const containerEl = this.$refs.containerDiv;
          const editorEl = this.$refs.editorDiv;
          if (containerEl && editorEl) {
            try {
              const inlineHeight = containerEl.style.height;
              const inlineWidth = containerEl.style.width;
              if (inlineHeight) {
                editorEl.style.height = inlineHeight;
              } else {
                editorEl.style.height = "200px";
              }
              if (inlineWidth) {
                editorEl.style.width = inlineWidth;
              } else {
                editorEl.style.width = "100%";
              }
              this.createEditorInstance();
            } catch (e) {
              console.error(
                "[NodeRedEditorInput] Error setting initial editor style:",
                e
              );
              this.createEditorInstance();
            }
          } else {
            console.error(
              "[NodeRedEditorInput] Container or Editor div refs not found on mount."
            );
          }
        });
      },
      createEditorInstance() {
        this.editorInstance = RED.editor.createEditor({
          id: this.editorId,
          mode: this.language,
          value: this.value
        });
        this.editorInstance.getSession().on("change", () => {
          const currentValue = this.editorInstance.getValue();
          if (currentValue !== this.value) {
            this.$emit("update:value", currentValue);
          }
        });
      }
    },
    beforeUnmount() {
      if (this.editorInstance) {
        try {
          this.editorInstance.destroy();
        } catch (err) {
          console.error(`Error destroying editor for ID ${this.editorId}:`, err);
        }
        this.editorInstance = null;
      }
    }
  };
  const _hoisted_1$2 = {
    ref: "containerDiv",
    class: "node-text-editor-container"
  };
  const _hoisted_2$2 = ["id"];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$2, [
      createBaseVNode("div", {
        ref: "editorDiv",
        id: $data.editorId,
        class: "node-text-editor"
      }, null, 8, _hoisted_2$2),
      withDirectives(createBaseVNode("div", { class: "node-red-vue-input-error-message" }, toDisplayString($props.error), 513), [
        [vShow, $props.error]
      ])
    ], 512);
  }
  const NodeRedEditorInput = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  function createNodeRedVueApp(node, form, validator) {
    const app = createApp(NodeRedVueApp, {
      node,
      validator,
      disableSaveButtonOnError: form.disableSaveButtonOnError
    });
    app.component("NodeRedInput", NodeRedInput);
    app.component("NodeRedTypedInput", NodeRedTypedInput);
    app.component("NodeRedConfigInput", NodeRedConfigInput);
    app.component("NodeRedSelectInput", NodeRedSelectInput);
    app.component("NodeRedEditorInput", NodeRedEditorInput);
    app.component("NodeRedNodeForm", form.component);
    return app;
  }
  function mountApp(node, form, validator) {
    $$1("#app").empty();
    node._newState = cloneDeep(node);
    node._app = createNodeRedVueApp(node._newState, form, validator);
    node._app.mount("#app");
  }
  function unmountApp(node) {
    if (node._app) {
      node._app.unmount();
      node._app = null;
    }
  }
  function getNodeState(node) {
    const state = {
      credentials: {}
    };
    Object.keys(node._def.defaults).forEach((prop) => {
      state[prop] = node[prop];
    });
    Object.keys(node._def.credentials).forEach((prop) => {
      state.credentials[prop] = node.credentials[prop];
      if (node._def.credentials[prop].type === "password") {
        state.credentials[`has_${prop}`] = node.credentials[`has_${prop}`] || false;
      }
    });
    return state;
  }
  function getChanges(o, n) {
    const changes = {};
    Object.keys(o).forEach((prop) => {
      const _o = o[prop];
      const _n = n[prop];
      if (typeof _o === "object") {
        const _changes = getChanges(_o, _n);
        if (Object.keys(_changes).length) {
          changes[prop] = _changes;
        }
      } else if (!isEqual(_o, _n)) {
        changes[prop] = _o;
      }
    });
    return changes;
  }
  function registerType(options) {
    return async function(type2) {
      try {
        const response = await fetch(`/nrg/nodes/${type2}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const { schema } = await response.json();
        const defaults2 = getDefaultsFromSchema(schema);
        if (defaults2.credentials) delete defaults2.credentials;
        const credentials = getCredentialsFromSchema(
          schema.properties.credentials
        );
        console.log("defaults", defaults2);
        console.log("credentials", credentials);
        RED.nodes.registerType(type2, {
          ...options,
          defaults: defaults2,
          credentials,
          type: type2,
          label: function() {
            return this.name;
          },
          oneditprepare: function() {
            const validator = validatorService.createValidator(schema);
            mountApp(this, options.form, validator);
          },
          oneditsave: function() {
            var _a;
            const node = this;
            unmountApp(node);
            const newState = getNodeState(node._newState);
            const oldState = getNodeState(node);
            const changes = getChanges(oldState, newState);
            const changed = !!((_a = Object.keys(changes)) == null ? void 0 : _a.length);
            if (!changed) return false;
            Object.keys(node._def.defaults).forEach((prop) => {
              var _a2, _b;
              if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
                const oldConfigNodeId = node[prop];
                const newConfigNodeId = node._newState[prop];
                if (oldConfigNodeId !== newConfigNodeId) {
                  const oldConfigNode = RED.nodes.node(oldConfigNodeId);
                  if (oldConfigNode && oldConfigNode._def.category === "config") {
                    const parentNodeIndex = oldConfigNode.users.findIndex(
                      (_node) => _node.id === node.id
                    );
                    if (parentNodeIndex !== -1) {
                      oldConfigNode.users.splice(parentNodeIndex, 1);
                    }
                  }
                }
              }
            });
            Object.keys(node._def.defaults).forEach((prop) => {
              var _a2, _b;
              if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
                const newStateConfigNodeId = node._newState[prop];
                const newStateConfigNode = RED.nodes.node(newStateConfigNodeId);
                if (newStateConfigNode && newStateConfigNode._def.category === "config") {
                  const parentNodeIndex = newStateConfigNode.users.findIndex(
                    (_node) => _node.id === node.id
                  );
                  if (parentNodeIndex === -1) {
                    newStateConfigNode.users.push(node);
                  }
                }
              }
            });
            merge(node, newState);
            return {
              changed,
              history: [
                {
                  t: "edit",
                  node,
                  changes,
                  links: [],
                  dirty: RED.nodes.dirty(),
                  changed
                }
              ]
            };
          },
          oneditcancel: function() {
            unmountApp(this);
          },
          oneditdelete: function() {
            unmountApp(this);
          },
          onpaletteadd: options.onPaletteAdd,
          onpaltteremove: options.onPaletteRemove
        });
      } catch (error) {
        console.error(`Error fetching node type ${type2}:`, error);
        throw error;
      }
    };
  }
  const _sfc_main$1 = {
    name: "NodeRedNodeForm",
    props: {
      node: {
        type: Object,
        required: true
      },
      errors: {
        type: Object,
        default: () => ({})
      }
    }
  };
  const _hoisted_1$1 = { class: "form-row" };
  const _hoisted_2$1 = { class: "form-row" };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedInput = resolveComponent("NodeRedInput");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1$1, [
        _cache[2] || (_cache[2] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Name")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.name,
          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.name = $event),
          error: $props.errors["node.name"],
          placeholder: "name"
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_2$1, [
        _cache[3] || (_cache[3] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Hostname")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.host,
          "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.host = $event),
          error: $props.errors["node.host"],
          placeholder: "hostname"
        }, null, 8, ["value", "error"])
      ])
    ]);
  }
  const component$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
  const remoteServer = registerType({
    category: "config",
    color: "#a6bbcf",
    form: {
      component: component$1,
      disableSaveButtonOnError: true
    }
  });
  const _sfc_main = {
    name: "NodeRedNodeForm",
    props: {
      node: {
        type: Object,
        required: true
      },
      errors: {
        type: Object,
        default: () => ({})
      }
    },
    data() {
      return {
        types: ["str", "msg", "node"],
        countries: [
          { value: "usa", label: "usa" },
          { value: "argentina", label: "argentina" },
          { value: "brasil", label: "brasil" }
        ],
        fruits: [
          { value: "apple", label: "apple" },
          { value: "melon", label: "melon" },
          { value: "raspberry", label: "raspberry" }
        ],
        numbers: [
          { value: "1", label: "1" },
          { value: "2", label: "2" },
          { value: "3", label: "3" }
        ],
        objects: [
          { value: JSON.stringify({ test: "a" }), label: "a" },
          { value: JSON.stringify({ test: "b" }), label: "b" },
          { value: JSON.stringify({ test: "c" }), label: "c" }
        ],
        arrays: [
          { value: JSON.stringify(["a"]), label: "a" },
          { value: JSON.stringify(["b"]), label: "b" },
          { value: JSON.stringify(["c"]), label: "c" }
        ]
      };
    }
  };
  const _hoisted_1 = { class: "form-row" };
  const _hoisted_2 = { class: "form-row" };
  const _hoisted_3 = { class: "form-row" };
  const _hoisted_4 = { class: "form-row" };
  const _hoisted_5 = { class: "form-row" };
  const _hoisted_6 = { class: "form-row" };
  const _hoisted_7 = { class: "form-row" };
  const _hoisted_8 = { class: "form-row" };
  const _hoisted_9 = { class: "form-row" };
  const _hoisted_10 = { class: "form-row" };
  const _hoisted_11 = { class: "form-row" };
  const _hoisted_12 = { class: "form-row" };
  const _hoisted_13 = { class: "form-row" };
  const _hoisted_14 = { class: "form-row" };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_NodeRedInput = resolveComponent("NodeRedInput");
    const _component_NodeRedTypedInput = resolveComponent("NodeRedTypedInput");
    const _component_NodeRedConfigInput = resolveComponent("NodeRedConfigInput");
    const _component_NodeRedSelectInput = resolveComponent("NodeRedSelectInput");
    const _component_NodeRedEditorInput = resolveComponent("NodeRedEditorInput");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1, [
        _cache[14] || (_cache[14] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Username")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.username,
          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.credentials.username = $event),
          error: $props.errors["node.credentials.username"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_2, [
        _cache[15] || (_cache[15] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Password")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.password,
          "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.credentials.password = $event),
          type: "password",
          error: $props.errors["node.credentials.password"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_3, [
        _cache[16] || (_cache[16] = createBaseVNode("label", null, [
          createBaseVNode("i", { class: "fa fa-tag" }),
          createTextVNode(" Password 2")
        ], -1)),
        createVNode(_component_NodeRedInput, {
          value: $props.node.credentials.password2,
          "onUpdate:value": _cache[2] || (_cache[2] = ($event) => $props.node.credentials.password2 = $event),
          type: "password",
          error: $props.errors["node.credentials.password2"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_4, [
        _cache[17] || (_cache[17] = createBaseVNode("label", null, "Typed Input", -1)),
        createVNode(_component_NodeRedTypedInput, {
          value: $props.node.myProperty,
          "onUpdate:value": _cache[3] || (_cache[3] = ($event) => $props.node.myProperty = $event),
          types: $data.types,
          error: $props.errors["node.myProperty"]
        }, null, 8, ["value", "types", "error"])
      ]),
      createBaseVNode("div", _hoisted_5, [
        _cache[18] || (_cache[18] = createBaseVNode("label", null, "Typed Input 2", -1)),
        createVNode(_component_NodeRedTypedInput, {
          value: $props.node.myProperty2,
          "onUpdate:value": _cache[4] || (_cache[4] = ($event) => $props.node.myProperty2 = $event),
          error: $props.errors["node.myProperty2"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_6, [
        _cache[19] || (_cache[19] = createBaseVNode("label", null, "Config Input", -1)),
        createVNode(_component_NodeRedConfigInput, {
          value: $props.node.remoteServer,
          "onUpdate:value": _cache[5] || (_cache[5] = ($event) => $props.node.remoteServer = $event),
          type: "remote-server",
          error: $props.errors["node.remoteServer"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_7, [
        _cache[20] || (_cache[20] = createBaseVNode("label", null, "Config Input", -1)),
        createVNode(_component_NodeRedConfigInput, {
          value: $props.node.anotherRemoteServer,
          "onUpdate:value": _cache[6] || (_cache[6] = ($event) => $props.node.anotherRemoteServer = $event),
          type: "remote-server",
          error: $props.errors["node.anotherRemoteServer"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_8, [
        _cache[21] || (_cache[21] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.country,
          "onUpdate:value": _cache[7] || (_cache[7] = ($event) => $props.node.country = $event),
          options: $data.countries,
          error: $props.errors["node.country"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_9, [
        _cache[22] || (_cache[22] = createBaseVNode("label", null, "MultiSelect Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.fruit,
          "onUpdate:value": _cache[8] || (_cache[8] = ($event) => $props.node.fruit = $event),
          options: $data.fruits,
          multiple: "",
          error: $props.errors["node.fruit"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_10, [
        _cache[23] || (_cache[23] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.number,
          "onUpdate:value": _cache[9] || (_cache[9] = ($event) => $props.node.number = $event),
          options: $data.numbers,
          error: $props.errors["node.number"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_11, [
        _cache[24] || (_cache[24] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.object,
          "onUpdate:value": _cache[10] || (_cache[10] = ($event) => $props.node.object = $event),
          options: $data.objects,
          multiple: "",
          error: $props.errors["node.object"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_12, [
        _cache[25] || (_cache[25] = createBaseVNode("label", null, "Select Input", -1)),
        createVNode(_component_NodeRedSelectInput, {
          value: $props.node.array,
          "onUpdate:value": _cache[11] || (_cache[11] = ($event) => $props.node.array = $event),
          options: $data.arrays,
          error: $props.errors["node.array"]
        }, null, 8, ["value", "options", "error"])
      ]),
      createBaseVNode("div", _hoisted_13, [
        _cache[26] || (_cache[26] = createBaseVNode("label", null, "Editor with default height 200px and JSON", -1)),
        createVNode(_component_NodeRedEditorInput, {
          value: $props.node.jsontest,
          "onUpdate:value": _cache[12] || (_cache[12] = ($event) => $props.node.jsontest = $event),
          error: $props.errors["node.jsontest"]
        }, null, 8, ["value", "error"])
      ]),
      createBaseVNode("div", _hoisted_14, [
        _cache[27] || (_cache[27] = createBaseVNode("label", null, "Editor with custom height and CSS", -1)),
        createVNode(_component_NodeRedEditorInput, {
          value: $props.node.csstest,
          "onUpdate:value": _cache[13] || (_cache[13] = ($event) => $props.node.csstest = $event),
          language: "css",
          style: { "height": "100px" },
          error: $props.errors["node.csstest"]
        }, null, 8, ["value", "error"])
      ])
    ]);
  }
  const component = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
  const yourNode = registerType({
    category: "function",
    color: "#FFFFFF",
    inputs: 1,
    outputs: 1,
    icon: "vue.png",
    form: {
      component,
      disableSaveButtonOnError: true
    },
    onPaletteAdd: () => {
      console.log("NODE TYPE REGISTERED ON THE PALETTE");
    }
  });
  async function registerNodes() {
    try {
      await Promise.all([remoteServer("remote-server"), yourNode("your-node")]);
      console.log("All node types registered in parallel");
    } catch (error) {
      console.error("Error registering node types:", error);
    }
  }
  registerNodes();
})($);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnJnLlhrcEFLdGk2LmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2Z1bmN0aW9uL25vb3AubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNQcmltaXRpdmUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNUeXBlZEFycmF5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L19pbnRlcm5hbC9nZXRTeW1ib2xzLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L19pbnRlcm5hbC9nZXRUYWcubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvX2ludGVybmFsL3RhZ3MubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9vYmplY3QvY2xvbmVEZWVwV2l0aC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9jbG9uZURlZXAubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNQbGFpbk9iamVjdC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9tZXJnZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC91dGlsL2VxLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzRXF1YWxXaXRoLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzRXF1YWwubWpzIiwiLi4vc3JjL2NvcmUvdXRpbHMudHMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL3Njb3BlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3V0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9uYW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2Vycm9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2Jvb2xTY2hlbWEuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9ydWxlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RlZmF1bHRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb2RlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUva2V5d29yZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL3N1YnNjaGVtYS5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZXNvbHZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVmX2Vycm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3Njb3BlZENoYXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3VyaS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2lkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL3JlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29yZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9tdWx0aXBsZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9wYXR0ZXJuLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdEl0ZW1zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvZXF1YWwuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vY29uc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZW51bS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsSXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2NvbnRhaW5zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0eU5hbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcGF0dGVyblByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL29uZU9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FsbE9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3RoZW5FbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kcmFmdDcuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvdHlwZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvYWp2LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2xpbWl0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2LWVycm9ycy9kaXN0L2luZGV4LmpzIiwiLi4vc3JjL2NvcmUvdmFsaWRhdG9yLXNlcnZpY2UudHMiLCIuLi9zcmMvY29yZS92YWxpZGF0b3IudHMiLCIuLi9ub2RlX21vZHVsZXMvanNvbnBvaW50ZXIvanNvbnBvaW50ZXIuanMiLCIuLi9zcmMvY29yZS9BcHAudnVlIiwiLi4vc3JjL2NvcmUvY29tcG9uZW50cy9Ob2RlUmVkSW5wdXQudnVlIiwiLi4vc3JjL2NvcmUvY29uc3RhbnRzLnRzIiwiLi4vc3JjL2NvcmUvY29tcG9uZW50cy9Ob2RlUmVkVHlwZWRJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRDb25maWdJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRTZWxlY3RJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jb21wb25lbnRzL05vZGVSZWRFZGl0b3JJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9pbmRleC50cyIsIi4uL3NyYy9ub2Rlcy9yZW1vdGUtc2VydmVyL0Zvcm0udnVlIiwiLi4vc3JjL25vZGVzL3JlbW90ZS1zZXJ2ZXIvaW5kZXgudHMiLCIuLi9zcmMvbm9kZXMveW91ci1ub2RlL0Zvcm0udnVlIiwiLi4vc3JjL25vZGVzL3lvdXItbm9kZS9pbmRleC50cyIsIi4uL3NyYy9jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEB2dWUvc2hhcmVkIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBzdHIuc3BsaXQoXCIsXCIpKSBtYXBba2V5XSA9IDE7XG4gIHJldHVybiAodmFsKSA9PiB2YWwgaW4gbWFwO1xufVxuXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyB1cHBlcmNhc2UgbGV0dGVyXG4oa2V5LmNoYXJDb2RlQXQoMikgPiAxMjIgfHwga2V5LmNoYXJDb2RlQXQoMikgPCA5Nyk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIC8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbiAgXCIsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLG9uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZFwiXG4pO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbiAgfVxuKTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgY29uc3QgcyA9IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYDtcbiAgICByZXR1cm4gcztcbiAgfVxuKTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIC4uLmFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXSguLi5hcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSwgd3JpdGFibGUgPSBmYWxzZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGUsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cbmZ1bmN0aW9uIGdlbkNhY2hlS2V5KHNvdXJjZSwgb3B0aW9ucykge1xuICByZXR1cm4gc291cmNlICsgSlNPTi5zdHJpbmdpZnkoXG4gICAgb3B0aW9ucyxcbiAgICAoXywgdmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwudG9TdHJpbmcoKSA6IHZhbFxuICApO1xufVxuXG5jb25zdCBQYXRjaEZsYWdzID0ge1xuICBcIlRFWFRcIjogMSxcbiAgXCIxXCI6IFwiVEVYVFwiLFxuICBcIkNMQVNTXCI6IDIsXG4gIFwiMlwiOiBcIkNMQVNTXCIsXG4gIFwiU1RZTEVcIjogNCxcbiAgXCI0XCI6IFwiU1RZTEVcIixcbiAgXCJQUk9QU1wiOiA4LFxuICBcIjhcIjogXCJQUk9QU1wiLFxuICBcIkZVTExfUFJPUFNcIjogMTYsXG4gIFwiMTZcIjogXCJGVUxMX1BST1BTXCIsXG4gIFwiTkVFRF9IWURSQVRJT05cIjogMzIsXG4gIFwiMzJcIjogXCJORUVEX0hZRFJBVElPTlwiLFxuICBcIlNUQUJMRV9GUkFHTUVOVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlNUQUJMRV9GUkFHTUVOVFwiLFxuICBcIktFWUVEX0ZSQUdNRU5UXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJLRVlFRF9GUkFHTUVOVFwiLFxuICBcIlVOS0VZRURfRlJBR01FTlRcIjogMjU2LFxuICBcIjI1NlwiOiBcIlVOS0VZRURfRlJBR01FTlRcIixcbiAgXCJORUVEX1BBVENIXCI6IDUxMixcbiAgXCI1MTJcIjogXCJORUVEX1BBVENIXCIsXG4gIFwiRFlOQU1JQ19TTE9UU1wiOiAxMDI0LFxuICBcIjEwMjRcIjogXCJEWU5BTUlDX1NMT1RTXCIsXG4gIFwiREVWX1JPT1RfRlJBR01FTlRcIjogMjA0OCxcbiAgXCIyMDQ4XCI6IFwiREVWX1JPT1RfRlJBR01FTlRcIixcbiAgXCJDQUNIRURcIjogLTEsXG4gIFwiLTFcIjogXCJDQUNIRURcIixcbiAgXCJCQUlMXCI6IC0yLFxuICBcIi0yXCI6IFwiQkFJTFwiXG59O1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gIFsxXTogYFRFWFRgLFxuICBbMl06IGBDTEFTU2AsXG4gIFs0XTogYFNUWUxFYCxcbiAgWzhdOiBgUFJPUFNgLFxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXG4gIFszMl06IGBORUVEX0hZRFJBVElPTmAsXG4gIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXG4gIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgWy0xXTogYEhPSVNURURgLFxuICBbLTJdOiBgQkFJTGBcbn07XG5cbmNvbnN0IFNoYXBlRmxhZ3MgPSB7XG4gIFwiRUxFTUVOVFwiOiAxLFxuICBcIjFcIjogXCJFTEVNRU5UXCIsXG4gIFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIjogMixcbiAgXCIyXCI6IFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIixcbiAgXCJTVEFURUZVTF9DT01QT05FTlRcIjogNCxcbiAgXCI0XCI6IFwiU1RBVEVGVUxfQ09NUE9ORU5UXCIsXG4gIFwiVEVYVF9DSElMRFJFTlwiOiA4LFxuICBcIjhcIjogXCJURVhUX0NISUxEUkVOXCIsXG4gIFwiQVJSQVlfQ0hJTERSRU5cIjogMTYsXG4gIFwiMTZcIjogXCJBUlJBWV9DSElMRFJFTlwiLFxuICBcIlNMT1RTX0NISUxEUkVOXCI6IDMyLFxuICBcIjMyXCI6IFwiU0xPVFNfQ0hJTERSRU5cIixcbiAgXCJURUxFUE9SVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlRFTEVQT1JUXCIsXG4gIFwiU1VTUEVOU0VcIjogMTI4LFxuICBcIjEyOFwiOiBcIlNVU1BFTlNFXCIsXG4gIFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCI6IDI1NixcbiAgXCIyNTZcIjogXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIixcbiAgXCJDT01QT05FTlRfS0VQVF9BTElWRVwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIixcbiAgXCJDT01QT05FTlRcIjogNixcbiAgXCI2XCI6IFwiQ09NUE9ORU5UXCJcbn07XG5cbmNvbnN0IFNsb3RGbGFncyA9IHtcbiAgXCJTVEFCTEVcIjogMSxcbiAgXCIxXCI6IFwiU1RBQkxFXCIsXG4gIFwiRFlOQU1JQ1wiOiAyLFxuICBcIjJcIjogXCJEWU5BTUlDXCIsXG4gIFwiRk9SV0FSREVEXCI6IDMsXG4gIFwiM1wiOiBcIkZPUldBUkRFRFwiXG59O1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgWzFdOiBcIlNUQUJMRVwiLFxuICBbMl06IFwiRFlOQU1JQ1wiLFxuICBbM106IFwiRk9SV0FSREVEXCJcbn07XG5cbmNvbnN0IEdMT0JBTFNfQUxMT1dFRCA9IFwiSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LGNvbnNvbGUsRXJyb3IsU3ltYm9sXCI7XG5jb25zdCBpc0dsb2JhbGx5QWxsb3dlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfQUxMT1dFRCk7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSBpc0dsb2JhbGx5QWxsb3dlZDtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCwgc291cmNlLmxlbmd0aCkpO1xuICBlbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlbmQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gXCJcIjtcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGggfHwgMCk7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgcmVzLnB1c2goXG4gICAgICAgICAgYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gbmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCIgXCIucmVwZWF0KHBhZCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooW15dKykvO1xuY29uc3Qgc3R5bGVDb21tZW50UkUgPSAvXFwvXFwqW15dKj9cXCpcXC8vZztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY3NzVGV4dC5yZXBsYWNlKHN0eWxlQ29tbWVudFJFLCBcIlwiKS5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gIGlmICghc3R5bGVzKSByZXR1cm4gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHN0eWxlcykpIHJldHVybiBzdHlsZXM7XG4gIGxldCByZXQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXMgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xuICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbmNvbnN0IEhUTUxfVEFHUyA9IFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LHN1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3RcIjtcbmNvbnN0IFNWR19UQUdTID0gXCJzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlcixmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLGZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCxmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLGZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzayxtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXdcIjtcbmNvbnN0IE1BVEhfVEFHUyA9IFwiYW5ub3RhdGlvbixhbm5vdGF0aW9uLXhtbCxtYWN0aW9uLG1hbGlnbmdyb3VwLG1hbGlnbm1hcmssbWF0aCxtZW5jbG9zZSxtZXJyb3IsbWZlbmNlZCxtZnJhYyxtZnJhY3Rpb24sbWdseXBoLG1pLG1sYWJlbGVkdHIsbWxvbmdkaXYsbW11bHRpc2NyaXB0cyxtbixtbyxtb3ZlcixtcGFkZGVkLG1waGFudG9tLG1wcmVzY3JpcHRzLG1yb290LG1yb3csbXMsbXNjYXJyaWVzLG1zY2FycnksbXNncm91cCxtc2xpbmUsbXNwYWNlLG1zcXJ0LG1zcm93LG1zdGFjayxtc3R5bGUsbXN1Yixtc3Vic3VwLG1zdXAsbXRhYmxlLG10ZCxtdGV4dCxtdHIsbXVuZGVyLG11bmRlcm92ZXIsbm9uZSxzZW1hbnRpY3NcIjtcbmNvbnN0IFZPSURfVEFHUyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIjtcbmNvbnN0IGlzSFRNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG5jb25zdCBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcbmNvbnN0IGlzTWF0aE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoTUFUSF9UQUdTKTtcbmNvbnN0IGlzVm9pZFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixpbmVydCxsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgXG4pO1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSBcIlwiO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICB9XG4gIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xuICBpZiAoaXNVbnNhZmUpIHtcbiAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgfVxuICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZTtcbn1cbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xuICBhY2NlcHRDaGFyc2V0OiBcImFjY2VwdC1jaGFyc2V0XCIsXG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiLFxuICBodHRwRXF1aXY6IFwiaHR0cC1lcXVpdlwiXG59O1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGluZXJ0LGludGVncml0eSxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcGBcbik7XG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxyZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxyZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2Usc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyx3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbG5zOnhsaW5rLHhtbDpiYXNlLHhtbDpsYW5nLHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYFxuKTtcbmNvbnN0IGlzS25vd25NYXRoTUxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlbnQsYWNjZW50dW5kZXIsYWN0aW9udHlwZSxhbGlnbixhbGlnbm1lbnRzY29wZSxhbHRpbWcsYWx0aW1nLWhlaWdodCxhbHRpbWctdmFsaWduLGFsdGltZy13aWR0aCxhbHR0ZXh0LGJldmVsbGVkLGNsb3NlLGNvbHVtbnNhbGlnbixjb2x1bW5saW5lcyxjb2x1bW5zcGFuLGRlbm9tYWxpZ24sZGVwdGgsZGlyLGRpc3BsYXksZGlzcGxheXN0eWxlLGVuY29kaW5nLGVxdWFsY29sdW1ucyxlcXVhbHJvd3MsZmVuY2UsZm9udHN0eWxlLGZvbnR3ZWlnaHQsZm9ybSxmcmFtZSxmcmFtZXNwYWNpbmcsZ3JvdXBhbGlnbixoZWlnaHQsaHJlZixpZCxpbmRlbnRhbGlnbixpbmRlbnRhbGlnbmZpcnN0LGluZGVudGFsaWdubGFzdCxpbmRlbnRzaGlmdCxpbmRlbnRzaGlmdGZpcnN0LGluZGVudHNoaWZ0bGFzdCxpbmRleHR5cGUsanVzdGlmeSxsYXJnZXRvcCxsYXJnZW9wLGxxdW90ZSxsc3BhY2UsbWF0aGJhY2tncm91bmQsbWF0aGNvbG9yLG1hdGhzaXplLG1hdGh2YXJpYW50LG1heHNpemUsbWlubGFiZWxzcGFjaW5nLG1vZGUsb3RoZXIsb3ZlcmZsb3cscG9zaXRpb24scm93YWxpZ24scm93bGluZXMscm93c3BhbixycXVvdGUscnNwYWNlLHNjcmlwdGxldmVsLHNjcmlwdG1pbnNpemUsc2NyaXB0c2l6ZW11bHRpcGxpZXIsc2VsZWN0aW9uLHNlcGFyYXRvcixzZXBhcmF0b3JzLHNoaWZ0LHNpZGUsc3JjLHN0YWNrYWxpZ24sc3RyZXRjaHksc3Vic2NyaXB0c2hpZnQsc3VwZXJzY3JpcHRzaGlmdCxzeW1tZXRyaWMsdm9mZnNldCx3aWR0aCx3aWR0aHMseGxpbms6aHJlZix4bGluazpzaG93LHhsaW5rOnR5cGUseG1sbnNgXG4pO1xuZnVuY3Rpb24gaXNSZW5kZXJhYmxlQXR0clZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5jb25zdCBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFID0gL1sgIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXFxdXmB7fH1+XS9nO1xuZnVuY3Rpb24gZ2V0RXNjYXBlZENzc1Zhck5hbWUoa2V5LCBkb3VibGVFc2NhcGUpIHtcbiAgcmV0dXJuIGtleS5yZXBsYWNlKFxuICAgIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsXG4gICAgKHMpID0+IGRvdWJsZUVzY2FwZSA/IHMgPT09ICdcIicgPyAnXFxcXFxcXFxcXFxcXCInIDogYFxcXFxcXFxcJHtzfWAgOiBgXFxcXCR7c31gXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuY29uc3QgaXNSZWYgPSAodmFsKSA9PiB7XG4gIHJldHVybiAhISh2YWwgJiYgdmFsW1wiX192X2lzUmVmXCJdID09PSB0cnVlKTtcbn07XG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBpc1JlZih2YWwpID8gdG9EaXNwbGF5U3RyaW5nKHZhbC52YWx1ZSkgOiBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAoaXNSZWYodmFsKSkge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoXG4gICAgICAgIChlbnRyaWVzLCBba2V5LCB2YWwyXSwgaSkgPT4ge1xuICAgICAgICAgIGVudHJpZXNbc3RyaW5naWZ5U3ltYm9sKGtleSwgaSkgKyBcIiA9PlwiXSA9IHZhbDI7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXS5tYXAoKHYpID0+IHN0cmluZ2lmeVN5bWJvbCh2KSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU3ltYm9sKHZhbCkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3ltYm9sKHZhbCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5jb25zdCBzdHJpbmdpZnlTeW1ib2wgPSAodiwgaSA9IFwiXCIpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKFxuICAgIC8vIFN5bWJvbC5kZXNjcmlwdGlvbiBpbiBlczIwMTkrIHNvIHdlIG5lZWQgdG8gY2FzdCBoZXJlIHRvIHBhc3NcbiAgICAvLyB0aGUgbGliOiBlczIwMTYgY2hlY2tcbiAgICBpc1N5bWJvbCh2KSA/IGBTeW1ib2woJHsoX2EgPSB2LmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBpfSlgIDogdlxuICApO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgUGF0Y2hGbGFncywgU2hhcGVGbGFncywgU2xvdEZsYWdzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5DYWNoZUtleSwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRFc2NhcGVkQ3NzVmFyTmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5QWxsb3dlZCwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duTWF0aE1MQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01hdGhNTFRhZywgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwiLyoqXG4qIEB2dWUvcmVhY3Rpdml0eSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBoYXNDaGFuZ2VkLCBleHRlbmQsIGlzQXJyYXksIGlzSW50ZWdlcktleSwgaXNTeW1ib2wsIGlzTWFwLCBoYXNPd24sIGlzT2JqZWN0LCBtYWtlTWFwLCB0b1Jhd1R5cGUsIGNhcGl0YWxpemUsIGRlZiwgaXNGdW5jdGlvbiwgRU1QVFlfT0JKLCBpc1NldCwgaXNQbGFpbk9iamVjdCwgTk9PUCwgcmVtb3ZlIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgdGhpcy5pbmRleCA9IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaChcbiAgICAgICAgdGhpc1xuICAgICAgKSAtIDE7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5zY29wZXNbaV0ucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIHRoZSBlZmZlY3Qgc2NvcGUsIGluY2x1ZGluZyBhbGwgY2hpbGQgc2NvcGVzIGFuZCBlZmZlY3RzLlxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSwgbDtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zY29wZXNbaV0ucmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJ1bihmbikge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb24oKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2ZmKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFudXBzLmxlbmd0aCA9IDA7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcbiAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuXG5sZXQgYWN0aXZlU3ViO1xuY29uc3QgRWZmZWN0RmxhZ3MgPSB7XG4gIFwiQUNUSVZFXCI6IDEsXG4gIFwiMVwiOiBcIkFDVElWRVwiLFxuICBcIlJVTk5JTkdcIjogMixcbiAgXCIyXCI6IFwiUlVOTklOR1wiLFxuICBcIlRSQUNLSU5HXCI6IDQsXG4gIFwiNFwiOiBcIlRSQUNLSU5HXCIsXG4gIFwiTk9USUZJRURcIjogOCxcbiAgXCI4XCI6IFwiTk9USUZJRURcIixcbiAgXCJESVJUWVwiOiAxNixcbiAgXCIxNlwiOiBcIkRJUlRZXCIsXG4gIFwiQUxMT1dfUkVDVVJTRVwiOiAzMixcbiAgXCIzMlwiOiBcIkFMTE9XX1JFQ1VSU0VcIixcbiAgXCJQQVVTRURcIjogNjQsXG4gIFwiNjRcIjogXCJQQVVTRURcIlxufTtcbmNvbnN0IHBhdXNlZFF1ZXVlRWZmZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY2xhc3MgUmVhY3RpdmVFZmZlY3Qge1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmZsYWdzID0gMSB8IDQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuY2xlYW51cCA9IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHZvaWQgMDtcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUgJiYgYWN0aXZlRWZmZWN0U2NvcGUuYWN0aXZlKSB7XG4gICAgICBhY3RpdmVFZmZlY3RTY29wZS5lZmZlY3RzLnB1c2godGhpcyk7XG4gICAgfVxuICB9XG4gIHBhdXNlKCkge1xuICAgIHRoaXMuZmxhZ3MgfD0gNjQ7XG4gIH1cbiAgcmVzdW1lKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgNjQpIHtcbiAgICAgIHRoaXMuZmxhZ3MgJj0gfjY0O1xuICAgICAgaWYgKHBhdXNlZFF1ZXVlRWZmZWN0cy5oYXModGhpcykpIHtcbiAgICAgICAgcGF1c2VkUXVldWVFZmZlY3RzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeSgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDIgJiYgISh0aGlzLmZsYWdzICYgMzIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHRoaXMuZmxhZ3MgJiA4KSkge1xuICAgICAgYmF0Y2godGhpcyk7XG4gICAgfVxuICB9XG4gIHJ1bigpIHtcbiAgICBpZiAoISh0aGlzLmZsYWdzICYgMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfVxuICAgIHRoaXMuZmxhZ3MgfD0gMjtcbiAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgIHByZXBhcmVEZXBzKHRoaXMpO1xuICAgIGNvbnN0IHByZXZFZmZlY3QgPSBhY3RpdmVTdWI7XG4gICAgY29uc3QgcHJldlNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gICAgYWN0aXZlU3ViID0gdGhpcztcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1YiAhPT0gdGhpcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiQWN0aXZlIGVmZmVjdCB3YXMgbm90IHJlc3RvcmVkIGNvcnJlY3RseSAtIHRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFsIGJ1Zy5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2xlYW51cERlcHModGhpcyk7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2RWZmZWN0O1xuICAgICAgc2hvdWxkVHJhY2sgPSBwcmV2U2hvdWxkVHJhY2s7XG4gICAgICB0aGlzLmZsYWdzICY9IH4yO1xuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgMSkge1xuICAgICAgZm9yIChsZXQgbGluayA9IHRoaXMuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgICAgICByZW1vdmVTdWIobGluayk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlcHMgPSB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICAgIHRoaXMub25TdG9wICYmIHRoaXMub25TdG9wKCk7XG4gICAgICB0aGlzLmZsYWdzICY9IH4xO1xuICAgIH1cbiAgfVxuICB0cmlnZ2VyKCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgNjQpIHtcbiAgICAgIHBhdXNlZFF1ZXVlRWZmZWN0cy5hZGQodGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjaGVkdWxlcikge1xuICAgICAgdGhpcy5zY2hlZHVsZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydW5JZkRpcnR5KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJ1bklmRGlydHkoKSB7XG4gICAgaWYgKGlzRGlydHkodGhpcykpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICB9XG4gIGdldCBkaXJ0eSgpIHtcbiAgICByZXR1cm4gaXNEaXJ0eSh0aGlzKTtcbiAgfVxufVxubGV0IGJhdGNoRGVwdGggPSAwO1xubGV0IGJhdGNoZWRTdWI7XG5sZXQgYmF0Y2hlZENvbXB1dGVkO1xuZnVuY3Rpb24gYmF0Y2goc3ViLCBpc0NvbXB1dGVkID0gZmFsc2UpIHtcbiAgc3ViLmZsYWdzIHw9IDg7XG4gIGlmIChpc0NvbXB1dGVkKSB7XG4gICAgc3ViLm5leHQgPSBiYXRjaGVkQ29tcHV0ZWQ7XG4gICAgYmF0Y2hlZENvbXB1dGVkID0gc3ViO1xuICAgIHJldHVybjtcbiAgfVxuICBzdWIubmV4dCA9IGJhdGNoZWRTdWI7XG4gIGJhdGNoZWRTdWIgPSBzdWI7XG59XG5mdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICBiYXRjaERlcHRoKys7XG59XG5mdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgaWYgKC0tYmF0Y2hEZXB0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGJhdGNoZWRDb21wdXRlZCkge1xuICAgIGxldCBlID0gYmF0Y2hlZENvbXB1dGVkO1xuICAgIGJhdGNoZWRDb21wdXRlZCA9IHZvaWQgMDtcbiAgICB3aGlsZSAoZSkge1xuICAgICAgY29uc3QgbmV4dCA9IGUubmV4dDtcbiAgICAgIGUubmV4dCA9IHZvaWQgMDtcbiAgICAgIGUuZmxhZ3MgJj0gfjg7XG4gICAgICBlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgbGV0IGVycm9yO1xuICB3aGlsZSAoYmF0Y2hlZFN1Yikge1xuICAgIGxldCBlID0gYmF0Y2hlZFN1YjtcbiAgICBiYXRjaGVkU3ViID0gdm9pZCAwO1xuICAgIHdoaWxlIChlKSB7XG4gICAgICBjb25zdCBuZXh0ID0gZS5uZXh0O1xuICAgICAgZS5uZXh0ID0gdm9pZCAwO1xuICAgICAgZS5mbGFncyAmPSB+ODtcbiAgICAgIGlmIChlLmZsYWdzICYgMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBlLnRyaWdnZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUgPSBuZXh0O1xuICAgIH1cbiAgfVxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gcHJlcGFyZURlcHMoc3ViKSB7XG4gIGZvciAobGV0IGxpbmsgPSBzdWIuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgIGxpbmsudmVyc2lvbiA9IC0xO1xuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSBsaW5rLmRlcC5hY3RpdmVMaW5rO1xuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRGVwcyhzdWIpIHtcbiAgbGV0IGhlYWQ7XG4gIGxldCB0YWlsID0gc3ViLmRlcHNUYWlsO1xuICBsZXQgbGluayA9IHRhaWw7XG4gIHdoaWxlIChsaW5rKSB7XG4gICAgY29uc3QgcHJldiA9IGxpbmsucHJldkRlcDtcbiAgICBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xuICAgICAgaWYgKGxpbmsgPT09IHRhaWwpIHRhaWwgPSBwcmV2O1xuICAgICAgcmVtb3ZlU3ViKGxpbmspO1xuICAgICAgcmVtb3ZlRGVwKGxpbmspO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gbGluaztcbiAgICB9XG4gICAgbGluay5kZXAuYWN0aXZlTGluayA9IGxpbmsucHJldkFjdGl2ZUxpbms7XG4gICAgbGluay5wcmV2QWN0aXZlTGluayA9IHZvaWQgMDtcbiAgICBsaW5rID0gcHJldjtcbiAgfVxuICBzdWIuZGVwcyA9IGhlYWQ7XG4gIHN1Yi5kZXBzVGFpbCA9IHRhaWw7XG59XG5mdW5jdGlvbiBpc0RpcnR5KHN1Yikge1xuICBmb3IgKGxldCBsaW5rID0gc3ViLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICBpZiAobGluay5kZXAudmVyc2lvbiAhPT0gbGluay52ZXJzaW9uIHx8IGxpbmsuZGVwLmNvbXB1dGVkICYmIChyZWZyZXNoQ29tcHV0ZWQobGluay5kZXAuY29tcHV0ZWQpIHx8IGxpbmsuZGVwLnZlcnNpb24gIT09IGxpbmsudmVyc2lvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc3ViLl9kaXJ0eSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlZnJlc2hDb21wdXRlZChjb21wdXRlZCkge1xuICBpZiAoY29tcHV0ZWQuZmxhZ3MgJiA0ICYmICEoY29tcHV0ZWQuZmxhZ3MgJiAxNikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZmxhZ3MgJj0gfjE2O1xuICBpZiAoY29tcHV0ZWQuZ2xvYmFsVmVyc2lvbiA9PT0gZ2xvYmFsVmVyc2lvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wdXRlZC5nbG9iYWxWZXJzaW9uID0gZ2xvYmFsVmVyc2lvbjtcbiAgY29uc3QgZGVwID0gY29tcHV0ZWQuZGVwO1xuICBjb21wdXRlZC5mbGFncyB8PSAyO1xuICBpZiAoZGVwLnZlcnNpb24gPiAwICYmICFjb21wdXRlZC5pc1NTUiAmJiBjb21wdXRlZC5kZXBzICYmICFpc0RpcnR5KGNvbXB1dGVkKSkge1xuICAgIGNvbXB1dGVkLmZsYWdzICY9IH4yO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgYWN0aXZlU3ViID0gY29tcHV0ZWQ7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBwcmVwYXJlRGVwcyhjb21wdXRlZCk7XG4gICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZC5mbihjb21wdXRlZC5fdmFsdWUpO1xuICAgIGlmIChkZXAudmVyc2lvbiA9PT0gMCB8fCBoYXNDaGFuZ2VkKHZhbHVlLCBjb21wdXRlZC5fdmFsdWUpKSB7XG4gICAgICBjb21wdXRlZC5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlcC52ZXJzaW9uKys7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZXAudmVyc2lvbisrO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgIGNsZWFudXBEZXBzKGNvbXB1dGVkKTtcbiAgICBjb21wdXRlZC5mbGFncyAmPSB+MjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3ViKGxpbmssIHNvZnQgPSBmYWxzZSkge1xuICBjb25zdCB7IGRlcCwgcHJldlN1YiwgbmV4dFN1YiB9ID0gbGluaztcbiAgaWYgKHByZXZTdWIpIHtcbiAgICBwcmV2U3ViLm5leHRTdWIgPSBuZXh0U3ViO1xuICAgIGxpbmsucHJldlN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAobmV4dFN1Yikge1xuICAgIG5leHRTdWIucHJldlN1YiA9IHByZXZTdWI7XG4gICAgbGluay5uZXh0U3ViID0gdm9pZCAwO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlcC5zdWJzSGVhZCA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzSGVhZCA9IG5leHRTdWI7XG4gIH1cbiAgaWYgKGRlcC5zdWJzID09PSBsaW5rKSB7XG4gICAgZGVwLnN1YnMgPSBwcmV2U3ViO1xuICAgIGlmICghcHJldlN1YiAmJiBkZXAuY29tcHV0ZWQpIHtcbiAgICAgIGRlcC5jb21wdXRlZC5mbGFncyAmPSB+NDtcbiAgICAgIGZvciAobGV0IGwgPSBkZXAuY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICByZW1vdmVTdWIobCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghc29mdCAmJiAhLS1kZXAuc2MgJiYgZGVwLm1hcCkge1xuICAgIGRlcC5tYXAuZGVsZXRlKGRlcC5rZXkpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVEZXAobGluaykge1xuICBjb25zdCB7IHByZXZEZXAsIG5leHREZXAgfSA9IGxpbms7XG4gIGlmIChwcmV2RGVwKSB7XG4gICAgcHJldkRlcC5uZXh0RGVwID0gbmV4dERlcDtcbiAgICBsaW5rLnByZXZEZXAgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHREZXApIHtcbiAgICBuZXh0RGVwLnByZXZEZXAgPSBwcmV2RGVwO1xuICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gIGlmIChmbi5lZmZlY3QgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGZuID0gZm4uZWZmZWN0LmZuO1xuICB9XG4gIGNvbnN0IGUgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZChlLCBvcHRpb25zKTtcbiAgfVxuICB0cnkge1xuICAgIGUucnVuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGUuc3RvcCgpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBjb25zdCBydW5uZXIgPSBlLnJ1bi5iaW5kKGUpO1xuICBydW5uZXIuZWZmZWN0ID0gZTtcbiAgcmV0dXJuIHJ1bm5lcjtcbn1cbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XG4gIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiBvbkVmZmVjdENsZWFudXAoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVTdWIgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGFjdGl2ZVN1Yi5jbGVhbnVwID0gZm47XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbkVmZmVjdENsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSBlZmZlY3QgdG8gYXNzb2NpYXRlIHdpdGguYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZSkge1xuICBjb25zdCB7IGNsZWFudXAgfSA9IGU7XG4gIGUuY2xlYW51cCA9IHZvaWQgMDtcbiAgaWYgKGNsZWFudXApIHtcbiAgICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICAgIGFjdGl2ZVN1YiA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgZ2xvYmFsVmVyc2lvbiA9IDA7XG5jbGFzcyBMaW5rIHtcbiAgY29uc3RydWN0b3Ioc3ViLCBkZXApIHtcbiAgICB0aGlzLnN1YiA9IHN1YjtcbiAgICB0aGlzLmRlcCA9IGRlcDtcbiAgICB0aGlzLnZlcnNpb24gPSBkZXAudmVyc2lvbjtcbiAgICB0aGlzLm5leHREZXAgPSB0aGlzLnByZXZEZXAgPSB0aGlzLm5leHRTdWIgPSB0aGlzLnByZXZTdWIgPSB0aGlzLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xuICB9XG59XG5jbGFzcyBEZXAge1xuICBjb25zdHJ1Y3Rvcihjb21wdXRlZCkge1xuICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIExpbmsgYmV0d2VlbiB0aGlzIGRlcCBhbmQgdGhlIGN1cnJlbnQgYWN0aXZlIGVmZmVjdFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlTGluayA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBEb3VibHkgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJzY3JpYmluZyBlZmZlY3RzICh0YWlsKVxuICAgICAqL1xuICAgIHRoaXMuc3VicyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBGb3Igb2JqZWN0IHByb3BlcnR5IGRlcHMgY2xlYW51cFxuICAgICAqL1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXIgY291bnRlclxuICAgICAqL1xuICAgIHRoaXMuc2MgPSAwO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLnN1YnNIZWFkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICB0cmFjayhkZWJ1Z0luZm8pIHtcbiAgICBpZiAoIWFjdGl2ZVN1YiB8fCAhc2hvdWxkVHJhY2sgfHwgYWN0aXZlU3ViID09PSB0aGlzLmNvbXB1dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsaW5rID0gdGhpcy5hY3RpdmVMaW5rO1xuICAgIGlmIChsaW5rID09PSB2b2lkIDAgfHwgbGluay5zdWIgIT09IGFjdGl2ZVN1Yikge1xuICAgICAgbGluayA9IHRoaXMuYWN0aXZlTGluayA9IG5ldyBMaW5rKGFjdGl2ZVN1YiwgdGhpcyk7XG4gICAgICBpZiAoIWFjdGl2ZVN1Yi5kZXBzKSB7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgfVxuICAgICAgYWRkU3ViKGxpbmspO1xuICAgIH0gZWxzZSBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgaWYgKGxpbmsubmV4dERlcCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gbGluay5uZXh0RGVwO1xuICAgICAgICBuZXh0LnByZXZEZXAgPSBsaW5rLnByZXZEZXA7XG4gICAgICAgIGlmIChsaW5rLnByZXZEZXApIHtcbiAgICAgICAgICBsaW5rLnByZXZEZXAubmV4dERlcCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xuICAgICAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgICAgaWYgKGFjdGl2ZVN1Yi5kZXBzID09PSBsaW5rKSB7XG4gICAgICAgICAgYWN0aXZlU3ViLmRlcHMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1Yi5vblRyYWNrKSB7XG4gICAgICBhY3RpdmVTdWIub25UcmFjayhcbiAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlU3ViXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH1cbiAgdHJpZ2dlcihkZWJ1Z0luZm8pIHtcbiAgICB0aGlzLnZlcnNpb24rKztcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgdGhpcy5ub3RpZnkoZGVidWdJbmZvKTtcbiAgfVxuICBub3RpZnkoZGVidWdJbmZvKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGxldCBoZWFkID0gdGhpcy5zdWJzSGVhZDsgaGVhZDsgaGVhZCA9IGhlYWQubmV4dFN1Yikge1xuICAgICAgICAgIGlmIChoZWFkLnN1Yi5vblRyaWdnZXIgJiYgIShoZWFkLnN1Yi5mbGFncyAmIDgpKSB7XG4gICAgICAgICAgICBoZWFkLnN1Yi5vblRyaWdnZXIoXG4gICAgICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlZmZlY3Q6IGhlYWQuc3ViXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLnN1YnM7IGxpbms7IGxpbmsgPSBsaW5rLnByZXZTdWIpIHtcbiAgICAgICAgaWYgKGxpbmsuc3ViLm5vdGlmeSgpKSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGxpbmsuc3ViLmRlcC5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkU3ViKGxpbmspIHtcbiAgbGluay5kZXAuc2MrKztcbiAgaWYgKGxpbmsuc3ViLmZsYWdzICYgNCkge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gbGluay5kZXAuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkICYmICFsaW5rLmRlcC5zdWJzKSB7XG4gICAgICBjb21wdXRlZC5mbGFncyB8PSA0IHwgMTY7XG4gICAgICBmb3IgKGxldCBsID0gY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICBhZGRTdWIobCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUYWlsID0gbGluay5kZXAuc3VicztcbiAgICBpZiAoY3VycmVudFRhaWwgIT09IGxpbmspIHtcbiAgICAgIGxpbmsucHJldlN1YiA9IGN1cnJlbnRUYWlsO1xuICAgICAgaWYgKGN1cnJlbnRUYWlsKSBjdXJyZW50VGFpbC5uZXh0U3ViID0gbGluaztcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbGluay5kZXAuc3Vic0hlYWQgPT09IHZvaWQgMCkge1xuICAgICAgbGluay5kZXAuc3Vic0hlYWQgPSBsaW5rO1xuICAgIH1cbiAgICBsaW5rLmRlcC5zdWJzID0gbGluaztcbiAgfVxufVxuY29uc3QgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiT2JqZWN0IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5jb25zdCBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJNYXAga2V5cyBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgQVJSQVlfSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkFycmF5IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlU3ViKSB7XG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFkZXBzTWFwKSB7XG4gICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgRGVwKCkpO1xuICAgICAgZGVwLm1hcCA9IGRlcHNNYXA7XG4gICAgICBkZXAua2V5ID0ga2V5O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXAudHJhY2soKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghZGVwc01hcCkge1xuICAgIGdsb2JhbFZlcnNpb24rKztcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcnVuID0gKGRlcCkgPT4ge1xuICAgIGlmIChkZXApIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YXJ0QmF0Y2goKTtcbiAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgIGRlcHNNYXAuZm9yRWFjaChydW4pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgY29uc3QgaXNBcnJheUluZGV4ID0gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KTtcbiAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiBrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IE51bWJlcihuZXdWYWx1ZSk7XG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID09PSBBUlJBWV9JVEVSQVRFX0tFWSB8fCAhaXNTeW1ib2woa2V5MikgJiYga2V5MiA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgICBydW4oZGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgIT09IHZvaWQgMCB8fCBkZXBzTWFwLmhhcyh2b2lkIDApKSB7XG4gICAgICAgIHJ1bihkZXBzTWFwLmdldChrZXkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW5kZXgpIHtcbiAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KEFSUkFZX0lURVJBVEVfS0VZKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCk7XG59XG5mdW5jdGlvbiBnZXREZXBGcm9tUmVhY3RpdmUob2JqZWN0LCBrZXkpIHtcbiAgY29uc3QgZGVwTWFwID0gdGFyZ2V0TWFwLmdldChvYmplY3QpO1xuICByZXR1cm4gZGVwTWFwICYmIGRlcE1hcC5nZXQoa2V5KTtcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmVSZWFkQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmF3ID0gdG9SYXcoYXJyYXkpO1xuICBpZiAocmF3ID09PSBhcnJheSkgcmV0dXJuIHJhdztcbiAgdHJhY2socmF3LCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gaXNTaGFsbG93KGFycmF5KSA/IHJhdyA6IHJhdy5tYXAodG9SZWFjdGl2ZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZEFycmF5KGFycikge1xuICB0cmFjayhhcnIgPSB0b1JhdyhhcnIpLCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gYXJyO1xufVxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBTeW1ib2wuaXRlcmF0b3IsIHRvUmVhY3RpdmUpO1xuICB9LFxuICBjb25jYXQoLi4uYXJncykge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5jb25jYXQoXG4gICAgICAuLi5hcmdzLm1hcCgoeCkgPT4gaXNBcnJheSh4KSA/IHJlYWN0aXZlUmVhZEFycmF5KHgpIDogeClcbiAgICApO1xuICB9LFxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcImVudHJpZXNcIiwgKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZVsxXSA9IHRvUmVhY3RpdmUodmFsdWVbMV0pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LFxuICBldmVyeShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImV2ZXJ5XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbHRlcihmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbHRlclwiLCBmbiwgdGhpc0FyZywgKHYpID0+IHYubWFwKHRvUmVhY3RpdmUpLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZFwiLCBmbiwgdGhpc0FyZywgdG9SZWFjdGl2ZSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZEluZGV4KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZExhc3RcIiwgZm4sIHRoaXNBcmcsIHRvUmVhY3RpdmUsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRMYXN0SW5kZXgoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kTGFzdEluZGV4XCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIC8vIGZsYXQsIGZsYXRNYXAgY291bGQgYmVuZWZpdCBmcm9tIEFSUkFZX0lURVJBVEUgYnV0IGFyZSBub3Qgc3RyYWlnaHQtZm9yd2FyZCB0byBpbXBsZW1lbnRcbiAgZm9yRWFjaChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZvckVhY2hcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgaW5jbHVkZXMoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImluY2x1ZGVzXCIsIGFyZ3MpO1xuICB9LFxuICBpbmRleE9mKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5qb2luKHNlcGFyYXRvcik7XG4gIH0sXG4gIC8vIGtleXMoKSBpdGVyYXRvciBvbmx5IHJlYWRzIGBsZW5ndGhgLCBubyBvcHRpbWlzYXRpb24gcmVxdWlyZWRcbiAgbGFzdEluZGV4T2YoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImxhc3RJbmRleE9mXCIsIGFyZ3MpO1xuICB9LFxuICBtYXAoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJtYXBcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgcG9wKCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicG9wXCIpO1xuICB9LFxuICBwdXNoKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInB1c2hcIiwgYXJncyk7XG4gIH0sXG4gIHJlZHVjZShmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VcIiwgZm4sIGFyZ3MpO1xuICB9LFxuICByZWR1Y2VSaWdodChmbiwgLi4uYXJncykge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgXCJyZWR1Y2VSaWdodFwiLCBmbiwgYXJncyk7XG4gIH0sXG4gIHNoaWZ0KCkge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic2hpZnRcIik7XG4gIH0sXG4gIC8vIHNsaWNlIGNvdWxkIHVzZSBBUlJBWV9JVEVSQVRFIGJ1dCBhbHNvIHNlZW1zIHRvIGJlZyBmb3IgcmFuZ2UgdHJhY2tpbmdcbiAgc29tZShmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcInNvbWVcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgc3BsaWNlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInNwbGljZVwiLCBhcmdzKTtcbiAgfSxcbiAgdG9SZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9SZXZlcnNlZCgpO1xuICB9LFxuICB0b1NvcnRlZChjb21wYXJlcikge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1NvcnRlZChjb21wYXJlcik7XG4gIH0sXG4gIHRvU3BsaWNlZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU3BsaWNlZCguLi5hcmdzKTtcbiAgfSxcbiAgdW5zaGlmdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJ1bnNoaWZ0XCIsIGFyZ3MpO1xuICB9LFxuICB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFwidmFsdWVzXCIsIHRvUmVhY3RpdmUpO1xuICB9XG59O1xuZnVuY3Rpb24gaXRlcmF0b3Ioc2VsZiwgbWV0aG9kLCB3cmFwVmFsdWUpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgaXRlciA9IGFyclttZXRob2RdKCk7XG4gIGlmIChhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKSkge1xuICAgIGl0ZXIuX25leHQgPSBpdGVyLm5leHQ7XG4gICAgaXRlci5uZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaXRlci5fbmV4dCgpO1xuICAgICAgaWYgKHJlc3VsdC52YWx1ZSkge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB3cmFwVmFsdWUocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gaXRlcjtcbn1cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5mdW5jdGlvbiBhcHBseShzZWxmLCBtZXRob2QsIGZuLCB0aGlzQXJnLCB3cmFwcGVkUmV0Rm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgY29uc3QgbmVlZHNXcmFwID0gYXJyICE9PSBzZWxmICYmICFpc1NoYWxsb3coc2VsZik7XG4gIGNvbnN0IG1ldGhvZEZuID0gYXJyW21ldGhvZF07XG4gIGlmIChtZXRob2RGbiAhPT0gYXJyYXlQcm90b1ttZXRob2RdKSB7XG4gICAgY29uc3QgcmVzdWx0MiA9IG1ldGhvZEZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIHJldHVybiBuZWVkc1dyYXAgPyB0b1JlYWN0aXZlKHJlc3VsdDIpIDogcmVzdWx0MjtcbiAgfVxuICBsZXQgd3JhcHBlZEZuID0gZm47XG4gIGlmIChhcnIgIT09IHNlbGYpIHtcbiAgICBpZiAobmVlZHNXcmFwKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0b1JlYWN0aXZlKGl0ZW0pLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm4ubGVuZ3RoID4gMikge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgaXRlbSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbWV0aG9kRm4uY2FsbChhcnIsIHdyYXBwZWRGbiwgdGhpc0FyZyk7XG4gIHJldHVybiBuZWVkc1dyYXAgJiYgd3JhcHBlZFJldEZuID8gd3JhcHBlZFJldEZuKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWR1Y2Uoc2VsZiwgbWV0aG9kLCBmbiwgYXJncykge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBsZXQgd3JhcHBlZEZuID0gZm47XG4gIGlmIChhcnIgIT09IHNlbGYpIHtcbiAgICBpZiAoIWlzU2hhbGxvdyhzZWxmKSkge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIHRvUmVhY3RpdmUoaXRlbSksIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAzKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFjYywgaXRlbSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyclttZXRob2RdKHdyYXBwZWRGbiwgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBzZWFyY2hQcm94eShzZWxmLCBtZXRob2QsIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gdG9SYXcoc2VsZik7XG4gIHRyYWNrKGFyciwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgY29uc3QgcmVzID0gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIGlmICgocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSAmJiBpc1Byb3h5KGFyZ3NbMF0pKSB7XG4gICAgYXJnc1swXSA9IHRvUmF3KGFyZ3NbMF0pO1xuICAgIHJldHVybiBhcnJbbWV0aG9kXSguLi5hcmdzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbm9UcmFja2luZyhzZWxmLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIHN0YXJ0QmF0Y2goKTtcbiAgY29uc3QgcmVzID0gdG9SYXcoc2VsZilbbWV0aG9kXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgZW5kQmF0Y2goKTtcbiAgcmVzZXRUcmFja2luZygpO1xuICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoXG4gIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLmZpbHRlcigoa2V5KSA9PiBrZXkgIT09IFwiYXJndW1lbnRzXCIgJiYga2V5ICE9PSBcImNhbGxlclwiKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbClcbik7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgaWYgKCFpc1N5bWJvbChrZXkpKSBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XG4gIHRyYWNrKG9iaiwgXCJoYXNcIiwga2V5KTtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xufVxuY2xhc3MgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKF9pc1JlYWRvbmx5ID0gZmFsc2UsIF9pc1NoYWxsb3cgPSBmYWxzZSkge1xuICAgIHRoaXMuX2lzUmVhZG9ubHkgPSBfaXNSZWFkb25seTtcbiAgICB0aGlzLl9pc1NoYWxsb3cgPSBfaXNTaGFsbG93O1xuICB9XG4gIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIpIHJldHVybiB0YXJnZXRbXCJfX3Zfc2tpcFwiXTtcbiAgICBjb25zdCBpc1JlYWRvbmx5MiA9IHRoaXMuX2lzUmVhZG9ubHksIGlzU2hhbGxvdzIgPSB0aGlzLl9pc1NoYWxsb3c7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIpIHtcbiAgICAgIHJldHVybiBpc1NoYWxsb3cyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgaWYgKHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpIHx8IC8vIHJlY2VpdmVyIGlzIG5vdCB0aGUgcmVhY3RpdmUgcHJveHksIGJ1dCBoYXMgdGhlIHNhbWUgcHJvdG90eXBlXG4gICAgICAvLyB0aGlzIG1lYW5zIHRoZSByZWNlaXZlciBpcyBhIHVzZXIgcHJveHkgb2YgdGhlIHJlYWN0aXZlIHByb3h5XG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHJlY2VpdmVyKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIGxldCBmbjtcbiAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIChmbiA9IGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImhhc093blByb3BlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldChcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm94eSB3cmFwcGluZyBhIHJlZiwgcmV0dXJuIG1ldGhvZHMgdXNpbmcgdGhlIHJhdyByZWZcbiAgICAgIC8vIGFzIHJlY2VpdmVyIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjYWxsIGB0b1Jhd2Agb24gdGhlIHJlZiBpbiBhbGxcbiAgICAgIC8vIGl0cyBjbGFzcyBtZXRob2RzXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcbiAgICApO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoaXNTaGFsbG93Mikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpID8gcmVzIDogcmVzLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cbmNsYXNzIE11dGFibGVSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoaXNTaGFsbG93MiA9IGZhbHNlKSB7XG4gICAgc3VwZXIoZmFsc2UsIGlzU2hhbGxvdzIpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCF0aGlzLl9pc1NoYWxsb3cpIHtcbiAgICAgIGNvbnN0IGlzT2xkVmFsdWVSZWFkb25seSA9IGlzUmVhZG9ubHkob2xkVmFsdWUpO1xuICAgICAgaWYgKCFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBpZiAoaXNPbGRWYWx1ZVJlYWRvbmx5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldChcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgaXNSZWYodGFyZ2V0KSA/IHRhcmdldCA6IHJlY2VpdmVyXG4gICAgKTtcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICB0cmFjayhcbiAgICAgIHRhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH1cbn1cbmNsYXNzIFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKHRydWUsIGlzU2hhbGxvdzIpO1xuICB9XG4gIHNldCh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIoKTtcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXV0YWJsZVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcih0cnVlKTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHkyLCBpc1NoYWxsb3cyKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XG4gICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93MiA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKFxuICAgICAgcmF3VGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyB2YWx1ZSwgZG9uZSB9IDoge1xuICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0b1Jhdyh0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHR5cGUgPT09IFwiY2xlYXJcIiA/IHZvaWQgMCA6IHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKHJlYWRvbmx5LCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgIGlmICghcmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwgcmF3S2V5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICAgICAgY29uc3Qgd3JhcCA9IHNoYWxsb3cgPyB0b1NoYWxsb3cgOiByZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICAgICAgfSBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgICFyZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgXCJzaXplXCIsIHRhcmdldCk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgaWYgKCFyZWFkb25seSkge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcbiAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbiAgICB9LFxuICAgIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCB3cmFwID0gc2hhbGxvdyA/IHRvU2hhbGxvdyA6IHJlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXh0ZW5kKFxuICAgIGluc3RydW1lbnRhdGlvbnMsXG4gICAgcmVhZG9ubHkgPyB7XG4gICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKVxuICAgIH0gOiB7XG4gICAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKGhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICAgICAgICBjb25zdCBvbGRUYXJnZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gICAgICAgIGlmIChoYWRJdGVtcykge1xuICAgICAgICAgIHRyaWdnZXIoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBcImNsZWFyXCIsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBvbGRUYXJnZXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXG4gICAgXCJrZXlzXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcImVudHJpZXNcIixcbiAgICBTeW1ib2wuaXRlcmF0b3JcbiAgXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgcmVhZG9ubHksIHNoYWxsb3cpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seTIsIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoaXNSZWFkb25seTIsIHNoYWxsb3cpO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXG4gICAgICBoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHJlY2VpdmVyXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KSB7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgd2FybihcbiAgICAgIGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgPyAwIC8qIElOVkFMSUQgKi8gOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgbXV0YWJsZUhhbmRsZXJzLFxuICAgIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyxcbiAgICBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICByZWFkb25seUhhbmRsZXJzLFxuICAgIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSAke2lzUmVhZG9ubHkyID8gXCJyZWFkb25seVwiIDogXCJyZWFjdGl2ZVwifTogJHtTdHJpbmcoXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG4gIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XG4gIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHRhcmdldCxcbiAgICB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnNcbiAgKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XG4gIH1cbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/ICEhdmFsdWVbXCJfX3ZfcmF3XCJdIDogZmFsc2U7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gIGlmICghaGFzT3duKHZhbHVlLCBcIl9fdl9za2lwXCIpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuIHIgPyByW1wiX192X2lzUmVmXCJdID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIGlzU2hhbGxvdzIpIHtcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSA9IGZhbHNlO1xuICAgIHRoaXMuX3Jhd1ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBpc1NoYWxsb3cyO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5kZXAudHJhY2soe1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXAudHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmF3VmFsdWU7XG4gICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSB8fCBpc1NoYWxsb3cobmV3VmFsdWUpIHx8IGlzUmVhZG9ubHkobmV3VmFsdWUpO1xuICAgIG5ld1ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmF3KG5ld1ZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbHVlIDogdG9SZWFjdGl2ZShuZXdWYWx1ZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICBpZiAocmVmMi5kZXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcmVmMi5kZXAudHJpZ2dlcih7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgIG5ld1ZhbHVlOiByZWYyLl92YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgcmV0dXJuIGlzUmVmKHJlZjIpID8gcmVmMi52YWx1ZSA6IHJlZjI7XG59XG5mdW5jdGlvbiB0b1ZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihzb3VyY2UpID8gc291cmNlKCkgOiB1bnJlZihzb3VyY2UpO1xufVxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IGtleSA9PT0gXCJfX3ZfcmF3XCIgPyB0YXJnZXQgOiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpID8gb2JqZWN0V2l0aFJlZnMgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XG59XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoZGVwLnRyYWNrLmJpbmQoZGVwKSwgZGVwLnRyaWdnZXIuYmluZChkZXApKTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgdGhpcy5fc2V0ID0gc2V0O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgIHdhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICB9XG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICByZXRba2V5XSA9IHByb3BlcnR5VG9SZWYob2JqZWN0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB2YWwgPT09IHZvaWQgMCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XG4gIH1cbiAgZ2V0IGRlcCgpIHtcbiAgICByZXR1cm4gZ2V0RGVwRnJvbVJlYWN0aXZlKHRvUmF3KHRoaXMuX29iamVjdCksIHRoaXMuX2tleSk7XG4gIH1cbn1cbmNsYXNzIEdldHRlclJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihfZ2V0dGVyKSB7XG4gICAgdGhpcy5fZ2V0dGVyID0gX2dldHRlcjtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXR0ZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBHZXR0ZXJSZWZJbXBsKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWYoc291cmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbCA9IHNvdXJjZVtrZXldO1xuICByZXR1cm4gaXNSZWYodmFsKSA/IHZhbCA6IG5ldyBPYmplY3RSZWZJbXBsKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xufVxuXG5jbGFzcyBDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcihmbiwgc2V0dGVyLCBpc1NTUikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgICB0aGlzLnNldHRlciA9IHNldHRlcjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAodGhpcyk7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIC8vIFRPRE8gaXNvbGF0ZWREZWNsYXJhdGlvbnMgXCJfX3ZfaXNSZWFkb25seVwiXG4gICAgLy8gQSBjb21wdXRlZCBpcyBhbHNvIGEgc3Vic2NyaWJlciB0aGF0IHRyYWNrcyBvdGhlciBkZXBzXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDE2O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb24gLSAxO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMuZWZmZWN0ID0gdGhpcztcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSAhc2V0dGVyO1xuICAgIHRoaXMuaXNTU1IgPSBpc1NTUjtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgdGhpcy5mbGFncyB8PSAxNjtcbiAgICBpZiAoISh0aGlzLmZsYWdzICYgOCkgJiYgLy8gYXZvaWQgaW5maW5pdGUgc2VsZiByZWN1cnNpb25cbiAgICBhY3RpdmVTdWIgIT09IHRoaXMpIHtcbiAgICAgIGJhdGNoKHRoaXMsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGNvbnN0IGxpbmsgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdGhpcy5kZXAudHJhY2soe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgfSkgOiB0aGlzLmRlcC50cmFjaygpO1xuICAgIHJlZnJlc2hDb21wdXRlZCh0aGlzKTtcbiAgICBpZiAobGluaykge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy5kZXAudmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnNldHRlcikge1xuICAgICAgdGhpcy5zZXR0ZXIobmV3VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcIldyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5XCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzU1NSID0gZmFsc2UpIHtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IHNldHRlcjtcbiAgaWYgKGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKSkge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gIH1cbiAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIGlzU1NSKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xuICAgIGNSZWYub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgIGNSZWYub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICByZXR1cm4gY1JlZjtcbn1cblxuY29uc3QgVHJhY2tPcFR5cGVzID0ge1xuICBcIkdFVFwiOiBcImdldFwiLFxuICBcIkhBU1wiOiBcImhhc1wiLFxuICBcIklURVJBVEVcIjogXCJpdGVyYXRlXCJcbn07XG5jb25zdCBUcmlnZ2VyT3BUeXBlcyA9IHtcbiAgXCJTRVRcIjogXCJzZXRcIixcbiAgXCJBRERcIjogXCJhZGRcIixcbiAgXCJERUxFVEVcIjogXCJkZWxldGVcIixcbiAgXCJDTEVBUlwiOiBcImNsZWFyXCJcbn07XG5jb25zdCBSZWFjdGl2ZUZsYWdzID0ge1xuICBcIlNLSVBcIjogXCJfX3Zfc2tpcFwiLFxuICBcIklTX1JFQUNUSVZFXCI6IFwiX192X2lzUmVhY3RpdmVcIixcbiAgXCJJU19SRUFET05MWVwiOiBcIl9fdl9pc1JlYWRvbmx5XCIsXG4gIFwiSVNfU0hBTExPV1wiOiBcIl9fdl9pc1NoYWxsb3dcIixcbiAgXCJSQVdcIjogXCJfX3ZfcmF3XCIsXG4gIFwiSVNfUkVGXCI6IFwiX192X2lzUmVmXCJcbn07XG5cbmNvbnN0IFdhdGNoRXJyb3JDb2RlcyA9IHtcbiAgXCJXQVRDSF9HRVRURVJcIjogMixcbiAgXCIyXCI6IFwiV0FUQ0hfR0VUVEVSXCIsXG4gIFwiV0FUQ0hfQ0FMTEJBQ0tcIjogMyxcbiAgXCIzXCI6IFwiV0FUQ0hfQ0FMTEJBQ0tcIixcbiAgXCJXQVRDSF9DTEVBTlVQXCI6IDQsXG4gIFwiNFwiOiBcIldBVENIX0NMRUFOVVBcIlxufTtcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuY29uc3QgY2xlYW51cE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IGFjdGl2ZVdhdGNoZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBnZXRDdXJyZW50V2F0Y2hlcigpIHtcbiAgcmV0dXJuIGFjdGl2ZVdhdGNoZXI7XG59XG5mdW5jdGlvbiBvbldhdGNoZXJDbGVhbnVwKGNsZWFudXBGbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UsIG93bmVyID0gYWN0aXZlV2F0Y2hlcikge1xuICBpZiAob3duZXIpIHtcbiAgICBsZXQgY2xlYW51cHMgPSBjbGVhbnVwTWFwLmdldChvd25lcik7XG4gICAgaWYgKCFjbGVhbnVwcykgY2xlYW51cE1hcC5zZXQob3duZXIsIGNsZWFudXBzID0gW10pO1xuICAgIGNsZWFudXBzLnB1c2goY2xlYW51cEZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uV2F0Y2hlckNsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSB3YXRjaGVyIHRvIGFzc29jaWF0ZSB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBvbmNlLCBzY2hlZHVsZXIsIGF1Z21lbnRKb2IsIGNhbGwgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICAob3B0aW9ucy5vbldhcm4gfHwgd2FybikoXG4gICAgICBgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsXG4gICAgICBzLFxuICAgICAgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcmVhY3RpdmVHZXR0ZXIgPSAoc291cmNlMikgPT4ge1xuICAgIGlmIChkZWVwKSByZXR1cm4gc291cmNlMjtcbiAgICBpZiAoaXNTaGFsbG93KHNvdXJjZTIpIHx8IGRlZXAgPT09IGZhbHNlIHx8IGRlZXAgPT09IDApXG4gICAgICByZXR1cm4gdHJhdmVyc2Uoc291cmNlMiwgMSk7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIpO1xuICB9O1xuICBsZXQgZWZmZWN0O1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgY2xlYW51cDtcbiAgbGV0IGJvdW5kQ2xlYW51cDtcbiAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xuICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBpc1NoYWxsb3coc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiByZWFjdGl2ZUdldHRlcihzb3VyY2UpO1xuICAgIGZvcmNlVHJpZ2dlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUoKHMpID0+IGlzUmVhY3RpdmUocykgfHwgaXNTaGFsbG93KHMpKTtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKChzKSA9PiB7XG4gICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgcmV0dXJuIHJlYWN0aXZlR2V0dGVyKHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzLCAyKSA6IHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBnZXR0ZXIgPSBjYWxsID8gKCkgPT4gY2FsbChzb3VyY2UsIDIpIDogc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEVmZmVjdCA9IGFjdGl2ZVdhdGNoZXI7XG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsKHNvdXJjZSwgMywgW2JvdW5kQ2xlYW51cF0pIDogc291cmNlKGJvdW5kQ2xlYW51cCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IE5PT1A7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xuICB9XG4gIGlmIChjYiAmJiBkZWVwKSB7XG4gICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICBjb25zdCBkZXB0aCA9IGRlZXAgPT09IHRydWUgPyBJbmZpbml0eSA6IGRlZXA7XG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpLCBkZXB0aCk7XG4gIH1cbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSAoKSA9PiB7XG4gICAgZWZmZWN0LnN0b3AoKTtcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgICByZW1vdmUoc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmIChvbmNlICYmIGNiKSB7XG4gICAgY29uc3QgX2NiID0gY2I7XG4gICAgY2IgPSAoLi4uYXJncykgPT4ge1xuICAgICAgX2NiKC4uLmFyZ3MpO1xuICAgICAgd2F0Y2hIYW5kbGUoKTtcbiAgICB9O1xuICB9XG4gIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICBjb25zdCBqb2IgPSAoaW1tZWRpYXRlRmlyc3RSdW4pID0+IHtcbiAgICBpZiAoIShlZmZlY3QuZmxhZ3MgJiAxKSB8fCAhZWZmZWN0LmRpcnR5ICYmICFpbW1lZGlhdGVGaXJzdFJ1bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2IpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgICAgaWYgKGRlZXAgfHwgZm9yY2VUcmlnZ2VyIHx8IChpc011bHRpU291cmNlID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSkge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50V2F0Y2hlciA9IGFjdGl2ZVdhdGNoZXI7XG4gICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBlZmZlY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB2b2lkIDAgOiBpc011bHRpU291cmNlICYmIG9sZFZhbHVlWzBdID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyBbXSA6IG9sZFZhbHVlLFxuICAgICAgICAgICAgYm91bmRDbGVhbnVwXG4gICAgICAgICAgXTtcbiAgICAgICAgICBjYWxsID8gY2FsbChjYiwgMywgYXJncykgOiAoXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBjYiguLi5hcmdzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgb2xkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhY3RpdmVXYXRjaGVyID0gY3VycmVudFdhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGF1Z21lbnRKb2IpIHtcbiAgICBhdWdtZW50Sm9iKGpvYik7XG4gIH1cbiAgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlcik7XG4gIGVmZmVjdC5zY2hlZHVsZXIgPSBzY2hlZHVsZXIgPyAoKSA9PiBzY2hlZHVsZXIoam9iLCBmYWxzZSkgOiBqb2I7XG4gIGJvdW5kQ2xlYW51cCA9IChmbikgPT4gb25XYXRjaGVyQ2xlYW51cChmbiwgZmFsc2UsIGVmZmVjdCk7XG4gIGNsZWFudXAgPSBlZmZlY3Qub25TdG9wID0gKCkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQoZWZmZWN0KTtcbiAgICBpZiAoY2xlYW51cHMpIHtcbiAgICAgIGlmIChjYWxsKSB7XG4gICAgICAgIGNhbGwoY2xlYW51cHMsIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBjbGVhbnVwMiBvZiBjbGVhbnVwcykgY2xlYW51cDIoKTtcbiAgICAgIH1cbiAgICAgIGNsZWFudXBNYXAuZGVsZXRlKGVmZmVjdCk7XG4gICAgfVxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGVmZmVjdC5vblRyYWNrID0gb3B0aW9ucy5vblRyYWNrO1xuICAgIGVmZmVjdC5vblRyaWdnZXIgPSBvcHRpb25zLm9uVHJpZ2dlcjtcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBqb2IodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFZhbHVlID0gZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzY2hlZHVsZXIpIHtcbiAgICBzY2hlZHVsZXIoam9iLmJpbmQobnVsbCwgdHJ1ZSksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5ydW4oKTtcbiAgfVxuICB3YXRjaEhhbmRsZS5wYXVzZSA9IGVmZmVjdC5wYXVzZS5iaW5kKGVmZmVjdCk7XG4gIHdhdGNoSGFuZGxlLnJlc3VtZSA9IGVmZmVjdC5yZXN1bWUuYmluZChlZmZlY3QpO1xuICB3YXRjaEhhbmRsZS5zdG9wID0gd2F0Y2hIYW5kbGU7XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbHVlLCBkZXB0aCA9IEluZmluaXR5LCBzZWVuKSB7XG4gIGlmIChkZXB0aCA8PSAwIHx8ICFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiXSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4uYWRkKHZhbHVlKTtcbiAgZGVwdGgtLTtcbiAgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHRyYXZlcnNlKHZhbHVlLnZhbHVlLCBkZXB0aCwgc2Vlbik7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgZGVwdGgsIHNlZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xuICAgICAgdHJhdmVyc2UodiwgZGVwdGgsIHNlZW4pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgZGVwdGgsIHNlZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IEFSUkFZX0lURVJBVEVfS0VZLCBFZmZlY3RGbGFncywgRWZmZWN0U2NvcGUsIElURVJBVEVfS0VZLCBNQVBfS0VZX0lURVJBVEVfS0VZLCBSZWFjdGl2ZUVmZmVjdCwgUmVhY3RpdmVGbGFncywgVHJhY2tPcFR5cGVzLCBUcmlnZ2VyT3BUeXBlcywgV2F0Y2hFcnJvckNvZGVzLCBjb21wdXRlZCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBlbmFibGVUcmFja2luZywgZ2V0Q3VycmVudFNjb3BlLCBnZXRDdXJyZW50V2F0Y2hlciwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25FZmZlY3RDbGVhbnVwLCBvblNjb3BlRGlzcG9zZSwgb25XYXRjaGVyQ2xlYW51cCwgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhY3RpdmVSZWFkQXJyYXksIHJlYWRvbmx5LCByZWYsIHJlc2V0VHJhY2tpbmcsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRBcnJheSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWFjdGl2ZSwgdG9SZWFkb25seSwgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJhY2ssIHRyYXZlcnNlLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiwgd2F0Y2ggfTtcbiIsIi8qKlxuKiBAdnVlL3J1bnRpbWUtY29yZSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBwYXVzZVRyYWNraW5nLCByZXNldFRyYWNraW5nLCBpc1JlZiwgdG9SYXcsIHRyYXZlcnNlLCBzaGFsbG93UmVmLCByZWFkb25seSwgaXNSZWFjdGl2ZSwgcmVmLCBpc1NoYWxsb3csIHNoYWxsb3dSZWFkQXJyYXksIHRvUmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIFJlYWN0aXZlRWZmZWN0LCB3YXRjaCBhcyB3YXRjaCQxLCBjdXN0b21SZWYsIGlzUHJveHksIHByb3h5UmVmcywgbWFya1JhdywgRWZmZWN0U2NvcGUsIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBUcmFja09wVHlwZXMsIFRyaWdnZXJPcFR5cGVzLCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBvbldhdGNoZXJDbGVhbnVwLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2UsIGlzQXJyYXksIEVNUFRZX09CSiwgTk9PUCwgZ2V0R2xvYmFsVGhpcywgZXh0ZW5kLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGhhc093biwgcmVtb3ZlLCBkZWYsIGlzT24sIGlzUmVzZXJ2ZWRQcm9wLCBub3JtYWxpemVDbGFzcywgc3RyaW5naWZ5U3R5bGUsIG5vcm1hbGl6ZVN0eWxlLCBpc0tub3duU3ZnQXR0ciwgaXNCb29sZWFuQXR0ciwgaXNLbm93bkh0bWxBdHRyLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzUmVuZGVyYWJsZUF0dHJWYWx1ZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGlzT2JqZWN0LCBpc1JlZ0V4cCwgaW52b2tlQXJyYXlGbnMsIHRvSGFuZGxlcktleSwgY2FwaXRhbGl6ZSwgY2FtZWxpemUsIGlzU3ltYm9sLCBpc0dsb2JhbGx5QWxsb3dlZCwgTk8sIGh5cGhlbmF0ZSwgRU1QVFlfQVJSLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIGhhc0NoYW5nZWQsIGxvb3NlVG9OdW1iZXIsIGlzTW9kZWxMaXN0ZW5lciwgdG9OdW1iZXIgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcbiAgc3RhY2sucHVzaCh2bm9kZSk7XG59XG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcbiAgc3RhY2sucG9wKCk7XG59XG5sZXQgaXNXYXJuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuJDEobXNnLCAuLi5hcmdzKSB7XG4gIGlmIChpc1dhcm5pbmcpIHJldHVybjtcbiAgaXNXYXJuaW5nID0gdHJ1ZTtcbiAgcGF1c2VUcmFja2luZygpO1xuICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XG4gIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XG4gIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcbiAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgYXBwV2FybkhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDExLFxuICAgICAgW1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgbXNnICsgYXJncy5tYXAoKGEpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBhLnRvU3RyaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChhKSkgIT0gbnVsbCA/IF9iIDogSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgIH0pLmpvaW4oXCJcIiksXG4gICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxuICAgICAgICB0cmFjZS5tYXAoXG4gICAgICAgICAgKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gXG4gICAgICAgICkuam9pbihcIlxcblwiKSxcbiAgICAgICAgdHJhY2VcbiAgICAgIF1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcbiAgICBpZiAodHJhY2UubGVuZ3RoICYmIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXG4gICAgdHJ1ZSkge1xuICAgICAgd2FybkFyZ3MucHVzaChgXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xuICB9XG4gIHJlc2V0VHJhY2tpbmcoKTtcbiAgaXNXYXJuaW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcbiAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICBpZiAoIWN1cnJlbnRWTm9kZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xuICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XG4gICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XG4gICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXG4gICAgICAgIHJlY3Vyc2VDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcbiAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcbiAgY29uc3QgbG9ncyA9IFtdO1xuICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgIGxvZ3MucHVzaCguLi5pID09PSAwID8gW10gOiBbYFxuYF0sIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcbiAgfSk7XG4gIHJldHVybiBsb2dzO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xuICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xuICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcbiAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICB2bm9kZS5jb21wb25lbnQsXG4gICAgdm5vZGUudHlwZSxcbiAgICBpc1Jvb3RcbiAgKX1gO1xuICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XG4gIHJldHVybiB2bm9kZS5wcm9wcyA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXSA6IFtvcGVuICsgY2xvc2VdO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcbiAgfSk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcbiAgICByZXMucHVzaChgIC4uLmApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgfSBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xuICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIodmFsLCB0eXBlKSB7XG4gIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgcmV0dXJuO1xuICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgIHdhcm4kMShgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybiQxKGAke3R5cGV9IGlzIE5hTiAtIHRoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC5gKTtcbiAgfVxufVxuXG5jb25zdCBFcnJvckNvZGVzID0ge1xuICBcIlNFVFVQX0ZVTkNUSU9OXCI6IDAsXG4gIFwiMFwiOiBcIlNFVFVQX0ZVTkNUSU9OXCIsXG4gIFwiUkVOREVSX0ZVTkNUSU9OXCI6IDEsXG4gIFwiMVwiOiBcIlJFTkRFUl9GVU5DVElPTlwiLFxuICBcIk5BVElWRV9FVkVOVF9IQU5ETEVSXCI6IDUsXG4gIFwiNVwiOiBcIk5BVElWRV9FVkVOVF9IQU5ETEVSXCIsXG4gIFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIjogNixcbiAgXCI2XCI6IFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIixcbiAgXCJWTk9ERV9IT09LXCI6IDcsXG4gIFwiN1wiOiBcIlZOT0RFX0hPT0tcIixcbiAgXCJESVJFQ1RJVkVfSE9PS1wiOiA4LFxuICBcIjhcIjogXCJESVJFQ1RJVkVfSE9PS1wiLFxuICBcIlRSQU5TSVRJT05fSE9PS1wiOiA5LFxuICBcIjlcIjogXCJUUkFOU0lUSU9OX0hPT0tcIixcbiAgXCJBUFBfRVJST1JfSEFORExFUlwiOiAxMCxcbiAgXCIxMFwiOiBcIkFQUF9FUlJPUl9IQU5ETEVSXCIsXG4gIFwiQVBQX1dBUk5fSEFORExFUlwiOiAxMSxcbiAgXCIxMVwiOiBcIkFQUF9XQVJOX0hBTkRMRVJcIixcbiAgXCJGVU5DVElPTl9SRUZcIjogMTIsXG4gIFwiMTJcIjogXCJGVU5DVElPTl9SRUZcIixcbiAgXCJBU1lOQ19DT01QT05FTlRfTE9BREVSXCI6IDEzLFxuICBcIjEzXCI6IFwiQVNZTkNfQ09NUE9ORU5UX0xPQURFUlwiLFxuICBcIlNDSEVEVUxFUlwiOiAxNCxcbiAgXCIxNFwiOiBcIlNDSEVEVUxFUlwiLFxuICBcIkNPTVBPTkVOVF9VUERBVEVcIjogMTUsXG4gIFwiMTVcIjogXCJDT01QT05FTlRfVVBEQVRFXCIsXG4gIFwiQVBQX1VOTU9VTlRfQ0xFQU5VUFwiOiAxNixcbiAgXCIxNlwiOiBcIkFQUF9VTk1PVU5UX0NMRUFOVVBcIlxufTtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MkMSA9IHtcbiAgW1wic3BcIl06IFwic2VydmVyUHJlZmV0Y2ggaG9va1wiLFxuICBbXCJiY1wiXTogXCJiZWZvcmVDcmVhdGUgaG9va1wiLFxuICBbXCJjXCJdOiBcImNyZWF0ZWQgaG9va1wiLFxuICBbXCJibVwiXTogXCJiZWZvcmVNb3VudCBob29rXCIsXG4gIFtcIm1cIl06IFwibW91bnRlZCBob29rXCIsXG4gIFtcImJ1XCJdOiBcImJlZm9yZVVwZGF0ZSBob29rXCIsXG4gIFtcInVcIl06IFwidXBkYXRlZFwiLFxuICBbXCJidW1cIl06IFwiYmVmb3JlVW5tb3VudCBob29rXCIsXG4gIFtcInVtXCJdOiBcInVubW91bnRlZCBob29rXCIsXG4gIFtcImFcIl06IFwiYWN0aXZhdGVkIGhvb2tcIixcbiAgW1wiZGFcIl06IFwiZGVhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJlY1wiXTogXCJlcnJvckNhcHR1cmVkIGhvb2tcIixcbiAgW1wicnRjXCJdOiBcInJlbmRlclRyYWNrZWQgaG9va1wiLFxuICBbXCJydGdcIl06IFwicmVuZGVyVHJpZ2dlcmVkIGhvb2tcIixcbiAgWzBdOiBcInNldHVwIGZ1bmN0aW9uXCIsXG4gIFsxXTogXCJyZW5kZXIgZnVuY3Rpb25cIixcbiAgWzJdOiBcIndhdGNoZXIgZ2V0dGVyXCIsXG4gIFszXTogXCJ3YXRjaGVyIGNhbGxiYWNrXCIsXG4gIFs0XTogXCJ3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb25cIixcbiAgWzVdOiBcIm5hdGl2ZSBldmVudCBoYW5kbGVyXCIsXG4gIFs2XTogXCJjb21wb25lbnQgZXZlbnQgaGFuZGxlclwiLFxuICBbN106IFwidm5vZGUgaG9va1wiLFxuICBbOF06IFwiZGlyZWN0aXZlIGhvb2tcIixcbiAgWzldOiBcInRyYW5zaXRpb24gaG9va1wiLFxuICBbMTBdOiBcImFwcCBlcnJvckhhbmRsZXJcIixcbiAgWzExXTogXCJhcHAgd2FybkhhbmRsZXJcIixcbiAgWzEyXTogXCJyZWYgZnVuY3Rpb25cIixcbiAgWzEzXTogXCJhc3luYyBjb21wb25lbnQgbG9hZGVyXCIsXG4gIFsxNF06IFwic2NoZWR1bGVyIGZsdXNoXCIsXG4gIFsxNV06IFwiY29tcG9uZW50IHVwZGF0ZVwiLFxuICBbMTZdOiBcImFwcCB1bm1vdW50IGNsZWFudXAgZnVuY3Rpb25cIlxufTtcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChpc0FycmF5KGZuKSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlcy5wdXNoKGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuW2ldLCBpbnN0YW5jZSwgdHlwZSwgYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgSW52YWxpZCB2YWx1ZSB0eXBlIHBhc3NlZCB0byBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZygpOiAke3R5cGVvZiBmbn1gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSwgdGhyb3dJbkRldiA9IHRydWUpIHtcbiAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XG4gIGNvbnN0IHsgZXJyb3JIYW5kbGVyLCB0aHJvd1VuaGFuZGxlZEVycm9ySW5Qcm9kdWN0aW9uIH0gPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyB8fCBFTVBUWV9PQko7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgY29uc3QgZXhwb3NlZEluc3RhbmNlID0gaW5zdGFuY2UucHJveHk7XG4gICAgY29uc3QgZXJyb3JJbmZvID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXSA6IGBodHRwczovL3Z1ZWpzLm9yZy9lcnJvci1yZWZlcmVuY2UvI3J1bnRpbWUtJHt0eXBlfWA7XG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgY29uc3QgZXJyb3JDYXB0dXJlZEhvb2tzID0gY3VyLmVjO1xuICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3NbaV0oZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mbykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXIucGFyZW50O1xuICAgIH1cbiAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZXJyb3JIYW5kbGVyLCBudWxsLCAxMCwgW1xuICAgICAgICBlcnIsXG4gICAgICAgIGV4cG9zZWRJbnN0YW5jZSxcbiAgICAgICAgZXJyb3JJbmZvXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYsIHRocm93VW5oYW5kbGVkRXJyb3JJblByb2R1Y3Rpb24pO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlLCB0aHJvd0luUHJvZCA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3MkMVt0eXBlXTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoY29udGV4dFZOb2RlKTtcbiAgICB9XG4gICAgd2FybiQxKGBVbmhhbmRsZWQgZXJyb3Ike2luZm8gPyBgIGR1cmluZyBleGVjdXRpb24gb2YgJHtpbmZvfWAgOiBgYH1gKTtcbiAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgIH1cbiAgICBpZiAodGhyb3dJbkRldikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRocm93SW5Qcm9kKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IGZsdXNoSW5kZXggPSAtMTtcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcbiAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcbn1cbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChpZCkge1xuICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcbiAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBlbmQgPj4+IDE7XG4gICAgY29uc3QgbWlkZGxlSm9iID0gcXVldWVbbWlkZGxlXTtcbiAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKG1pZGRsZUpvYik7XG4gICAgaWYgKG1pZGRsZUpvYklkIDwgaWQgfHwgbWlkZGxlSm9iSWQgPT09IGlkICYmIG1pZGRsZUpvYi5mbGFncyAmIDIpIHtcbiAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gbWlkZGxlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcbiAgaWYgKCEoam9iLmZsYWdzICYgMSkpIHtcbiAgICBjb25zdCBqb2JJZCA9IGdldElkKGpvYik7XG4gICAgY29uc3QgbGFzdEpvYiA9IHF1ZXVlW3F1ZXVlLmxlbmd0aCAtIDFdO1xuICAgIGlmICghbGFzdEpvYiB8fCAvLyBmYXN0IHBhdGggd2hlbiB0aGUgam9iIGlkIGlzIGxhcmdlciB0aGFuIHRoZSB0YWlsXG4gICAgIShqb2IuZmxhZ3MgJiAyKSAmJiBqb2JJZCA+PSBnZXRJZChsYXN0Sm9iKSkge1xuICAgICAgcXVldWUucHVzaChqb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYklkKSwgMCwgam9iKTtcbiAgICB9XG4gICAgam9iLmZsYWdzIHw9IDE7XG4gICAgcXVldWVGbHVzaCgpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xuICBpZiAoIWN1cnJlbnRGbHVzaFByb21pc2UpIHtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xuICBpZiAoIWlzQXJyYXkoY2IpKSB7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicyAmJiBjYi5pZCA9PT0gLTEpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zcGxpY2UocG9zdEZsdXNoSW5kZXggKyAxLCAwLCBjYik7XG4gICAgfSBlbHNlIGlmICghKGNiLmZsYWdzICYgMSkpIHtcbiAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaChjYik7XG4gICAgICBjYi5mbGFncyB8PSAxO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLnB1c2goLi4uY2IpO1xuICB9XG4gIHF1ZXVlRmx1c2goKTtcbn1cbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoaW5zdGFuY2UsIHNlZW4sIGkgPSBmbHVzaEluZGV4ICsgMSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNiID0gcXVldWVbaV07XG4gICAgaWYgKGNiICYmIGNiLmZsYWdzICYgMikge1xuICAgICAgaWYgKGluc3RhbmNlICYmIGNiLmlkICE9PSBpbnN0YW5jZS51aWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgaS0tO1xuICAgICAgaWYgKGNiLmZsYWdzICYgNCkge1xuICAgICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICAgIGNiKCk7XG4gICAgICBpZiAoIShjYi5mbGFncyAmIDQpKSB7XG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbikge1xuICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldLnNvcnQoXG4gICAgICAoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKVxuICAgICk7XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBjYiA9IGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF07XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgY2IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNiLmZsYWdzICYgNCkge1xuICAgICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICAgIGlmICghKGNiLmZsYWdzICYgOCkpIGNiKCk7XG4gICAgICBjYi5mbGFncyAmPSB+MTtcbiAgICB9XG4gICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbiAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XG4gIH1cbn1cbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBqb2IuZmxhZ3MgJiAyID8gLTEgOiBJbmZpbml0eSA6IGpvYi5pZDtcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBjb25zdCBjaGVjayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKSA6IE5PT1A7XG4gIHRyeSB7XG4gICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IgJiYgIShqb2IuZmxhZ3MgJiA4KSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVjayhqb2IpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpvYi5mbGFncyAmIDQpIHtcbiAgICAgICAgICBqb2IuZmxhZ3MgJj0gfjE7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgICAgIGpvYixcbiAgICAgICAgICBqb2IuaSxcbiAgICAgICAgICBqb2IuaSA/IDE1IDogMTRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEoam9iLmZsYWdzICYgNCkpIHtcbiAgICAgICAgICBqb2IuZmxhZ3MgJj0gfjE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZm9yICg7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iKSB7XG4gICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hJbmRleCA9IC0xO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XG4gICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCB8fCBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgICAgZmx1c2hKb2JzKHNlZW4pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XG4gIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pIHx8IDA7XG4gIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZm4uaTtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcbiAgICBoYW5kbGVFcnJvcihcbiAgICAgIGBNYXhpbXVtIHJlY3Vyc2l2ZSB1cGRhdGVzIGV4Y2VlZGVkJHtjb21wb25lbnROYW1lID8gYCBpbiBjb21wb25lbnQgPCR7Y29tcG9uZW50TmFtZX0+YCA6IGBgfS4gVGhpcyBtZWFucyB5b3UgaGF2ZSBhIHJlYWN0aXZlIGVmZmVjdCB0aGF0IGlzIG11dGF0aW5nIGl0cyBvd24gZGVwZW5kZW5jaWVzIGFuZCB0aHVzIHJlY3Vyc2l2ZWx5IHRyaWdnZXJpbmcgaXRzZWxmLiBQb3NzaWJsZSBzb3VyY2VzIGluY2x1ZGUgY29tcG9uZW50IHRlbXBsYXRlLCByZW5kZXIgZnVuY3Rpb24sIHVwZGF0ZWQgaG9vayBvciB3YXRjaGVyIHNvdXJjZSBmdW5jdGlvbi5gLFxuICAgICAgbnVsbCxcbiAgICAgIDEwXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZWVuLnNldChmbiwgY291bnQgKyAxKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xuICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxuICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcbiAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxuICB9O1xufVxuY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xuICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcbiAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgfVxuICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xuICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFwLnNldChpZCwge1xuICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxuICAgIGluc3RhbmNlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XG4gIFsuLi5yZWNvcmQuaW5zdGFuY2VzXS5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgIGlmIChuZXdSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcbiAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XG4gIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICBpZiAoIXJlY29yZCkgcmV0dXJuO1xuICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XG4gIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XG4gIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5yZWNvcmQuaW5zdGFuY2VzXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XG4gICAgbGV0IGRpcnR5SW5zdGFuY2VzID0gaG1yRGlydHlDb21wb25lbnRzLmdldChvbGRDb21wKTtcbiAgICBpZiAoIWRpcnR5SW5zdGFuY2VzKSB7XG4gICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xuICAgICAgfVxuICAgICAgaG1yRGlydHlDb21wb25lbnRzLnNldChvbGRDb21wLCBkaXJ0eUluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBkaXJ0eUluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQucHJvcHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5lbWl0c0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XG4gICAgICBkaXJ0eUluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xuICAgICAgaW5zdGFuY2UuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xuICAgICAgZGlydHlJbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgcXVldWVKb2IoKCkgPT4ge1xuICAgICAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UucGFyZW50LnVwZGF0ZSgpO1xuICAgICAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XG4gICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnJvb3QuY2UgJiYgaW5zdGFuY2UgIT09IGluc3RhbmNlLnJvb3QpIHtcbiAgICAgIGluc3RhbmNlLnJvb3QuY2UuX3JlbW92ZUNoaWxkU3R5bGUob2xkQ29tcCk7XG4gICAgfVxuICB9XG4gIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xuICAgIGhtckRpcnR5Q29tcG9uZW50cy5jbGVhcigpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XG4gIGV4dGVuZChvbGRDb21wLCBuZXdDb21wKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xuICAgIGlmIChrZXkgIT09IFwiX19maWxlXCIgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcbiAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cnlXcmFwKGZuKSB7XG4gIHJldHVybiAoaWQsIGFyZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oaWQsIGFyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5sZXQgZGV2dG9vbHMkMTtcbmxldCBidWZmZXIgPSBbXTtcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdCQxKGV2ZW50LCAuLi5hcmdzKSB7XG4gIGlmIChkZXZ0b29scyQxKSB7XG4gICAgZGV2dG9vbHMkMS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfSBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcbiAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2skMShob29rLCB0YXJnZXQpIHtcbiAgdmFyIF9hLCBfYjtcbiAgZGV2dG9vbHMkMSA9IGhvb2s7XG4gIGlmIChkZXZ0b29scyQxKSB7XG4gICAgZGV2dG9vbHMkMS5lbmFibGVkID0gdHJ1ZTtcbiAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfSBlbHNlIGlmIChcbiAgICAvLyBoYW5kbGUgbGF0ZSBkZXZ0b29scyBpbmplY3Rpb24gLSBvbmx5IGRvIHRoaXMgaWYgd2UgYXJlIGluIGFuIGFjdHVhbFxuICAgIC8vIGJyb3dzZXIgZW52aXJvbm1lbnQgdG8gYXZvaWQgdGhlIHRpbWVyIGhhbmRsZSBzdGFsbGluZyB0ZXN0IHJ1bm5lciBleGl0XG4gICAgLy8gKCM0ODE1KVxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgLy8gc29tZSBlbnZzIG1vY2sgd2luZG93IGJ1dCBub3QgZnVsbHlcbiAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiYgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJqc2RvbVwiKSlcbiAgKSB7XG4gICAgY29uc3QgcmVwbGF5ID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyB8fCBbXTtcbiAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgc2V0RGV2dG9vbHNIb29rJDEobmV3SG9vaywgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghZGV2dG9vbHMkMSkge1xuICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfSwgM2UzKTtcbiAgfSBlbHNlIHtcbiAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgYnVmZmVyID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcbiAgZW1pdCQxKFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XG4gICAgRnJhZ21lbnQsXG4gICAgVGV4dCxcbiAgICBDb21tZW50LFxuICAgIFN0YXRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcbiAgZW1pdCQxKFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgYXBwKTtcbn1cbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovKTtcbmNvbnN0IF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFxuICBcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi9cbik7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAoY29tcG9uZW50KSA9PiB7XG4gIGlmIChkZXZ0b29scyQxICYmIHR5cGVvZiBkZXZ0b29scyQxLmNsZWFudXBCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyByZW1vdmUgdGhlIGNvbXBvbmVudCBpZiBpdCB3YXNuJ3QgYnVmZmVyZWRcbiAgIWRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XG4gICAgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChjb21wb25lbnQpO1xuICB9XG59O1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcbiAgICBlbWl0JDEoXG4gICAgICBob29rLFxuICAgICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgICAgY29tcG9uZW50LnVpZCxcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHZvaWQgMCxcbiAgICAgIGNvbXBvbmVudFxuICAgICk7XG4gIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqLyk7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqLyk7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XG4gICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgZW1pdCQxKFxuICAgIFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLyxcbiAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgY29tcG9uZW50LFxuICAgIGV2ZW50LFxuICAgIHBhcmFtc1xuICApO1xufVxuXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XG4gIGN1cnJlbnRTY29wZUlkID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQgfHwgbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICBjdXJyZW50U2NvcGVJZCA9IGlkO1xufVxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QpIHtcbiAgaWYgKCFjdHgpIHJldHVybiBmbjtcbiAgaWYgKGZuLl9uKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG4gIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gZm4oLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xuICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XG4gIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICB3YXJuJDEoXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSk7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xuICAgIGlmIChkaXIpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcbiAgICAgICAgZGlyID0ge1xuICAgICAgICAgIG1vdW50ZWQ6IGRpcixcbiAgICAgICAgICB1cGRhdGVkOiBkaXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXIuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgZGlyLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGFyZyxcbiAgICAgICAgbW9kaWZpZXJzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgcHJldlZOb2RlLCBpbnN0YW5jZSwgbmFtZSkge1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XG4gIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgIGlmIChvbGRCaW5kaW5ncykge1xuICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xuICAgIH1cbiAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgIGlmIChob29rKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCwgW1xuICAgICAgICB2bm9kZS5lbCxcbiAgICAgICAgYmluZGluZyxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHByZXZWTm9kZVxuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRlbGVwb3J0RW5kS2V5ID0gU3ltYm9sKFwiX3Z0ZVwiKTtcbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gXCJcIik7XG5jb25zdCBpc1RlbGVwb3J0RGVmZXJyZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kZWZlciB8fCBwcm9wcy5kZWZlciA9PT0gXCJcIik7XG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCBpc1RhcmdldE1hdGhNTCA9ICh0YXJnZXQpID0+IHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudDtcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xuICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xuICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XG4gICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldCAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTZWxlY3RvcjtcbiAgfVxufTtcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcbiAgbmFtZTogXCJUZWxlcG9ydFwiLFxuICBfX2lzVGVsZXBvcnQ6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgICAgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfVxuICAgIH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xuICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBuMi5lbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgc3RhcnRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgZW5kXCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lcjIsIGFuY2hvcjIpID0+IHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuaXNDRSkge1xuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmNlLl90ZWxlcG9ydFRhcmdldCA9IGNvbnRhaW5lcjI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbW91bnRUb1RhcmdldCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3Rvcik7XG4gICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IHByZXBhcmVBbmNob3IodGFyZ2V0LCBuMiwgY3JlYXRlVGV4dCwgaW5zZXJ0KTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIGlmIChuYW1lc3BhY2UgIT09IFwic3ZnXCIgJiYgaXNUYXJnZXRTVkcodGFyZ2V0KSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSAhPT0gXCJtYXRobWxcIiAmJiBpc1RhcmdldE1hdGhNTCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICB1cGRhdGVDc3NWYXJzKG4yLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDpcIixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgICB1cGRhdGVDc3NWYXJzKG4yLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RlbGVwb3J0RGVmZXJyZWQobjIucHJvcHMpKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgbW91bnRUb1RhcmdldCgpO1xuICAgICAgICAgIG4yLmVsLl9faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRUb1RhcmdldCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZWxlcG9ydERlZmVycmVkKG4yLnByb3BzKSAmJiAhbjEuZWwuX19pc01vdW50ZWQpIHtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBUZWxlcG9ydEltcGwucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGVsZXRlIG4xLmVsLl9faXNNb3VudGVkO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi50YXJnZXRTdGFydCA9IG4xLnRhcmdldFN0YXJ0O1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG4yLnRhcmdldCA9IG4xLnRhcmdldDtcbiAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IG4yLnRhcmdldEFuY2hvciA9IG4xLnRhcmdldEFuY2hvcjtcbiAgICAgIGNvbnN0IHdhc0Rpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4xLnByb3BzKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBcIm1hdGhtbFwiIHx8IGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIGN1cnJlbnRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBtYWluQW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG4yLnByb3BzICYmIG4xLnByb3BzICYmIG4yLnByb3BzLnRvICE9PSBuMS5wcm9wcy50bykge1xuICAgICAgICAgICAgbjIucHJvcHMudG8gPSBuMS5wcm9wcy50bztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgICAgICAgICBuMi5wcm9wcyxcbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgICBuZXh0VGFyZ2V0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOlwiLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIGAoJHt0eXBlb2YgdGFyZ2V0fSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xuICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIGRpc2FibGVkKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgYW5jaG9yLFxuICAgICAgdGFyZ2V0U3RhcnQsXG4gICAgICB0YXJnZXRBbmNob3IsXG4gICAgICB0YXJnZXQsXG4gICAgICBwcm9wc1xuICAgIH0gPSB2bm9kZTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBob3N0UmVtb3ZlKHRhcmdldFN0YXJ0KTtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcbiAgICB9XG4gICAgZG9SZW1vdmUgJiYgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlID0gZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNob3VsZFJlbW92ZSxcbiAgICAgICAgICAhIWNoaWxkLmR5bmFtaWNDaGlsZHJlblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW92ZTogbW92ZVRlbGVwb3J0LFxuICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcbn07XG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyKSB7XG4gIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcbiAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDI7XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxuICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoXG4gICAgICAgICAgY2hpbGRyZW5baV0sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudEFuY2hvcixcbiAgICAgICAgICAyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpc1Jlb3JkZXIpIHtcbiAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHtcbiAgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciwgaW5zZXJ0LCBjcmVhdGVUZXh0IH1cbn0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgIHZub2RlLnByb3BzLFxuICAgIHF1ZXJ5U2VsZWN0b3JcbiAgKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKTtcbiAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIG5leHRTaWJsaW5nKG5vZGUpLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudE5vZGUobm9kZSksXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgdm5vZGUudGFyZ2V0U3RhcnQgPSB0YXJnZXROb2RlO1xuICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlICYmIG5leHRTaWJsaW5nKHRhcmdldE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIGxldCB0YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xuICAgICAgICB3aGlsZSAodGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgaWYgKHRhcmdldEFuY2hvciAmJiB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBzdGFydCBhbmNob3JcIikge1xuICAgICAgICAgICAgICB2bm9kZS50YXJnZXRTdGFydCA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0QW5jaG9yLmRhdGEgPT09IFwidGVsZXBvcnQgYW5jaG9yXCIpIHtcbiAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgICB0YXJnZXQuX2xwYSA9IHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0QW5jaG9yID0gbmV4dFNpYmxpbmcodGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgICAgIHByZXBhcmVBbmNob3IodGFyZ2V0LCB2bm9kZSwgY3JlYXRlVGV4dCwgaW5zZXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgdGFyZ2V0Tm9kZSAmJiBuZXh0U2libGluZyh0YXJnZXROb2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ3NzVmFycyh2bm9kZSwgZGlzYWJsZWQpO1xuICB9XG4gIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcbn1cbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSwgaXNEaXNhYmxlZCkge1xuICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gIGlmIChjdHggJiYgY3R4LnV0KSB7XG4gICAgbGV0IG5vZGUsIGFuY2hvcjtcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgbm9kZSA9IHZub2RlLmVsO1xuICAgICAgYW5jaG9yID0gdm5vZGUuYW5jaG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdm5vZGUudGFyZ2V0U3RhcnQ7XG4gICAgICBhbmNob3IgPSB2bm9kZS50YXJnZXRBbmNob3I7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGFuY2hvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12LW93bmVyXCIsIGN0eC51aWQpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGN0eC51dCgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCkge1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHZub2RlLnRhcmdldFN0YXJ0ID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgY29uc3QgdGFyZ2V0QW5jaG9yID0gdm5vZGUudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgdGFyZ2V0U3RhcnRbVGVsZXBvcnRFbmRLZXldID0gdGFyZ2V0QW5jaG9yO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgaW5zZXJ0KHRhcmdldFN0YXJ0LCB0YXJnZXQpO1xuICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEFuY2hvcjtcbn1cblxuY29uc3QgbGVhdmVDYktleSA9IFN5bWJvbChcIl9sZWF2ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzTGVhdmluZzogZmFsc2UsXG4gICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgfSk7XG4gIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XG5jb25zdCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbW9kZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgLy8gZW50ZXJcbiAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gbGVhdmVcbiAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gYXBwZWFyXG4gIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG59O1xuY29uc3QgcmVjdXJzaXZlR2V0U3VidHJlZSA9IChpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgcmV0dXJuIHN1YlRyZWUuY29tcG9uZW50ID8gcmVjdXJzaXZlR2V0U3VidHJlZShzdWJUcmVlLmNvbXBvbmVudCkgOiBzdWJUcmVlO1xufTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcbiAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcbiAgcHJvcHM6IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGQgPSBmaW5kTm9uQ29tbWVudENoaWxkKGNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG1vZGUgJiYgbW9kZSAhPT0gXCJpbi1vdXRcIiAmJiBtb2RlICE9PSBcIm91dC1pblwiICYmIG1vZGUgIT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHdhcm4kMShgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0SW5uZXJDaGlsZCQxKGNoaWxkKTtcbiAgICAgIGlmICghaW5uZXJDaGlsZCkge1xuICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgICBsZXQgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIGlubmVyQ2hpbGQsXG4gICAgICAgIHJhd1Byb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIC8vICMxMTA2MSwgZW5zdXJlIGVudGVySG9va3MgaXMgZnJlc2ggYWZ0ZXIgY2xvbmVcbiAgICAgICAgKGhvb2tzKSA9PiBlbnRlckhvb2tzID0gaG9va3NcbiAgICAgICk7XG4gICAgICBpZiAoaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcbiAgICAgIH1cbiAgICAgIGxldCBvbGRJbm5lckNoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZSAmJiBnZXRJbm5lckNoaWxkJDEoaW5zdGFuY2Uuc3ViVHJlZSk7XG4gICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJiBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiYgIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSAmJiByZWN1cnNpdmVHZXRTdWJ0cmVlKGluc3RhbmNlKS50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgIGxldCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgIG9sZElubmVyQ2hpbGQsXG4gICAgICAgICAgcmF3UHJvcHMsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XG4gICAgICAgIGlmIChtb2RlID09PSBcIm91dC1pblwiICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlLmpvYi5mbGFncyAmIDgpKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlO1xuICAgICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImluLW91dFwiICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XG4gICAgICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcbiAgICAgICAgICAgICAgZWxbbGVhdmVDYktleV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZGVsYXllZExlYXZlKCk7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9sZElubmVyQ2hpbGQpIHtcbiAgICAgICAgb2xkSW5uZXJDaGlsZCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gZmluZE5vbkNvbW1lbnRDaGlsZChjaGlsZHJlbikge1xuICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaGFzRm91bmQpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBcIjx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjO1xuICAgICAgICBoYXNGb3VuZCA9IHRydWU7XG4gICAgICAgIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZDtcbn1cbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xuZnVuY3Rpb24gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpIHtcbiAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcbiAgbGV0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGxlYXZpbmdWTm9kZXMuZ2V0KHZub2RlLnR5cGUpO1xuICBpZiAoIWxlYXZpbmdWTm9kZXNDYWNoZSkge1xuICAgIGxlYXZpbmdWTm9kZXNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxlYXZpbmdWTm9kZXMuc2V0KHZub2RlLnR5cGUsIGxlYXZpbmdWTm9kZXNDYWNoZSk7XG4gIH1cbiAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UsIHBvc3RDbG9uZSkge1xuICBjb25zdCB7XG4gICAgYXBwZWFyLFxuICAgIG1vZGUsXG4gICAgcGVyc2lzdGVkID0gZmFsc2UsXG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uQWZ0ZXJFbnRlcixcbiAgICBvbkVudGVyQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlTGVhdmUsXG4gICAgb25MZWF2ZSxcbiAgICBvbkFmdGVyTGVhdmUsXG4gICAgb25MZWF2ZUNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUFwcGVhcixcbiAgICBvbkFwcGVhcixcbiAgICBvbkFmdGVyQXBwZWFyLFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XG4gIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKTtcbiAgY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgIGhvb2sgJiYgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBob29rLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA5LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH07XG4gIGNvbnN0IGNhbGxBc3luY0hvb2sgPSAoaG9vaywgYXJncykgPT4ge1xuICAgIGNvbnN0IGRvbmUgPSBhcmdzWzFdO1xuICAgIGNhbGxIb29rKGhvb2ssIGFyZ3MpO1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBpZiAoaG9vay5ldmVyeSgoaG9vazIpID0+IGhvb2syLmxlbmd0aCA8PSAxKSkgZG9uZSgpO1xuICAgIH0gZWxzZSBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaG9va3MgPSB7XG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQsXG4gICAgYmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbFtsZWF2ZUNiS2V5XSkge1xuICAgICAgICBlbFtsZWF2ZUNiS2V5XShcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiYgaXNTYW1lVk5vZGVUeXBlKHZub2RlLCBsZWF2aW5nVk5vZGUpICYmIGxlYXZpbmdWTm9kZS5lbFtsZWF2ZUNiS2V5XSkge1xuICAgICAgICBsZWF2aW5nVk5vZGUuZWxbbGVhdmVDYktleV0oKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbF0pO1xuICAgIH0sXG4gICAgZW50ZXIoZWwpIHtcbiAgICAgIGxldCBob29rID0gb25FbnRlcjtcbiAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XG4gICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XG4gICAgICAgICAgYWZ0ZXJIb29rID0gb25BZnRlckFwcGVhciB8fCBvbkFmdGVyRW50ZXI7XG4gICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWxbZW50ZXJDYktleV0gPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKGFmdGVySG9vaywgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xuICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsW2VudGVyQ2JLZXldID0gdm9pZCAwO1xuICAgICAgfTtcbiAgICAgIGlmIChob29rKSB7XG4gICAgICAgIGNhbGxBc3luY0hvb2soaG9vaywgW2VsLCBkb25lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XG4gICAgICBjb25zdCBrZXkyID0gU3RyaW5nKHZub2RlLmtleSk7XG4gICAgICBpZiAoZWxbZW50ZXJDYktleV0pIHtcbiAgICAgICAgZWxbZW50ZXJDYktleV0oXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlzVW5tb3VudGluZykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbFtsZWF2ZUNiS2V5XSA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxbbGVhdmVDYktleV0gPSB2b2lkIDA7XG4gICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPT09IHZub2RlKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9IHZub2RlO1xuICAgICAgaWYgKG9uTGVhdmUpIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lKHZub2RlMikge1xuICAgICAgY29uc3QgaG9va3MyID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgdm5vZGUyLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBwb3N0Q2xvbmVcbiAgICAgICk7XG4gICAgICBpZiAocG9zdENsb25lKSBwb3N0Q2xvbmUoaG9va3MyKTtcbiAgICAgIHJldHVybiBob29rczI7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaG9va3M7XG59XG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XG4gIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQkMSh2bm9kZSkge1xuICBpZiAoIWlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIGlmIChpc1RlbGVwb3J0KHZub2RlLnR5cGUpICYmIHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gZmluZE5vbkNvbW1lbnRDaGlsZCh2bm9kZS5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAzMiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuLmRlZmF1bHQpKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4uZGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleSA9PSBudWxsID8gY2hpbGQua2V5IDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCwga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucykge1xuICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IChcbiAgICAvLyAjODIzNjogZXh0ZW5kIGNhbGwgYW5kIG9wdGlvbnMubmFtZSBhY2Nlc3MgYXJlIGNvbnNpZGVyZWQgc2lkZS1lZmZlY3RzXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxuICAgIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXh0ZW5kKHsgbmFtZTogb3B0aW9ucy5uYW1lIH0sIGV4dHJhT3B0aW9ucywgeyBzZXR1cDogb3B0aW9ucyB9KSkoKVxuICApIDogb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGkpIHtcbiAgICByZXR1cm4gKGkuYXBwQ29udGV4dC5jb25maWcuaWRQcmVmaXggfHwgXCJ2XCIpICsgXCItXCIgKyBpLmlkc1swXSArIGkuaWRzWzFdKys7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGB1c2VJZCgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuaWRzID0gW2luc3RhbmNlLmlkc1swXSArIGluc3RhbmNlLmlkc1syXSsrICsgXCItXCIsIDAsIDBdO1xufVxuXG5jb25zdCBrbm93blRlbXBsYXRlUmVmcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gdXNlVGVtcGxhdGVSZWYoa2V5KSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgciA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGlmIChpKSB7XG4gICAgY29uc3QgcmVmcyA9IGkucmVmcyA9PT0gRU1QVFlfT0JKID8gaS5yZWZzID0ge30gOiBpLnJlZnM7XG4gICAgbGV0IGRlc2M7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlZnMsIGtleSkpICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgd2FybiQxKGB1c2VUZW1wbGF0ZVJlZignJHtrZXl9JykgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWZzLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiByLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2YWwpID0+IHIudmFsdWUgPSB2YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHVzZVRlbXBsYXRlUmVmKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbiAgY29uc3QgcmV0ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHJlYWRvbmx5KHIpIDogcjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBrbm93blRlbXBsYXRlUmVmcy5hZGQocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcbiAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xuICAgIHJhd1JlZi5mb3JFYWNoKFxuICAgICAgKHIsIGkpID0+IHNldFJlZihcbiAgICAgICAgcixcbiAgICAgICAgb2xkUmF3UmVmICYmIChpc0FycmF5KG9sZFJhd1JlZikgPyBvbGRSYXdSZWZbaV0gOiBvbGRSYXdSZWYpLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGlzVW5tb3VudFxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIWlzVW5tb3VudCkge1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA1MTIgJiYgdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgJiYgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUuY29tcG9uZW50KSB7XG4gICAgICBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLnNoYXBlRmxhZyAmIDQgPyBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSh2bm9kZS5jb21wb25lbnQpIDogdm5vZGUuZWw7XG4gIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xuICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW93bmVyKSB7XG4gICAgd2FybiQxKFxuICAgICAgYE1pc3NpbmcgcmVmIG93bmVyIGNvbnRleHQuIHJlZiBjYW5ub3QgYmUgdXNlZCBvbiBob2lzdGVkIHZub2Rlcy4gQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcbiAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IG93bmVyLnJlZnMgPSB7fSA6IG93bmVyLnJlZnM7XG4gIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xuICBjb25zdCByYXdTZXR1cFN0YXRlID0gdG9SYXcoc2V0dXBTdGF0ZSk7XG4gIGNvbnN0IGNhblNldFNldHVwUmVmID0gc2V0dXBTdGF0ZSA9PT0gRU1QVFlfT0JKID8gKCkgPT4gZmFsc2UgOiAoa2V5KSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChoYXNPd24ocmF3U2V0dXBTdGF0ZSwga2V5KSAmJiAhaXNSZWYocmF3U2V0dXBTdGF0ZVtrZXldKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFRlbXBsYXRlIHJlZiBcIiR7a2V5fVwiIHVzZWQgb24gYSBub24tcmVmIHZhbHVlLiBJdCB3aWxsIG5vdCB3b3JrIGluIHRoZSBwcm9kdWN0aW9uIGJ1aWxkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChrbm93blRlbXBsYXRlUmVmcy5oYXMocmF3U2V0dXBTdGF0ZVtrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNPd24ocmF3U2V0dXBTdGF0ZSwga2V5KTtcbiAgfTtcbiAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XG4gICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcbiAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XG4gICAgICBpZiAoY2FuU2V0U2V0dXBSZWYob2xkUmVmKSkge1xuICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xuICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiwgW3ZhbHVlLCByZWZzXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgX2lzU3RyaW5nID0gaXNTdHJpbmcocmVmKTtcbiAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJhd1JlZi5mKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyBjYW5TZXRTZXR1cFJlZihyZWYpID8gc2V0dXBTdGF0ZVtyZWZdIDogcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xuICAgICAgICAgIGlmIChpc1VubW91bnQpIHtcbiAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZShleGlzdGluZywgcmVmVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihyZWYpKSB7XG4gICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSByZWZzW3JlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoY2FuU2V0U2V0dXBSZWYocmVmKSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1JlZikge1xuICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChyYXdSZWYuaykgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZG9TZXQuaWQgPSAtMTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1NldCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgfVxuICB9XG59XG5cbmxldCBoYXNMb2dnZWRNaXNtYXRjaEVycm9yID0gZmFsc2U7XG5jb25zdCBsb2dNaXNtYXRjaEVycm9yID0gKCkgPT4ge1xuICBpZiAoaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmVycm9yKFwiSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5cIik7XG4gIGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSB0cnVlO1xufTtcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcInN2Z1wiKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gXCJmb3JlaWduT2JqZWN0XCI7XG5jb25zdCBpc01hdGhNTENvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJNYXRoTUxcIik7XG5jb25zdCBnZXRDb250YWluZXJUeXBlID0gKGNvbnRhaW5lcikgPT4ge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaXNTVkdDb250YWluZXIoY29udGFpbmVyKSkgcmV0dXJuIFwic3ZnXCI7XG4gIGlmIChpc01hdGhNTENvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJtYXRobWxcIjtcbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIHA6IHBhdGNoLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcCxcbiAgICAgIGNyZWF0ZVRleHQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICByZW1vdmUsXG4gICAgICBpbnNlcnQsXG4gICAgICBjcmVhdGVDb21tZW50XG4gICAgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcbiAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiO1xuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcbiAgICAgIG5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgaXNGcmFnbWVudFN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICB2bm9kZS5lbCA9IG5vZGU7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZWYobm9kZSwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcbiAgICAgIGRlZihub2RlLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIGlmIChkb21UeXBlICE9PSAzKSB7XG4gICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcbiAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoIGluYCxcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YVxuICAgICAgICAgICAgICApfVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIHJlcGxhY2VOb2RlKFxuICAgICAgICAgICAgdm5vZGUuZWwgPSBub2RlLmNvbnRlbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGRvbVR5cGUgIT09IDggfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21UeXBlID09PSAxIHx8IGRvbVR5cGUgPT09IDMpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm5vZGVUeXBlID09PSAxID8gbmV4dE5vZGUub3V0ZXJIVE1MIDogbmV4dE5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzRnJhZ21lbnRTdGFydCA/IG5leHRTaWJsaW5nKG5leHROb2RlKSA6IG5leHROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIGlmICgoZG9tVHlwZSAhPT0gMSB8fCB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiAhaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0XCIpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlLCBub2RlLmRhdGEsIFwidGVsZXBvcnQgZW5kXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICF2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICAgICAgbGV0IHN1YlRyZWU7XG4gICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XG4gICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGUgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmcgOiBjb250YWluZXIubGFzdENoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoXCJcIikgOiBjcmVhdGVWTm9kZShcImRpdlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xuICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUgPSBzdWJUcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICAgIGh5ZHJhdGVDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGdldENvbnRhaW5lclR5cGUocGFyZW50Tm9kZShub2RlKSksXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgSG9zdFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dE5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGNvbnN0IGZvcmNlUGF0Y2ggPSB0eXBlID09PSBcImlucHV0XCIgfHwgdHlwZSA9PT0gXCJvcHRpb25cIjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmb3JjZVBhdGNoIHx8IHBhdGNoRmxhZyAhPT0gLTEpIHtcbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgICAgfVxuICAgICAgbGV0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gZmFsc2U7XG4gICAgICBpZiAoaXNUZW1wbGF0ZU5vZGUoZWwpKSB7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24oXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBubyBuZWVkIGNoZWNrIHBhcmVudFN1c3BlbnNlIGluIGh5ZHJhdGlvblxuICAgICAgICAgIHRyYW5zaXRpb25cbiAgICAgICAgKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcy5hcHBlYXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZU5vZGUoY29udGVudCwgZWwsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIHZub2RlLmVsID0gZWwgPSBjb250ZW50O1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2ICYmIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcbiAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIGVsLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgIHJlbW92ZShjdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgbGV0IGNsaWVudFRleHQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNsaWVudFRleHRbMF0gPT09IFwiXFxuXCIgJiYgKGVsLnRhZ05hbWUgPT09IFwiUFJFXCIgfHwgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSkge1xuICAgICAgICAgIGNsaWVudFRleHQgPSBjbGllbnRUZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gY2xpZW50VGV4dCkge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDAgLyogVEVYVCAqLykpIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke2VsLnRleHRDb250ZW50fVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHt2bm9kZS5jaGlsZHJlbn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fIHx8IGZvcmNlUGF0Y2ggfHwgIW9wdGltaXplZCB8fCBwYXRjaEZsYWcgJiAoMTYgfCAzMikpIHtcbiAgICAgICAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBlbC50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgLy8gIzExMTg5IHNraXAgaWYgdGhpcyBub2RlIGhhcyBkaXJlY3RpdmVzIHRoYXQgaGF2ZSBjcmVhdGVkIGhvb2tzXG4gICAgICAgICAgICAvLyBhcyBpdCBjb3VsZCBoYXZlIG11dGF0ZWQgdGhlIERPTSBpbiBhbnkgcG9zc2libGUgd2F5XG4gICAgICAgICAgICAhKGRpcnMgJiYgZGlycy5zb21lKChkKSA9PiBkLmRpci5jcmVhdGVkKSkgJiYgcHJvcEhhc01pc21hdGNoKGVsLCBrZXksIHByb3BzW2tleV0sIHZub2RlLCBwYXJlbnRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoICYmIChrZXkuZW5kc1dpdGgoXCJ2YWx1ZVwiKSB8fCBrZXkgPT09IFwiaW5kZXRlcm1pbmF0ZVwiKSB8fCBpc09uKGtleSkgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkgfHwgLy8gZm9yY2UgaHlkcmF0ZSB2LWJpbmQgd2l0aCAucHJvcCBtb2RpZmllcnNcbiAgICAgICAgICAgIGtleVswXSA9PT0gXCIuXCIgfHwgaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCB2b2lkIDAsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICBwYXRjaFByb3AoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2ssXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDQgJiYgaXNSZWFjdGl2ZShwcm9wcy5zdHlsZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcy5zdHlsZSkgcHJvcHMuc3R5bGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICBpZiAodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycyB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB2bm9kZSA9IG9wdGltaXplZCA/IGNoaWxkcmVuW2ldIDogY2hpbGRyZW5baV0gPSBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBjb25zdCBpc1RleHQgPSB2bm9kZS50eXBlID09PSBUZXh0O1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzVGV4dCAmJiAhb3B0aW1pemVkKSB7XG4gICAgICAgICAgaWYgKGkgKyAxIDwgbCAmJiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpICsgMV0pLnR5cGUgPT09IFRleHQpIHtcbiAgICAgICAgICAgIGluc2VydChcbiAgICAgICAgICAgICAgY3JlYXRlVGV4dChcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEuc2xpY2Uodm5vZGUuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIG5leHRTaWJsaW5nKG5vZGUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoY29udGFpbmVyLCAxIC8qIENISUxEUkVOICovKSkge1xuICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgYFxuU2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICBjb25zdCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgbmV4dFNpYmxpbmcobm9kZSksXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgb3B0aW1pemVkXG4gICAgKTtcbiAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvciA9IG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICBpbnNlcnQodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApLCBjb250YWluZXIsIG5leHQpO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XG4gICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChub2RlLnBhcmVudEVsZW1lbnQsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxuLSByZW5kZXJlZCBvbiBzZXJ2ZXI6YCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGAodGV4dClgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWAgOiBgYCxcbiAgICAgICAgYFxuLSBleHBlY3RlZCBvbiBjbGllbnQ6YCxcbiAgICAgICAgdm5vZGUudHlwZVxuICAgICAgKTtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICB9XG4gICAgdm5vZGUuZWwgPSBudWxsO1xuICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dDIgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgaWYgKG5leHQyICYmIG5leHQyICE9PSBlbmQpIHtcbiAgICAgICAgICByZW1vdmUobmV4dDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIHJlbW92ZShub2RlKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5leHQsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIGdldENvbnRhaW5lclR5cGUoY29udGFpbmVyKSxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gdm5vZGUuZWw7XG4gICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCB2bm9kZS5lbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9O1xuICBjb25zdCBsb2NhdGVDbG9zaW5nQW5jaG9yID0gKG5vZGUsIG9wZW4gPSBcIltcIiwgY2xvc2UgPSBcIl1cIikgPT4ge1xuICAgIGxldCBtYXRjaCA9IDA7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBvcGVuKSBtYXRjaCsrO1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBjbG9zZSkge1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgcmVwbGFjZU5vZGUgPSAobmV3Tm9kZSwgb2xkTm9kZSwgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgY29uc3QgcGFyZW50Tm9kZTIgPSBvbGROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUyKSB7XG4gICAgICBwYXJlbnROb2RlMi5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgb2xkTm9kZSk7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBwYXJlbnRDb21wb25lbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC52bm9kZS5lbCA9PT0gb2xkTm9kZSkge1xuICAgICAgICBwYXJlbnQudm5vZGUuZWwgPSBwYXJlbnQuc3ViVHJlZS5lbCA9IG5ld05vZGU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaXNUZW1wbGF0ZU5vZGUgPSAobm9kZSkgPT4ge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUudGFnTmFtZSA9PT0gXCJURU1QTEFURVwiO1xuICB9O1xuICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcbn1cbmZ1bmN0aW9uIHByb3BIYXNNaXNtYXRjaChlbCwga2V5LCBjbGllbnRWYWx1ZSwgdm5vZGUsIGluc3RhbmNlKSB7XG4gIGxldCBtaXNtYXRjaFR5cGU7XG4gIGxldCBtaXNtYXRjaEtleTtcbiAgbGV0IGFjdHVhbDtcbiAgbGV0IGV4cGVjdGVkO1xuICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICBleHBlY3RlZCA9IG5vcm1hbGl6ZUNsYXNzKGNsaWVudFZhbHVlKTtcbiAgICBpZiAoIWlzU2V0RXF1YWwodG9DbGFzc1NldChhY3R1YWwgfHwgXCJcIiksIHRvQ2xhc3NTZXQoZXhwZWN0ZWQpKSkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gMiAvKiBDTEFTUyAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0gYGNsYXNzYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xuICAgIGV4cGVjdGVkID0gaXNTdHJpbmcoY2xpZW50VmFsdWUpID8gY2xpZW50VmFsdWUgOiBzdHJpbmdpZnlTdHlsZShub3JtYWxpemVTdHlsZShjbGllbnRWYWx1ZSkpO1xuICAgIGNvbnN0IGFjdHVhbE1hcCA9IHRvU3R5bGVNYXAoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZE1hcCA9IHRvU3R5bGVNYXAoZXhwZWN0ZWQpO1xuICAgIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgZGlyLCB2YWx1ZSB9IG9mIHZub2RlLmRpcnMpIHtcbiAgICAgICAgaWYgKGRpci5uYW1lID09PSBcInNob3dcIiAmJiAhdmFsdWUpIHtcbiAgICAgICAgICBleHBlY3RlZE1hcC5zZXQoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApO1xuICAgIH1cbiAgICBpZiAoIWlzTWFwRXF1YWwoYWN0dWFsTWFwLCBleHBlY3RlZE1hcCkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDMgLyogU1RZTEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IFwic3R5bGVcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGlzS25vd25TdmdBdHRyKGtleSkgfHwgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoaXNCb29sZWFuQXR0cihrZXkpIHx8IGlzS25vd25IdG1sQXR0cihrZXkpKSkge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBpbmNsdWRlQm9vbGVhbkF0dHIoY2xpZW50VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgYWN0dWFsID0gZWwuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgICBleHBlY3RlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICBhY3R1YWwgPSBlbC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhwZWN0ZWQgPSBpc1JlbmRlcmFibGVBdHRyVmFsdWUoY2xpZW50VmFsdWUpID8gU3RyaW5nKGNsaWVudFZhbHVlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gNCAvKiBBVFRSSUJVVEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGtleTtcbiAgICB9XG4gIH1cbiAgaWYgKG1pc21hdGNoVHlwZSAhPSBudWxsICYmICFpc01pc21hdGNoQWxsb3dlZChlbCwgbWlzbWF0Y2hUeXBlKSkge1xuICAgIGNvbnN0IGZvcm1hdCA9ICh2KSA9PiB2ID09PSBmYWxzZSA/IGAobm90IHJlbmRlcmVkKWAgOiBgJHttaXNtYXRjaEtleX09XCIke3Z9XCJgO1xuICAgIGNvbnN0IHByZVNlZ21lbnQgPSBgSHlkcmF0aW9uICR7TWlzbWF0Y2hUeXBlU3RyaW5nW21pc21hdGNoVHlwZV19IG1pc21hdGNoIG9uYDtcbiAgICBjb25zdCBwb3N0U2VnbWVudCA9IGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7Zm9ybWF0KGFjdHVhbCl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke2Zvcm1hdChleHBlY3RlZCl9XG4gIE5vdGU6IHRoaXMgbWlzbWF0Y2ggaXMgY2hlY2stb25seS4gVGhlIERPTSB3aWxsIG5vdCBiZSByZWN0aWZpZWQgaW4gcHJvZHVjdGlvbiBkdWUgdG8gcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXG4gIFlvdSBzaG91bGQgZml4IHRoZSBzb3VyY2Ugb2YgdGhlIG1pc21hdGNoLmA7XG4gICAge1xuICAgICAgd2FybiQxKHByZVNlZ21lbnQsIGVsLCBwb3N0U2VnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvQ2xhc3NTZXQoc3RyKSB7XG4gIHJldHVybiBuZXcgU2V0KHN0ci50cmltKCkuc3BsaXQoL1xccysvKSk7XG59XG5mdW5jdGlvbiBpc1NldEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgcyBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvU3R5bGVNYXAoc3RyKSB7XG4gIGNvbnN0IHN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHN0ci5zcGxpdChcIjtcIikpIHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdChcIjpcIik7XG4gICAga2V5ID0ga2V5LnRyaW0oKTtcbiAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnRyaW0oKTtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICBzdHlsZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTWFwRXF1YWwoYSwgYikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYSkge1xuICAgIGlmICh2YWx1ZSAhPT0gYi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApIHtcbiAgY29uc3Qgcm9vdCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIGlmIChpbnN0YW5jZS5nZXRDc3NWYXJzICYmICh2bm9kZSA9PT0gcm9vdCB8fCByb290ICYmIHJvb3QudHlwZSA9PT0gRnJhZ21lbnQgJiYgcm9vdC5jaGlsZHJlbi5pbmNsdWRlcyh2bm9kZSkpKSB7XG4gICAgY29uc3QgY3NzVmFycyA9IGluc3RhbmNlLmdldENzc1ZhcnMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjc3NWYXJzKSB7XG4gICAgICBleHBlY3RlZE1hcC5zZXQoXG4gICAgICAgIGAtLSR7Z2V0RXNjYXBlZENzc1Zhck5hbWUoa2V5LCBmYWxzZSl9YCxcbiAgICAgICAgU3RyaW5nKGNzc1ZhcnNba2V5XSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZSA9PT0gcm9vdCAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlLnZub2RlLCBleHBlY3RlZE1hcCk7XG4gIH1cbn1cbmNvbnN0IGFsbG93TWlzbWF0Y2hBdHRyID0gXCJkYXRhLWFsbG93LW1pc21hdGNoXCI7XG5jb25zdCBNaXNtYXRjaFR5cGVTdHJpbmcgPSB7XG4gIFswIC8qIFRFWFQgKi9dOiBcInRleHRcIixcbiAgWzEgLyogQ0hJTERSRU4gKi9dOiBcImNoaWxkcmVuXCIsXG4gIFsyIC8qIENMQVNTICovXTogXCJjbGFzc1wiLFxuICBbMyAvKiBTVFlMRSAqL106IFwic3R5bGVcIixcbiAgWzQgLyogQVRUUklCVVRFICovXTogXCJhdHRyaWJ1dGVcIlxufTtcbmZ1bmN0aW9uIGlzTWlzbWF0Y2hBbGxvd2VkKGVsLCBhbGxvd2VkVHlwZSkge1xuICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyB8fCBhbGxvd2VkVHlwZSA9PT0gMSAvKiBDSElMRFJFTiAqLykge1xuICAgIHdoaWxlIChlbCAmJiAhZWwuaGFzQXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKSkge1xuICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCBhbGxvd2VkQXR0ciA9IGVsICYmIGVsLmdldEF0dHJpYnV0ZShhbGxvd01pc21hdGNoQXR0cik7XG4gIGlmIChhbGxvd2VkQXR0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGFsbG93ZWRBdHRyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9IGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKTtcbiAgICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyAmJiBsaXN0LmluY2x1ZGVzKFwiY2hpbGRyZW5cIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYWxsb3dlZEF0dHIuc3BsaXQoXCIsXCIpLmluY2x1ZGVzKE1pc21hdGNoVHlwZVN0cmluZ1thbGxvd2VkVHlwZV0pO1xuICB9XG59XG5cbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSBnZXRHbG9iYWxUaGlzKCkucmVxdWVzdElkbGVDYWxsYmFjayB8fCAoKGNiKSA9PiBzZXRUaW1lb3V0KGNiLCAxKSk7XG5jb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPSBnZXRHbG9iYWxUaGlzKCkuY2FuY2VsSWRsZUNhbGxiYWNrIHx8ICgoaWQpID0+IGNsZWFyVGltZW91dChpZCkpO1xuY29uc3QgaHlkcmF0ZU9uSWRsZSA9ICh0aW1lb3V0ID0gMWU0KSA9PiAoaHlkcmF0ZSkgPT4ge1xuICBjb25zdCBpZCA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soaHlkcmF0ZSwgeyB0aW1lb3V0IH0pO1xuICByZXR1cm4gKCkgPT4gY2FuY2VsSWRsZUNhbGxiYWNrKGlkKTtcbn07XG5mdW5jdGlvbiBlbGVtZW50SXNWaXNpYmxlSW5WaWV3cG9ydChlbCkge1xuICBjb25zdCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHsgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGggfSA9IHdpbmRvdztcbiAgcmV0dXJuICh0b3AgPiAwICYmIHRvcCA8IGlubmVySGVpZ2h0IHx8IGJvdHRvbSA+IDAgJiYgYm90dG9tIDwgaW5uZXJIZWlnaHQpICYmIChsZWZ0ID4gMCAmJiBsZWZ0IDwgaW5uZXJXaWR0aCB8fCByaWdodCA+IDAgJiYgcmlnaHQgPCBpbm5lcldpZHRoKTtcbn1cbmNvbnN0IGh5ZHJhdGVPblZpc2libGUgPSAob3B0cykgPT4gKGh5ZHJhdGUsIGZvckVhY2gpID0+IHtcbiAgY29uc3Qgb2IgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgaWYgKCFlLmlzSW50ZXJzZWN0aW5nKSBjb250aW51ZTtcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIGZvckVhY2goKGVsKSA9PiB7XG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgIGlmIChlbGVtZW50SXNWaXNpYmxlSW5WaWV3cG9ydChlbCkpIHtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2Iub2JzZXJ2ZShlbCk7XG4gIH0pO1xuICByZXR1cm4gKCkgPT4gb2IuZGlzY29ubmVjdCgpO1xufTtcbmNvbnN0IGh5ZHJhdGVPbk1lZGlhUXVlcnkgPSAocXVlcnkpID0+IChoeWRyYXRlKSA9PiB7XG4gIGlmIChxdWVyeSkge1xuICAgIGNvbnN0IG1xbCA9IG1hdGNoTWVkaWEocXVlcnkpO1xuICAgIGlmIChtcWwubWF0Y2hlcykge1xuICAgICAgaHlkcmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtcWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gbXFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaHlkcmF0ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgaHlkcmF0ZU9uSW50ZXJhY3Rpb24gPSAoaW50ZXJhY3Rpb25zID0gW10pID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGlmIChpc1N0cmluZyhpbnRlcmFjdGlvbnMpKSBpbnRlcmFjdGlvbnMgPSBbaW50ZXJhY3Rpb25zXTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGRvSHlkcmF0ZSA9IChlKSA9PiB7XG4gICAgaWYgKCFoYXNIeWRyYXRlZCkge1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgdGVhcmRvd24oKTtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IGUuY29uc3RydWN0b3IoZS50eXBlLCBlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB0ZWFyZG93biA9ICgpID0+IHtcbiAgICBmb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGksIGRvSHlkcmF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvckVhY2goKGVsKSA9PiB7XG4gICAgZm9yIChjb25zdCBpIG9mIGludGVyYWN0aW9ucykge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGVhcmRvd247XG59O1xuZnVuY3Rpb24gZm9yRWFjaEVsZW1lbnQobm9kZSwgY2IpIHtcbiAgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiKSB7XG4gICAgbGV0IGRlcHRoID0gMTtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNiKG5leHQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChuZXh0KSkge1xuICAgICAgICBpZiAobmV4dC5kYXRhID09PSBcIl1cIikge1xuICAgICAgICAgIGlmICgtLWRlcHRoID09PSAwKSBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0LmRhdGEgPT09IFwiW1wiKSB7XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNiKG5vZGUpO1xuICB9XG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcbiAgfVxuICBjb25zdCB7XG4gICAgbG9hZGVyLFxuICAgIGxvYWRpbmdDb21wb25lbnQsXG4gICAgZXJyb3JDb21wb25lbnQsXG4gICAgZGVsYXkgPSAyMDAsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN0cmF0ZWd5LFxuICAgIHRpbWVvdXQsXG4gICAgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XG4gICAgc3VzcGVuc2libGUgPSB0cnVlLFxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yXG4gIH0gPSBzb3VyY2U7XG4gIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gIGxldCByZXNvbHZlZENvbXA7XG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgcmV0cmllcysrO1xuICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICByZXR1cm4gbG9hZCgpO1xuICB9O1xuICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3QgfHwgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPSBsb2FkZXIoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICBpZiAodXNlck9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKGNvbXApID0+IHtcbiAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNvbXApIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXAgJiYgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiTW9kdWxlXCIpKSB7XG4gICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSkpO1xuICB9O1xuICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBuYW1lOiBcIkFzeW5jQ29tcG9uZW50V3JhcHBlclwiLFxuICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXG4gICAgX19hc3luY0h5ZHJhdGUoZWwsIGluc3RhbmNlLCBoeWRyYXRlKSB7XG4gICAgICBjb25zdCBkb0h5ZHJhdGUgPSBoeWRyYXRlU3RyYXRlZ3kgPyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlYXJkb3duID0gaHlkcmF0ZVN0cmF0ZWd5KFxuICAgICAgICAgIGh5ZHJhdGUsXG4gICAgICAgICAgKGNiKSA9PiBmb3JFYWNoRWxlbWVudChlbCwgY2IpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0ZWFyZG93bikge1xuICAgICAgICAgIChpbnN0YW5jZS5idW0gfHwgKGluc3RhbmNlLmJ1bSA9IFtdKSkucHVzaCh0ZWFyZG93bik7XG4gICAgICAgIH1cbiAgICAgIH0gOiBoeWRyYXRlO1xuICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICBkb0h5ZHJhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWQoKS50aGVuKCgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBkb0h5ZHJhdGUoKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcbiAgICB9LFxuICAgIHNldHVwKCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGhhbmRsZUVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAhZXJyb3JDb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBpZiAoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UgfHwgaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgICAgIHJldHVybiBsb2FkKCkudGhlbigoY29tcCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudCA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfSkgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XG4gICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xuICAgICAgY29uc3QgZGVsYXllZCA9IHJlZighIWRlbGF5KTtcbiAgICAgIGlmIChkZWxheSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCAmJiBpc0tlZXBBbGl2ZShpbnN0YW5jZS5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgICAgaW5zdGFuY2UucGFyZW50LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHBhcmVudCkge1xuICBjb25zdCB7IHJlZjogcmVmMiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XG4gIHZub2RlLnJlZiA9IHJlZjI7XG4gIHZub2RlLmNlID0gY2U7XG4gIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XG4gIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gIG5hbWU6IGBLZWVwQWxpdmVgLFxuICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxuICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gIF9faXNLZWVwQWxpdmU6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJlcjoge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgbTogbW92ZSxcbiAgICAgICAgdW06IF91bm1vdW50LFxuICAgICAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICAgICAgfVxuICAgIH0gPSBzaGFyZWRDb250ZXh0O1xuICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgbW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIDAsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBpbnN0YW5jZTIudm5vZGUsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgaW5zdGFuY2UyLFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5hKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgaW52YWxpZGF0ZU1vdW50KGluc3RhbmNlMi5tKTtcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIuYSk7XG4gICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmRhKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlMi5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1bm1vdW50KHZub2RlKSB7XG4gICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcbiAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XG4gICAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKGNhY2hlZCAmJiAoIWN1cnJlbnQgfHwgIWlzU2FtZVZOb2RlVHlwZShjYWNoZWQsIGN1cnJlbnQpKSkge1xuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxuICAgICAgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc1N1c3BlbnNlKGluc3RhbmNlLnN1YlRyZWUudHlwZSkpIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgICAgfSwgaW5zdGFuY2Uuc3ViVHJlZS5zdXNwZW5zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgICBjYWNoZS5mb3JFYWNoKChjYWNoZWQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlICYmIGNhY2hlZC5rZXkgPT09IHZub2RlLmtleSkge1xuICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICBpZiAoIXNsb3RzLmRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XG4gICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoYEtlZXBBbGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8ICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCkgJiYgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjgpKSB7XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcbiAgICAgIGlmICh2bm9kZS50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wID0gdm5vZGUudHlwZTtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBpc0FzeW5jV3JhcHBlcih2bm9kZSkgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fSA6IGNvbXBcbiAgICAgICk7XG4gICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XG4gICAgICBpZiAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpIHx8IGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSB7XG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xuICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodm5vZGUuZWwpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XG4gICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcbiAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xuICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMjtcbiAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2O1xuICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8IChob29rLl9fd2RjID0gKCkgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2soKTtcbiAgfSk7XG4gIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xuICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2soXG4gICAgdHlwZSxcbiAgICBob29rLFxuICAgIGtlZXBBbGl2ZVJvb3QsXG4gICAgdHJ1ZVxuICAgIC8qIHByZXBlbmQgKi9cbiAgKTtcbiAgb25Vbm1vdW50ZWQoKCkgPT4ge1xuICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XG4gIH0sIHRhcmdldCk7XG59XG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NjtcbiAgdm5vZGUuc2hhcGVGbGFnICY9IH41MTI7XG59XG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHwgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIHRhcmdldCwgdHlwZSwgYXJncyk7XG4gICAgICByZXNldCgpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICBpZiAocHJlcGVuZCkge1xuICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZEhvb2s7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sIFwiXCIpKTtcbiAgICB3YXJuJDEoXG4gICAgICBgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC4gTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgKyAoYCBJZiB5b3UgYXJlIHVzaW5nIGFzeW5jIHNldHVwKCksIG1ha2Ugc3VyZSB0byByZWdpc3RlciBsaWZlY3ljbGUgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYCApXG4gICAgKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IHtcbiAgaWYgKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIpIHtcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldCk7XG4gIH1cbn07XG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIpO1xuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIik7XG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXG4gIFwiYnVcIlxuKTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIpO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlSG9vayhcbiAgXCJidW1cIlxuKTtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIpO1xuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXG4gIFwic3BcIlxuKTtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiKTtcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUhvb2soXCJydGNcIik7XG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XG4gIGluamVjdEhvb2soXCJlY1wiLCBob29rLCB0YXJnZXQpO1xufVxuXG5jb25zdCBDT01QT05FTlRTID0gXCJjb21wb25lbnRzXCI7XG5jb25zdCBESVJFQ1RJVkVTID0gXCJkaXJlY3RpdmVzXCI7XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcbn1cbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2wuZm9yKFwidi1uZGNcIik7XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBpZiAoc2VsZk5hbWUgJiYgKHNlbGZOYW1lID09PSBuYW1lIHx8IHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fCBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IChcbiAgICAgIC8vIGxvY2FsIHJlZ2lzdHJhdGlvblxuICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKVxuICAgICk7XG4gICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFMgPyBgXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGNvbXBvbmVudCByZXNvbHV0aW9uIHZpYSBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50LmAgOiBgYDtcbiAgICAgIHdhcm4kMShgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICByZXR1cm4gcmVnaXN0cnkgJiYgKHJlZ2lzdHJ5W25hbWVdIHx8IHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fCByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gIGxldCByZXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlICYmIGNhY2hlW2luZGV4XTtcbiAgY29uc3Qgc291cmNlSXNBcnJheSA9IGlzQXJyYXkoc291cmNlKTtcbiAgaWYgKHNvdXJjZUlzQXJyYXkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIGNvbnN0IHNvdXJjZUlzUmVhY3RpdmVBcnJheSA9IHNvdXJjZUlzQXJyYXkgJiYgaXNSZWFjdGl2ZShzb3VyY2UpO1xuICAgIGxldCBuZWVkc1dyYXAgPSBmYWxzZTtcbiAgICBpZiAoc291cmNlSXNSZWFjdGl2ZUFycmF5KSB7XG4gICAgICBuZWVkc1dyYXAgPSAhaXNTaGFsbG93KHNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSBzaGFsbG93UmVhZEFycmF5KHNvdXJjZSk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oXG4gICAgICAgIG5lZWRzV3JhcCA/IHRvUmVhY3RpdmUoc291cmNlW2ldKSA6IHNvdXJjZVtpXSxcbiAgICAgICAgaSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBjYWNoZWQgJiYgY2FjaGVkW2ldXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgd2FybiQxKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IEFycmF5LmZyb20oXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZVtpbmRleF0gPSByZXQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2xvdHMoc2xvdHMsIGR5bmFtaWNTbG90cykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XG4gICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmtleSA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHNsb3QuZm4oLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXMpIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gOiBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIGZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQpICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQuY2UpIHtcbiAgICBpZiAobmFtZSAhPT0gXCJkZWZhdWx0XCIpIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICBbY3JlYXRlVk5vZGUoXCJzbG90XCIsIHByb3BzLCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKV0sXG4gICAgICA2NFxuICAgICk7XG4gIH1cbiAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgU1NSLW9wdGltaXplZCBzbG90IGZ1bmN0aW9uIGRldGVjdGVkIGluIGEgbm9uLVNTUi1vcHRpbWl6ZWQgcmVuZGVyIGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIHBhcmVudCB0ZW1wbGF0ZS5gXG4gICAgKTtcbiAgICBzbG90ID0gKCkgPT4gW107XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSBmYWxzZTtcbiAgfVxuICBvcGVuQmxvY2soKTtcbiAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XG4gIGNvbnN0IHNsb3RLZXkgPSBwcm9wcy5rZXkgfHwgLy8gc2xvdCBjb250ZW50IGFycmF5IG9mIGEgZHluYW1pYyBjb25kaXRpb25hbCBzbG90IG1heSBoYXZlIGEgYnJhbmNoXG4gIC8vIGtleSBhdHRhY2hlZCBpbiB0aGUgYGNyZWF0ZVNsb3RzYCBoZWxwZXIsIHJlc3BlY3QgdGhhdFxuICB2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5O1xuICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKFxuICAgIEZyYWdtZW50LFxuICAgIHtcbiAgICAgIGtleTogKHNsb3RLZXkgJiYgIWlzU3ltYm9sKHNsb3RLZXkpID8gc2xvdEtleSA6IGBfJHtuYW1lfWApICsgLy8gIzcyNTYgZm9yY2UgZGlmZmVyZW50aWF0ZSBmYWxsYmFjayBjb250ZW50IGZyb20gYWN0dWFsIGNvbnRlbnRcbiAgICAgICghdmFsaWRTbG90Q29udGVudCAmJiBmYWxsYmFjayA/IFwiX2ZiXCIgOiBcIlwiKVxuICAgIH0sXG4gICAgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLFxuICAgIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSA/IDY0IDogLTJcbiAgKTtcbiAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xuICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgXCItc1wiXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcbiAgcmV0dXJuIHZub2Rlcy5zb21lKChjaGlsZCkgPT4ge1xuICAgIGlmICghaXNWTm9kZShjaGlsZCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgPyB2bm9kZXMgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaiwgcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChvYmopKSB7XG4gICAgd2FybiQxKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICByZXRbcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkgJiYgL1tBLVpdLy50ZXN0KGtleSkgPyBgb246JHtrZXl9YCA6IHRvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcbiAgaWYgKCFpKSByZXR1cm4gbnVsbDtcbiAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpIHJldHVybiBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZShpKTtcbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcbn07XG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gKFxuICAvLyBNb3ZlIFBVUkUgbWFya2VyIHRvIG5ldyBsaW5lIHRvIHdvcmthcm91bmQgY29tcGlsZXIgZGlzY2FyZGluZyBpdFxuICAvLyBkdWUgdG8gdHlwZSBhbm5vdGF0aW9uXG4gIC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAkOiAoaSkgPT4gaSxcbiAgICAkZWw6IChpKSA9PiBpLnZub2RlLmVsLFxuICAgICRkYXRhOiAoaSkgPT4gaS5kYXRhLFxuICAgICRwcm9wczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzLFxuICAgICRhdHRyczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5hdHRycykgOiBpLmF0dHJzLFxuICAgICRzbG90czogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzLFxuICAgICRyZWZzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzLFxuICAgICRwYXJlbnQ6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCksXG4gICAgJHJvb3Q6IChpKSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxuICAgICRob3N0OiAoaSkgPT4gaS5jZSxcbiAgICAkZW1pdDogKGkpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSxcbiAgICAkZm9yY2VVcGRhdGU6IChpKSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHtcbiAgICAgIHF1ZXVlSm9iKGkudXBkYXRlKTtcbiAgICB9KSxcbiAgICAkbmV4dFRpY2s6IChpKSA9PiBpLm4gfHwgKGkubiA9IG5leHRUaWNrLmJpbmQoaS5wcm94eSkpLFxuICAgICR3YXRjaDogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyBpbnN0YW5jZVdhdGNoLmJpbmQoaSkgOiBOT09QXG4gIH0pXG4pO1xuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRcIjtcbmNvbnN0IGhhc1NldHVwQmluZGluZyA9IChzdGF0ZSwga2V5KSA9PiBzdGF0ZSAhPT0gRU1QVFlfT0JKICYmICFzdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHN0YXRlLCBrZXkpO1xuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xuICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiX19pc1Z1ZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcbiAgICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xuICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XG4gICAgICBpZiAobiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgIGNhc2UgMSAvKiBTRVRVUCAqLzpcbiAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICAgICAgY2FzZSAyIC8qIERBVEEgKi86XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgIGNhc2UgNCAvKiBDT05URVhUICovOlxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICAgIGNhc2UgMyAvKiBQUk9QUyAqLzpcbiAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIFNFVFVQICovO1xuICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogREFUQSAqLztcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXG4gICAgICAgIC8vIHByb3BzXG4gICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSlcbiAgICAgICkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcbiAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgfSBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xuICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XG4gICAgaWYgKHB1YmxpY0dldHRlcikge1xuICAgICAgaWYgKGtleSA9PT0gXCIkYXR0cnNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZS5hdHRycywgXCJnZXRcIiwgXCJcIik7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmICghaXNTdHJpbmcoa2V5KSB8fCAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xuICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICB3YXJuJDEoYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7a2V5fVwiIGZyb20gT3B0aW9ucyBBUEkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGtleVswXSA9PT0gXCIkXCIgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSBpbiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGhhcyh7XG4gICAgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfVxuICB9LCBrZXkpIHtcbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIHJldHVybiAhIWFjY2Vzc0NhY2hlW2tleV0gfHwgZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpIHx8IGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpIHx8IChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkgfHwgaGFzT3duKGN0eCwga2V5KSB8fCBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fCBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xuICAgICAgdGFyZ2V0Ll8uYWNjZXNzQ2FjaGVba2V5XSA9IDA7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oZGVzY3JpcHRvciwgXCJ2YWx1ZVwiKSkge1xuICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IudmFsdWUsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn07XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xuICAgIHdhcm4kMShcbiAgICAgIGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYFxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcbiAgfSxcbiAgaGFzKF8sIGtleSkge1xuICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gXCJfXCIgJiYgIWlzR2xvYmFsbHlBbGxvd2VkKGtleSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAga2V5XG4gICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBoYXM7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogKCkgPT4gaW5zdGFuY2VcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXG4gICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXG4gICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xuICAgICAgc2V0OiBOT09QXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIGN0eCxcbiAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gIH0gPSBpbnN0YW5jZTtcbiAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xuICBPYmplY3Qua2V5cyh0b1JhdyhzZXR1cFN0YXRlKSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3Qgd2FyblJ1bnRpbWVVc2FnZSA9IChtZXRob2QpID0+IHdhcm4kMShcbiAgYCR7bWV0aG9kfSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmBcbik7XG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVQcm9wc2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRW1pdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZU9wdGlvbnNgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lU2xvdHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lU2xvdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZU1vZGVsKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoXCJkZWZpbmVNb2RlbFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERlZmF1bHRzKHByb3BzLCBkZWZhdWx0cykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuJDEoYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gIH1cbiAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09yRW1pdHMocHJvcHMpIHtcbiAgcmV0dXJuIGlzQXJyYXkocHJvcHMpID8gcHJvcHMucmVkdWNlKFxuICAgIChub3JtYWxpemVkLCBwKSA9PiAobm9ybWFsaXplZFtwXSA9IG51bGwsIG5vcm1hbGl6ZWQpLFxuICAgIHt9XG4gICkgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICBjb25zdCBwcm9wcyA9IG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhyYXcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fc2tpcFwiKSkgY29udGludWU7XG4gICAgbGV0IG9wdCA9IHByb3BzW2tleV07XG4gICAgaWYgKG9wdCkge1xuICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcbiAgICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcbiAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKG9wdCAmJiBkZWZhdWx0c1tgX19za2lwXyR7a2V5fWBdKSB7XG4gICAgICBvcHQuc2tpcEZhY3RvcnkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU1vZGVscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGEgfHwgYjtcbiAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSkgcmV0dXJuIGEuY29uY2F0KGIpO1xuICByZXR1cm4gZXh0ZW5kKHt9LCBub3JtYWxpemVQcm9wc09yRW1pdHMoYSksIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhiKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIGlmICghZXhjbHVkZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjdHgpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgd2l0aEFzeW5jQ29udGV4dCBjYWxsZWQgd2l0aG91dCBhY3RpdmUgY3VycmVudCBpbnN0YW5jZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIH1cbiAgbGV0IGF3YWl0YWJsZSA9IGdldEF3YWl0YWJsZSgpO1xuICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcbiAgICBhd2FpdGFibGUgPSBhd2FpdGFibGUuY2F0Y2goKGUpID0+IHtcbiAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdHgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICB3YXJuJDEoYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XG4gICAgfVxuICB9O1xufVxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XG4gIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XG4gICAgY2FsbEhvb2sob3B0aW9ucy5iZWZvcmVDcmVhdGUsIGluc3RhbmNlLCBcImJjXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGRhdGFPcHRpb25zLFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsXG4gICAgbWV0aG9kcyxcbiAgICB3YXRjaDogd2F0Y2hPcHRpb25zLFxuICAgIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLFxuICAgIGluamVjdDogaW5qZWN0T3B0aW9ucyxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkLFxuICAgIGJlZm9yZU1vdW50LFxuICAgIG1vdW50ZWQsXG4gICAgYmVmb3JlVXBkYXRlLFxuICAgIHVwZGF0ZWQsXG4gICAgYWN0aXZhdGVkLFxuICAgIGRlYWN0aXZhdGVkLFxuICAgIGJlZm9yZURlc3Ryb3ksXG4gICAgYmVmb3JlVW5tb3VudCxcbiAgICBkZXN0cm95ZWQsXG4gICAgdW5tb3VudGVkLFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJUcmFja2VkLFxuICAgIHJlbmRlclRyaWdnZXJlZCxcbiAgICBlcnJvckNhcHR1cmVkLFxuICAgIHNlcnZlclByZWZldGNoLFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2UsXG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluamVjdE9wdGlvbnMpIHtcbiAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyk7XG4gIH1cbiAgaWYgKG1ldGhvZHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xuICAgICAgaWYgKGlzRnVuY3Rpb24obWV0aG9kSGFuZGxlcikpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGFPcHRpb25zKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBQbGFpbiBvYmplY3QgdXNhZ2UgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1Byb21pc2UoZGF0YSkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXG4gICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbiAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XG4gICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdCkgPyBvcHQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IGlzRnVuY3Rpb24ob3B0LmdldCkgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBOT09QO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZ2V0ID09PSBOT09QKSB7XG4gICAgICAgIHdhcm4kMShgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpIDogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/ICgpID0+IHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gOiBOT09QO1xuICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBjLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucykgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpIDogcHJvdmlkZU9wdGlvbnM7XG4gICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY3JlYXRlZCkge1xuICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGhvb2suZm9yRWFjaCgoX2hvb2spID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcbiAgICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xuICBpZiAoaXNBcnJheShleHBvc2UpKSB7XG4gICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0ge30pO1xuICAgICAgZXhwb3NlLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgc2V0OiAodmFsKSA9PiBwdWJsaWNUaGlzW2tleV0gPSB2YWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XG4gICAgfVxuICB9XG4gIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xuICB9XG4gIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgfVxuICBpZiAoY29tcG9uZW50cykgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gIGlmIChkaXJlY3RpdmVzKSBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgaWYgKHNlcnZlclByZWZldGNoKSB7XG4gICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcbiAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgbGV0IGluamVjdGVkO1xuICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gb3B0KSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KFxuICAgICAgICAgIG9wdC5mcm9tIHx8IGtleSxcbiAgICAgICAgICBvcHQuZGVmYXVsdCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBpbmplY3RlZC52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgaXNBcnJheShob29rKSA/IGhvb2subWFwKChoKSA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKSA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksXG4gICAgaW5zdGFuY2UsXG4gICAgdHlwZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XG4gIGxldCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xuICBpZiAoaXNTdHJpbmcocmF3KSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcbiAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgIHtcbiAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgcmF3LmZvckVhY2goKHIpID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSA6IGN0eFtyYXcuaGFuZGxlcl07XG4gICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBiYXNlID0gaW5zdGFuY2UudHlwZTtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xuICBjb25zdCB7XG4gICAgbWl4aW5zOiBnbG9iYWxNaXhpbnMsXG4gICAgb3B0aW9uc0NhY2hlOiBjYWNoZSxcbiAgICBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH1cbiAgfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcbiAgbGV0IHJlc29sdmVkO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpIHtcbiAgICB7XG4gICAgICByZXNvbHZlZCA9IGJhc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkID0ge307XG4gICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcbiAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKFxuICAgICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpXG4gICAgICApO1xuICAgIH1cbiAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGJhc2UpKSB7XG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XG4gICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcbiAgfVxuICBpZiAobWl4aW5zKSB7XG4gICAgbWl4aW5zLmZvckVhY2goXG4gICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSBcImV4cG9zZVwiKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCBzdHJhdHMgJiYgc3RyYXRzW2tleV07XG4gICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICBkYXRhOiBtZXJnZURhdGFGbixcbiAgcHJvcHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgZW1pdHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgLy8gb2JqZWN0c1xuICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIGxpZmVjeWNsZVxuICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcbiAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxuICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcbiAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXG4gIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gIC8vIGFzc2V0c1xuICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gd2F0Y2hcbiAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxuICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxuICBpbmplY3Q6IG1lcmdlSW5qZWN0XG59O1xuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGlmICghdG8pIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgIHJldHVybiAoZXh0ZW5kKShcbiAgICAgIGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLFxuICAgICAgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb21cbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiByYXc7XG59XG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKHRvKSB7XG4gICAgaWYgKGlzQXJyYXkodG8pICYmIGlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRvLCAuLi5mcm9tXSldO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKFxuICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHModG8pLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKGZyb20gIT0gbnVsbCA/IGZyb20gOiB7fSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAoIXRvKSByZXR1cm4gZnJvbTtcbiAgaWYgKCFmcm9tKSByZXR1cm4gdG87XG4gIGNvbnN0IG1lcmdlZCA9IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIGFwcDogbnVsbCxcbiAgICBjb25maWc6IHtcbiAgICAgIGlzTmF0aXZlVGFnOiBOTyxcbiAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgIGVycm9ySGFuZGxlcjogdm9pZCAwLFxuICAgICAgd2FybkhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICB9LFxuICAgIG1peGluczogW10sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgZGlyZWN0aXZlczoge30sXG4gICAgcHJvdmlkZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG9wdGlvbnNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgcHJvcHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgZW1pdHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgfTtcbn1cbmxldCB1aWQkMSA9IDA7XG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgIGlmICghaXNGdW5jdGlvbihyb290Q29tcG9uZW50KSkge1xuICAgICAgcm9vdENvbXBvbmVudCA9IGV4dGVuZCh7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgcm9vdFByb3BzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3QgcGx1Z2luQ2xlYW51cEZucyA9IFtdO1xuICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhcHAgPSBjb250ZXh0LmFwcCA9IHtcbiAgICAgIF91aWQ6IHVpZCQxKyssXG4gICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxuICAgICAgX3Byb3BzOiByb290UHJvcHMsXG4gICAgICBfY29udGFpbmVyOiBudWxsLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfaW5zdGFuY2U6IG51bGwsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xuICAgICAgfSxcbiAgICAgIHNldCBjb25maWcodikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGZ1bmN0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbWl4aW4obWl4aW4pIHtcbiAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcbiAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xuICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIk1peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUElcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgICAgd2FybiQxKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMShgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZub2RlID0gYXBwLl9jZVZOb2RlIHx8IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XG4gICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZW5kZXIoXG4gICAgICAgICAgICAgICAgY2xvbmVWTm9kZSh2bm9kZSksXG4gICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxuSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVubW91bnQoY2xlYW51cEZuKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHR5cGVvZiBjbGVhbnVwRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHBlY3RlZCBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudCB0byBhcHAub25Vbm1vdW50KCksIGJ1dCBnb3QgJHt0eXBlb2YgY2xlYW51cEZufWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHBsdWdpbkNsZWFudXBGbnMucHVzaChjbGVhbnVwRm4pO1xuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICAgIHBsdWdpbkNsZWFudXBGbnMsXG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlLFxuICAgICAgICAgICAgMTZcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBJdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggdGhlIG5ldyB2YWx1ZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBydW5XaXRoQ29udGV4dChmbikge1xuICAgICAgICBjb25zdCBsYXN0QXBwID0gY3VycmVudEFwcDtcbiAgICAgICAgY3VycmVudEFwcCA9IGFwcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50QXBwID0gbGFzdEFwcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcbn1cbmxldCBjdXJyZW50QXBwID0gbnVsbDtcblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcbiAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcbiAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XG4gICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xuICAgIH1cbiAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UgfHwgY3VycmVudEFwcCkge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gY3VycmVudEFwcCA/IGN1cnJlbnRBcHAuX2NvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZSA/IGluc3RhbmNlLnBhcmVudCA9PSBudWxsID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzIDogdm9pZCAwO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0luamVjdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiAhIShjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRBcHApO1xufVxuXG5jb25zdCBpbnRlcm5hbE9iamVjdFByb3RvID0ge307XG5jb25zdCBjcmVhdGVJbnRlcm5hbE9iamVjdCA9ICgpID0+IE9iamVjdC5jcmVhdGUoaW50ZXJuYWxPYmplY3RQcm90byk7XG5jb25zdCBpc0ludGVybmFsT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IGludGVybmFsT2JqZWN0UHJvdG87XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSID0gZmFsc2UpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgYXR0cnMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxuICBpZiAoaXNTdGF0ZWZ1bCkge1xuICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgfVxuICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xufVxuZnVuY3Rpb24gaXNJbkhtckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgd2hpbGUgKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19obXJJZCkgcmV0dXJuIHRydWU7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3Qge1xuICAgIHByb3BzLFxuICAgIGF0dHJzLFxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcbiAgKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xuICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGtlYmFiS2V5O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgaWYgKCFyYXdQcm9wcyB8fCAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiYgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdm9pZCAwIHx8IC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICB0cmlnZ2VyKGluc3RhbmNlLmF0dHJzLCBcInNldFwiLCBcIlwiKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgaWYgKHJhd1Byb3BzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XG4gICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XG4gICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICBrZXksXG4gICAgICAgIGNhc3RWYWx1ZXNba2V5XSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICFoYXNPd24oY2FzdFZhbHVlcywga2V5KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XG4gIGlmIChvcHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmICFvcHQuc2tpcEZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZS5jZSkge1xuICAgICAgICBpbnN0YW5jZS5jZS5fc2V0UHJvcChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XG4gICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgbWl4aW5Qcm9wc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gX19WVUVfT1BUSU9OU19BUElfXyAmJiBhc01peGluID8gbWl4aW5Qcm9wc0NhY2hlIDogYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAucHJvcHM7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3MikgPT4ge1xuICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcbiAgICAgIGlmIChrZXlzKSBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XG4gICAgfVxuICAgIHJldHVybiBFTVBUWV9BUlI7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xuICAgICAgICB3YXJuJDEoYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyYXcpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgd2FybiQxKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgIGNvbnN0IHByb3AgPSBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBleHRlbmQoe30sIG9wdCk7XG4gICAgICAgIGNvbnN0IHByb3BUeXBlID0gcHJvcC50eXBlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hvdWxkQ2FzdFRydWUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNBcnJheShwcm9wVHlwZSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcHJvcFR5cGUubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcHJvcFR5cGVbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBpc0Z1bmN0aW9uKHR5cGUpICYmIHR5cGUubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gXCJCb29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgc2hvdWxkQ2FzdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0VHJ1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG91bGRDYXN0ID0gaXNGdW5jdGlvbihwcm9wVHlwZSkgJiYgcHJvcFR5cGUubmFtZSA9PT0gXCJCb29sZWFuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gc2hvdWxkQ2FzdDtcbiAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9IHNob3VsZENhc3RUcnVlO1xuICAgICAgICBpZiAoc2hvdWxkQ2FzdCB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgbmVlZENhc3RLZXlzLnB1c2gobm9ybWFsaXplZEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICBpZiAoa2V5WzBdICE9PSBcIiRcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XG4gIGlmIChjdG9yID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmICh0eXBlb2YgY3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGN0b3IubmFtZSB8fCBcIlwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgbmFtZSA9IGN0b3IuY29uc3RydWN0b3IgJiYgY3Rvci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBuYW1lIHx8IFwiXCI7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcbiAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XG4gIGNvbnN0IGNhbWVsaXplUHJvcHNLZXkgPSBPYmplY3Qua2V5cyhyYXdQcm9wcykubWFwKChrZXkpID0+IGNhbWVsaXplKGtleSkpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ID09IG51bGwpIGNvbnRpbnVlO1xuICAgIHZhbGlkYXRlUHJvcChcbiAgICAgIGtleSxcbiAgICAgIHJlc29sdmVkVmFsdWVzW2tleV0sXG4gICAgICBvcHQsXG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHJlc29sdmVkVmFsdWVzKSA6IHJlc29sdmVkVmFsdWVzLFxuICAgICAgIWNhbWVsaXplUHJvcHNLZXkuaW5jbHVkZXMoa2V5KVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgcHJvcHMsIGlzQWJzZW50KSB7XG4gIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciwgc2tpcENoZWNrIH0gPSBwcm9wO1xuICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICB3YXJuJDEoJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcmVxdWlyZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlICYmICFza2lwQ2hlY2spIHtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoICYmICFpc1ZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCBcIlwiKTtcbiAgICAgIGlzVmFsaWQgPSB2YWxpZDtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB3YXJuJDEoZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSwgcHJvcHMpKSB7XG4gICAgd2FybiQxKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gIH1cbn1cbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBcIlN0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50XCJcbik7XG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIGxldCB2YWxpZDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICB9IGVsc2UgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJPYmplY3RcIikge1xuICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJBcnJheVwiKSB7XG4gICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBgUHJvcCB0eXBlIFtdIGZvciBwcm9wIFwiJHtuYW1lfVwiIHdvbid0IG1hdGNoIGFueXRoaW5nLiBEaWQgeW91IG1lYW4gdG8gdXNlIHR5cGUgQXJyYXkgaW5zdGVhZD9gO1xuICB9XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbihcIiB8IFwiKX1gO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJiBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJiAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICB9XG4gIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcbiAgfVxuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwiU3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJOdW1iZXJcIikge1xuICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKChlbGVtKSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3Muc29tZSgoZWxlbSkgPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSBcImJvb2xlYW5cIik7XG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkc3RhYmxlXCI7XG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKSA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xuICBpZiAocmF3U2xvdC5fbikge1xuICAgIHJldHVybiByYXdTbG90O1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KCguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudEluc3RhbmNlICYmICghY3R4IHx8IGN0eC5yb290ID09PSBjdXJyZW50SW5zdGFuY2Uucm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcbiAgfSwgY3R4KTtcbiAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XG4gICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmIHRydWUpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xuICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBhc3NpZ25TbG90cyA9IChzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZHJlbikge1xuICAgIGlmIChvcHRpbWl6ZWQgfHwga2V5ICE9PSBcIl9cIikge1xuICAgICAgc2xvdHNba2V5XSA9IGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHNsb3RzID0gaW5zdGFuY2Uuc2xvdHMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKG9wdGltaXplZCkge1xuICAgICAgICBkZWYoc2xvdHMsIFwiX1wiLCB0eXBlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gIH1cbn07XG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XG4gIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XG4gIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgfVxuICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xuICAgIHBlcmYubWFyayhlbmRUYWcpO1xuICAgIHBlcmYubWVhc3VyZShcbiAgICAgIGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLFxuICAgICAgc3RhcnRUYWcsXG4gICAgICBlbmRUYWdcbiAgICApO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKHN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcbiAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKFwiLCBcIil9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIHByb2R1Y3Rpb24gYnVuZGxlLlxuXG5Gb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIDtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICB7XG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcbiAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBzZXREZXZ0b29sc0hvb2skMSh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5zZXJ0OiBob3N0SW5zZXJ0LFxuICAgIHJlbW92ZTogaG9zdFJlbW92ZSxcbiAgICBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsXG4gICAgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsXG4gICAgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsXG4gICAgc2V0VGV4dDogaG9zdFNldFRleHQsXG4gICAgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCxcbiAgICBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLFxuICAgIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCxcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgbmFtZXNwYWNlID0gdm9pZCAwLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcgPyBmYWxzZSA6ICEhbjIuZHluYW1pY0NoaWxkcmVuKSA9PiB7XG4gICAgaWYgKG4xID09PSBuMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICBuMSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBwcm9jZXNzRnJhZ21lbnQoXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIHByb2Nlc3NFbGVtZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgVk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8IFwiXCIpLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSkgPT4ge1xuICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuMi5lbCxcbiAgICAgIG4yLmFuY2hvclxuICAgICk7XG4gIH07XG4gIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcbiAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KFxuICAgICAgICBuMi5jaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBpZiAobjIudHlwZSA9PT0gXCJzdmdcIikge1xuICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICB9IGVsc2UgaWYgKG4yLnR5cGUgPT09IFwibWF0aFwiKSB7XG4gICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRFbGVtZW50KFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoRWxlbWVudChcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGxldCBlbDtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGNvbnN0IHsgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgZGlycyB9ID0gdm5vZGU7XG4gICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KFxuICAgICAgdm5vZGUudHlwZSxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIHByb3BzICYmIHByb3BzLmlzLFxuICAgICAgcHJvcHNcbiAgICApO1xuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZSh2bm9kZSwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICB9XG4gICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwidmFsdWVcIiAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIHByb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgbnVsbCwgcHJvcHMudmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRlZihlbCwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcbiAgICAgIGRlZihlbCwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCBwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9IG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKTtcbiAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHwgZGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldFNjb3BlSWQgPSAoZWwsIHZub2RlLCBzY29wZUlkLCBzbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChzY29wZUlkKSB7XG4gICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XG4gICAgfVxuICAgIGlmIChzbG90U2NvcGVJZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmIHN1YlRyZWUucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgICAgICBzdWJUcmVlID0gZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlIHx8IGlzU3VzcGVuc2Uoc3ViVHJlZS50eXBlKSAmJiAoc3ViVHJlZS5zc0NvbnRlbnQgPT09IHZub2RlIHx8IHN1YlRyZWUuc3NGYWxsYmFjayA9PT0gdm5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xuICAgICAgICBzZXRTY29wZUlkKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHBhcmVudFZOb2RlLFxuICAgICAgICAgIHBhcmVudFZOb2RlLnNjb3BlSWQsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudC5wYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZWwgPSBuMi5lbCA9IG4xLmVsO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZWwuX192bm9kZSA9IG4yO1xuICAgIH1cbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XG4gICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2O1xuICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCBmYWxzZSk7XG4gICAgaWYgKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICAgIH1cbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChvbGRQcm9wcy5pbm5lckhUTUwgJiYgbmV3UHJvcHMuaW5uZXJIVE1MID09IG51bGwgfHwgb2xkUHJvcHMudGV4dENvbnRlbnQgJiYgbmV3UHJvcHMudGV4dENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHJlc29sdmVDaGlsZHJlbk5hbWVzcGFjZShuMiwgbmFtZXNwYWNlKSxcbiAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICApO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2KSB7XG4gICAgICAgIHBhdGNoUHJvcHMoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIpIHtcbiAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcImNsYXNzXCIsIG51bGwsIG5ld1Byb3BzLmNsYXNzLCBuYW1lc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwic3R5bGVcIiwgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4KSB7XG4gICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMSkge1xuICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHBhdGNoUHJvcHMoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsIFwidXBkYXRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG4gICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gKFxuICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxuICAgICAgICBvbGRWTm9kZS5lbCAmJiAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxuICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XG4gICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cbiAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgKDYgfCA2NCkpID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpIDogKFxuICAgICAgICAgIC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxuICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cbiAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG9sZFZOb2RlLFxuICAgICAgICBuZXdWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiAhKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG9sZFByb3BzW2tleV0sXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0ICE9PSBwcmV2ICYmIGtleSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBvbGRQcm9wcy52YWx1ZSwgbmV3UHJvcHMudmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSBuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIC8vICM1NTIzIGRldiByb290IGZyYWdtZW50IG1heSBpbmhlcml0IGRpcmVjdGl2ZXNcbiAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4KSkge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50RW5kQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAvLyAjMTAwMDdcbiAgICAgICAgLy8gc3VjaCBmcmFnbWVudCBsaWtlIGA8PjwvPmAgd2lsbCBiZSBjb21waWxlZCBpbnRvXG4gICAgICAgIC8vIGEgZnJhZ21lbnQgd2hpY2ggZG9lc24ndCBoYXZlIGEgY2hpbGRyZW4uXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSBmYWxsYmFjayB0byBhbiBlbXB0eSBhcnJheVxuICAgICAgICBuMi5jaGlsZHJlbiB8fCBbXSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgJiYgZHluYW1pY0NoaWxkcmVuICYmIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cbiAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XG4gICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cbiAgICAgICAgICAvLyAjMjEzNCBvciBpZiBpdCdzIGEgY29tcG9uZW50IHJvb3QsIGl0IG1heSBhbHNvIGdldCBtb3ZlZCBhcm91bmRcbiAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxuICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8IHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAvKiBzaGFsbG93ICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICApKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xuICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcbiAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcbiAgICB9XG4gICAge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGZhbHNlLCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSBpbml0aWFsVk5vZGUuZWwgPSBudWxsO1xuICAgICAgcGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0LCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xuICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCwgcm9vdCwgdHlwZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChibSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xuICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoeWRyYXRlTm9kZShcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSAmJiB0eXBlLl9fYXN5bmNIeWRyYXRlKSB7XG4gICAgICAgICAgICB0eXBlLl9fYXN5bmNIeWRyYXRlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocm9vdC5jZSkge1xuICAgICAgICAgICAgcm9vdC5jZS5faW5qZWN0Q2hpbGRTdHlsZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJUcmVlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9uSHlkcmF0ZWRBc3luY1Jvb3QgPSBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKG5vbkh5ZHJhdGVkQXN5bmNSb290KSB7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vbkh5ZHJhdGVkQXN5bmNSb290LmFzeW5jRGVwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlRm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIHByZXZUcmVlLFxuICAgICAgICAgIG5leHRUcmVlLFxuICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxuICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICAgIGNvbnN0IGVmZmVjdCA9IGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbik7XG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgY29uc3QgdXBkYXRlID0gaW5zdGFuY2UudXBkYXRlID0gZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCk7XG4gICAgY29uc3Qgam9iID0gaW5zdGFuY2Uuam9iID0gZWZmZWN0LnJ1bklmRGlydHkuYmluZChlZmZlY3QpO1xuICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIGVmZmVjdC5zY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZUpvYihqb2IpO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgIH1cbiAgICB1cGRhdGUoKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xuICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcbiAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcbiAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XG4gICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICB9O1xuICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcbiAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xuICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTI4KSB7XG4gICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoYzIgIT09IGMxKSB7XG4gICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgICBjMSxcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCkge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xuICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XG4gICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgYzFbaV0sXG4gICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMxLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICBjMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7XG4gICAgbGV0IGUyID0gbDIgLSAxO1xuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbaV07XG4gICAgICBjb25zdCBuMiA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xuICAgICAgY29uc3QgbjIgPSBjMltlMl0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaSA+IGUyKSB7XG4gICAgICB3aGlsZSAoaSA8PSBlMSkge1xuICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzMSA9IGk7XG4gICAgICBjb25zdCBzMiA9IGk7XG4gICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKSBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhdGNoZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZCA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcCkgOiBFTVBUWV9BUlI7XG4gICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyBjMltuZXh0SW5kZXggKyAxXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZlZCkge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwpID0+IHtcbiAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgbW92ZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgfVxuICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmVlZFRyYW5zaXRpb24yID0gbW92ZVR5cGUgIT09IDIgJiYgc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uO1xuICAgIGlmIChuZWVkVHJhbnNpdGlvbjIpIHtcbiAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCkge1xuICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHJlbW92ZTIgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBsZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlMigpO1xuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlMiwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50ID0gKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZGlycyxcbiAgICAgIGNhY2hlSW5kZXhcbiAgICB9ID0gdm5vZGU7XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjYWNoZUluZGV4ICE9IG51bGwpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5yZW5kZXJDYWNoZVtjYWNoZUluZGV4XSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgJiYgZGlycztcbiAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVubW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzUxNTRcbiAgICAgIC8vIHdoZW4gdi1vbmNlIGlzIHVzZWQgaW5zaWRlIGEgYmxvY2ssIHNldEJsb2NrVHJhY2tpbmcoLTEpIG1hcmtzIHRoZVxuICAgICAgLy8gcGFyZW50IGJsb2NrIHdpdGggaGFzT25jZTogdHJ1ZVxuICAgICAgLy8gc28gdGhhdCBpdCBkb2Vzbid0IHRha2UgdGhlIGZhc3QgcGF0aCBkdXJpbmcgdW5tb3VudCAtIG90aGVyd2lzZVxuICAgICAgLy8gY29tcG9uZW50cyBuZXN0ZWQgaW4gdi1vbmNlIGFyZSBuZXZlciB1bm1vdW50ZWQuXG4gICAgICAhZHluYW1pY0NoaWxkcmVuLmhhc09uY2UgJiYgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAodHlwZSAhPT0gRnJhZ21lbnQgfHwgcGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCkpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBGcmFnbWVudCAmJiBwYXRjaEZsYWcgJiAoMTI4IHwgMjU2KSB8fCAhb3B0aW1pemVkICYmIHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgcmVtb3ZlKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkgfHwgc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJ1bm1vdW50ZWRcIik7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmUgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUucGF0Y2hGbGFnID4gMCAmJiB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4ICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcbiAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVyZm9ybVJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoY3VyKTtcbiAgICAgIGhvc3RSZW1vdmUoY3VyKTtcbiAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoZW5kKTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudENvbXBvbmVudCA9IChpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgY29uc3QgeyBidW0sIHNjb3BlLCBqb2IsIHN1YlRyZWUsIHVtLCBtLCBhIH0gPSBpbnN0YW5jZTtcbiAgICBpbnZhbGlkYXRlTW91bnQobSk7XG4gICAgaW52YWxpZGF0ZU1vdW50KGEpO1xuICAgIGlmIChidW0pIHtcbiAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XG4gICAgfVxuICAgIHNjb3BlLnN0b3AoKTtcbiAgICBpZiAoam9iKSB7XG4gICAgICBqb2IuZmxhZ3MgfD0gODtcbiAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfVxuICAgIGlmICh1bSkge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJiBpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJiBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gKHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xuICAgIH1cbiAgICBjb25zdCBlbCA9IGhvc3ROZXh0U2libGluZyh2bm9kZS5hbmNob3IgfHwgdm5vZGUuZWwpO1xuICAgIGNvbnN0IHRlbGVwb3J0RW5kID0gZWwgJiYgZWxbVGVsZXBvcnRFbmRLZXldO1xuICAgIHJldHVybiB0ZWxlcG9ydEVuZCA/IGhvc3ROZXh0U2libGluZyh0ZWxlcG9ydEVuZCkgOiBlbDtcbiAgfTtcbiAgbGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSB8fCBudWxsLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGludGVybmFscyA9IHtcbiAgICBwOiBwYXRjaCxcbiAgICB1bTogdW5tb3VudCxcbiAgICBtOiBtb3ZlLFxuICAgIHI6IHJlbW92ZSxcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxuICAgIG86IG9wdGlvbnNcbiAgfTtcbiAgbGV0IGh5ZHJhdGU7XG4gIGxldCBoeWRyYXRlTm9kZTtcbiAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoXG4gICAgICBpbnRlcm5hbHNcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVuZGVyLFxuICAgIGh5ZHJhdGUsXG4gICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHsgdHlwZSwgcHJvcHMgfSwgY3VycmVudE5hbWVzcGFjZSkge1xuICByZXR1cm4gY3VycmVudE5hbWVzcGFjZSA9PT0gXCJzdmdcIiAmJiB0eXBlID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCBjdXJyZW50TmFtZXNwYWNlID09PSBcIm1hdGhtbFwiICYmIHR5cGUgPT09IFwiYW5ub3RhdGlvbi14bWxcIiAmJiBwcm9wcyAmJiBwcm9wcy5lbmNvZGluZyAmJiBwcm9wcy5lbmNvZGluZy5pbmNsdWRlcyhcImh0bWxcIikgPyB2b2lkIDAgOiBjdXJyZW50TmFtZXNwYWNlO1xufVxuZnVuY3Rpb24gdG9nZ2xlUmVjdXJzZSh7IGVmZmVjdCwgam9iIH0sIGFsbG93ZWQpIHtcbiAgaWYgKGFsbG93ZWQpIHtcbiAgICBlZmZlY3QuZmxhZ3MgfD0gMzI7XG4gICAgam9iLmZsYWdzIHw9IDQ7XG4gIH0gZWxzZSB7XG4gICAgZWZmZWN0LmZsYWdzICY9IH4zMjtcbiAgICBqb2IuZmxhZ3MgJj0gfjQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG5lZWRUcmFuc2l0aW9uKHBhcmVudFN1c3BlbnNlLCB0cmFuc2l0aW9uKSB7XG4gIHJldHVybiAoIXBhcmVudFN1c3BlbnNlIHx8IHBhcmVudFN1c3BlbnNlICYmICFwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZDtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XG4gIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xuICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIpIHtcbiAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgYzIucGF0Y2hGbGFnICE9PSAtMilcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XG4gICAgICB9XG4gICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xuICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFswXTtcbiAgbGV0IGksIGosIHUsIHYsIGM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgaWYgKGFyckkgIT09IDApIHtcbiAgICAgIGogPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcbiAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHUgPSAwO1xuICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHUgPCB2KSB7XG4gICAgICAgIGMgPSB1ICsgdiA+PiAxO1xuICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XG4gICAgICAgICAgdSA9IGMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYgPSBjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgIGlmICh1ID4gMCkge1xuICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFt1XSA9IGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHUgPSByZXN1bHQubGVuZ3RoO1xuICB2ID0gcmVzdWx0W3UgLSAxXTtcbiAgd2hpbGUgKHUtLSA+IDApIHtcbiAgICByZXN1bHRbdV0gPSB2O1xuICAgIHYgPSBwW3ZdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSkge1xuICBjb25zdCBzdWJDb21wb25lbnQgPSBpbnN0YW5jZS5zdWJUcmVlLmNvbXBvbmVudDtcbiAgaWYgKHN1YkNvbXBvbmVudCkge1xuICAgIGlmIChzdWJDb21wb25lbnQuYXN5bmNEZXAgJiYgIXN1YkNvbXBvbmVudC5hc3luY1Jlc29sdmVkKSB7XG4gICAgICByZXR1cm4gc3ViQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbG9jYXRlTm9uSHlkcmF0ZWRBc3luY1Jvb3Qoc3ViQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVNb3VudChob29rcykge1xuICBpZiAoaG9va3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKVxuICAgICAgaG9va3NbaV0uZmxhZ3MgfD0gODtcbiAgfVxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sLmZvcihcInYtc2N4XCIpO1xuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcbiAge1xuICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxufTtcblxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwicG9zdFwiIH0pIDogeyBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInN5bmNcIiB9KSA6IHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25jZSB9ID0gb3B0aW9ucztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRlZXAgIT09IHZvaWQgMCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob25jZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwib25jZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGJhc2VXYXRjaE9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgYmFzZVdhdGNoT3B0aW9ucy5vbldhcm4gPSB3YXJuJDE7XG4gIGNvbnN0IHJ1bnNJbW1lZGlhdGVseSA9IGNiICYmIGltbWVkaWF0ZSB8fCAhY2IgJiYgZmx1c2ggIT09IFwicG9zdFwiO1xuICBsZXQgc3NyQ2xlYW51cDtcbiAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgIGlmIChmbHVzaCA9PT0gXCJzeW5jXCIpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHVzZVNTUkNvbnRleHQoKTtcbiAgICAgIHNzckNsZWFudXAgPSBjdHguX193YXRjaGVySGFuZGxlcyB8fCAoY3R4Ll9fd2F0Y2hlckhhbmRsZXMgPSBbXSk7XG4gICAgfSBlbHNlIGlmICghcnVuc0ltbWVkaWF0ZWx5KSB7XG4gICAgICBjb25zdCB3YXRjaFN0b3BIYW5kbGUgPSAoKSA9PiB7XG4gICAgICB9O1xuICAgICAgd2F0Y2hTdG9wSGFuZGxlLnN0b3AgPSBOT09QO1xuICAgICAgd2F0Y2hTdG9wSGFuZGxlLnJlc3VtZSA9IE5PT1A7XG4gICAgICB3YXRjaFN0b3BIYW5kbGUucGF1c2UgPSBOT09QO1xuICAgICAgcmV0dXJuIHdhdGNoU3RvcEhhbmRsZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gIGJhc2VXYXRjaE9wdGlvbnMuY2FsbCA9IChmbiwgdHlwZSwgYXJncykgPT4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgbGV0IGlzUHJlID0gZmFsc2U7XG4gIGlmIChmbHVzaCA9PT0gXCJwb3N0XCIpIHtcbiAgICBiYXNlV2F0Y2hPcHRpb25zLnNjaGVkdWxlciA9IChqb2IpID0+IHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZsdXNoICE9PSBcInN5bmNcIikge1xuICAgIGlzUHJlID0gdHJ1ZTtcbiAgICBiYXNlV2F0Y2hPcHRpb25zLnNjaGVkdWxlciA9IChqb2IsIGlzRmlyc3RSdW4pID0+IHtcbiAgICAgIGlmIChpc0ZpcnN0UnVuKSB7XG4gICAgICAgIGpvYigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVKb2Ioam9iKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGJhc2VXYXRjaE9wdGlvbnMuYXVnbWVudEpvYiA9IChqb2IpID0+IHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGpvYi5mbGFncyB8PSA0O1xuICAgIH1cbiAgICBpZiAoaXNQcmUpIHtcbiAgICAgIGpvYi5mbGFncyB8PSAyO1xuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGpvYi5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICAgICAgam9iLmkgPSBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHdhdGNoSGFuZGxlID0gd2F0Y2gkMShzb3VyY2UsIGNiLCBiYXNlV2F0Y2hPcHRpb25zKTtcbiAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgIGlmIChzc3JDbGVhbnVwKSB7XG4gICAgICBzc3JDbGVhbnVwLnB1c2god2F0Y2hIYW5kbGUpO1xuICAgIH0gZWxzZSBpZiAocnVuc0ltbWVkaWF0ZWx5KSB7XG4gICAgICB3YXRjaEhhbmRsZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gd2F0Y2hIYW5kbGU7XG59XG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XG4gIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSkgPyBzb3VyY2UuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gIGxldCBjYjtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgY2IgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XG4gICAgb3B0aW9ucyA9IHZhbHVlO1xuICB9XG4gIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xuICBjb25zdCByZXMgPSBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucyk7XG4gIHJlc2V0KCk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBjdXIgPSBjdHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcbiAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1vZGVsKHByb3BzLCBuYW1lLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuJDEoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBjb25zdCBjYW1lbGl6ZWROYW1lID0gY2FtZWxpemUobmFtZSk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpLnByb3BzT3B0aW9uc1swXVtjYW1lbGl6ZWROYW1lXSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aCBwcm9wIFwiJHtuYW1lfVwiIHdoaWNoIGlzIG5vdCBkZWNsYXJlZC5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgY29uc3QgaHlwaGVuYXRlZE5hbWUgPSBoeXBoZW5hdGUobmFtZSk7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBjYW1lbGl6ZWROYW1lKTtcbiAgY29uc3QgcmVzID0gY3VzdG9tUmVmKCh0cmFjaywgdHJpZ2dlcikgPT4ge1xuICAgIGxldCBsb2NhbFZhbHVlO1xuICAgIGxldCBwcmV2U2V0VmFsdWUgPSBFTVBUWV9PQko7XG4gICAgbGV0IHByZXZFbWl0dGVkVmFsdWU7XG4gICAgd2F0Y2hTeW5jRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW2NhbWVsaXplZE5hbWVdO1xuICAgICAgaWYgKGhhc0NoYW5nZWQobG9jYWxWYWx1ZSwgcHJvcFZhbHVlKSkge1xuICAgICAgICBsb2NhbFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgdHJhY2soKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0ID8gb3B0aW9ucy5nZXQobG9jYWxWYWx1ZSkgOiBsb2NhbFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbWl0dGVkVmFsdWUgPSBvcHRpb25zLnNldCA/IG9wdGlvbnMuc2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBpZiAoIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBsb2NhbFZhbHVlKSAmJiAhKHByZXZTZXRWYWx1ZSAhPT0gRU1QVFlfT0JKICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd1Byb3BzID0gaS52bm9kZS5wcm9wcztcbiAgICAgICAgaWYgKCEocmF3UHJvcHMgJiYgLy8gY2hlY2sgaWYgcGFyZW50IGhhcyBwYXNzZWQgdi1tb2RlbFxuICAgICAgICAobmFtZSBpbiByYXdQcm9wcyB8fCBjYW1lbGl6ZWROYW1lIGluIHJhd1Byb3BzIHx8IGh5cGhlbmF0ZWROYW1lIGluIHJhd1Byb3BzKSAmJiAoYG9uVXBkYXRlOiR7bmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2NhbWVsaXplZE5hbWV9YCBpbiByYXdQcm9wcyB8fCBgb25VcGRhdGU6JHtoeXBoZW5hdGVkTmFtZX1gIGluIHJhd1Byb3BzKSkpIHtcbiAgICAgICAgICBsb2NhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICAgIGkuZW1pdChgdXBkYXRlOiR7bmFtZX1gLCBlbWl0dGVkVmFsdWUpO1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgZW1pdHRlZFZhbHVlKSAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpICYmICFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgcHJldkVtaXR0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlNldFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByZXZFbWl0dGVkVmFsdWUgPSBlbWl0dGVkVmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJlc1tTeW1ib2wuaXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGxldCBpMiA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGlmIChpMiA8IDIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaTIrKyA/IG1vZGlmaWVycyB8fCBFTVBUWV9PQkogOiByZXMsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGdldE1vZGVsTW9kaWZpZXJzID0gKHByb3BzLCBtb2RlbE5hbWUpID0+IHtcbiAgcmV0dXJuIG1vZGVsTmFtZSA9PT0gXCJtb2RlbFZhbHVlXCIgfHwgbW9kZWxOYW1lID09PSBcIm1vZGVsLXZhbHVlXCIgPyBwcm9wcy5tb2RlbE1vZGlmaWVycyA6IHByb3BzW2Ake21vZGVsTmFtZX1Nb2RpZmllcnNgXSB8fCBwcm9wc1tgJHtjYW1lbGl6ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2h5cGhlbmF0ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdO1xufTtcblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcbiAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkKSByZXR1cm47XG4gIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXRzT3B0aW9ucyxcbiAgICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgICB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJiB0cnVlKSB7XG4gICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkgaW4gcHJvcHNPcHRpb25zKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpfVwiIHByb3AuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGFyZ3MgPSByYXdBcmdzO1xuICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKFwidXBkYXRlOlwiKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gaXNNb2RlbExpc3RlbmVyICYmIGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBldmVudC5zbGljZSg3KSk7XG4gIGlmIChtb2RpZmllcnMpIHtcbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCgoYSkgPT4gaXNTdHJpbmcoYSkgPyBhLnRyaW0oKSA6IGEpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGxvb3NlVG9OdW1iZXIpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgJHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnR5cGVcbiAgICAgICAgKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2Ugdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoXG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgKX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgaGFuZGxlck5hbWU7XG4gIGxldCBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpXSB8fCAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gIHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSldO1xuICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XG4gICAgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpXTtcbiAgfVxuICBpZiAoaGFuZGxlcikge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xuICBpZiAob25jZUhhbmRsZXIpIHtcbiAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcbiAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIG9uY2VIYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xuICBsZXQgbm9ybWFsaXplZCA9IHt9O1xuICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgIGNvbnN0IGV4dGVuZEVtaXRzID0gKHJhdzIpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdzIsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XG4gICAgICAgIGhhc0V4dGVuZHMgPSB0cnVlO1xuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICByYXcuZm9yRWFjaCgoa2V5KSA9PiBub3JtYWxpemVkW2tleV0gPSBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcbiAgfVxuICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcbiAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgXCJcIik7XG4gIHJldHVybiBoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8IGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHwgaGFzT3duKG9wdGlvbnMsIGtleSk7XG59XG5cbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcbiAgYWNjZXNzZWRBdHRycyA9IHRydWU7XG59XG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgdm5vZGUsXG4gICAgcHJveHksXG4gICAgd2l0aFByb3h5LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sXG4gICAgc2xvdHMsXG4gICAgYXR0cnMsXG4gICAgZW1pdCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyQ2FjaGUsXG4gICAgcHJvcHMsXG4gICAgZGF0YSxcbiAgICBzZXR1cFN0YXRlLFxuICAgIGN0eCxcbiAgICBpbmhlcml0QXR0cnNcbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQpIHtcbiAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XG4gICAgICBjb25zdCB0aGlzUHJveHkgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwID8gbmV3IFByb3h5KHByb3h5VG9Vc2UsIHtcbiAgICAgICAgZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBQcm9wZXJ0eSAnJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKX0nIHdhcyBhY2Nlc3NlZCB2aWEgJ3RoaXMnLiBBdm9pZCB1c2luZyAndGhpcycgaW4gdGVtcGxhdGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICB9KSA6IHByb3h5VG9Vc2U7XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyLmNhbGwoXG4gICAgICAgICAgdGhpc1Byb3h5LFxuICAgICAgICAgIHByb3h5VG9Vc2UsXG4gICAgICAgICAgcmVuZGVyQ2FjaGUsXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICBzZXR1cFN0YXRlLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgY3R4XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlcjIgPSBDb21wb25lbnQ7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcbiAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIyLmxlbmd0aCA+IDEgPyByZW5kZXIyKFxuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocHJvcHMpIDogcHJvcHMsXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHtcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShhdHRycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICBlbWl0XG4gICAgICAgICAgfSA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH1cbiAgICAgICAgKSA6IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzID8gYXR0cnMgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEpO1xuICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9XG4gIGxldCByb290ID0gcmVzdWx0O1xuICBsZXQgc2V0Um9vdCA9IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiYgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcbiAgfVxuICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNikpIHtcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xuICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMsXG4gICAgICAgICAgICBwcm9wc09wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcbiAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xuICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0cmFBdHRycy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzICgke2V4dHJhQXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IG9yIHRlbGVwb3J0IHJvb3Qgbm9kZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoJHtldmVudEF0dHJzLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgUnVudGltZSBkaXJlY3RpdmUgdXNlZCBvbiBjb21wb25lbnQgd2l0aCBub24tZWxlbWVudCByb290IG5vZGUuIFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIG51bGwsIGZhbHNlLCB0cnVlKTtcbiAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcbiAgfVxuICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBDb21wb25lbnQgaW5zaWRlIDxUcmFuc2l0aW9uPiByZW5kZXJzIG5vbi1lbGVtZW50IHJvb3Qgbm9kZSB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBzZXRUcmFuc2l0aW9uSG9va3Mocm9vdCwgdm5vZGUudHJhbnNpdGlvbik7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0Um9vdCkge1xuICAgIHNldFJvb3Qocm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gcm9vdDtcbiAgfVxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuLCBmYWxzZSk7XG4gIGlmICghY2hpbGRSb290KSB7XG4gICAgcmV0dXJuIFt2bm9kZSwgdm9pZCAwXTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgPiAwICYmIGNoaWxkUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgcmV0dXJuIGdldENoaWxkUm9vdChjaGlsZFJvb3QpO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xuICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XG4gIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcbiAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICAgIH0gZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xuICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xufTtcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4sIHJlY3Vyc2UgPSB0cnVlKSB7XG4gIGxldCBzaW5nbGVSb290O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50IHx8IGNoaWxkLmNoaWxkcmVuID09PSBcInYtaWZcIikge1xuICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVjdXJzZSAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyA+IDAgJiYgc2luZ2xlUm9vdC5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyU2luZ2xlUm9vdChzaW5nbGVSb290LmNoaWxkcmVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2luZ2xlUm9vdDtcbn1cbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xuICBsZXQgcmVzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIiB8fCBrZXkgPT09IFwic3R5bGVcIiB8fCBpc09uKGtleSkpIHtcbiAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XG4gICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xuICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgKDYgfCAxKSB8fCB2bm9kZS50eXBlID09PSBDb21tZW50O1xufTtcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XG4gIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XG4gIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XG4gIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiYgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgfVxuICAgIGlmICghbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHNPcHRpb25zKSB7XG4gIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcbiAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XG4gICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdXBkYXRlSE9DSG9zdEVsKHsgdm5vZGUsIHBhcmVudCB9LCBlbCkge1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmVudC5zdWJUcmVlO1xuICAgIGlmIChyb290LnN1c3BlbnNlICYmIHJvb3Quc3VzcGVuc2UuYWN0aXZlQnJhbmNoID09PSB2bm9kZSkge1xuICAgICAgcm9vdC5lbCA9IHZub2RlLmVsO1xuICAgIH1cbiAgICBpZiAocm9vdCA9PT0gdm5vZGUpIHtcbiAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xubGV0IHN1c3BlbnNlSWQgPSAwO1xuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xuICBuYW1lOiBcIlN1c3BlbnNlXCIsXG4gIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcbiAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcbiAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXG4gIC8vIGludGVybmFscy5cbiAgX19pc1N1c3BlbnNlOiB0cnVlLFxuICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50U3VzcGVuc2UoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5kZXBzID4gMCAmJiAhbjEuc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gICAgICAgIG4yLnN1c3BlbnNlLnZub2RlID0gbjI7XG4gICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhdGNoU3VzcGVuc2UoXG4gICAgICAgIG4xLFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxufTtcbmNvbnN0IFN1c3BlbnNlID0gU3VzcGVuc2VJbXBsIDtcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XG4gIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XG4gICAgZXZlbnRMaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkoXG4gICAgdm5vZGUsXG4gICAgcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgYW5jaG9yLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHMsXG4gICAgb3B0aW1pemVkLFxuICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICk7XG4gIHBhdGNoKFxuICAgIG51bGwsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgbnVsbCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkc1xuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25QZW5kaW5nXCIpO1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvbkZhbGxiYWNrXCIpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLnNzRmFsbGJhY2ssXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIHNsb3RTY29wZUlkc1xuICAgICk7XG4gICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgbjIuZWwgPSBuMS5lbDtcbiAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xuICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XG4gIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcbiAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBzdXNwZW5zZUlkKys7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5kZXBzID0gMDtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyRXZlbnQobjIsIFwib25QZW5kaW5nXCIpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICAgIGlmIChuZXdCcmFuY2guc2hhcGVGbGFnICYgNTEyKSB7XG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IG5ld0JyYW5jaC5jb21wb25lbnQuc3VzcGVuc2VJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcbiAgICAgIH1cbiAgICAgIHBhdGNoKFxuICAgICAgICBudWxsLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSAmJiAhaGFzV2FybmVkKSB7XG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/IFwiaW5mb1wiIDogXCJsb2dcIl0oXG4gICAgICBgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHA6IHBhdGNoLFxuICAgIG06IG1vdmUsXG4gICAgdW06IHVubW91bnQsXG4gICAgbjogbmV4dCxcbiAgICBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgbGV0IHBhcmVudFN1c3BlbnNlSWQ7XG4gIGNvbnN0IGlzU3VzcGVuc2libGUgPSBpc1ZOb2RlU3VzcGVuc2libGUodm5vZGUpO1xuICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZUlkID0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkO1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcysrO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lb3V0ID0gdm5vZGUucHJvcHMgPyB0b051bWJlcih2bm9kZS5wcm9wcy50aW1lb3V0KSA6IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIodGltZW91dCwgYFN1c3BlbnNlIHRpbWVvdXRgKTtcbiAgfVxuICBjb25zdCBpbml0aWFsQW5jaG9yID0gYW5jaG9yO1xuICBjb25zdCBzdXNwZW5zZSA9IHtcbiAgICB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBuYW1lc3BhY2UsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBkZXBzOiAwLFxuICAgIHBlbmRpbmdJZDogc3VzcGVuc2VJZCsrLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiID8gdGltZW91dCA6IC0xLFxuICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcbiAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxuICAgIGlzSW5GYWxsYmFjazogIWlzSHlkcmF0aW5nLFxuICAgIGlzSHlkcmF0aW5nLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBlZmZlY3RzOiBbXSxcbiAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlLCBzeW5jID0gZmFsc2UpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGlmICghcmVzdW1lICYmICFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZub2RlOiB2bm9kZTIsXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgcGVuZGluZ0lkLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyMlxuICAgICAgfSA9IHN1c3BlbnNlO1xuICAgICAgbGV0IGRlbGF5RW50ZXIgPSBmYWxzZTtcbiAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghcmVzdW1lKSB7XG4gICAgICAgIGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgbW92ZShcbiAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICAgICAgYW5jaG9yID09PSBpbml0aWFsQW5jaG9yID8gbmV4dChhY3RpdmVCcmFuY2gpIDogYW5jaG9yLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICBpZiAocGFyZW50Tm9kZShhY3RpdmVCcmFuY2guZWwpID09PSBjb250YWluZXIyKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQyLCBzdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XG4gICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XG4gICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNVbnJlc29sdmVkQW5jZXN0b3IgJiYgIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcbiAgICAgIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmIHBhcmVudFN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCAmJiAhc3luYykge1xuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvblJlc29sdmVcIik7XG4gICAgfSxcbiAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XG4gICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MiwgY29udGFpbmVyOiBjb250YWluZXIyLCBuYW1lc3BhY2U6IG5hbWVzcGFjZTIgfSA9IHN1c3BlbnNlO1xuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvbkZhbGxiYWNrXCIpO1xuICAgICAgY29uc3QgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmFsbGJhY2tWTm9kZSxcbiAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgbmFtZXNwYWNlMixcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbiAmJiBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIHVubW91bnQoXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICB0cnVlXG4gICAgICAgIC8vIHNob3VsZFJlbW92ZVxuICAgICAgKTtcbiAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICBtb3VudEZhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3ZlKGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpIHtcbiAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSk7XG4gICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXIyO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0LCBvcHRpbWl6ZWQyKSB7XG4gICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xuICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcbiAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xuICAgICAgfVxuICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xuICAgICAgaW5zdGFuY2UuYXN5bmNEZXAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwKTtcbiAgICAgIH0pLnRoZW4oKGFzeW5jU2V0dXBSZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8IHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB2bm9kZTogdm5vZGUyIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xuICAgICAgICBpZiAoaHlkcmF0ZWRFbCkge1xuICAgICAgICAgIHZub2RlMi5lbCA9IGh5ZHJhdGVkRWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xuICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICB2bm9kZTIsXG4gICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxuICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXG4gICAgICAgICAgLy8gY29uc2lkZXIgdGhlIGNvbW1lbnQgcGxhY2Vob2xkZXIgY2FzZS5cbiAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZDJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlMi5lbCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZTIsIGRvUmVtb3ZlKSB7XG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3VzcGVuc2U7XG59XG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbm9kZS5wYXJlbnROb2RlLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgIG51bGwsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgdHJ1ZVxuICApO1xuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcbiAgICBub2RlLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWRcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xuICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoXG4gICAgaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW5cbiAgKTtcbiAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgbGV0IGJsb2NrO1xuICBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgb3BlbkJsb2NrKCk7XG4gICAgfVxuICAgIHMgPSBzKCk7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICBjbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5KHMpKSB7XG4gICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFzaW5nbGVDaGlsZCAmJiBzLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkICE9PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKS5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuJDEoYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcbiAgICB9XG4gICAgcyA9IHNpbmdsZUNoaWxkO1xuICB9XG4gIHMgPSBub3JtYWxpemVWTm9kZShzKTtcbiAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xuICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKChjKSA9PiBjICE9PSBzKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xuICBpZiAoc3VzcGVuc2UgJiYgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XG4gIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcbiAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgbGV0IGVsID0gYnJhbmNoLmVsO1xuICB3aGlsZSAoIWVsICYmIGJyYW5jaC5jb21wb25lbnQpIHtcbiAgICBicmFuY2ggPSBicmFuY2guY29tcG9uZW50LnN1YlRyZWU7XG4gICAgZWwgPSBicmFuY2guZWw7XG4gIH1cbiAgdm5vZGUuZWwgPSBlbDtcbiAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcbiAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSkge1xuICBjb25zdCBzdXNwZW5zaWJsZSA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlO1xuICByZXR1cm4gc3VzcGVuc2libGUgIT0gbnVsbCAmJiBzdXNwZW5zaWJsZSAhPT0gZmFsc2U7XG59XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sLmZvcihcInYtZmd0XCIpO1xuY29uc3QgVGV4dCA9IFN5bWJvbC5mb3IoXCJ2LXR4dFwiKTtcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2wuZm9yKFwidi1jbXRcIik7XG5jb25zdCBTdGF0aWMgPSBTeW1ib2wuZm9yKFwidi1zdGNcIik7XG5jb25zdCBibG9ja1N0YWNrID0gW107XG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xuICBibG9ja1N0YWNrLnB1c2goY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKTtcbn1cbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XG4gIGJsb2NrU3RhY2sucG9wKCk7XG4gIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxubGV0IGlzQmxvY2tUcmVlRW5hYmxlZCA9IDE7XG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlLCBpblZPbmNlID0gZmFsc2UpIHtcbiAgaXNCbG9ja1RyZWVFbmFibGVkICs9IHZhbHVlO1xuICBpZiAodmFsdWUgPCAwICYmIGN1cnJlbnRCbG9jayAmJiBpblZPbmNlKSB7XG4gICAgY3VycmVudEJsb2NrLmhhc09uY2UgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXR1cEJsb2NrKHZub2RlKSB7XG4gIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgPyBjdXJyZW50QmxvY2sgfHwgRU1QVFlfQVJSIDogbnVsbDtcbiAgY2xvc2VCbG9jaygpO1xuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudEJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVCYXNlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHRydWVcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICB0cnVlXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5fX3ZfaXNWTm9kZSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuMi5zaGFwZUZsYWcgJiA2ICYmIG4xLmNvbXBvbmVudCkge1xuICAgIGNvbnN0IGRpcnR5SW5zdGFuY2VzID0gaG1yRGlydHlDb21wb25lbnRzLmdldChuMi50eXBlKTtcbiAgICBpZiAoZGlydHlJbnN0YW5jZXMgJiYgZGlydHlJbnN0YW5jZXMuaGFzKG4xLmNvbXBvbmVudCkpIHtcbiAgICAgIG4xLnNoYXBlRmxhZyAmPSB+MjU2O1xuICAgICAgbjIuc2hhcGVGbGFnICY9IH41MTI7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xufVxubGV0IHZub2RlQXJnc1RyYW5zZm9ybWVyO1xuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XG4gIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG59XG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIF9jcmVhdGVWTm9kZShcbiAgICAuLi52bm9kZUFyZ3NUcmFuc2Zvcm1lciA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkgOiBhcmdzXG4gICk7XG59O1xuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7XG4gIHJlZixcbiAgcmVmX2tleSxcbiAgcmVmX2ZvclxufSkgPT4ge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlZiA9IFwiXCIgKyByZWY7XG4gIH1cbiAgcmV0dXJuIHJlZiAhPSBudWxsID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKSA/IHsgaTogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCByOiByZWYsIGs6IHJlZl9rZXksIGY6ICEhcmVmX2ZvciB9IDogcmVmIDogbnVsbDtcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEsIGlzQmxvY2tOb2RlID0gZmFsc2UsIG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uID0gZmFsc2UpIHtcbiAgY29uc3Qgdm5vZGUgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXG4gICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxuICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogbnVsbCxcbiAgICBjaGlsZHJlbixcbiAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgc3VzcGVuc2U6IG51bGwsXG4gICAgc3NDb250ZW50OiBudWxsLFxuICAgIHNzRmFsbGJhY2s6IG51bGwsXG4gICAgZGlyczogbnVsbCxcbiAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgIGVsOiBudWxsLFxuICAgIGFuY2hvcjogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGFyZ2V0U3RhcnQ6IG51bGwsXG4gICAgdGFyZ2V0QW5jaG9yOiBudWxsLFxuICAgIHN0YXRpY0NvdW50OiAwLFxuICAgIHNoYXBlRmxhZyxcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcbiAgICBhcHBDb250ZXh0OiBudWxsLFxuICAgIGN0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlXG4gIH07XG4gIGlmIChuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbikge1xuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIHZub2RlLnNoYXBlRmxhZyB8PSBpc1N0cmluZyhjaGlsZHJlbikgPyA4IDogMTY7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcbiAgICB3YXJuJDEoYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcbiAgIWlzQmxvY2tOb2RlICYmIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xuICBjdXJyZW50QmxvY2sgJiYgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cbiAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXG4gIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xuICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXG4gICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYpICYmIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxuICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxuICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gOiBfY3JlYXRlVk5vZGU7XG5mdW5jdGlvbiBfY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIGlzQmxvY2tOb2RlID0gZmFsc2UpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdHlwZSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIHZub2RlIHR5cGUgd2hlbiBjcmVhdGluZyB2bm9kZTogJHt0eXBlfS5gKTtcbiAgICB9XG4gICAgdHlwZSA9IENvbW1lbnQ7XG4gIH1cbiAgaWYgKGlzVk5vZGUodHlwZSkpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgdHJ1ZVxuICAgICAgLyogbWVyZ2VSZWY6IHRydWUgKi9cbiAgICApO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmICFpc0Jsb2NrTm9kZSAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgIGlmIChjbG9uZWQuc2hhcGVGbGFnICYgNikge1xuICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2xvbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xvbmVkLnBhdGNoRmxhZyA9IC0yO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcbiAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XG4gIH1cbiAgaWYgKHByb3BzKSB7XG4gICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xuICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpID8gMSA6IGlzU3VzcGVuc2UodHlwZSkgPyAxMjggOiBpc1RlbGVwb3J0KHR5cGUpID8gNjQgOiBpc09iamVjdCh0eXBlKSA/IDQgOiBpc0Z1bmN0aW9uKHR5cGUpID8gMiA6IDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNoYXBlRmxhZyAmIDQgJiYgaXNQcm94eSh0eXBlKSkge1xuICAgIHR5cGUgPSB0b1Jhdyh0eXBlKTtcbiAgICB3YXJuJDEoXG4gICAgICBgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgYSByZWFjdGl2ZSBvYmplY3QuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLFxuICAgICAgYFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsXG4gICAgICB0eXBlXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBzaGFwZUZsYWcsXG4gICAgaXNCbG9ja05vZGUsXG4gICAgdHJ1ZVxuICApO1xufVxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xuICByZXR1cm4gaXNQcm94eShwcm9wcykgfHwgaXNJbnRlcm5hbE9iamVjdChwcm9wcykgPyBleHRlbmQoe30sIHByb3BzKSA6IHByb3BzO1xufVxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSwgY2xvbmVUcmFuc2l0aW9uID0gZmFsc2UpIHtcbiAgY29uc3QgeyBwcm9wcywgcmVmLCBwYXRjaEZsYWcsIGNoaWxkcmVuLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcbiAgY29uc3QgY2xvbmVkID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGU6IHZub2RlLnR5cGUsXG4gICAgcHJvcHM6IG1lcmdlZFByb3BzLFxuICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcbiAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWYgPyAoXG4gICAgICAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XG4gICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxuICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcbiAgICAgIG1lcmdlUmVmICYmIHJlZiA/IGlzQXJyYXkocmVmKSA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKSA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV0gOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcbiAgICApIDogcmVmLFxuICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXG4gICAgY2hpbGRyZW46ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcGF0Y2hGbGFnID09PSAtMSAmJiBpc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSkgOiBjaGlsZHJlbixcbiAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcbiAgICB0YXJnZXRTdGFydDogdm5vZGUudGFyZ2V0U3RhcnQsXG4gICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXG4gICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxuICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxuICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXG4gICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cbiAgICAvLyBub3RlOiBwcmVzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXG4gICAgLy8gZmFzdCBwYXRocyBvbmx5LlxuICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudCA/IHBhdGNoRmxhZyA9PT0gLTEgPyAxNiA6IHBhdGNoRmxhZyB8IDE2IDogcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wczogdm5vZGUuZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxuICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXG4gICAgZGlyczogdm5vZGUuZGlycyxcbiAgICB0cmFuc2l0aW9uLFxuICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxuICAgIC8vIHRoZXkgKnNob3VsZCogYmUgY29waWVkIGZvciBrZXB0LWFsaXZlIHZub2Rlcy4gU28gd2UganVzdCBhbHdheXMgY29weVxuICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcbiAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxuICAgIGNvbXBvbmVudDogdm5vZGUuY29tcG9uZW50LFxuICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcbiAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXG4gICAgc3NGYWxsYmFjazogdm5vZGUuc3NGYWxsYmFjayAmJiBjbG9uZVZOb2RlKHZub2RlLnNzRmFsbGJhY2spLFxuICAgIGVsOiB2bm9kZS5lbCxcbiAgICBhbmNob3I6IHZub2RlLmFuY2hvcixcbiAgICBjdHg6IHZub2RlLmN0eCxcbiAgICBjZTogdm5vZGUuY2VcbiAgfTtcbiAgaWYgKHRyYW5zaXRpb24gJiYgY2xvbmVUcmFuc2l0aW9uKSB7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgY2xvbmVkLFxuICAgICAgdHJhbnNpdGlvbi5jbG9uZShjbG9uZWQpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcbiAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGlmIChpc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gXCIgXCIsIGZsYWcgPSAwKSB7XG4gIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShTdGF0aWMsIG51bGwsIGNvbnRlbnQpO1xuICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gXCJcIiwgYXNCbG9jayA9IGZhbHNlKSB7XG4gIHJldHVybiBhc0Jsb2NrID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50LCBudWxsLCB0ZXh0KSkgOiBjcmVhdGVWTm9kZShDb21tZW50LCBudWxsLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XG4gIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcbiAgICAgIGNoaWxkLnNsaWNlKClcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lSWZNb3VudGVkKGNoaWxkKSB7XG4gIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCAmJiBjaGlsZC5wYXRjaEZsYWcgIT09IC0xIHx8IGNoaWxkLm1lbW8gPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XG4gIGxldCB0eXBlID0gMDtcbiAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIHR5cGUgPSAxNjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2NCkpIHtcbiAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xuICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IGZhbHNlKTtcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XG4gICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDMyO1xuICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xuICAgICAgaWYgKCFzbG90RmxhZyAmJiAhaXNJbnRlcm5hbE9iamVjdChjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2Uuc2xvdHMuXyA9PT0gMSkge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLl8gPSAyO1xuICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcbiAgICB0eXBlID0gMzI7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZSA9IDE2O1xuICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSA4O1xuICAgIH1cbiAgfVxuICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xuICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcbiAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc09uKGtleSkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcbiAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XG4gICAgICAgIGlmIChpbmNvbWluZyAmJiBleGlzdGluZyAhPT0gaW5jb21pbmcgJiYgIShpc0FycmF5KGV4aXN0aW5nKSAmJiBleGlzdGluZy5pbmNsdWRlcyhpbmNvbWluZykpKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpIDogaW5jb21pbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSBcIlwiKSB7XG4gICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaW52b2tlVk5vZGVIb29rKGhvb2ssIGluc3RhbmNlLCB2bm9kZSwgcHJldlZOb2RlID0gbnVsbCkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNywgW1xuICAgIHZub2RlLFxuICAgIHByZXZWTm9kZVxuICBdKTtcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xubGV0IHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xuICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcbiAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgdWlkOiB1aWQrKyxcbiAgICB2bm9kZSxcbiAgICB0eXBlLFxuICAgIHBhcmVudCxcbiAgICBhcHBDb250ZXh0LFxuICAgIHJvb3Q6IG51bGwsXG4gICAgLy8gdG8gYmUgaW1tZWRpYXRlbHkgc2V0XG4gICAgbmV4dDogbnVsbCxcbiAgICBzdWJUcmVlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBlZmZlY3Q6IG51bGwsXG4gICAgdXBkYXRlOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHN5bmNocm9ub3VzbHkgcmlnaHQgYWZ0ZXIgY3JlYXRpb25cbiAgICBqb2I6IG51bGwsXG4gICAgc2NvcGU6IG5ldyBFZmZlY3RTY29wZShcbiAgICAgIHRydWVcbiAgICAgIC8qIGRldGFjaGVkICovXG4gICAgKSxcbiAgICByZW5kZXI6IG51bGwsXG4gICAgcHJveHk6IG51bGwsXG4gICAgZXhwb3NlZDogbnVsbCxcbiAgICBleHBvc2VQcm94eTogbnVsbCxcbiAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXG4gICAgaWRzOiBwYXJlbnQgPyBwYXJlbnQuaWRzIDogW1wiXCIsIDAsIDBdLFxuICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxuICAgIHJlbmRlckNhY2hlOiBbXSxcbiAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICBjb21wb25lbnRzOiBudWxsLFxuICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICBwcm9wc09wdGlvbnM6IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICAvLyBlbWl0XG4gICAgZW1pdDogbnVsbCxcbiAgICAvLyB0byBiZSBzZXQgaW1tZWRpYXRlbHlcbiAgICBlbWl0dGVkOiBudWxsLFxuICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcbiAgICBwcm9wc0RlZmF1bHRzOiBFTVBUWV9PQkosXG4gICAgLy8gaW5oZXJpdEF0dHJzXG4gICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcbiAgICAvLyBzdGF0ZVxuICAgIGN0eDogRU1QVFlfT0JKLFxuICAgIGRhdGE6IEVNUFRZX09CSixcbiAgICBwcm9wczogRU1QVFlfT0JKLFxuICAgIGF0dHJzOiBFTVBUWV9PQkosXG4gICAgc2xvdHM6IEVNUFRZX09CSixcbiAgICByZWZzOiBFTVBUWV9PQkosXG4gICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxuICAgIHNldHVwQ29udGV4dDogbnVsbCxcbiAgICAvLyBzdXNwZW5zZSByZWxhdGVkXG4gICAgc3VzcGVuc2UsXG4gICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgIGFzeW5jRGVwOiBudWxsLFxuICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXG4gICAgYmM6IG51bGwsXG4gICAgYzogbnVsbCxcbiAgICBibTogbnVsbCxcbiAgICBtOiBudWxsLFxuICAgIGJ1OiBudWxsLFxuICAgIHU6IG51bGwsXG4gICAgdW06IG51bGwsXG4gICAgYnVtOiBudWxsLFxuICAgIGRhOiBudWxsLFxuICAgIGE6IG51bGwsXG4gICAgcnRnOiBudWxsLFxuICAgIHJ0YzogbnVsbCxcbiAgICBlYzogbnVsbCxcbiAgICBzcDogbnVsbFxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgfVxuICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcbiAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XG4gIGlmICh2bm9kZS5jZSkge1xuICAgIHZub2RlLmNlKGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG5sZXQgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2U7XG5sZXQgc2V0SW5TU1JTZXR1cFN0YXRlO1xue1xuICBjb25zdCBnID0gZ2V0R2xvYmFsVGhpcygpO1xuICBjb25zdCByZWdpc3Rlckdsb2JhbFNldHRlciA9IChrZXksIHNldHRlcikgPT4ge1xuICAgIGxldCBzZXR0ZXJzO1xuICAgIGlmICghKHNldHRlcnMgPSBnW2tleV0pKSBzZXR0ZXJzID0gZ1trZXldID0gW107XG4gICAgc2V0dGVycy5wdXNoKHNldHRlcik7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICBpZiAoc2V0dGVycy5sZW5ndGggPiAxKSBzZXR0ZXJzLmZvckVhY2goKHNldCkgPT4gc2V0KHYpKTtcbiAgICAgIGVsc2Ugc2V0dGVyc1swXSh2KTtcbiAgICB9O1xuICB9O1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZSA9IHJlZ2lzdGVyR2xvYmFsU2V0dGVyKFxuICAgIGBfX1ZVRV9JTlNUQU5DRV9TRVRURVJTX19gLFxuICAgICh2KSA9PiBjdXJyZW50SW5zdGFuY2UgPSB2XG4gICk7XG4gIHNldEluU1NSU2V0dXBTdGF0ZSA9IHJlZ2lzdGVyR2xvYmFsU2V0dGVyKFxuICAgIGBfX1ZVRV9TU1JfU0VUVEVSU19fYCxcbiAgICAodikgPT4gaXNJblNTUkNvbXBvbmVudFNldHVwID0gdlxuICApO1xufVxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IHByZXYgPSBjdXJyZW50SW5zdGFuY2U7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShwcmV2KTtcbiAgfTtcbn07XG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcbiAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XG59O1xuY29uc3QgaXNCdWlsdEluVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCJzbG90LGNvbXBvbmVudFwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCB7IGlzTmF0aXZlVGFnIH0pIHtcbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBpc05hdGl2ZVRhZyhuYW1lKSkge1xuICAgIHdhcm4kMShcbiAgICAgIFwiRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogXCIgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNDtcbn1cbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSkge1xuICBpc1NTUiAmJiBzZXRJblNTUlNldHVwU3RhdGUoaXNTU1IpO1xuICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XG4gIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcbiAgaW5pdFByb3BzKGluc3RhbmNlLCBwcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IpO1xuICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWwgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikgOiB2b2lkIDA7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShmYWxzZSk7XG4gIHJldHVybiBzZXR1cFJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGluc3RhbmNlLnByb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH1cbiAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xuICBpZiAoc2V0dXApIHtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID0gc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsO1xuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIHNldHVwLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAwLFxuICAgICAgW1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLFxuICAgICAgICBzZXR1cENvbnRleHRcbiAgICAgIF1cbiAgICApO1xuICAgIGNvbnN0IGlzQXN5bmNTZXR1cCA9IGlzUHJvbWlzZShzZXR1cFJlc3VsdCk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHJlc2V0KCk7XG4gICAgaWYgKChpc0FzeW5jU2V0dXAgfHwgaW5zdGFuY2Uuc3ApICYmICFpc0FzeW5jV3JhcHBlcihpbnN0YW5jZSkpIHtcbiAgICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmNTZXR1cCkge1xuICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xuICAgICAgaWYgKGlzU1NSKSB7XG4gICAgICAgIHJldHVybiBzZXR1cFJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGluc3RhbmNlLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCA9IHNldHVwUmVzdWx0O1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaW5zdGFuY2Uuc3VzcGVuc2UpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gQ29tcG9uZW50Lm5hbWUpICE9IG51bGwgPyBfYSA6IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYENvbXBvbmVudCA8JHtuYW1lfT46IHNldHVwIGZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSwgYnV0IG5vIDxTdXNwZW5zZT4gYm91bmRhcnkgd2FzIGZvdW5kIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHRyZWUuIEEgY29tcG9uZW50IHdpdGggYXN5bmMgc2V0dXAoKSBtdXN0IGJlIG5lc3RlZCBpbiBhIDxTdXNwZW5zZT4gaW4gb3JkZXIgdG8gYmUgcmVuZGVyZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwUmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICB3YXJuJDEoXG4gICAgICBgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gXG4gICAgKTtcbiAgfVxuICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xufVxubGV0IGNvbXBpbGU7XG5sZXQgaW5zdGFsbFdpdGhQcm94eTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XG4gIGNvbXBpbGUgPSBfY29tcGlsZTtcbiAgaW5zdGFsbFdpdGhQcm94eSA9IChpKSA9PiB7XG4gICAgaWYgKGkucmVuZGVyLl9yYykge1xuICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xuICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBDb21wb25lbnQudGVtcGxhdGUgfHwgX19WVUVfT1BUSU9OU19BUElfXyAmJiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XG4gICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcbiAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoXG4gICAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgICAgICAgICAgIGRlbGltaXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgIGNvbXBvbmVudENvbXBpbGVyT3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyID0gQ29tcG9uZW50LnJlbmRlciB8fCBOT09QO1xuICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XG4gICAgICBpbnN0YWxsV2l0aFByb3h5KGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgdHJ1ZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgdHJ5IHtcbiAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcbiAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQxKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb246IGAsIENvbXBvbmVudCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBhdHRyc1Byb3h5SGFuZGxlcnMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwgXCJcIik7XG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICB9LFxuICBzZXQoKSB7XG4gICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0gOiB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwgXCJcIik7XG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSkge1xuICByZXR1cm4gbmV3IFByb3h5KGluc3RhbmNlLnNsb3RzLCB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCBleHBvc2UgPSAoZXhwb3NlZCkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICB3YXJuJDEoYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9zZWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZXhwb3NlZFR5cGUgPSB0eXBlb2YgZXhwb3NlZDtcbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWYoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gXCJyZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9zZWRUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7ZXhwb3NlZFR5cGV9LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGxldCBhdHRyc1Byb3h5O1xuICAgIGxldCBzbG90c1Byb3h5O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzUHJveHkgfHwgKGF0dHJzUHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycykpO1xuICAgICAgfSxcbiAgICAgIGdldCBzbG90cygpIHtcbiAgICAgICAgcmV0dXJuIHNsb3RzUHJveHkgfHwgKHNsb3RzUHJveHkgPSBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSk7XG4gICAgICB9LFxuICAgICAgZ2V0IGVtaXQoKSB7XG4gICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyczogbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRyc1Byb3h5SGFuZGxlcnMpLFxuICAgICAgc2xvdHM6IGluc3RhbmNlLnNsb3RzLFxuICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcbiAgICAgIGV4cG9zZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmV4cG9zZVByb3h5IHx8IChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcbiAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xuICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0IHx8IGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5zdGFuY2UucHJveHk7XG4gIH1cbn1cbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgXCJcIik7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIDogQ29tcG9uZW50Lm5hbWUgfHwgaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWU7XG59XG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XG4gIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xuICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xuICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfVxuICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XG4gICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBuYW1lID0gaW5mZXJGcm9tUmVnaXN0cnkoXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRzIHx8IGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHNcbiAgICApIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XG4gIH1cbiAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XG59XG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiBcIl9fdmNjT3B0c1wiIGluIHZhbHVlO1xufVxuXG5jb25zdCBjb21wdXRlZCA9IChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xuICBjb25zdCBjID0gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNJblNTUkNvbXBvbmVudFNldHVwKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKGkgJiYgaS5hcHBDb250ZXh0LmNvbmZpZy53YXJuUmVjdXJzaXZlQ29tcHV0ZWQpIHtcbiAgICAgIGMuX3dhcm5SZWN1cnNpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYztcbn07XG5cbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xuICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGwgPT09IDIpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsID4gMykge1xuICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIH0gZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xuICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiMzYmE3NzZcIiB9O1xuICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzE2NzdmZlwiIH07XG4gIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogXCJjb2xvcjojZjUyMjJkXCIgfTtcbiAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojZWIyZjk2XCIgfTtcbiAgY29uc3QgZm9ybWF0dGVyID0ge1xuICAgIF9fdnVlX2N1c3RvbV9mb3JtYXR0ZXI6IHRydWUsXG4gICAgaGVhZGVyKG9iaikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXCJkaXZcIiwgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZihvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIC8vIGF2b2lkIGRlYnVnZ2VyIGFjY2Vzc2luZyB2YWx1ZSBhZmZlY3RpbmcgYmVoYXZpb3JcbiAgICAgICAgICBmb3JtYXRWYWx1ZShcIl92YWx1ZVwiIGluIG9iaiA/IG9iai5fdmFsdWUgOiBvYmopLFxuICAgICAgICAgIGA+YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhY3RpdmVcIiA6IFwiUmVhY3RpdmVcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBpc1NoYWxsb3cob2JqKSA/IFwiU2hhbGxvd1JlYWRvbmx5XCIgOiBcIlJlYWRvbmx5XCJdLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgXCI+XCJcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgaGFzQm9keShvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XG4gICAgfSxcbiAgICBib2R5KG9iaikge1xuICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uZm9ybWF0SW5zdGFuY2Uob2JqLiQpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwicHJvcHNcIiwgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJzZXR1cFwiLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJkYXRhXCIsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsIFwiY29tcHV0ZWRcIik7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgaW5qZWN0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJpbmplY3RcIik7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKFwiaW5qZWN0ZWRcIiwgaW5qZWN0ZWQpKTtcbiAgICB9XG4gICAgYmxvY2tzLnB1c2goW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHt9LFxuICAgICAgW1xuICAgICAgICBcInNwYW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyBcIjtvcGFjaXR5OjAuNjZcIlxuICAgICAgICB9LFxuICAgICAgICBcIiQgKGludGVybmFsKTogXCJcbiAgICAgIF0sXG4gICAgICBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGluc3RhbmNlIH1dXG4gICAgXSk7XG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xuICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCB7fV07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdHlsZTogXCJsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbVwiIH0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJjb2xvcjojNDc2NTgyXCJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcInBhZGRpbmctbGVmdDoxLjI1ZW1cIlxuICAgICAgICB9LFxuICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIFtcInNwYW5cIiwga2V5d29yZFN0eWxlLCBrZXkgKyBcIjogXCJdLFxuICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxuICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgXTtcbiAgfVxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2LCBhc1JhdyA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIG51bWJlclN0eWxlLCB2XTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgIHJldHVybiBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1wic3BhblwiLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcbiAgICAgIGlmIChpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpKSB7XG4gICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XG4gICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XG4gICAgaWYgKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpIHx8IGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZSgobSkgPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcbiAgICBpZiAoaXNTaGFsbG93KHYpKSB7XG4gICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xuICAgIH1cbiAgICBpZiAodi5lZmZlY3QpIHtcbiAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xuICAgIH1cbiAgICByZXR1cm4gYFJlZmA7XG4gIH1cbiAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xuICBpZiAoY2FjaGVkICYmIGlzTWVtb1NhbWUoY2FjaGVkLCBtZW1vKSkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmV0ID0gcmVuZGVyKCk7XG4gIHJldC5tZW1vID0gbWVtby5zbGljZSgpO1xuICByZXQuY2FjaGVJbmRleCA9IGluZGV4O1xuICByZXR1cm4gY2FjaGVbaW5kZXhdID0gcmV0O1xufVxuZnVuY3Rpb24gaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pIHtcbiAgY29uc3QgcHJldiA9IGNhY2hlZC5tZW1vO1xuICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc0NoYW5nZWQocHJldltpXSwgbWVtb1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgdmVyc2lvbiA9IFwiMy41LjEzXCI7XG5jb25zdCB3YXJuID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHdhcm4kMSA6IE5PT1A7XG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0gRXJyb3JUeXBlU3RyaW5ncyQxIDtcbmNvbnN0IGRldnRvb2xzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0cnVlID8gZGV2dG9vbHMkMSA6IHZvaWQgMDtcbmNvbnN0IHNldERldnRvb2xzSG9vayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHJ1ZSA/IHNldERldnRvb2xzSG9vayQxIDogTk9PUDtcbmNvbnN0IF9zc3JVdGlscyA9IHtcbiAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UsXG4gIHNldHVwQ29tcG9uZW50LFxuICByZW5kZXJDb21wb25lbnRSb290LFxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsXG4gIGlzVk5vZGU6IGlzVk5vZGUsXG4gIG5vcm1hbGl6ZVZOb2RlLFxuICBnZXRDb21wb25lbnRQdWJsaWNJbnN0YW5jZSxcbiAgZW5zdXJlVmFsaWRWTm9kZSxcbiAgcHVzaFdhcm5pbmdDb250ZXh0LFxuICBwb3BXYXJuaW5nQ29udGV4dFxufTtcbmNvbnN0IHNzclV0aWxzID0gX3NzclV0aWxzIDtcbmNvbnN0IHJlc29sdmVGaWx0ZXIgPSBudWxsO1xuY29uc3QgY29tcGF0VXRpbHMgPSBudWxsO1xuY29uc3QgRGVwcmVjYXRpb25UeXBlcyA9IG51bGw7XG5cbmV4cG9ydCB7IEJhc2VUcmFuc2l0aW9uLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgQ29tbWVudCwgRGVwcmVjYXRpb25UeXBlcywgRXJyb3JDb2RlcywgRXJyb3JUeXBlU3RyaW5ncywgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGFzc2VydE51bWJlciwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVFbGVtZW50QmxvY2ssIGNyZWF0ZUJhc2VWTm9kZSBhcyBjcmVhdGVFbGVtZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVQcm9wc1Jlc3RQcm94eSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lTW9kZWwsIGRlZmluZU9wdGlvbnMsIGRlZmluZVByb3BzLCBkZWZpbmVTbG90cywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBndWFyZFJlYWN0aXZlUHJvcHMsIGgsIGhhbmRsZUVycm9yLCBoYXNJbmplY3Rpb25Db250ZXh0LCBoeWRyYXRlT25JZGxlLCBoeWRyYXRlT25JbnRlcmFjdGlvbiwgaHlkcmF0ZU9uTWVkaWFRdWVyeSwgaHlkcmF0ZU9uVmlzaWJsZSwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc01lbW9TYW1lLCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZURlZmF1bHRzLCBtZXJnZU1vZGVscywgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQXR0cnMsIHVzZUlkLCB1c2VNb2RlbCwgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRlbXBsYXRlUmVmLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QsIHdpdGhBc3luY0NvbnRleHQsIHdpdGhDdHgsIHdpdGhEZWZhdWx0cywgd2l0aERpcmVjdGl2ZXMsIHdpdGhNZW1vLCB3aXRoU2NvcGVJZCB9O1xuIiwiLyoqXG4qIEB2dWUvcnVudGltZS1kb20gdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgd2FybiwgaCwgQmFzZVRyYW5zaXRpb24sIGFzc2VydE51bWJlciwgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIGdldEN1cnJlbnRJbnN0YW5jZSwgb25CZWZvcmVVcGRhdGUsIHF1ZXVlUG9zdEZsdXNoQ2IsIG9uTW91bnRlZCwgd2F0Y2gsIG9uVW5tb3VudGVkLCBGcmFnbWVudCwgU3RhdGljLCBjYW1lbGl6ZSwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGRlZmluZUNvbXBvbmVudCwgbmV4dFRpY2ssIHVucmVmLCBjcmVhdGVWTm9kZSwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgVGV4dCwgaXNSdW50aW1lT25seSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgZXh0ZW5kLCBpc09iamVjdCwgdG9OdW1iZXIsIGlzQXJyYXksIE5PT1AsIGlzU3RyaW5nLCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNTeW1ib2wsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc0Z1bmN0aW9uLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIGlzUGxhaW5PYmplY3QsIGhhc093biwgRU1QVFlfT0JKLCBsb29zZVRvTnVtYmVyLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpbnZva2VBcnJheUZucywgaXNIVE1MVGFnLCBpc1NWR1RhZywgaXNNYXRoTUxUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmxldCBwb2xpY3kgPSB2b2lkIDA7XG5jb25zdCB0dCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnRydXN0ZWRUeXBlcztcbmlmICh0dCkge1xuICB0cnkge1xuICAgIHBvbGljeSA9IC8qIEBfX1BVUkVfXyAqLyB0dC5jcmVhdGVQb2xpY3koXCJ2dWVcIiwge1xuICAgICAgY3JlYXRlSFRNTDogKHZhbCkgPT4gdmFsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEVycm9yIGNyZWF0aW5nIHRydXN0ZWQgdHlwZXMgcG9saWN5OiAke2V9YCk7XG4gIH1cbn1cbmNvbnN0IHVuc2FmZVRvVHJ1c3RlZEhUTUwgPSBwb2xpY3kgPyAodmFsKSA9PiBwb2xpY3kuY3JlYXRlSFRNTCh2YWwpIDogKHZhbCkgPT4gdmFsO1xuY29uc3Qgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBtYXRobWxOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyogQF9fUFVSRV9fICovIGRvYy5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5jb25zdCBub2RlT3BzID0ge1xuICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XG4gIH0sXG4gIHJlbW92ZTogKGNoaWxkKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogKHRhZywgbmFtZXNwYWNlLCBpcywgcHJvcHMpID0+IHtcbiAgICBjb25zdCBlbCA9IG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZykgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBkb2MuY3JlYXRlRWxlbWVudE5TKG1hdGhtbE5TLCB0YWcpIDogaXMgPyBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHsgaXMgfSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcgPT09IFwic2VsZWN0XCIgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gIGNyZWF0ZUNvbW1lbnQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIH0sXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0sXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgcXVlcnlTZWxlY3RvcjogKHNlbGVjdG9yKSA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgfSxcbiAgLy8gX19VTlNBRkVfX1xuICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBuYW1lc3BhY2UsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcbiAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IHVuc2FmZVRvVHJ1c3RlZEhUTUwoXG4gICAgICAgIG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiID8gYDxtYXRoPiR7Y29udGVudH08L21hdGg+YCA6IGNvbnRlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIikge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLy8gZmlyc3RcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgLy8gbGFzdFxuICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICBdO1xuICB9XG59O1xuXG5jb25zdCBUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG5jb25zdCBBTklNQVRJT04gPSBcImFuaW1hdGlvblwiO1xuY29uc3QgdnRjS2V5ID0gU3ltYm9sKFwiX3Z0Y1wiKTtcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBjc3M6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnNcbik7XG5jb25zdCBkZWNvcmF0ZSQxID0gKHQpID0+IHtcbiAgdC5kaXNwbGF5TmFtZSA9IFwiVHJhbnNpdGlvblwiO1xuICB0LnByb3BzID0gVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycztcbiAgcmV0dXJuIHQ7XG59O1xuY29uc3QgVHJhbnNpdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBkZWNvcmF0ZSQxKFxuICAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKVxuKTtcbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xuICBpZiAoaXNBcnJheShob29rKSkge1xuICAgIGhvb2suZm9yRWFjaCgoaDIpID0+IGgyKC4uLmFyZ3MpKTtcbiAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgaG9vayguLi5hcmdzKTtcbiAgfVxufTtcbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xuICByZXR1cm4gaG9vayA/IGlzQXJyYXkoaG9vaykgPyBob29rLnNvbWUoKGgyKSA9PiBoMi5sZW5ndGggPiAxKSA6IGhvb2subGVuZ3RoID4gMSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcbiAgY29uc3QgYmFzZVByb3BzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XG4gICAgICBiYXNlUHJvcHNba2V5XSA9IHJhd1Byb3BzW2tleV07XG4gICAgfVxuICB9XG4gIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGJhc2VQcm9wcztcbiAgfVxuICBjb25zdCB7XG4gICAgbmFtZSA9IFwidlwiLFxuICAgIHR5cGUsXG4gICAgZHVyYXRpb24sXG4gICAgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCxcbiAgICBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLFxuICAgIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsXG4gICAgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCxcbiAgICBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2BcbiAgfSA9IHJhd1Byb3BzO1xuICBjb25zdCBkdXJhdGlvbnMgPSBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbik7XG4gIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xuICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcbiAgY29uc3Qge1xuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkVudGVyQ2FuY2VsbGVkLFxuICAgIG9uTGVhdmUsXG4gICAgb25MZWF2ZUNhbmNlbGxlZCxcbiAgICBvbkJlZm9yZUFwcGVhciA9IG9uQmVmb3JlRW50ZXIsXG4gICAgb25BcHBlYXIgPSBvbkVudGVyLFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZFxuICB9ID0gYmFzZVByb3BzO1xuICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUsIGlzQ2FuY2VsbGVkKSA9PiB7XG4gICAgZWwuX2VudGVyQ2FuY2VsbGVkID0gaXNDYW5jZWxsZWQ7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9O1xuICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xuICAgIGVsLl9pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xuICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xuICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhob29rKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgZW50ZXJEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XG4gICAgb25CZWZvcmVFbnRlcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xuICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJGcm9tQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XG4gICAgfSxcbiAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcbiAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcbiAgICBvbkxlYXZlKGVsLCBkb25lKSB7XG4gICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgIGlmICghZWwuX2VudGVyQ2FuY2VsbGVkKSB7XG4gICAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgfVxuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgaWYgKCFlbC5faXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhvbkxlYXZlKSkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgbGVhdmVEdXJhdGlvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZSwgW2VsLCByZXNvbHZlXSk7XG4gICAgfSxcbiAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSwgdm9pZCAwLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xuICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgcmV0dXJuIFtuLCBuXTtcbiAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHJlcywgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIChlbFt2dGNLZXldIHx8IChlbFt2dGNLZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkpLmFkZChjbHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgY29uc3QgX3Z0YyA9IGVsW3Z0Y0tleV07XG4gIGlmIChfdnRjKSB7XG4gICAgX3Z0Yy5kZWxldGUoY2xzKTtcbiAgICBpZiAoIV92dGMuc2l6ZSkge1xuICAgICAgZWxbdnRjS2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH0pO1xufVxubGV0IGVuZElkID0gMDtcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcbiAgY29uc3QgaWQgPSBlbC5fZW5kSWQgPSArK2VuZElkO1xuICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcbiAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGV4cGxpY2l0VGltZW91dCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICB9XG4gIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArIFwiZW5kXCI7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG4gICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCBcIlwiKS5zcGxpdChcIiwgXCIpO1xuICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcbiAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xuICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgbGV0IHR5cGUgPSBudWxsO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0ID8gVFJBTlNJVElPTiA6IEFOSU1BVElPTiA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZSA/IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aCA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KFxuICAgIGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdGltZW91dCxcbiAgICBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xufVxuZnVuY3Rpb24gdG9NcyhzKSB7XG4gIGlmIChzID09PSBcImF1dG9cIikgcmV0dXJuIDA7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZShcIixcIiwgXCIuXCIpKSAqIDFlMztcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsW3Z0Y0tleV07XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHZhbHVlID0gKHZhbHVlID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc10gOiBbLi4udHJhbnNpdGlvbkNsYXNzZXNdKS5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICB9IGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IHZTaG93T3JpZ2luYWxEaXNwbGF5ID0gU3ltYm9sKFwiX3ZvZFwiKTtcbmNvbnN0IHZTaG93SGlkZGVuID0gU3ltYm9sKFwiX3ZzaFwiKTtcbmNvbnN0IHZTaG93ID0ge1xuICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA9IGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHJldHVybjtcbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcbiAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICB9XG59O1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgdlNob3cubmFtZSA9IFwic2hvd1wiO1xufVxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWxbdlNob3dPcmlnaW5hbERpc3BsYXldIDogXCJub25lXCI7XG4gIGVsW3ZTaG93SGlkZGVuXSA9ICF2YWx1ZTtcbn1cbmZ1bmN0aW9uIGluaXRWU2hvd0ZvclNTUigpIHtcbiAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQ1NTX1ZBUl9URVhUID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkNTU19WQVJfVEVYVFwiIDogXCJcIik7XG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXBkYXRlVGVsZXBvcnRzID0gaW5zdGFuY2UudXQgPSAodmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSkpID0+IHtcbiAgICBBcnJheS5mcm9tKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtdi1vd25lcj1cIiR7aW5zdGFuY2UudWlkfVwiXWApXG4gICAgKS5mb3JFYWNoKChub2RlKSA9PiBzZXRWYXJzT25Ob2RlKG5vZGUsIHZhcnMpKTtcbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbnN0YW5jZS5nZXRDc3NWYXJzID0gKCkgPT4gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgfVxuICBjb25zdCBzZXRWYXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICAgIGlmIChpbnN0YW5jZS5jZSkge1xuICAgICAgc2V0VmFyc09uTm9kZShpbnN0YW5jZS5jZSwgdmFycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIHZhcnMpO1xuICAgIH1cbiAgICB1cGRhdGVUZWxlcG9ydHModmFycyk7XG4gIH07XG4gIG9uQmVmb3JlVXBkYXRlKCgpID0+IHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKHNldFZhcnMpO1xuICB9KTtcbiAgb25Nb3VudGVkKCgpID0+IHtcbiAgICB3YXRjaChzZXRWYXJzLCBOT09QLCB7IGZsdXNoOiBcInBvc3RcIiB9KTtcbiAgICBjb25zdCBvYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHNldFZhcnMpO1xuICAgIG9iLm9ic2VydmUoaW5zdGFuY2Uuc3ViVHJlZS5lbC5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICBvblVubW91bnRlZCgoKSA9PiBvYi5kaXNjb25uZWN0KCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xuICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xuICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcbiAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XG4gICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgfVxuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAmJiB2bm9kZS5lbCkge1xuICAgIHNldFZhcnNPbk5vZGUodm5vZGUuZWwsIHZhcnMpO1xuICB9IGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xuICB9IGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFN0YXRpYykge1xuICAgIGxldCB7IGVsLCBhbmNob3IgfSA9IHZub2RlO1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgc2V0VmFyc09uTm9kZShlbCwgdmFycyk7XG4gICAgICBpZiAoZWwgPT09IGFuY2hvcikgYnJlYWs7XG4gICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VmFyc09uTm9kZShlbCwgdmFycykge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgIGxldCBjc3NUZXh0ID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xuICAgICAgY3NzVGV4dCArPSBgLS0ke2tleX06ICR7dmFyc1trZXldfTtgO1xuICAgIH1cbiAgICBzdHlsZVtDU1NfVkFSX1RFWFRdID0gY3NzVGV4dDtcbiAgfVxufVxuXG5jb25zdCBkaXNwbGF5UkUgPSAvKF58OylcXHMqZGlzcGxheVxccyo6LztcbmZ1bmN0aW9uIHBhdGNoU3R5bGUoZWwsIHByZXYsIG5leHQpIHtcbiAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgY29uc3QgaXNDc3NTdHJpbmcgPSBpc1N0cmluZyhuZXh0KTtcbiAgbGV0IGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gZmFsc2U7XG4gIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xuICAgIGlmIChwcmV2KSB7XG4gICAgICBpZiAoIWlzU3RyaW5nKHByZXYpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBwcmV2U3R5bGUgb2YgcHJldi5zcGxpdChcIjtcIikpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBwcmV2U3R5bGUuc2xpY2UoMCwgcHJldlN0eWxlLmluZGV4T2YoXCI6XCIpKS50cmltKCk7XG4gICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgaWYgKGtleSA9PT0gXCJkaXNwbGF5XCIpIHtcbiAgICAgICAgaGFzQ29udHJvbGxlZERpc3BsYXkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQ3NzU3RyaW5nKSB7XG4gICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICBjb25zdCBjc3NWYXJUZXh0ID0gc3R5bGVbQ1NTX1ZBUl9URVhUXTtcbiAgICAgICAgaWYgKGNzc1ZhclRleHQpIHtcbiAgICAgICAgICBuZXh0ICs9IFwiO1wiICsgY3NzVmFyVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcbiAgICAgICAgaGFzQ29udHJvbGxlZERpc3BsYXkgPSBkaXNwbGF5UkUudGVzdChuZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgfVxuICBpZiAodlNob3dPcmlnaW5hbERpc3BsYXkgaW4gZWwpIHtcbiAgICBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gPSBoYXNDb250cm9sbGVkRGlzcGxheSA/IHN0eWxlLmRpc3BsYXkgOiBcIlwiO1xuICAgIGlmIChlbFt2U2hvd0hpZGRlbl0pIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHNlbWljb2xvblJFID0gL1teXFxcXF07XFxzKiQvO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcbiAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIHZhbC5mb3JFYWNoKCh2KSA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPT0gbnVsbCkgdmFsID0gXCJcIjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKHNlbWljb2xvblJFLnRlc3QodmFsKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBVbmV4cGVjdGVkIHNlbWljb2xvbiBhdCB0aGUgZW5kIG9mICcke25hbWV9JyBzdHlsZSB2YWx1ZTogJyR7dmFsfSdgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcbiAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgaHlwaGVuYXRlKHByZWZpeGVkKSxcbiAgICAgICAgICB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgXCJcIiksXG4gICAgICAgICAgXCJpbXBvcnRhbnRcIlxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgcHJlZml4ZXMgPSBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiXTtcbmNvbnN0IHByZWZpeENhY2hlID0ge307XG5mdW5jdGlvbiBhdXRvUHJlZml4KHN0eWxlLCByYXdOYW1lKSB7XG4gIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xuICBpZiAobmFtZSAhPT0gXCJmaWx0ZXJcIiAmJiBuYW1lIGluIHN0eWxlKSB7XG4gICAgcmV0dXJuIHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZTtcbiAgfVxuICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xuICAgIGlmIChwcmVmaXhlZCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdOYW1lO1xufVxuXG5jb25zdCB4bGlua05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSwgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KSkge1xuICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoXCJ4bGluazpcIikpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAga2V5LFxuICAgICAgICBpc0Jvb2xlYW4gPyBcIlwiIDogaXNTeW1ib2wodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIHBhcmVudENvbXBvbmVudCwgYXR0ck5hbWUpIHtcbiAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBlbFtrZXldID0ga2V5ID09PSBcImlubmVySFRNTFwiID8gdW5zYWZlVG9UcnVzdGVkSFRNTCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWU7XG4gIGlmIChrZXkgPT09IFwidmFsdWVcIiAmJiB0YWcgIT09IFwiUFJPR1JFU1NcIiAmJiAvLyBjdXN0b20gZWxlbWVudHMgbWF5IHVzZSBfdmFsdWUgaW50ZXJuYWxseVxuICAhdGFnLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFnID09PSBcIk9QVElPTlwiID8gZWwuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIiA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IChcbiAgICAgIC8vICMxMTY0NzogdmFsdWUgc2hvdWxkIGJlIHNldCBhcyBlbXB0eSBzdHJpbmcgZm9yIG51bGwgYW5kIHVuZGVmaW5lZCxcbiAgICAgIC8vIGJ1dCA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+IHNob3VsZCBiZSBzZXQgYXMgJ29uJy5cbiAgICAgIGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIiA/IFwib25cIiA6IFwiXCJcbiAgICApIDogU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlIHx8ICEoXCJfdmFsdWVcIiBpbiBlbCkpIHtcbiAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBuZWVkUmVtb3ZlID0gZmFsc2U7XG4gIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBlbFtrZXldO1xuICAgIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdmFsdWUgPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFuZWVkUmVtb3ZlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke3RhZy50b0xvd2VyQ2FzZSgpfT46IHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbmVlZFJlbW92ZSAmJiBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUgfHwga2V5KTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmNvbnN0IHZlaUtleSA9IFN5bWJvbChcIl92ZWlcIik7XG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XG4gIGNvbnN0IGludm9rZXJzID0gZWxbdmVpS2V5XSB8fCAoZWxbdmVpS2V5XSA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XG4gIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNhbml0aXplRXZlbnRWYWx1ZShuZXh0VmFsdWUsIHJhd05hbWUpIDogbmV4dFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcbiAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICBjb25zdCBpbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKFxuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2FuaXRpemVFdmVudFZhbHVlKG5leHRWYWx1ZSwgcmF3TmFtZSkgOiBuZXh0VmFsdWUsXG4gICAgICAgIGluc3RhbmNlXG4gICAgICApO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XG4gICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBtO1xuICAgIHdoaWxlIChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xuICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZXZlbnQgPSBuYW1lWzJdID09PSBcIjpcIiA/IG5hbWUuc2xpY2UoMykgOiBoeXBoZW5hdGUobmFtZS5zbGljZSgyKSk7XG4gIHJldHVybiBbZXZlbnQsIG9wdGlvbnNdO1xufVxubGV0IGNhY2hlZE5vdyA9IDA7XG5jb25zdCBwID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4oKCkgPT4gY2FjaGVkTm93ID0gMCksIGNhY2hlZE5vdyA9IERhdGUubm93KCkpO1xuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xuICAgIGlmICghZS5fdnRzKSB7XG4gICAgICBlLl92dHMgPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAoZS5fdnRzIDw9IGludm9rZXIuYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNSxcbiAgICAgIFtlXVxuICAgICk7XG4gIH07XG4gIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcbiAgcmV0dXJuIGludm9rZXI7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUV2ZW50VmFsdWUodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB3YXJuKFxuICAgIGBXcm9uZyB0eXBlIHBhc3NlZCBhcyBldmVudCBoYW5kbGVyIHRvICR7cHJvcE5hbWV9IC0gZGlkIHlvdSBmb3JnZXQgQCBvciA6IGluIGZyb250IG9mIHlvdXIgcHJvcD9cbkV4cGVjdGVkIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucywgcmVjZWl2ZWQgdHlwZSAke3R5cGVvZiB2YWx1ZX0uYFxuICApO1xuICByZXR1cm4gTk9PUDtcbn1cbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xuICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XG4gICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiB2YWx1ZS5tYXAoXG4gICAgICAoZm4pID0+IChlMikgPT4gIWUyLl9zdG9wcGVkICYmIGZuICYmIGZuKGUyKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmNvbnN0IGlzTmF0aXZlT24gPSAoa2V5KSA9PiBrZXkuY2hhckNvZGVBdCgwKSA9PT0gMTExICYmIGtleS5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgLy8gbG93ZXJjYXNlIGxldHRlclxua2V5LmNoYXJDb2RlQXQoMikgPiA5NiAmJiBrZXkuY2hhckNvZGVBdCgyKSA8IDEyMztcbmNvbnN0IHBhdGNoUHJvcCA9IChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgbmFtZXNwYWNlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgY29uc3QgaXNTVkcgPSBuYW1lc3BhY2UgPT09IFwic3ZnXCI7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleVswXSA9PT0gXCIuXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCB0cnVlKSA6IGtleVswXSA9PT0gXCJeXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCBmYWxzZSkgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcbiAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlKTtcbiAgICBpZiAoIWVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpICYmIChrZXkgPT09IFwidmFsdWVcIiB8fCBrZXkgPT09IFwiY2hlY2tlZFwiIHx8IGtleSA9PT0gXCJzZWxlY3RlZFwiKSkge1xuICAgICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcsIHBhcmVudENvbXBvbmVudCwga2V5ICE9PSBcInZhbHVlXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAvLyAjMTEwODEgZm9yY2Ugc2V0IHByb3BzIGZvciBwb3NzaWJsZSBhc3luYyBjdXN0b20gZWxlbWVudFxuICAgIGVsLl9pc1Z1ZUNFICYmICgvW0EtWl0vLnRlc3Qoa2V5KSB8fCAhaXNTdHJpbmcobmV4dFZhbHVlKSlcbiAgKSB7XG4gICAgcGF0Y2hET01Qcm9wKGVsLCBjYW1lbGl6ZSQxKGtleSksIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50LCBrZXkpO1xuICB9IGVsc2Uge1xuICAgIGlmIChrZXkgPT09IFwidHJ1ZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImZhbHNlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl9mYWxzZVZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH1cbiAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XG4gIGlmIChpc1NWRykge1xuICAgIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoa2V5IGluIGVsICYmIGlzTmF0aXZlT24oa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInNwZWxsY2hlY2tcIiB8fCBrZXkgPT09IFwiZHJhZ2dhYmxlXCIgfHwga2V5ID09PSBcInRyYW5zbGF0ZVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZm9ybVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwibGlzdFwiICYmIGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ3aWR0aFwiIHx8IGtleSA9PT0gXCJoZWlnaHRcIikge1xuICAgIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWU7XG4gICAgaWYgKHRhZyA9PT0gXCJJTUdcIiB8fCB0YWcgPT09IFwiVklERU9cIiB8fCB0YWcgPT09IFwiQ0FOVkFTXCIgfHwgdGFnID09PSBcIlNPVVJDRVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc05hdGl2ZU9uKGtleSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBrZXkgaW4gZWw7XG59XG5cbmNvbnN0IFJFTU9WQUwgPSB7fTtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zLCBfY3JlYXRlQXBwKSB7XG4gIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgaWYgKGlzUGxhaW5PYmplY3QoQ29tcCkpIGV4dGVuZChDb21wLCBleHRyYU9wdGlvbnMpO1xuICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XG4gICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIF9jcmVhdGVBcHApO1xuICAgIH1cbiAgfVxuICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XG4gIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xufVxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKG9wdGlvbnMsIGV4dHJhT3B0aW9ucykgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zLCBjcmVhdGVTU1JBcHApO1xufTtcbmNvbnN0IEJhc2VDbGFzcyA9IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xufTtcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZGVmLCBfcHJvcHMgPSB7fSwgX2NyZWF0ZUFwcCA9IGNyZWF0ZUFwcCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZGVmID0gX2RlZjtcbiAgICB0aGlzLl9wcm9wcyA9IF9wcm9wcztcbiAgICB0aGlzLl9jcmVhdGVBcHAgPSBfY3JlYXRlQXBwO1xuICAgIHRoaXMuX2lzVnVlQ0UgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hcHAgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX25vbmNlID0gdGhpcy5fZGVmLm5vbmNlO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBfY3JlYXRlQXBwICE9PSBjcmVhdGVBcHApIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoX2RlZi5zaGFkb3dSb290ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5zaGFkb3dSb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXIpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5fcGFyc2VTbG90cygpO1xuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkge1xuICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgIHRoaXMuX3NldFBhcmVudCgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nUmVzb2x2ZSkge1xuICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gcGFyZW50Ll9wZW5kaW5nUmVzb2x2ZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0UGFyZW50KHBhcmVudCA9IHRoaXMuX3BhcmVudCkge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XG4gICAgICB0aGlzLl9pbnN0YW5jZS5wcm92aWRlcyA9IHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYikge1xuICAgICAgICAgIHRoaXMuX29iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwICYmIHRoaXMuX2FwcC51bm1vdW50KCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkgdGhpcy5faW5zdGFuY2UuY2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2FwcCA9IHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcbiAgICovXG4gIF9yZXNvbHZlRGVmKCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzb2x2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX29iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG11dGF0aW9ucykge1xuICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChkZWYsIGlzQXN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdHlsZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkN1c3RvbSBlbGVtZW50IHN0eWxlIGluamVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gdXNpbmcgc2hhZG93Um9vdDogZmFsc2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW91bnQoZGVmKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IGFzeW5jRGVmKCkudGhlbihcbiAgICAgICAgKGRlZikgPT4gcmVzb2x2ZSh0aGlzLl9kZWYgPSBkZWYsIHRydWUpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIF9tb3VudChkZWYpIHtcbiAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAhZGVmLm5hbWUpIHtcbiAgICAgIGRlZi5uYW1lID0gXCJWdWVFbGVtZW50XCI7XG4gICAgfVxuICAgIHRoaXMuX2FwcCA9IHRoaXMuX2NyZWF0ZUFwcChkZWYpO1xuICAgIGlmIChkZWYuY29uZmlndXJlQXBwKSB7XG4gICAgICBkZWYuY29uZmlndXJlQXBwKHRoaXMuX2FwcCk7XG4gICAgfVxuICAgIHRoaXMuX2FwcC5fY2VWTm9kZSA9IHRoaXMuX2NyZWF0ZVZOb2RlKCk7XG4gICAgdGhpcy5fYXBwLm1vdW50KHRoaXMuX3Jvb3QpO1xuICAgIGNvbnN0IGV4cG9zZWQgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5leHBvc2VkO1xuICAgIGlmICghZXhwb3NlZCkgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9zZWQpIHtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIC8vIHVud3JhcCByZWYgdG8gYmUgY29uc2lzdGVudCB3aXRoIHB1YmxpYyBpbnN0YW5jZSBiZWhhdmlvclxuICAgICAgICAgIGdldDogKCkgPT4gdW5yZWYoZXhwb3NlZFtrZXldKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKGBFeHBvc2VkIHByb3BlcnR5IFwiJHtrZXl9XCIgYWxyZWFkeSBleGlzdHMgb24gY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9yZXNvbHZlUHJvcHMoZGVmKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgIGNvbnN0IGRlY2xhcmVkUHJvcEtleXMgPSBpc0FycmF5KHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSBcIl9cIiAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGRlY2xhcmVkUHJvcEtleXMubWFwKGNhbWVsaXplJDEpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0QXR0cihrZXkpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJkYXRhLXYtXCIpKSByZXR1cm47XG4gICAgY29uc3QgaGFzID0gdGhpcy5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICBsZXQgdmFsdWUgPSBoYXMgPyB0aGlzLmdldEF0dHJpYnV0ZShrZXkpIDogUkVNT1ZBTDtcbiAgICBjb25zdCBjYW1lbEtleSA9IGNhbWVsaXplJDEoa2V5KTtcbiAgICBpZiAoaGFzICYmIHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2NhbWVsS2V5XSkge1xuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX3NldFByb3AoY2FtZWxLZXksIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldFByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BzW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcbiAgICAgIGlmICh2YWwgPT09IFJFTU9WQUwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Byb3BzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xuICAgICAgICBpZiAoa2V5ID09PSBcImtleVwiICYmIHRoaXMuX2FwcCkge1xuICAgICAgICAgIHRoaXMuX2FwcC5fY2VWTm9kZS5rZXkgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xuICAgICAgICBjb25zdCBvYiA9IHRoaXMuX29iO1xuICAgICAgICBvYiAmJiBvYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgb2IgJiYgb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGUoKSB7XG4gICAgcmVuZGVyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuX3Jvb3QpO1xuICB9XG4gIF9jcmVhdGVWTm9kZSgpIHtcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgYmFzZVByb3BzLm9uVm5vZGVNb3VudGVkID0gYmFzZVByb3BzLm9uVm5vZGVVcGRhdGVkID0gdGhpcy5fcmVuZGVyU2xvdHMuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZChiYXNlUHJvcHMsIHRoaXMuX3Byb3BzKSk7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdm5vZGUuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuY2UgPSB0aGlzO1xuICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZCA9IChuZXdTdHlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KFxuICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGV4dGVuZCh7IGRldGFpbDogYXJncyB9LCBhcmdzWzBdKSA6IHsgZGV0YWlsOiBhcmdzIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goaHlwaGVuYXRlKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBfYXBwbHlTdHlsZXMoc3R5bGVzLCBvd25lcikge1xuICAgIGlmICghc3R5bGVzKSByZXR1cm47XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICBpZiAob3duZXIgPT09IHRoaXMuX2RlZiB8fCB0aGlzLl9zdHlsZUNoaWxkcmVuLmhhcyhvd25lcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5hZGQob3duZXIpO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHRoaXMuX25vbmNlO1xuICAgIGZvciAobGV0IGkgPSBzdHlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBpZiAobm9uY2UpIHMuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgcy50ZXh0Q29udGVudCA9IHN0eWxlc1tpXTtcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5wcmVwZW5kKHMpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgICAgaWYgKG93bmVyLl9faG1ySWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hpbGRTdHlsZXMpIHRoaXMuX2NoaWxkU3R5bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChvd25lci5fX2htcklkKTtcbiAgICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2hpbGRTdHlsZXMuc2V0KG93bmVyLl9faG1ySWQsIGVudHJ5ID0gW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRvd1Jvb3QgaXMgZmFsc2VcbiAgICovXG4gIF9wYXJzZVNsb3RzKCkge1xuICAgIGNvbnN0IHNsb3RzID0gdGhpcy5fc2xvdHMgPSB7fTtcbiAgICBsZXQgbjtcbiAgICB3aGlsZSAobiA9IHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBuLm5vZGVUeXBlID09PSAxICYmIG4uZ2V0QXR0cmlidXRlKFwic2xvdFwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIChzbG90c1tzbG90TmFtZV0gfHwgKHNsb3RzW3Nsb3ROYW1lXSA9IFtdKSkucHVzaChuKTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbmx5IGNhbGxlZCB3aGVuIHNoYWRvd1Jvb3QgaXMgZmFsc2VcbiAgICovXG4gIF9yZW5kZXJTbG90cygpIHtcbiAgICBjb25zdCBvdXRsZXRzID0gKHRoaXMuX3RlbGVwb3J0VGFyZ2V0IHx8IHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzbG90XCIpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSB0aGlzLl9pbnN0YW5jZS50eXBlLl9fc2NvcGVJZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGxldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSBvdXRsZXRzW2ldO1xuICAgICAgY29uc3Qgc2xvdE5hbWUgPSBvLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fc2xvdHNbc2xvdE5hbWVdO1xuICAgICAgY29uc3QgcGFyZW50ID0gby5wYXJlbnROb2RlO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIGNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoc2NvcGVJZCAmJiBuLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjb3BlSWQgKyBcIi1zXCI7XG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG4sIDEpO1xuICAgICAgICAgICAgbi5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkID0gd2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG8uZmlyc3RDaGlsZCkgcGFyZW50Lmluc2VydEJlZm9yZShvLmZpcnN0Q2hpbGQsIG8pO1xuICAgICAgfVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG8pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaW5qZWN0Q2hpbGRTdHlsZShjb21wKSB7XG4gICAgdGhpcy5fYXBwbHlTdHlsZXMoY29tcC5zdHlsZXMsIGNvbXApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZW1vdmVDaGlsZFN0eWxlKGNvbXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5fc3R5bGVDaGlsZHJlbi5kZWxldGUoY29tcCk7XG4gICAgICBpZiAodGhpcy5fY2hpbGRTdHlsZXMgJiYgY29tcC5fX2htcklkKSB7XG4gICAgICAgIGNvbnN0IG9sZFN0eWxlcyA9IHRoaXMuX2NoaWxkU3R5bGVzLmdldChjb21wLl9faG1ySWQpO1xuICAgICAgICBpZiAob2xkU3R5bGVzKSB7XG4gICAgICAgICAgb2xkU3R5bGVzLmZvckVhY2goKHMpID0+IHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgIG9sZFN0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1c2VIb3N0KGNhbGxlcikge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCBlbCA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNlO1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gZWw7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FsbGVkIHdpdGhvdXQgYW4gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYWxsZXIgfHwgXCJ1c2VIb3N0XCJ9IGNhbiBvbmx5IGJlIHVzZWQgaW4gY29tcG9uZW50cyBkZWZpbmVkIHZpYSBkZWZpbmVDdXN0b21FbGVtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdXNlU2hhZG93Um9vdCgpIHtcbiAgY29uc3QgZWwgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gdXNlSG9zdChcInVzZVNoYWRvd1Jvb3RcIikgOiB1c2VIb3N0KCk7XG4gIHJldHVybiBlbCAmJiBlbC5zaGFkb3dSb290O1xufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9IFwiJHN0eWxlXCIpIHtcbiAge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICBpZiAoIW1vZHVsZXMpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcbiAgICBpZiAoIW1vZCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIHJldHVybiBtb2Q7XG4gIH1cbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtb3ZlQ2JLZXkgPSBTeW1ib2woXCJfbW92ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IFN5bWJvbChcIl9lbnRlckNiXCIpO1xuY29uc3QgZGVjb3JhdGUgPSAodCkgPT4ge1xuICBkZWxldGUgdC5wcm9wcy5tb2RlO1xuICByZXR1cm4gdDtcbn07XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0gLyogQF9fUFVSRV9fICovIGRlY29yYXRlKHtcbiAgbmFtZTogXCJUcmFuc2l0aW9uR3JvdXBcIixcbiAgcHJvcHM6IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9KSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICBsZXQgcHJldkNoaWxkcmVuO1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBvblVwZGF0ZWQoKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8IFwidlwifS1tb3ZlYDtcbiAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKFxuICAgICAgICBwcmV2Q2hpbGRyZW5bMF0uZWwsXG4gICAgICAgIGluc3RhbmNlLnZub2RlLmVsLFxuICAgICAgICBtb3ZlQ2xhc3NcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gYy5lbDtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiO1xuICAgICAgICBjb25zdCBjYiA9IGVsW21vdmVDYktleV0gPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICAgICAgICBlbFttb3ZlQ2JLZXldID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcbiAgICAgIHByZXZDaGlsZHJlbiA9IFtdO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5lbCAmJiBjaGlsZC5lbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgICAgY3NzVHJhbnNpdGlvblByb3BzLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoXG4gICAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgICBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkLnR5cGUgIT09IFRleHQpIHtcbiAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xuICBjb25zdCBlbCA9IGMuZWw7XG4gIGlmIChlbFttb3ZlQ2JLZXldKSB7XG4gICAgZWxbbW92ZUNiS2V5XSgpO1xuICB9XG4gIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgIGVsW2VudGVyQ2JLZXldKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcbiAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gXCIwc1wiO1xuICAgIHJldHVybiBjO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9KTtcbiAgfVxuICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xuICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHJvb3Qubm9kZVR5cGUgPT09IDEgPyByb290IDogcm9vdC5wYXJlbnROb2RlO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICByZXR1cm4gaGFzVHJhbnNmb3JtO1xufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbXCJvblVwZGF0ZTptb2RlbFZhbHVlXCJdIHx8IGZhbHNlO1xuICByZXR1cm4gaXNBcnJheShmbikgPyAodmFsdWUpID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSk7XG4gIH1cbn1cbmNvbnN0IGFzc2lnbktleSA9IFN5bWJvbChcIl9hc3NpZ25cIik7XG5jb25zdCB2TW9kZWxUZXh0ID0ge1xuICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSA9PT0gXCJudW1iZXJcIjtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpIHJldHVybjtcbiAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdFRvTnVtYmVyKSB7XG4gICAgICAgIGRvbVZhbHVlID0gbG9vc2VUb051bWJlcihkb21WYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbFthc3NpZ25LZXldKGRvbVZhbHVlKTtcbiAgICB9KTtcbiAgICBpZiAodHJpbSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWxhenkpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgIH1cbiAgfSxcbiAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAoZWwuY29tcG9zaW5nKSByZXR1cm47XG4gICAgY29uc3QgZWxWYWx1ZSA9IChudW1iZXIgfHwgZWwudHlwZSA9PT0gXCJudW1iZXJcIikgJiYgIS9eMFxcZC8udGVzdChlbC52YWx1ZSkgPyBsb29zZVRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAoZWxWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09IFwicmFuZ2VcIikge1xuICAgICAgaWYgKGxhenkgJiYgdmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG59O1xuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XG4gIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XG4gICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XG4gICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsW2Fzc2lnbktleV07XG4gICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XG4gICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxuICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gIGxldCBjaGVja2VkO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSByZXR1cm47XG4gICAgY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcbiAgfVxuICBpZiAoZWwuY2hlY2tlZCAhPT0gY2hlY2tlZCkge1xuICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGVsW2Fzc2lnbktleV0oZ2V0VmFsdWUoZWwpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKS5tYXAoXG4gICAgICAgIChvKSA9PiBudW1iZXIgPyBsb29zZVRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pXG4gICAgICApO1xuICAgICAgZWxbYXNzaWduS2V5XShcbiAgICAgICAgZWwubXVsdGlwbGUgPyBpc1NldE1vZGVsID8gbmV3IFNldChzZWxlY3RlZFZhbCkgOiBzZWxlY3RlZFZhbCA6IHNlbGVjdGVkVmFsWzBdXG4gICAgICApO1xuICAgICAgZWwuX2Fzc2lnbmluZyA9IHRydWU7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGVsLl9hc3NpZ25pbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAvLyA8b3B0aW9uPnMuXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBpZiAoIWVsLl9hc3NpZ25pbmcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgY29uc3QgaXNBcnJheVZhbHVlID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5VmFsdWUgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSB0eXBlb2Ygb3B0aW9uVmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25UeXBlID09PSBcInN0cmluZ1wiIHx8IG9wdGlvblR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5zb21lKCh2KSA9PiBTdHJpbmcodikgPT09IFN0cmluZyhvcHRpb25WYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHJldHVybiBcIl92YWx1ZVwiIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gIGNvbnN0IGtleSA9IGNoZWNrZWQgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xuICB9LFxuICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgIGVsLnRhZ05hbWUsXG4gICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICApO1xuICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gIHN0b3A6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICBzZWxmOiAoZSkgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgY3RybDogKGUpID0+ICFlLmN0cmxLZXksXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXG4gIGFsdDogKGUpID0+ICFlLmFsdEtleSxcbiAgbWV0YTogKGUpID0+ICFlLm1ldGFLZXksXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gIG1pZGRsZTogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgcmlnaHQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhNb2RzIHx8IChmbi5fd2l0aE1vZHMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xuICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKSByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gIH0pO1xufTtcbmNvbnN0IGtleU5hbWVzID0ge1xuICBlc2M6IFwiZXNjYXBlXCIsXG4gIHNwYWNlOiBcIiBcIixcbiAgdXA6IFwiYXJyb3ctdXBcIixcbiAgbGVmdDogXCJhcnJvdy1sZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gIGRvd246IFwiYXJyb3ctZG93blwiLFxuICBkZWxldGU6IFwiYmFja3NwYWNlXCJcbn07XG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhLZXlzIHx8IChmbi5fd2l0aEtleXMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIShcImtleVwiIGluIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgIGlmIChtb2RpZmllcnMuc29tZShcbiAgICAgIChrKSA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXlcbiAgICApKSB7XG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xubGV0IHJlbmRlcmVyO1xubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xuICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcbiAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uID8gcmVuZGVyZXIgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlcmVyO1xufVxuY29uc3QgcmVuZGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XG59O1xuY29uc3QgaHlkcmF0ZSA9ICguLi5hcmdzKSA9PiB7XG4gIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcbn07XG5jb25zdCBjcmVhdGVBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSB7XG4gIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwic3ZnXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgY29udGFpbmVyIGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudCkge1xuICAgIHJldHVybiBcIm1hdGhtbFwiO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNOYXRpdmVUYWdcIiwge1xuICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpIHx8IGlzTWF0aE1MVGFnKHRhZyksXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc0N1c3RvbUVsZW1lbnRcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cbi0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXG4tIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1zZmNgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lci5tb2RlID09PSBcImNsb3NlZFwiKSB7XG4gICAgd2FybihcbiAgICAgIGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICB9XG59IDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB1c2VIb3N0LCB1c2VTaGFkb3dSb290LCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcbiogdnVlIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4gfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuXG5mdW5jdGlvbiBpbml0RGV2KCkge1xuICB7XG4gICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xuICB9XG59XG5cbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGluaXREZXYoKTtcbn1cbmNvbnN0IGNvbXBpbGUgPSAoKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihcbiAgICAgIGBSdW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNvbXBpbGUgfTtcbiIsImZ1bmN0aW9uIG5vb3AoKSB7IH1cblxuZXhwb3J0IHsgbm9vcCB9O1xuIiwiZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgeyBpc1ByaW1pdGl2ZSB9O1xuIiwiZnVuY3Rpb24gaXNUeXBlZEFycmF5KHgpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmICEoeCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cblxuZXhwb3J0IHsgaXNUeXBlZEFycmF5IH07XG4iLCJmdW5jdGlvbiBnZXRTeW1ib2xzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkuZmlsdGVyKHN5bWJvbCA9PiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpKTtcbn1cblxuZXhwb3J0IHsgZ2V0U3ltYm9scyB9O1xuIiwiZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAnW29iamVjdCBVbmRlZmluZWRdJyA6ICdbb2JqZWN0IE51bGxdJztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCB7IGdldFRhZyB9O1xuIiwiY29uc3QgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5jb25zdCBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcbmNvbnN0IG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuY29uc3QgYm9vbGVhblRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcbmNvbnN0IGFyZ3VtZW50c1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuY29uc3Qgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5jb25zdCBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xuY29uc3QgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5jb25zdCBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcbmNvbnN0IGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcbmNvbnN0IGZ1bmN0aW9uVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbmNvbnN0IGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbmNvbnN0IG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuY29uc3QgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuY29uc3QgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuY29uc3QgdWludDhBcnJheVRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbmNvbnN0IHVpbnQ4Q2xhbXBlZEFycmF5VGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJztcbmNvbnN0IHVpbnQxNkFycmF5VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJztcbmNvbnN0IHVpbnQzMkFycmF5VGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcbmNvbnN0IGJpZ1VpbnQ2NEFycmF5VGFnID0gJ1tvYmplY3QgQmlnVWludDY0QXJyYXldJztcbmNvbnN0IGludDhBcnJheVRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nO1xuY29uc3QgaW50MTZBcnJheVRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJztcbmNvbnN0IGludDMyQXJyYXlUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XSc7XG5jb25zdCBiaWdJbnQ2NEFycmF5VGFnID0gJ1tvYmplY3QgQmlnSW50NjRBcnJheV0nO1xuY29uc3QgZmxvYXQzMkFycmF5VGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc7XG5jb25zdCBmbG9hdDY0QXJyYXlUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJztcblxuZXhwb3J0IHsgYXJndW1lbnRzVGFnLCBhcnJheUJ1ZmZlclRhZywgYXJyYXlUYWcsIGJpZ0ludDY0QXJyYXlUYWcsIGJpZ1VpbnQ2NEFycmF5VGFnLCBib29sZWFuVGFnLCBkYXRhVmlld1RhZywgZGF0ZVRhZywgZXJyb3JUYWcsIGZsb2F0MzJBcnJheVRhZywgZmxvYXQ2NEFycmF5VGFnLCBmdW5jdGlvblRhZywgaW50MTZBcnJheVRhZywgaW50MzJBcnJheVRhZywgaW50OEFycmF5VGFnLCBtYXBUYWcsIG51bWJlclRhZywgb2JqZWN0VGFnLCByZWdleHBUYWcsIHNldFRhZywgc3RyaW5nVGFnLCBzeW1ib2xUYWcsIHVpbnQxNkFycmF5VGFnLCB1aW50MzJBcnJheVRhZywgdWludDhBcnJheVRhZywgdWludDhDbGFtcGVkQXJyYXlUYWcgfTtcbiIsImltcG9ydCB7IGdldFN5bWJvbHMgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL2dldFN5bWJvbHMubWpzJztcbmltcG9ydCB7IGdldFRhZyB9IGZyb20gJy4uL2NvbXBhdC9faW50ZXJuYWwvZ2V0VGFnLm1qcyc7XG5pbXBvcnQgeyB1aW50MzJBcnJheVRhZywgdWludDE2QXJyYXlUYWcsIHVpbnQ4Q2xhbXBlZEFycmF5VGFnLCB1aW50OEFycmF5VGFnLCBzeW1ib2xUYWcsIHN0cmluZ1RhZywgc2V0VGFnLCByZWdleHBUYWcsIG9iamVjdFRhZywgbnVtYmVyVGFnLCBtYXBUYWcsIGludDMyQXJyYXlUYWcsIGludDE2QXJyYXlUYWcsIGludDhBcnJheVRhZywgZmxvYXQ2NEFycmF5VGFnLCBmbG9hdDMyQXJyYXlUYWcsIGRhdGVUYWcsIGJvb2xlYW5UYWcsIGRhdGFWaWV3VGFnLCBhcnJheUJ1ZmZlclRhZywgYXJyYXlUYWcsIGFyZ3VtZW50c1RhZyB9IGZyb20gJy4uL2NvbXBhdC9faW50ZXJuYWwvdGFncy5tanMnO1xuaW1wb3J0IHsgaXNQcmltaXRpdmUgfSBmcm9tICcuLi9wcmVkaWNhdGUvaXNQcmltaXRpdmUubWpzJztcbmltcG9ydCB7IGlzVHlwZWRBcnJheSB9IGZyb20gJy4uL3ByZWRpY2F0ZS9pc1R5cGVkQXJyYXkubWpzJztcblxuZnVuY3Rpb24gY2xvbmVEZWVwV2l0aChvYmosIGNsb25lVmFsdWUpIHtcbiAgICByZXR1cm4gY2xvbmVEZWVwV2l0aEltcGwob2JqLCB1bmRlZmluZWQsIG9iaiwgbmV3IE1hcCgpLCBjbG9uZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlVG9DbG9uZSwga2V5VG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2sgPSBuZXcgTWFwKCksIGNsb25lVmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZhbHVlPy4odmFsdWVUb0Nsb25lLCBrZXlUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjayk7XG4gICAgaWYgKGNsb25lZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvQ2xvbmU7XG4gICAgfVxuICAgIGlmIChzdGFjay5oYXModmFsdWVUb0Nsb25lKSkge1xuICAgICAgICByZXR1cm4gc3RhY2suZ2V0KHZhbHVlVG9DbG9uZSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHZhbHVlVG9DbG9uZS5sZW5ndGgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlVG9DbG9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmVEZWVwV2l0aEltcGwodmFsdWVUb0Nsb25lW2ldLCBpLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odmFsdWVUb0Nsb25lLCAnaW5kZXgnKSkge1xuICAgICAgICAgICAgcmVzdWx0LmluZGV4ID0gdmFsdWVUb0Nsb25lLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHZhbHVlVG9DbG9uZSwgJ2lucHV0JykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlVG9DbG9uZS5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWVUb0Nsb25lLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlZ0V4cCh2YWx1ZVRvQ2xvbmUuc291cmNlLCB2YWx1ZVRvQ2xvbmUuZmxhZ3MpO1xuICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWVUb0Nsb25lLmxhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHZhbHVlVG9DbG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlLCBrZXksIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVUb0Nsb25lKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKGNsb25lRGVlcFdpdGhJbXBsKHZhbHVlLCB1bmRlZmluZWQsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvQ2xvbmUuc3ViYXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlVG9DbG9uZSkuY29uc3RydWN0b3IpKHZhbHVlVG9DbG9uZS5sZW5ndGgpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlVG9DbG9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmVEZWVwV2l0aEltcGwodmFsdWVUb0Nsb25lW2ldLCBpLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVUb0Nsb25lLnNsaWNlKDApO1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGFWaWV3KHZhbHVlVG9DbG9uZS5idWZmZXIuc2xpY2UoMCksIHZhbHVlVG9DbG9uZS5ieXRlT2Zmc2V0LCB2YWx1ZVRvQ2xvbmUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmlsZShbdmFsdWVUb0Nsb25lXSwgdmFsdWVUb0Nsb25lLm5hbWUsIHtcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlVG9DbG9uZS50eXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEJsb2IoW3ZhbHVlVG9DbG9uZV0sIHsgdHlwZTogdmFsdWVUb0Nsb25lLnR5cGUgfSk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgdmFsdWVUb0Nsb25lLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gdmFsdWVUb0Nsb25lLm1lc3NhZ2U7XG4gICAgICAgIHJlc3VsdC5uYW1lID0gdmFsdWVUb0Nsb25lLm5hbWU7XG4gICAgICAgIHJlc3VsdC5zdGFjayA9IHZhbHVlVG9DbG9uZS5zdGFjaztcbiAgICAgICAgcmVzdWx0LmNhdXNlID0gdmFsdWVUb0Nsb25lLmNhdXNlO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlVG9DbG9uZSA9PT0gJ29iamVjdCcgJiYgaXNDbG9uZWFibGVPYmplY3QodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZVRvQ2xvbmUpKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlVG9DbG9uZTtcbn1cbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlLCBvYmplY3RUb0Nsb25lID0gdGFyZ2V0LCBzdGFjaywgY2xvbmVWYWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmtleXMoc291cmNlKSwgLi4uZ2V0U3ltYm9scyhzb3VyY2UpXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciA9PSBudWxsIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2xvbmVEZWVwV2l0aEltcGwoc291cmNlW2tleV0sIGtleSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDbG9uZWFibGVPYmplY3Qob2JqZWN0KSB7XG4gICAgc3dpdGNoIChnZXRUYWcob2JqZWN0KSkge1xuICAgICAgICBjYXNlIGFyZ3VtZW50c1RhZzpcbiAgICAgICAgY2FzZSBhcnJheVRhZzpcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgY2FzZSBib29sZWFuVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgZmxvYXQzMkFycmF5VGFnOlxuICAgICAgICBjYXNlIGZsb2F0NjRBcnJheVRhZzpcbiAgICAgICAgY2FzZSBpbnQ4QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgaW50MTZBcnJheVRhZzpcbiAgICAgICAgY2FzZSBpbnQzMkFycmF5VGFnOlxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugb2JqZWN0VGFnOlxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgY2FzZSB1aW50OEFycmF5VGFnOlxuICAgICAgICBjYXNlIHVpbnQ4Q2xhbXBlZEFycmF5VGFnOlxuICAgICAgICBjYXNlIHVpbnQxNkFycmF5VGFnOlxuICAgICAgICBjYXNlIHVpbnQzMkFycmF5VGFnOiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGNsb25lRGVlcFdpdGgsIGNsb25lRGVlcFdpdGhJbXBsLCBjb3B5UHJvcGVydGllcyB9O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwV2l0aEltcGwgfSBmcm9tICcuL2Nsb25lRGVlcFdpdGgubWpzJztcblxuZnVuY3Rpb24gY2xvbmVEZWVwKG9iaikge1xuICAgIHJldHVybiBjbG9uZURlZXBXaXRoSW1wbChvYmosIHVuZGVmaW5lZCwgb2JqLCBuZXcgTWFwKCksIHVuZGVmaW5lZCk7XG59XG5cbmV4cG9ydCB7IGNsb25lRGVlcCB9O1xuIiwiZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICBjb25zdCBoYXNPYmplY3RQcm90b3R5cGUgPSBwcm90byA9PT0gbnVsbCB8fFxuICAgICAgICBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pID09PSBudWxsO1xuICAgIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnQgeyBpc1BsYWluT2JqZWN0IH07XG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vcHJlZGljYXRlL2lzUGxhaW5PYmplY3QubWpzJztcblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBjb25zdCBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKFtdLCBzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2VWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2Uoe30sIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHNvdXJjZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IHsgbWVyZ2UgfTtcbiIsImZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKG90aGVyKSk7XG59XG5cbmV4cG9ydCB7IGVxIH07XG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9pc1BsYWluT2JqZWN0Lm1qcyc7XG5pbXBvcnQgeyBnZXRTeW1ib2xzIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRTeW1ib2xzLm1qcyc7XG5pbXBvcnQgeyBnZXRUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL2dldFRhZy5tanMnO1xuaW1wb3J0IHsgZnVuY3Rpb25UYWcsIHJlZ2V4cFRhZywgc3ltYm9sVGFnLCBkYXRlVGFnLCBib29sZWFuVGFnLCBudW1iZXJUYWcsIHN0cmluZ1RhZywgb2JqZWN0VGFnLCBlcnJvclRhZywgZGF0YVZpZXdUYWcsIGFycmF5QnVmZmVyVGFnLCBmbG9hdDY0QXJyYXlUYWcsIGZsb2F0MzJBcnJheVRhZywgYmlnSW50NjRBcnJheVRhZywgaW50MzJBcnJheVRhZywgaW50MTZBcnJheVRhZywgaW50OEFycmF5VGFnLCBiaWdVaW50NjRBcnJheVRhZywgdWludDMyQXJyYXlUYWcsIHVpbnQxNkFycmF5VGFnLCB1aW50OENsYW1wZWRBcnJheVRhZywgdWludDhBcnJheVRhZywgYXJyYXlUYWcsIHNldFRhZywgbWFwVGFnLCBhcmd1bWVudHNUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL3RhZ3MubWpzJztcbmltcG9ydCB7IGVxIH0gZnJvbSAnLi4vY29tcGF0L3V0aWwvZXEubWpzJztcblxuZnVuY3Rpb24gaXNFcXVhbFdpdGgoYSwgYiwgYXJlVmFsdWVzRXF1YWwpIHtcbiAgICByZXR1cm4gaXNFcXVhbFdpdGhJbXBsKGEsIGIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJlVmFsdWVzRXF1YWwpO1xufVxuZnVuY3Rpb24gaXNFcXVhbFdpdGhJbXBsKGEsIGIsIHByb3BlcnR5LCBhUGFyZW50LCBiUGFyZW50LCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhcmVWYWx1ZXNFcXVhbChhLCBiLCBwcm9wZXJ0eSwgYVBhcmVudCwgYlBhcmVudCwgc3RhY2spO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09IHR5cGVvZiBiKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiIHx8IE9iamVjdC5pcyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG59XG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSB7XG4gICAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGFUYWcgPSBnZXRUYWcoYSk7XG4gICAgbGV0IGJUYWcgPSBnZXRUYWcoYik7XG4gICAgaWYgKGFUYWcgPT09IGFyZ3VtZW50c1RhZykge1xuICAgICAgICBhVGFnID0gb2JqZWN0VGFnO1xuICAgIH1cbiAgICBpZiAoYlRhZyA9PT0gYXJndW1lbnRzVGFnKSB7XG4gICAgICAgIGJUYWcgPSBvYmplY3RUYWc7XG4gICAgfVxuICAgIGlmIChhVGFnICE9PSBiVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChhVGFnKSB7XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICAgICAgICBjYXNlIG51bWJlclRhZzoge1xuICAgICAgICAgICAgY29uc3QgeCA9IGEudmFsdWVPZigpO1xuICAgICAgICAgICAgY29uc3QgeSA9IGIudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIGVxKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgYm9vbGVhblRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuaXMoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKTtcbiAgICAgICAgY2FzZSByZWdleHBUYWc6IHtcbiAgICAgICAgICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGZ1bmN0aW9uVGFnOiB7XG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFjayA9IHN0YWNrID8/IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhU3RhY2sgPSBzdGFjay5nZXQoYSk7XG4gICAgY29uc3QgYlN0YWNrID0gc3RhY2suZ2V0KGIpO1xuICAgIGlmIChhU3RhY2sgIT0gbnVsbCAmJiBiU3RhY2sgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYVN0YWNrID09PSBiO1xuICAgIH1cbiAgICBzdGFjay5zZXQoYSwgYik7XG4gICAgc3RhY2suc2V0KGIsIGEpO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAoYVRhZykge1xuICAgICAgICAgICAgY2FzZSBtYXBUYWc6IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWlzRXF1YWxXaXRoSW1wbCh2YWx1ZSwgYi5nZXQoa2V5KSwga2V5LCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHNldFRhZzoge1xuICAgICAgICAgICAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFWYWx1ZXMgPSBBcnJheS5mcm9tKGEudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJWYWx1ZXMgPSBBcnJheS5mcm9tKGIudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVmFsdWUgPSBhVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGJWYWx1ZXMuZmluZEluZGV4KGJWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNFcXVhbFdpdGhJbXBsKGFWYWx1ZSwgYlZhbHVlLCB1bmRlZmluZWQsIGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYlZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQ4QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQ4Q2xhbXBlZEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50MTZBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGJpZ1VpbnQ2NEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBpbnQ4QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGludDE2QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGludDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGJpZ0ludDY0QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGZsb2F0MzJBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgZmxvYXQ2NEFycmF5VGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlcihhKSAhPT0gQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxXaXRoSW1wbChhW2ldLCBiW2ldLCBpLCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChuZXcgVWludDhBcnJheShhKSwgbmV3IFVpbnQ4QXJyYXkoYiksIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoIHx8IGEuYnl0ZU9mZnNldCAhPT0gYi5ieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChuZXcgVWludDhBcnJheShhKSwgbmV3IFVpbnQ4QXJyYXkoYiksIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGVycm9yVGFnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBvYmplY3RUYWc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmVFcXVhbEluc3RhbmNlcyA9IGFyZU9iamVjdHNFcXVhbChhLmNvbnN0cnVjdG9yLCBiLmNvbnN0cnVjdG9yLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpO1xuICAgICAgICAgICAgICAgIGlmICghYXJlRXF1YWxJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhS2V5cyA9IFsuLi5PYmplY3Qua2V5cyhhKSwgLi4uZ2V0U3ltYm9scyhhKV07XG4gICAgICAgICAgICAgICAgY29uc3QgYktleXMgPSBbLi4uT2JqZWN0LmtleXMoYiksIC4uLmdldFN5bWJvbHMoYildO1xuICAgICAgICAgICAgICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcEtleSA9IGFLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhUHJvcCA9IGFbcHJvcEtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihiLCBwcm9wS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJQcm9wID0gYltwcm9wS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsV2l0aEltcGwoYVByb3AsIGJQcm9wLCBwcm9wS2V5LCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzdGFjay5kZWxldGUoYSk7XG4gICAgICAgIHN0YWNrLmRlbGV0ZShiKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGlzRXF1YWxXaXRoIH07XG4iLCJpbXBvcnQgeyBpc0VxdWFsV2l0aCB9IGZyb20gJy4vaXNFcXVhbFdpdGgubWpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9mdW5jdGlvbi9ub29wLm1qcyc7XG5cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBpc0VxdWFsV2l0aChhLCBiLCBub29wKTtcbn1cblxuZXhwb3J0IHsgaXNFcXVhbCB9O1xuIiwiaW1wb3J0IHsgQW55U2NoZW1hIH0gZnJvbSBcImFqdlwiO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gXCJAc2luY2xhaXIvdHlwZWJveFwiO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0c0Zyb21TY2hlbWEoc2NoZW1hOiBBbnlTY2hlbWEpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyB8fCB7fTtcbiAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSA/IHNjaGVtYS5yZXF1aXJlZCA6IFtdO1xuXG4gIGNvbnNvbGUubG9nKFwiZ2V0RGVmYXVsdHNGcm9tU2NoZW1hXCIpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIHJlc3VsdFtrZXldID0ge1xuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkUHJvcHMuaW5jbHVkZXMoa2V5KSxcbiAgICAgIHZhbHVlOiB2YWx1ZS5kZWZhdWx0ID8/IFwiXCIsXG4gICAgfTtcbiAgICBpZiAoXCJub2RlVHlwZVwiIGluIHZhbHVlKSB7XG4gICAgICByZXN1bHRba2V5XS50eXBlID0gdmFsdWUubm9kZVR5cGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hKFxuICBzY2hlbWE6IFRTY2hlbWFcbik6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBwYXNzd29yZD86IGJvb2xlYW4gfT4ge1xuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBwYXNzd29yZD86IGJvb2xlYW4gfT4gPSB7fTtcbiAgY29uc3QgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICBjb25zdCByZXF1aXJlZFByb3BzID0gQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpID8gc2NoZW1hLnJlcXVpcmVkIDogW107XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgfVxuICAgIGNvbnN0IGlzUGFzc3dvcmQgPSB2YWx1ZS5mb3JtYXQgPT09IFwicGFzc3dvcmRcIjtcblxuICAgIHJlc3VsdFtrZXldID0ge1xuICAgICAgdHlwZTogaXNQYXNzd29yZCA/IFwicGFzc3dvcmRcIiA6IFwidGV4dFwiLFxuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkUHJvcHMuaW5jbHVkZXMoa2V5KSxcbiAgICAgIHZhbHVlOiB2YWx1ZS5kZWZhdWx0ID8/IFwiXCIsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZFBhdHRlcm5XaXRoUFdEKHBhdHRlcm46IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IG9yaWdpbmFsID0gbmV3IFJlZ0V4cChgXiR7cGF0dGVybn0kYCk7XG4gIGNvbnN0IHB3ZCA9IC9eX19QV0RfXyQvO1xuICBjb25zdCBjb21iaW5lZCA9IG5ldyBSZWdFeHAoYCg/OiR7b3JpZ2luYWwuc291cmNlfXwke3B3ZC5zb3VyY2V9KWApO1xuICByZXR1cm4gY29tYmluZWQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXRjaFBhc3N3b3JkUGF0dGVybnMoc2NoZW1hOiBUU2NoZW1hKTogdm9pZCB7XG4gIGlmICghKFwicHJvcGVydGllc1wiIGluIHNjaGVtYSkpIHJldHVybjtcblxuICBjb25zdCBwcm9wcyA9IChzY2hlbWEgYXMgYW55KS5wcm9wZXJ0aWVzO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgIGNvbnN0IHByb3AgPSB2YWx1ZSBhcyBhbnk7XG5cbiAgICBpZiAocHJvcC5mb3JtYXQgPT09IFwicGFzc3dvcmRcIiAmJiB0eXBlb2YgcHJvcC5wYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcm9wLnBhdHRlcm4gPSBleHRlbmRQYXR0ZXJuV2l0aFBXRChwcm9wLnBhdHRlcm4pO1xuICAgICAgcHJvcC5taW5MZW5ndGggPSAwOyAvLyBvcHRpb25hbDogYWxsb3cgXCJfX1BXRF9fXCJcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0RGVmYXVsdHNGcm9tU2NoZW1hLFxuICBnZXRDcmVkZW50aWFsc0Zyb21TY2hlbWEsXG4gIHBhdGNoUGFzc3dvcmRQYXR0ZXJucyxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKTtcbn1cbmV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGdldEVzbUV4cG9ydE5hbWU7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgfHwgKGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSBVc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9ICgwLCBjb2RlXzEuXykgYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSAoMCwgY29kZV8xLl8pIGBcXG5gO1xuY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IGNvZGVfMS5uaWwgfTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGU7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICB2YWx1ZShuYW1lT3JQcmVmaXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gKF9hID0gdmFsdWUua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5yZWY7XG4gICAgICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAodnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KTtcbiAgICAgICAgICAgIGlmIChfbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aDtcbiAgICAgICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmO1xuICAgICAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleCB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHZzLmdldChrZXlPclJlZik7XG4gICAgfVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUsIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZV8xLl8pIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZSA9IFZhbHVlU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3IgPSBleHBvcnRzLmFuZCA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5vcGVyYXRvcnMgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY29uc3Qgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGNvZGVfMiA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0ckNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0ckNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuZ2V0UHJvcGVydHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdleHBDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIucmVnZXhwQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5OYW1lOyB9IH0pO1xudmFyIHNjb3BlXzIgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZU5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZU5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YXJLaW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi52YXJLaW5kczsgfSB9KTtcbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAgIEdUOiBuZXcgY29kZV8xLl9Db2RlKFwiPlwiKSxcbiAgICBHVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI+PVwiKSxcbiAgICBMVDogbmV3IGNvZGVfMS5fQ29kZShcIjxcIiksXG4gICAgTFRFOiBuZXcgY29kZV8xLl9Db2RlKFwiPD1cIiksXG4gICAgRVE6IG5ldyBjb2RlXzEuX0NvZGUoXCI9PT1cIiksXG4gICAgTkVROiBuZXcgY29kZV8xLl9Db2RlKFwiIT09XCIpLFxuICAgIE5PVDogbmV3IGNvZGVfMS5fQ29kZShcIiFcIiksXG4gICAgT1I6IG5ldyBjb2RlXzEuX0NvZGUoXCJ8fFwiKSxcbiAgICBBTkQ6IG5ldyBjb2RlXzEuX0NvZGUoXCImJlwiKSxcbiAgICBBREQ6IG5ldyBjb2RlXzEuX0NvZGUoXCIrXCIpLFxufTtcbmNsYXNzIE5vZGUge1xuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKF9uYW1lcywgX2NvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCByaHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgfVxuICAgIHJlbmRlcih7IGVzNSwgX24gfSkge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YDtcbiAgICAgICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yaHMpXG4gICAgICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5zaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RzO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB7fSA6IHsgLi4udGhpcy5saHMubmFtZXMgfTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpO1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIG9wLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cyk7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX247XG4gICAgfVxufVxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubik7XG4gICAgICAgICAgICBlbHNlIGlmIChuKVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpO1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uO1xuICAgIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbn1cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRWxzZS5raW5kID0gXCJlbHNlXCI7XG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBub2Rlcykge1xuICAgICAgICBzdXBlcihub2Rlcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7IC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgICAgIGxldCBlID0gdGhpcy5lbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IG5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbHNlID0gKF9hID0gdGhpcy5lbHNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5JZi5raW5kID0gXCJpZlwiO1xuY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkZvci5raW5kID0gXCJmb3JcIjtcbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmcm9tLCB0byB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29wLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhc3luYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFzeW5jID0gYXN5bmM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRnVuYy5raW5kID0gXCJmdW5jXCI7XG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuUmV0dXJuLmtpbmQgPSBcInJldHVyblwiO1xuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOb2RlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuQ2F0Y2gua2luZCA9IFwiY2F0Y2hcIjtcbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GaW5hbGx5LmtpbmQgPSBcImZpbmFsbHlcIjtcbmNsYXNzIENvZGVHZW4ge1xuICAgIGNvbnN0cnVjdG9yKGV4dFNjb3BlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSh7IHBhcmVudDogZXh0U2NvcGUgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cyk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gICAgc2NvcGVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpO1xuICAgICAgICB2cy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRTY29wZVZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gICAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIF9kZWYodmFyS2luZCwgbmFtZU9yUHJlZml4LCByaHMsIGNvbnN0YW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KVxuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJocztcbiAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGNvbnN0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBsZXQobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gICAgdmFyKG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnQgY29kZVxuICAgIGFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSk7XG4gICAgfVxuICAgIC8vIGArPWAgY29kZVxuICAgIGFkZChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgZXhwb3J0cy5vcGVyYXRvcnMuQURELCByaHMpKTtcbiAgICB9XG4gICAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICAgIGNvZGUoYykge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgYygpO1xuICAgICAgICBlbHNlIGlmIChjICE9PSBjb2RlXzEubmlsKVxuICAgICAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgIG9iamVjdCguLi5rZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcIntcIl07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCIsXCIpO1xuICAgICAgICAgICAgY29kZS5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiOlwiKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmFkZENvZGVBcmcpKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsICgwLCBjb2RlXzEuXykgYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsICgwLCBjb2RlXzEuXykgYCR7YXJyfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGZvckJvZHkobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAgIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgICBmb3JJbihuYW1lT3JQcmVmaXgsIG9iaiwgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsICgwLCBjb2RlXzEuXykgYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6ICgwLCBjb2RlXzEuXykgYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogKDAsIGNvZGVfMS5fKSBgJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApO1xufVxuZnVuY3Rpb24gcGFyKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8geCA6ICgwLCBjb2RlXzEuXykgYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgIGlmIChwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZTtcbmZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcykge1xuICAgIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgICAgICAgOiBpc051bWJlclxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/ICgwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcCk7XG59XG5leHBvcnRzLmdldEVycm9yUGF0aCA9IGdldEVycm9yUGF0aDtcbmZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBtb2RlID0gaXQub3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBpZiAoIW1vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWA7XG4gICAgaWYgKG1vZGUgPT09IHRydWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKTtcbn1cbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gY2hlY2tTdHJpY3RNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0cikgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJ9XWApLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtzY2hQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8ICgwLCBjb2RlZ2VuXzEuXykgYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IERhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSkoaXQsIHR5cGVzWzBdKSk7XG4gICAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGVja1R5cGVzO1xufVxuZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZTtcbmNvbnN0IENPRVJDSUJMRSA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXMsIGNvZXJjZVR5cGVzKSB7XG4gICAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgICAgIDogW107XG59XG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT4gZ2VuXG4gICAgICAgICAgICAuYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICAgICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuLmVsc2UoKTtcbiAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgIGdlbi5lbmRJZigpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6ICgwLCBjb2RlZ2VuXzEubm90KShjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5hbmQpKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/ICgwLCBjb2RlZ2VuXzEuXykgYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9ICgwLCB1dGlsXzEudG9IYXNoKShkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImA7XG4gICAgICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogKDAsIGNvZGVnZW5fMS5fKSBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLmFuZCkoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYX19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBzY2hlbWEsIFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgICAgICBzY2hlbWFDb2RlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICAgICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPSAkeygwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5mdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiAoMCwgY29kZWdlbl8xLl8pIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+ICgwLCBjb2RlZ2VuXzEuYW5kKShub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgO1xufVxuZXhwb3J0cy5pc093blByb3BlcnR5ID0gaXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kO1xufVxuZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IHByb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLm9yKShjb25kLCAoMCwgY29kZWdlbl8xLm5vdCkoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGE7XG4gICAgY29uc3QgdmFsQ3h0ID0gW1xuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmNvbnN0IG5ld1JlZ0V4cCA9ICgwLCBjb2RlZ2VuXzEuXykgYG5ldyBSZWdFeHBgO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIGNvbnN0IHsgcmVnRXhwIH0gPSBvcHRzLmNvZGU7XG4gICAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAgICAgIGtleTogcngudG9TdHJpbmcoKSxcbiAgICAgICAgcmVmOiByeCxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZWdFeHAuY29kZSA9PT0gXCJuZXcgUmVnRXhwXCIgPyBuZXdSZWdFeHAgOiAoMCwgdXRpbF8yLnVzZUZ1bmMpKGdlbiwgcmVnRXhwKX0oJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKTtcbiAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgICAgaWYgKCFtZXJnZWQpXG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfWAsICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCA6IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IG5hbWVzXzEuZGVmYXVsdC5zZWxmO1xuICAgICAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke19hd2FpdH0keygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSgoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKSwgZXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGZ1bmNLZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICAoMCwgZXJyb3JzXzEuZXh0ZW5kRXJyb3JzKShjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHJlc3VsdCkgfSk7XG59XG5mdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgICByZXR1cm4gKCFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgICAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PiBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5leHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IHZhbGlkU2NoZW1hVHlwZTtcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKHsgc2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRoIH0sIGRlZiwga2V5d29yZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IHZhbGlkYXRlS2V5d29yZFVzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5d29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFN1YnNjaGVtYShpdCwgeyBrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZiB9KSB7XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHsoMCwgdXRpbF8xLmVzY2FwZUZyYWdtZW50KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICAgICAgICBlcnJTY2hlbWFQYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJyk7XG59XG5leHBvcnRzLmdldFN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCBpdCwgeyBkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lIH0pIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZ2VuIH0gPSBpdDtcbiAgICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyb3JQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEsIGJhc2VJZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCwgdXJpUmVzb2x2ZXIgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZTtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERhdGEgPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdm9pZCAwO1xuY29uc3QgYm9vbFNjaGVtYV8xID0gcmVxdWlyZShcIi4vYm9vbFNjaGVtYVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBkYXRhVHlwZV8yID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBrZXl3b3JkXzEgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuY29uc3Qgc3Vic2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zdWJzY2hlbWFcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+ICgwLCBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEpKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApO1xuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKTtcbiAgICAgICAgICAgIGdlbi5jb2RlKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/ICgwLCBjb2RlZ2VuXzEuXykgYCwgJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9PXt9YCA6IGNvZGVnZW5fMS5uaWx9fT17fWA7XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpIHtcbiAgICBnZW4uaWYobmFtZXNfMS5kZWZhdWx0LnZhbEN4dCwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cywgZ2VuIH0gPSBpdDtcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICAgICAgY2hlY2tOb0RlZmF1bHQoaXQpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAwKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXNldEV2YWx1YXRlZChpdCk7XG4gICAgICAgIHR5cGVBbmRLZXl3b3JkcyhpdCk7XG4gICAgICAgIHJldHVyblJlc3VsdHMoaXQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0KSB7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/ICgwLCBjb2RlZ2VuXzEuXykgYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYSkoaXQsIHZhbGlkKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHsgc2NoZW1hLCBzZWxmIH0pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBnZW4sIG9wdHMgfSA9IGl0O1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgIHVwZGF0ZUNvbnRleHQoaXQpO1xuICAgIGNoZWNrQXN5bmNTY2hlbWEoaXQpO1xuICAgIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KTtcbiAgICAvLyBUT0RPIHZhclxuICAgIGdlbi52YXIodmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgICgwLCB1dGlsXzEuY2hlY2tVbmtub3duUnVsZXMpKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykoaXQuc2NoZW1hKTtcbiAgICBjb25zdCBjaGVja2VkVHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiAoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQpIHtcbiAgICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXTtcbiAgICBpZiAoc2NoSWQpXG4gICAgICAgIGl0LmJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGA7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiBzY2hlbWFFbnYucm9vdCB9KTtcbiAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtWYWxpZGF0aW9uRXJyb3J9KCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9KWApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcyk7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoISgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXApKHNjaGVtYSwgZ3JvdXApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUpKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgICgwLCBkYXRhVHlwZV8yLnJlcG9ydFR5cGVFcnJvcikoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIG9wdHM6IHsgdXNlRGVmYXVsdHMgfSwgfSA9IGl0O1xuICAgIGlmICh1c2VEZWZhdWx0cylcbiAgICAgICAgKDAsIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMpKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbmFycm93U2NoZW1hVHlwZXMoaXQsIHR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHMpIHtcbiAgICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQsIHRzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbDtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgd2l0aFR5cGVzKSB7XG4gICAgY29uc3QgdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1R5cGUod2l0aFR5cGVzLCB0KSlcbiAgICAgICAgICAgIHRzLnB1c2godCk7XG4gICAgICAgIGVsc2UgaWYgKHdpdGhUeXBlcy5pbmNsdWRlcyhcImludGVnZXJcIikgJiYgdCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRzLnB1c2goXCJpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBpdC5kYXRhVHlwZXMgPSB0cztcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcyk7XG59XG5jbGFzcyBLZXl3b3JkQ3h0IHtcbiAgICBjb25zdHJ1Y3RvcihpdCwgZGVmLCBrZXl3b3JkKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UpKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoISgwLCBrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7KDAsIGNvZGVnZW5fMS5vcikodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgKDAsIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQpKHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudCk7XG4gICAgfVxuICAgIG9rKGNvbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGNvbmQpO1xuICAgIH1cbiAgICBzZXRQYXJhbXMob2JqLCBhc3NpZ24pIHtcbiAgICAgICAgaWYgKGFzc2lnbilcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb2JqO1xuICAgIH1cbiAgICBibG9jayRkYXRhKHZhbGlkLCBjb2RlQmxvY2ssICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZCk7XG4gICAgICAgICAgICBjb2RlQmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrJGRhdGEodmFsaWQgPSBjb2RlZ2VuXzEubmlsLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYgfSA9IHRoaXM7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSh3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZXMpKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY2hlbWEoYXBwbCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0gKDAsIHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSkodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgICgwLCBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFEYXRhKShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZSkoc3Vic2NoZW1hLCBhcHBsKTtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSB7IC4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q29udGV4dDtcbiAgICB9XG4gICAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB0b05hbWUpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB2YWxpZCkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIGNvZGVnZW5fMS5OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuS2V5d29yZEN4dCA9IEtleXdvcmRDeHQ7XG5mdW5jdGlvbiBrZXl3b3JkQ29kZShpdCwga2V5d29yZCwgZGVmLCBydWxlVHlwZSkge1xuICAgIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpO1xuICAgIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICAoMCwga2V5d29yZF8xLm1hY3JvS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxufVxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgeyBkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnIgfSkge1xuICAgIGxldCBqc29uUG9pbnRlcjtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgICAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICAgIGRhdGEgPSBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBjb25zdCB1cCA9ICttYXRjaGVzWzFdO1xuICAgICAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwID4gZGF0YUxldmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpO1xuICAgICAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgaWYgKCFqc29uUG9pbnRlcilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBsZXQgZXhwciA9IGRhdGE7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBkYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoKDAsIHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKShzZWdtZW50KSl9YDtcbiAgICAgICAgICAgIGV4cHIgPSAoMCwgY29kZWdlbl8xLl8pIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc29sdmVyLCBiYXNlSWQsIHJlZiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YCk7XG4gICAgICAgIHRoaXMubWlzc2luZ1JlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICAgICAgdGhpcy5taXNzaW5nU2NoZW1hID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkocmVzb2x2ZXIsIHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZSkoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKCgwLCByZXNvbHZlXzEuaW5saW5lUmVmKShzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSAoMCwgcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKTtcbiAgICBsZXQgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVsoMCwgdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQpKHBhcnQpXTtcbiAgICAgICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gcGFydFNjaGVtYTtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEhFWCA9IHtcbiAgMDogMCxcbiAgMTogMSxcbiAgMjogMixcbiAgMzogMyxcbiAgNDogNCxcbiAgNTogNSxcbiAgNjogNixcbiAgNzogNyxcbiAgODogOCxcbiAgOTogOSxcbiAgYTogMTAsXG4gIEE6IDEwLFxuICBiOiAxMSxcbiAgQjogMTEsXG4gIGM6IDEyLFxuICBDOiAxMixcbiAgZDogMTMsXG4gIEQ6IDEzLFxuICBlOiAxNCxcbiAgRTogMTQsXG4gIGY6IDE1LFxuICBGOiAxNVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSEVYXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIRVggfSA9IHJlcXVpcmUoJy4vc2NvcGVkQ2hhcnMnKVxuXG5jb25zdCBJUFY0X1JFRyA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdVxuXG5mdW5jdGlvbiBub3JtYWxpemVJUHY0IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJy4nKSA8IDMpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY0OiBmYWxzZSB9IH1cbiAgY29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2goSVBWNF9SRUcpIHx8IFtdXG4gIGNvbnN0IFthZGRyZXNzXSA9IG1hdGNoZXNcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICByZXR1cm4geyBob3N0OiBzdHJpcExlYWRpbmdaZXJvcyhhZGRyZXNzLCAnLicpLCBpc0lQVjQ6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBaZXJvPWZhbHNlXVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQsIGtlZXBaZXJvID0gZmFsc2UpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBzdHJpcCA9IHRydWVcbiAgZm9yIChjb25zdCBjIG9mIGlucHV0KSB7XG4gICAgaWYgKEhFWFtjXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKGMgIT09ICcwJyAmJiBzdHJpcCA9PT0gdHJ1ZSkgc3RyaXAgPSBmYWxzZVxuICAgIGlmICghc3RyaXApIGFjYyArPSBjXG4gIH1cbiAgaWYgKGtlZXBaZXJvICYmIGFjYy5sZW5ndGggPT09IDApIGFjYyA9ICcwJ1xuICByZXR1cm4gYWNjXG59XG5cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBpc1pvbmUgPSBmYWxzZVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWUgKCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNab25lID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoKSkgeyBicmVhayB9XG4gICAgICB0b2tlbkNvdW50KytcbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBpZiAodG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpIC0gMSA+PSAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBpc1pvbmUgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgZXNjYXBlZEhvc3QsIGlzSVBWNjogdHJ1ZSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBMZWFkaW5nWmVyb3MgKHN0ciwgdG9rZW4pIHtcbiAgbGV0IG91dCA9ICcnXG4gIGxldCBza2lwID0gdHJ1ZVxuICBjb25zdCBsID0gc3RyLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGMgPSBzdHJbaV1cbiAgICBpZiAoYyA9PT0gJzAnICYmIHNraXApIHtcbiAgICAgIGlmICgoaSArIDEgPD0gbCAmJiBzdHJbaSArIDFdID09PSB0b2tlbikgfHwgaSArIDEgPT09IGwpIHtcbiAgICAgICAgb3V0ICs9IGNcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjID09PSB0b2tlbikge1xuICAgICAgICBza2lwID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgICBvdXQgKz0gY1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuY29uc3QgUkRTMSA9IC9eXFwuXFwuP1xcLy91XG5jb25zdCBSRFMyID0gL15cXC9cXC4oPzpcXC98JCkvdVxuY29uc3QgUkRTMyA9IC9eXFwvXFwuXFwuKD86XFwvfCQpL3VcbmNvbnN0IFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS91XG5cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChpbnB1dCkge1xuICBjb25zdCBvdXRwdXQgPSBbXVxuXG4gIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCAnJylcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgJy8nKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCAnLycpXG4gICAgICBvdXRwdXQucG9wKClcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnLicgfHwgaW5wdXQgPT09ICcuLicpIHtcbiAgICAgIGlucHV0ID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW0gPSBpbnB1dC5tYXRjaChSRFM1KVxuICAgICAgaWYgKGltKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpbVswXVxuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKVxuICAgICAgICBvdXRwdXQucHVzaChzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgKGNvbXBvbmVudHMsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudHMuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnNjaGVtZSA9IGZ1bmMoY29tcG9uZW50cy5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSBmdW5jKGNvbXBvbmVudHMudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5ob3N0ID0gZnVuYyhjb21wb25lbnRzLmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5wYXRoID0gZnVuYyhjb21wb25lbnRzLnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMucXVlcnkgPSBmdW5jKGNvbXBvbmVudHMucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBmdW5jKGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnRzKSB7XG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGhvc3QgPSB1bmVzY2FwZShjb21wb25lbnRzLmhvc3QpXG4gICAgY29uc3QgaXBWNHJlcyA9IG5vcm1hbGl6ZUlQdjQoaG9zdClcblxuICAgIGlmIChpcFY0cmVzLmlzSVBWNCkge1xuICAgICAgaG9zdCA9IGlwVjRyZXMuaG9zdFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2NihpcFY0cmVzLmhvc3QpXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50cy5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBub3JtYWxpemVJUHY0LFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBVVUlEX1JFRyA9IC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuZnVuY3Rpb24gaXNTZWN1cmUgKHdzQ29tcG9uZW50cykge1xuICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ3dzcydcbn1cblxuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnRzKSB7XG4gIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudHMpIHtcbiAgY29uc3Qgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09ICcnKSB7XG4gICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICBjb21wb25lbnRzLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIE5PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgLy8gYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gIC8vIGFuZCBub3QgdGhlIEhUVFAgc3BlYy5cblxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1BhcnNlICh3c0NvbXBvbmVudHMpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cylcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWRcbiAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnRzKSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSAnJykge1xuICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gKHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICBjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnRzLnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5XG4gICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGlmICghdXJuQ29tcG9uZW50cy5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50cy5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudHNcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJuQ29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnRzLm5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgIHVybkNvbXBvbmVudHMubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnRzLm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXVxuICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudHMubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV1cblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHNcbiAgY29uc3QgbnNzID0gdXJuQ29tcG9uZW50cy5uc3NcbiAgdXJpQ29tcG9uZW50cy5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzXG4gIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3NcbiAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhVVVJRF9SRUcudGVzdCh1dWlkQ29tcG9uZW50cy51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudHMpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzXG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuY29uc3QgaHR0cCA9IHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCBodHRwcyA9IHtcbiAgc2NoZW1lOiAnaHR0cHMnLFxuICBkb21haW5Ib3N0OiBodHRwLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCB3cyA9IHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufVxuXG5jb25zdCB3c3MgPSB7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn1cblxuY29uc3QgdXJuID0ge1xuICBzY2hlbWU6ICd1cm4nLFxuICBwYXJzZTogdXJuUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJuU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IHVybnV1aWQgPSB7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IFNDSEVNRVMgPSB7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTQ0hFTUVTXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBub3JtYWxpemVJUHY2LCBub3JtYWxpemVJUHY0LCByZW1vdmVEb3RTZWdtZW50cywgcmVjb21wb3NlQXV0aG9yaXR5LCBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyB9ID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKVxuY29uc3QgU0NIRU1FUyA9IHJlcXVpcmUoJy4vbGliL3NjaGVtZXMnKVxuXG5mdW5jdGlvbiBub3JtYWxpemUgKHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9XG4gIHJldHVybiB1cmlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZSAoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucylcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKVxuICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVkLCB7IC4uLnNjaGVtZWxlc3NPcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzIChiYXNlLCByZWxhdGl2ZSwgb3B0aW9ucywgc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgY29uc3QgdGFyZ2V0ID0ge31cbiAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcbiAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZVxuICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGhcbiAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gJy8nICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgIH1cbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydFxuICAgIH1cbiAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWVcbiAgfVxuXG4gIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG5mdW5jdGlvbiBlcXVhbCAodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaUEgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQSA9IHVuZXNjYXBlKHVyaUEpXG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlBLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlBID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiB1cmlCID09PSAnc3RyaW5nJykge1xuICAgIHVyaUIgPSB1bmVzY2FwZSh1cmlCKVxuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQiwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQiA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUIsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB1cmlBLnRvTG93ZXJDYXNlKCkgPT09IHVyaUIudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNtcHRzLCBvcHRzKSB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB7XG4gICAgaG9zdDogY21wdHMuaG9zdCxcbiAgICBzY2hlbWU6IGNtcHRzLnNjaGVtZSxcbiAgICB1c2VyaW5mbzogY21wdHMudXNlcmluZm8sXG4gICAgcG9ydDogY21wdHMucG9ydCxcbiAgICBwYXRoOiBjbXB0cy5wYXRoLFxuICAgIHF1ZXJ5OiBjbXB0cy5xdWVyeSxcbiAgICBuaWQ6IGNtcHRzLm5pZCxcbiAgICBuc3M6IGNtcHRzLm5zcyxcbiAgICB1dWlkOiBjbXB0cy51dWlkLFxuICAgIGZyYWdtZW50OiBjbXB0cy5mcmFnbWVudCxcbiAgICByZWZlcmVuY2U6IGNtcHRzLnJlZmVyZW5jZSxcbiAgICByZXNvdXJjZU5hbWU6IGNtcHRzLnJlc291cmNlTmFtZSxcbiAgICBzZWN1cmU6IGNtcHRzLnNlY3VyZSxcbiAgICBlcnJvcjogJydcbiAgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKVxuXG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghb3B0aW9ucy5za2lwRXNjYXBlKSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSBlc2NhcGUoY29tcG9uZW50cy5wYXRoKVxuXG4gICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnRzLnBhdGggPSBjb21wb25lbnRzLnBhdGguc3BsaXQoJyUzQScpLmpvaW4oJzonKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSB1bmVzY2FwZShjb21wb25lbnRzLnBhdGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lLCAnOicpXG4gIH1cblxuICBjb25zdCBhdXRob3JpdHkgPSByZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cylcbiAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4Jykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8vJylcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpXG5cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8nKVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcyA9IGNvbXBvbmVudHMucGF0aFxuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpXG4gICAgfVxuXG4gICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvL3UsICcvJTJGJykgLy8gZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChzKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCc/JywgY29tcG9uZW50cy5xdWVyeSlcbiAgfVxuXG4gIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnIycsIGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKVxufVxuXG5jb25zdCBoZXhMb29rVXAgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMjcgfSwgKF92LCBrKSA9PiAvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShrKSkpXG5cbmZ1bmN0aW9uIG5vblNpbXBsZURvbWFpbiAodmFsdWUpIHtcbiAgbGV0IGNvZGUgPSAwXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGNvZGUgPiAxMjYgfHwgaGV4TG9va1VwW2NvZGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW14jLzo/XSspOik/KD86XFwvXFwvKCg/OihbXiMvP0BdKilAKT8oXFxbW14jLz9cXF1dK1xcXXxbXiMvOj9dKikoPzo6KFxcZCopKT8pKT8oW14jP10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxbXFxuXFxyXSkqKSk/L3VcblxuZnVuY3Rpb24gcGFyc2UgKHVyaSwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHNjaGVtZTogdW5kZWZpbmVkLFxuICAgIHVzZXJpbmZvOiB1bmRlZmluZWQsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIHBhdGg6ICcnLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnQ6IHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IGdvdEVuY29kaW5nID0gdXJpLmluZGV4T2YoJyUnKSAhPT0gLTFcbiAgbGV0IGlzSVAgPSBmYWxzZVxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09ICdzdWZmaXgnKSB1cmkgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArICc6JyA6ICcnKSArICcvLycgKyB1cmlcblxuICBjb25zdCBtYXRjaGVzID0gdXJpLm1hdGNoKFVSSV9QQVJTRSlcblxuICBpZiAobWF0Y2hlcykge1xuICAgIC8vIHN0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgcGFyc2VkLnNjaGVtZSA9IG1hdGNoZXNbMV1cbiAgICBwYXJzZWQudXNlcmluZm8gPSBtYXRjaGVzWzNdXG4gICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVzWzRdXG4gICAgcGFyc2VkLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMClcbiAgICBwYXJzZWQucGF0aCA9IG1hdGNoZXNbNl0gfHwgJydcbiAgICBwYXJzZWQucXVlcnkgPSBtYXRjaGVzWzddXG4gICAgcGFyc2VkLmZyYWdtZW50ID0gbWF0Y2hlc1s4XVxuXG4gICAgLy8gZml4IHBvcnQgbnVtYmVyXG4gICAgaWYgKGlzTmFOKHBhcnNlZC5wb3J0KSkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBtYXRjaGVzWzVdXG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgY29uc3QgaXB2NHJlc3VsdCA9IG5vcm1hbGl6ZUlQdjQocGFyc2VkLmhvc3QpXG4gICAgICBpZiAoaXB2NHJlc3VsdC5pc0lQVjQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlwdjZyZXN1bHQgPSBub3JtYWxpemVJUHY2KGlwdjRyZXN1bHQuaG9zdClcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2cmVzdWx0Lmhvc3QudG9Mb3dlckNhc2UoKVxuICAgICAgICBpc0lQID0gaXB2NnJlc3VsdC5pc0lQVjZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NHJlc3VsdC5ob3N0XG4gICAgICAgIGlzSVAgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucG9ydCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkICYmICFwYXJzZWQucGF0aCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdzYW1lLWRvY3VtZW50J1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnYWJzb2x1dGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAndXJpJ1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gcGFyc2VkLnJlZmVyZW5jZSkge1xuICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgaXMgbm90IGEgJyArIG9wdGlvbnMucmVmZXJlbmNlICsgJyByZWZlcmVuY2UuJ1xuICAgIH1cblxuICAgIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAvLyBpZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICBpZiAocGFyc2VkLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSAmJiBpc0lQID09PSBmYWxzZSAmJiBub25TaW1wbGVEb21haW4ocGFyc2VkLmhvc3QpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSBVUkwuZG9tYWluVG9BU0NJSShwYXJzZWQuaG9zdC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJOiBcIiArIGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBJUkkgLT4gVVJJXG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWVIYW5kbGVyIHx8IChzY2hlbWVIYW5kbGVyICYmICFzY2hlbWVIYW5kbGVyLnNraXBOb3JtYWxpemUpKSB7XG4gICAgICBpZiAoZ290RW5jb2RpbmcgJiYgcGFyc2VkLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5zY2hlbWUgPSB1bmVzY2FwZShwYXJzZWQuc2NoZW1lKVxuICAgICAgfVxuICAgICAgaWYgKGdvdEVuY29kaW5nICYmIHBhcnNlZC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLmhvc3QgPSB1bmVzY2FwZShwYXJzZWQuaG9zdClcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IGVzY2FwZSh1bmVzY2FwZShwYXJzZWQucGF0aCkpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLmZyYWdtZW50KSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudHMsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVyaSA9IHJlcXVpcmUoXCJmYXN0LXVyaVwiKTtcbnVyaS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgdXJpXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3VyaVwiKTtcbmNvbnN0IGRlZmF1bHRSZWdFeHAgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTtcbmRlZmF1bHRSZWdFeHAuY29kZSA9IFwibmV3IFJlZ0V4cFwiO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3gsIF95LCBfeiwgXzA7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgY29uc3QgcmVnRXhwID0gKF9jID0gKF9iID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnRXhwKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVnRXhwO1xuICAgIGNvbnN0IHVyaVJlc29sdmVyID0gKF9kID0gby51cmlSZXNvbHZlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdXJpXzEuZGVmYXVsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfZiA9IChfZSA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2ggPSAoX2cgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2sgPSAoX2ogPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBzKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfbSA9IChfbCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBzKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9wID0gKF9vID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogcykgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwIH0gOiB7IG9wdGltaXplLCByZWdFeHAgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX3EgPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX3IgPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9zID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF90ID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF91ID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF92ID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF93ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF94ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3kgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3kgIT09IHZvaWQgMCA/IF95IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF96ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfeiAhPT0gdm9pZCAwID8gX3ogOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoXzAgPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF8wICE9PSB2b2lkIDAgPyBfMCA6IHRydWUsXG4gICAgICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9ICgwLCBydWxlc18xLmdldFJ1bGVzKSgpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKTtcbiAgICAgICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0cy5mb3JtYXRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3Jkcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICAgICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKTtcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHQ7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBsZXQgX2RhdGFSZWZTY2hlbWEgPSAkZGF0YVJlZlNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hID0geyAuLi4kZGF0YVJlZlNjaGVtYSB9O1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhICYmICRkYXRhKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRLZXl3b3JkKGt3ZE9yRGVmLCBkZWYgLy8gZGVwcmVjYXRlZFxuICAgICkge1xuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpO1xuICAgICAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYuc2NoZW1hVHlwZSksXG4gICAgICAgIH07XG4gICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hLCBiYXNlSWQpO1xuICAgICAgICBzY2ggPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzIH0pO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKTtcbiAgICAgICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgICAgICAgaWYgKGJhc2VJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBfY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSB7XG4gICAgICAgIGlmIChzY2gubWV0YSlcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc2NoLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlO1xuICAgIH1cbiAgICBfY29tcGlsZU1ldGFTY2hlbWEoc2NoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzO1xuICAgICAgICB9XG4gICAgfVxufVxuQWp2LlZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0O1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IHJlZl9lcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoY2hlY2tPcHRzLCBvcHRpb25zLCBtc2csIGxvZyA9IFwiZXJyb3JcIikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBrZXk7XG4gICAgICAgIGlmIChvcHQgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY2hFbnYoa2V5UmVmKSB7XG4gICAga2V5UmVmID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsICgwLCBjb2RlZ2VuXzEuXykgYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2gpIH0gOiB7IHJlZjogc2NoIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQsIHNjaCkge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgICAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwgeyByZWY6IHNjaC52YWxpZGF0ZSB9KVxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpfWApO1xuICAgICAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KTsgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KCgwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApO1xuICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgICAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxlT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKVxuICAgICAgICAgICAgICAgIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVjczJsZW5ndGg7XG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVjczJsZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHVjczJsZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIHV0aWxfMS51c2VGdW5jKShjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/ICgwLCBjb2RlZ2VuXzEuXykgYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiAoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBwcm9wZXJ0aWVzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0UHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEoY29kZWdlbl8xLm5pbCwgbG9vcEFsbFJlcXVpcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpIHtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBwcm9wIH0pO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLm5vUHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuZXF1YWwuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXTtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4oaSwgaikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdyb25nVHlwZSA9ICgwLCBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKShpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KGl0ZW0sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosICgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hIH0gPSBjeHQ7XG4gICAgICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7KDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX0gIT09ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBsZXQgZXFsO1xuICAgICAgICBjb25zdCBnZXRFcWwgPSAoKSA9PiAoZXFsICE9PSBudWxsICYmIGVxbCAhPT0gdm9pZCAwID8gZXFsIDogKGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpKSk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcygoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoY3h0LCBleHRyYUl0ZW1zLCBzY2hBcnIgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID4gJHtpfWAsICgpID0+IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSwgdmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaCkge1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGggfSA9IGl0O1xuICAgICAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+ICgwLCBpdGVtc18xLnZhbGlkYXRlVHVwbGUpKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgICgwLCBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcykoY3h0LCBwcmVmaXhJdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkID8gKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaW4sIG1heCB9KTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBsZXQgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkLCBibG9jaykge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIF92YWxpZCk7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcGVydHl9ICYmICgkeygwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkUHJvcDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlXzEuaXNPd25Qcm9wZXJ0eSkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKShkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEubm90KShkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5IH0pO1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLlN0cixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQuY29kZShuZXcgdmFsaWRhdGVfMS5LZXl3b3JkQ3h0KGl0LCBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgKDAsIHV0aWxfMS50b0hhc2gpKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID0gb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gKDAsIHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZSkoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVyblByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsICgwLCBjb2RlZ2VuXzEuXykgYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIik7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKTtcbiAgICAgICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgdmFsaWRhdGVJZigpO1xuICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2UgfSk7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gICAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQsIHJ1bGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgkZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEub3IpKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm10KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEucmVnZXhwQ29kZSkoZm10RGVmKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LnZhbGlkYXRlYF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfSgke2RhdGF9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0udGVzdCgke2RhdGF9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgZm9ybWF0ID0gW2Zvcm1hdF8xLmRlZmF1bHRdO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IERpc2NyRXJyb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lIH0pO1xuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3AgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mTWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgaWYgKChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guJHJlZikgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gc2NoLiRyZWY7XG4gICAgICAgICAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoaXQuc2VsZiwgaXQuc2NoZW1hRW52LnJvb3QsIGl0LmJhc2VJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2ggPSBzY2guc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaXNzaW5nUmVmRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMuQWp2ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2ID0gQWp2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYoZ2V0VGltZSh0cnVlKSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSh0cnVlKSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICBcImlzby10aW1lXCI6IGZtdERlZihnZXRUaW1lKCksIGNvbXBhcmVJc29UaW1lKSxcbiAgICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKCksIGNvbXBhcmVJc29EYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSQvLFxuICAgIGlwdjY6IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pLFxuICAgIHJlZ2V4LFxuICAgIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgICB1dWlkOiAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaSxcbiAgICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gICAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gICAgXCJqc29uLXBvaW50ZXJcIjogL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLyxcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gICAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAgIC8vIGJ5dGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL2lzLWJhc2U2NFxuICAgIGJ5dGUsXG4gICAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gICAgaW50MzI6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzIgfSxcbiAgICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgICBpbnQ2NDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NCB9LFxuICAgIC8vIEMtdHlwZSBmbG9hdFxuICAgIGZsb2F0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIEMtdHlwZSBkb3VibGVcbiAgICBkb3VibGU6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgLy8gdW5jaGVja2VkIHN0cmluZyBwYXlsb2FkXG4gICAgYmluYXJ5OiB0cnVlLFxufTtcbmV4cG9ydHMuZmFzdEZvcm1hdHMgPSB7XG4gICAgLi4uZXhwb3J0cy5mdWxsRm9ybWF0cyxcbiAgICBkYXRlOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLywgY29tcGFyZURhdGUpLFxuICAgIHRpbWU6IGZtdERlZigvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkdCg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlRGF0ZVRpbWUpLFxuICAgIFwiaXNvLXRpbWVcIjogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlSXNvVGltZSksXG4gICAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSwgY29tcGFyZUlzb0RhdGVUaW1lKSxcbiAgICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gICAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAgIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn07XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5mdWxsRm9ybWF0cyk7XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAgIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBtYXRjaGVzID0gREFURS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxLCBkMikge1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGQxIDwgZDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQoPzpcXC5cXGQrKT8pKHp8KFsrLV0pKFxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pPyQvaTtcbmZ1bmN0aW9uIGdldFRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGltZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFRJTUUuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhyID0gK21hdGNoZXNbMV07XG4gICAgICAgIGNvbnN0IG1pbiA9ICttYXRjaGVzWzJdO1xuICAgICAgICBjb25zdCBzZWMgPSArbWF0Y2hlc1szXTtcbiAgICAgICAgY29uc3QgdHogPSBtYXRjaGVzWzRdO1xuICAgICAgICBjb25zdCB0elNpZ24gPSBtYXRjaGVzWzVdID09PSBcIi1cIiA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgdHpIID0gKyhtYXRjaGVzWzZdIHx8IDApO1xuICAgICAgICBjb25zdCB0ek0gPSArKG1hdGNoZXNbN10gfHwgMCk7XG4gICAgICAgIGlmICh0ekggPiAyMyB8fCB0ek0gPiA1OSB8fCAoc3RyaWN0VGltZVpvbmUgJiYgIXR6KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGhyIDw9IDIzICYmIG1pbiA8PSA1OSAmJiBzZWMgPCA2MClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBsZWFwIHNlY29uZFxuICAgICAgICBjb25zdCB1dGNNaW4gPSBtaW4gLSB0ek0gKiB0elNpZ247XG4gICAgICAgIGNvbnN0IHV0Y0hyID0gaHIgLSB0ekggKiB0elNpZ24gLSAodXRjTWluIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuICh1dGNIciA9PT0gMjMgfHwgdXRjSHIgPT09IC0xKSAmJiAodXRjTWluID09PSA1OSB8fCB1dGNNaW4gPT09IC0xKSAmJiBzZWMgPCA2MTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUoczEsIHMyKSB7XG4gICAgaWYgKCEoczEgJiYgczIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHQxID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCB0MiA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMyKS52YWx1ZU9mKCk7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0MSAtIHQyO1xufVxuZnVuY3Rpb24gY29tcGFyZUlzb1RpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZ2V0RGF0ZVRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICBjb25zdCB0aW1lID0gZ2V0VGltZShzdHJpY3RUaW1lWm9uZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgICAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZDEgPSBuZXcgRGF0ZShkdDEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCBkMiA9IG5ldyBEYXRlKGR0MikudmFsdWVPZigpO1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZDEgLSBkMjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJc29EYXRlVGltZShkdDEsIGR0Mikge1xuICAgIGlmICghKGR0MSAmJiBkdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IFtkMSwgdDFdID0gZHQxLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IFtkMiwgdDJdID0gZHQyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmVEYXRlKGQxLCBkMik7XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXMgfHwgY29tcGFyZVRpbWUodDEsIHQyKTtcbn1cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuY29uc3QgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgICAvLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sICsgb3B0aW9uYWwgcHJvdG9jb2wgKyByZXF1aXJlZCBcIi5cIlxuICAgIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuY29uc3QgQllURSA9IC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kL2dtO1xuZnVuY3Rpb24gYnl0ZShzdHIpIHtcbiAgICBCWVRFLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIEJZVEUudGVzdChzdHIpO1xufVxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKTtcbmNvbnN0IE1BWF9JTlQzMiA9IDIgKiogMzEgLSAxO1xuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnQ2NCh2YWx1ZSkge1xuICAgIC8vIEpTT04gYW5kIGphdmFzY3JpcHQgbWF4IEludCBpcyAyKio1Mywgc28gYW55IGludCB0aGF0IHBhc3NlcyBpc0ludGVnZXIgaXMgdmFsaWQgZm9yIEludDY0XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovO1xuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gICAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB2b2lkIDA7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgZm9ybWF0TWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgZm9ybWF0TWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmQ3h0ID0gbmV3IGFqdl8xLktleXdvcmRDeHQoaXQsIHNlbGYuUlVMRVMuYWxsLmZvcm1hdC5kZWZpbml0aW9uLCBcImZvcm1hdFwiKTtcbiAgICAgICAgaWYgKGZDeHQuJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10c31bJHtmQ3h0LnNjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9ICE9IFwib2JqZWN0XCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdH0gaW5zdGFuY2VvZiBSZWdFeHBgLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShmb3JtYXQpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29tcGFyZUNvZGUoZm10KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUNvZGUoZm10KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgKDAsIGxpbWl0XzEuZGVmYXVsdCkoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gKDAsIGNvZGVnZW5fMS5fKSBgcmVxdWlyZShcImFqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0c1wiKS4ke2V4cG9ydE5hbWV9YCk7XG4gICAgZm9yIChjb25zdCBmIG9mIGxpc3QpXG4gICAgICAgIGFqdi5hZGRGb3JtYXQoZiwgZnNbZl0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZm9ybWF0c1BsdWdpbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdHNQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGVcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2Vycm9yc1wiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IGtleXdvcmQgPSBcImVycm9yTWVzc2FnZVwiO1xuY29uc3QgdXNlZCA9IG5ldyBhanZfMS5OYW1lKFwiZW1Vc2VkXCIpO1xuY29uc3QgS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMgPSB7XG4gICAgcmVxdWlyZWQ6IFwibWlzc2luZ1Byb3BlcnR5XCIsXG4gICAgZGVwZW5kZW5jaWVzOiBcInByb3BlcnR5XCIsXG4gICAgZGVwZW5kZW50UmVxdWlyZWQ6IFwicHJvcGVydHlcIixcbn07XG5jb25zdCBJTlRFUlBPTEFUSU9OID0gL1xcJFxce1tefV0rXFx9LztcbmNvbnN0IElOVEVSUE9MQVRJT05fUkVQTEFDRSA9IC9cXCRcXHsoW159XSspXFx9L2c7XG5jb25zdCBFTVBUWV9TVFIgPSAvXlwiXCJcXHMqXFwrXFxzKnxcXHMqXFwrXFxzKlwiXCIkL2c7XG5mdW5jdGlvbiBlcnJvck1lc3NhZ2Uob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcIm9iamVjdFwiXSxcbiAgICAgICAgcG9zdDogdHJ1ZSxcbiAgICAgICAgY29kZShjeHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VQYXRoID0gY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpO1xuICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPiAwYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2t3ZFByb3BFcnJvcnMsIGt3ZEVycm9yc10gPSBrZXl3b3JkRXJyb3JzQ29uZmlnKHNjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrd2RFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzS2V5d29yZEVycm9ycyhrd2RFcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa3dkUHJvcEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NoaWxkRXJyb3JzKGNoaWxkRXJyb3JzQ29uZmlnKHNjaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hNZXNzYWdlID0gdHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiID8gc2NoIDogc2NoLl87XG4gICAgICAgICAgICAgICAgaWYgKHNjaE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBbGxFcnJvcnMoc2NoTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVVzZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2hpbGRFcnJvcnNDb25maWcoeyBwcm9wZXJ0aWVzLCBpdGVtcyB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzW3BdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMuaXRlbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5pdGVtc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24ga2V5d29yZEVycm9yc0NvbmZpZyhlbVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wRXJyb3JzO1xuICAgICAgICAgICAgICAgIGxldCBlcnJvcnM7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGVtU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBcInByb3BlcnRpZXNcIiB8fCBrID09PSBcIml0ZW1zXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga3dkU2NoID0gZW1TY2hlbWFba107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga3dkU2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BFcnJvcnMgfHwgKHByb3BFcnJvcnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNYXAgPSAocHJvcEVycm9yc1trXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBrd2RTY2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyTWFwW3BdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgfHwgKGVycm9ycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yc1trXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcHJvcEVycm9ycywgZXJyb3JzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkRXJyb3JzKGt3ZEVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZEVycnMgPSBnZW4uY29uc3QoXCJlbUVycm9yc1wiLCBhanZfMS5zdHJpbmdpZnkoa3dkRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdldFRlbXBsYXRlc0NvZGUoa3dkRXJyb3JzLCBzY2hlbWEpKTtcbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGdlbi5pZihtYXRjaEtleXdvcmRFcnJvcihlcnIsIGt3ZEVycnMpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2t3ZEVycnN9WyR7ZXJyfS5rZXl3b3JkXS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2luZ2xlRXJyb3IgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW4ubGV0KFwibWVzc2FnZVwiLCBhanZfMS5fIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc0Vycm9ycyA9IGdlbi5sZXQoXCJwYXJhbXNFcnJvcnNcIiwgYWp2XzEuXyBgW11gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9vcEVycm9ycygoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYobWVzc2FnZSwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHttZXNzYWdlfSArPSAke3R5cGVvZiBzaW5nbGVFcnJvciA9PSBcInN0cmluZ1wiID8gc2luZ2xlRXJyb3IgOiBcIjtcIn1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uY29kZShhanZfMS5fIGAke21lc3NhZ2V9ICs9ICR7ZXJyTWVzc2FnZShrZXkpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7cGFyYW1zRXJyb3JzfS5jb25jYXQoJHtrd2RFcnJzfVske2tleX1dKWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7IG1lc3NhZ2UsIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtwYXJhbXNFcnJvcnN9fWAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb29wRXJyb3JzKChrZXkpID0+IGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2t3ZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb29wRXJyb3JzKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2t3ZEVycnN9WyR7a2V5fV0ubGVuZ3RoYCwgKCkgPT4gYm9keShrZXkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVyck1lc3NhZ2Uoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGAke2tleX0gaW4gJHt0ZW1wbGF0ZXN9ID8gJHt0ZW1wbGF0ZXN9WyR7a2V5fV0oKSA6ICR7c2NoZW1hVmFsdWV9WyR7a2V5fV1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga3dkRXJycyA9IGdlbi5jb25zdChcImVtRXJyb3JzXCIsIGFqdl8xLnN0cmluZ2lmeShrd2RQcm9wRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzQ29kZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlc0NvZGUucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGVtcGxhdGVzQ29kZShrd2RQcm9wRXJyb3JzW2tdLCBzY2hlbWFba10pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdlbi5vYmplY3QoLi4udGVtcGxhdGVzQ29kZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZFByb3BQYXJhbXMgPSBnZW4uc2NvcGVWYWx1ZShcIm9ialwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGFqdl8xLnN0cmluZ2lmeShLRVlXT1JEX1BST1BFUlRZX1BBUkFNUyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFBhcmFtID0gZ2VuLmxldChcImVtUHJvcFBhcmFtc1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNFcnJvcnMgPSBnZW4ubGV0KFwiZW1QYXJhbXNFcnJvcnNcIik7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHByb3BQYXJhbSwgYWp2XzEuXyBgJHtrd2RQcm9wUGFyYW1zfVske2Vycn0ua2V5d29yZF1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtlcnJ9LmtleXdvcmRdWyR7ZXJyfS5wYXJhbXNbJHtwcm9wUGFyYW19XV1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHBhcmFtc0Vycm9ycywgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5mb3JJbihcImtleVByb3BcIiwgYWp2XzEuXyBgJHtrd2RFcnJzfVske2tleX1dYCwgKGtleVByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtrZXl9XVske2tleVByb3B9XWApO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9Lmxlbmd0aGAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcGwgPSBnZW4uY29uc3QoXCJ0bXBsXCIsIGFqdl8xLl8gYCR7dGVtcGxhdGVzfVske2tleX1dICYmICR7dGVtcGxhdGVzfVske2tleX1dWyR7a2V5UHJvcH1dYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhanZfMS5fIGAke3RtcGx9ID8gJHt0bXBsfSgpIDogJHtzY2hlbWFWYWx1ZX1bJHtrZXl9XVske2tleVByb3B9XWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke3BhcmFtc0Vycm9yc319YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRFcnJvcnMoY2hpbGRFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gY2hpbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcyAmJiAhaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc09iaiA9IGFqdl8xLl8gYHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCJgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXJyID0gYWp2XzEuXyBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFcnJzID0gZ2VuLmxldChcImVtRXJyb3JzXCIpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEt3ZDtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRQcm9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IGdlbi5sZXQoXCJ0ZW1wbGF0ZXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzICYmIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkS3dkID0gZ2VuLmxldChcImVtQ2hpbGRLd2RcIik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc09iaik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FyciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRLd2QsIGFqdl8xLnN0ciBgaXRlbXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChwcm9wcywgc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjaGlsZEt3ZCwgYWp2XzEuc3RyIGBwcm9wZXJ0aWVzYCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3AgPSBhanZfMS5fIGBbJHtjaGlsZEt3ZH1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLml0ZW1zYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoaXNPYmosIGNvZGVnZW5fMS5ub3QoaXNBcnIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQocHJvcHMsIHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLnByb3BlcnRpZXNgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIChjaGlsZCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtjaGlsZEVycnN9WyR7Y2hpbGR9XS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBjaGlsZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2NoaWxkRXJyc31bJHtrZXl9XS5sZW5ndGhgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWp2XzEuXyBgJHtrZXl9IGluICR7dGVtcGxhdGVzfSA/ICR7dGVtcGxhdGVzfVske2tleX1dKCkgOiAke3NjaGVtYVZhbHVlfSR7Y2hpbGRQcm9wfVske2tleX1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtjaGlsZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oYWp2XzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfS0xXS5pbnN0YW5jZVBhdGhgLCBhanZfMS5fIGAke2luc3RhbmNlUGF0aH0gKyBcIi9cIiArICR7a2V5fS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWApO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0KGNoaWxkcmVuLCBtc2dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRFcnJzLCBhanZfMS5zdHJpbmdpZnkoY2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0ZW1wbGF0ZXMsIGdldFRlbXBsYXRlc0NvZGUoY2hpbGRyZW4sIG1zZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQWxsRXJyb3JzKHNjaE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hBbnlFcnJvcihlcnIpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2VycnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7ZXJyc30ubGVuZ3RoYCwgKCkgPT4gZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRlbXBsYXRlRXhwcihzY2hNZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2VycnN9fWAsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVXNlZEVycm9ycygpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYoYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtlcnJzfS5wdXNoKCR7ZXJyfSlgKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGVycnMpLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBhanZfMS5fIGAke2VycnN9Lmxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSAke2luc3RhbmNlUGF0aH1gLCBhanZfMS5fIGAke2Vycn0ua2V5d29yZCBpbiAke2t3ZEVycnN9YCwgXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXRjaCB0aGUgZW5kIG9mIHRoZSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYC9eXFxcXC9bXlxcXFwvXSokLy50ZXN0KCR7ZXJyfS5zY2hlbWFQYXRoLnNsaWNlKCR7aXQuZXJyU2NoZW1hUGF0aC5sZW5ndGh9KSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoLmluZGV4T2YoJHtpbnN0YW5jZVBhdGh9KSA9PT0gMGApLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVnZXggPSBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiAvXlxcLyhbXi9dKikoPzpcXC98JCkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYWp2XzEuXyBgbmV3IFJlZ0V4cChcIl5cXFxcXFwvKFteL10qKSg/OlxcXFxcXC98JClcIilgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGdlbi5jb25zdChcImVtTWF0Y2hlc1wiLCBhanZfMS5fIGAke2NoaWxkUmVnZXh9LmV4ZWMoJHtlcnJ9Lmluc3RhbmNlUGF0aC5zbGljZSgke2luc3RhbmNlUGF0aH0ubGVuZ3RoKSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBnZW4uY29uc3QoXCJlbUNoaWxkXCIsIGFqdl8xLl8gYCR7bWF0Y2hlc30gJiYgJHttYXRjaGVzfVsxXS5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpYCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihhanZfMS5fIGAke2NoaWxkfSAhPT0gdW5kZWZpbmVkICYmICR7Y2hpbGR9IGluICR7Y2hpbGRFcnJzfWAsICgpID0+IHRoZW5Cb2R5KGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaEFueUVycm9yKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuYW5kKGFqdl8xLl8gYCR7ZXJyfS5rZXl3b3JkICE9PSAke2tleXdvcmR9YCwgYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgY29kZWdlbl8xLm9yKGFqdl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09ICR7aW5zdGFuY2VQYXRofWAsIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aC5pbmRleE9mKCR7aW5zdGFuY2VQYXRofSkgPT09IDBgLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoWyR7aW5zdGFuY2VQYXRofS5sZW5ndGhdID09PSBcIi9cImApKSwgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoWyR7aXQuZXJyU2NoZW1hUGF0aH0ubGVuZ3RoXSA9PT0gXCIvXCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlc0NvZGUoa2V5cywgbXNncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlc0NvZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4ga2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBtc2dzW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNDb2RlLnB1c2goW2ssIHRlbXBsYXRlRnVuYyhtc2cpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLnRlbXBsYXRlc0NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVFeHByKG1zZykge1xuICAgICAgICAgICAgICAgIGlmICghSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5zdHJpbmdpZnkobXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlXzEuc2FmZVN0cmluZ2lmeShtc2cpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKElOVEVSUE9MQVRJT05fUkVQTEFDRSwgKF9zLCBwdHIpID0+IGBcIiArIEpTT04uc3RyaW5naWZ5KCR7dmFsaWRhdGVfMS5nZXREYXRhKHB0ciwgaXQpfSkgKyBcImApXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKEVNUFRZX1NUUiwgXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVGdW5jKG1zZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGBmdW5jdGlvbigpe3JldHVybiAke3RlbXBsYXRlRXhwcihtc2cpfX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXRhU2NoZW1hOiB7XG4gICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdMaXN0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdPck1hcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHsgJHJlZjogXCIjLyRkZWZzL3N0cmluZ09yTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJGRlZnM6IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5nT3JNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgYW55T2Y6IFt7IHR5cGU6IFwic3RyaW5nXCIgfSwgeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfV0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJpbmdMaXN0OiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5jb25zdCBhanZFcnJvcnMgPSAoYWp2LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIWFqdi5vcHRzLmFsbEVycm9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LWVycm9yczogQWp2IG9wdGlvbiBhbGxFcnJvcnMgbXVzdCBiZSB0cnVlXCIpO1xuICAgIGlmIChhanYub3B0cy5qc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi1lcnJvcnM6IGFqdiBvcHRpb24ganNQcm9wZXJ0eVN5bnRheCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWp2LmFkZEtleXdvcmQoZXJyb3JNZXNzYWdlKG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG5tb2R1bGUuZXhwb3J0cyA9IGFqdkVycm9ycztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgQWp2LCB7IE9wdGlvbnMsIEVycm9yT2JqZWN0LCBFcnJvcnNUZXh0T3B0aW9ucyB9IGZyb20gXCJhanZcIjtcbmltcG9ydCBhZGRGb3JtYXRzIGZyb20gXCJhanYtZm9ybWF0c1wiO1xuaW1wb3J0IGFkZEVycm9ycyBmcm9tIFwiYWp2LWVycm9yc1wiO1xuaW1wb3J0IFR5cGVkSW5wdXRTY2hlbWEgZnJvbSBcIi4vc2NoZW1hcy90eXBlZC1pbnB1dFwiO1xuaW1wb3J0IE1lc3NhZ2VTY2hlbWEgZnJvbSBcIi4vc2NoZW1hcy9tZXNzYWdlXCI7XG5cbmNsYXNzIFZhbGlkYXRvclNlcnZpY2Uge1xuICBhanY6IEFqdjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogT3B0aW9ucykge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENPTlNUUlVDVE9SIE9GIFZBTElEQVRPUiBTRVJWSUNFXCIpO1xuICAgIHRoaXMuYWp2ID0gbmV3IEFqdih7XG4gICAgICBhbGxFcnJvcnM6IHRydWUsXG4gICAgICB1c2VEZWZhdWx0czogXCJlbXB0eVwiLFxuICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlRm9ybWF0czogdHJ1ZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGNvZXJjZVR5cGVzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKHRoaXMuYWp2LnNjaGVtYXMpO1xuXG4gICAgLy8gTk9URTogdGhpcyBwbHVnaW4gZW5hYmxlcyB1c2VycyB0byB1c2UgZm9ybWF0cyBrZXl3b3JkXG4gICAgYWRkRm9ybWF0cyh0aGlzLmFqdik7XG5cbiAgICAvLyBOT1RFOyB0aGlzIHBsdWdpbiBlbmFibGVzIHVzZXJzIHRvIGRlY2xhcmUgY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gICAgYWRkRXJyb3JzKHRoaXMuYWp2KTtcblxuICAgIHRoaXMuYWp2LmFkZEtleXdvcmQoXCJub2RlVHlwZVwiKTtcbiAgfVxuXG4gIGNyZWF0ZVZhbGlkYXRvcihzY2hlbWE6IEFueVNjaGVtYSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENSRUFURVZBTElEQVRPUlwiKTtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmFqdi5zY2hlbWFzKTtcbiAgICByZXR1cm4gdGhpcy5hanYuY29tcGlsZShzY2hlbWEpO1xuICB9XG5cbiAgcmVzZXRDYWNoZSgpIHtcbiAgICB0aGlzLmFqdi5jYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgZXJyb3JzKFxuICAgIGVycm9ycz86IEVycm9yT2JqZWN0W10gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM/OiBFcnJvcnNUZXh0T3B0aW9uc1xuICApIHtcbiAgICByZXR1cm4gdGhpcy5hanYuZXJyb3JzVGV4dChlcnJvcnMsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfTtcbiIsImltcG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi4vdmFsaWRhdG9yLXNlcnZpY2VcIjtcbi8vIE5PVEU6IHNpbmdsZXRvbiB0byB1c2UgYWp2IGNhY2hpbmcgZmVhdHVyZXNcbmNvbnN0IHZhbGlkYXRvclNlcnZpY2UgPSBuZXcgVmFsaWRhdG9yU2VydmljZSgpO1xuXG5leHBvcnQgeyB2YWxpZGF0b3JTZXJ2aWNlIH07XG4iLCJ2YXIgaGFzRXhjYXBlID0gL34vXG52YXIgZXNjYXBlTWF0Y2hlciA9IC9+WzAxXS9nXG5mdW5jdGlvbiBlc2NhcGVSZXBsYWNlciAobSkge1xuICBzd2l0Y2ggKG0pIHtcbiAgICBjYXNlICd+MSc6IHJldHVybiAnLydcbiAgICBjYXNlICd+MCc6IHJldHVybiAnfidcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGlsZGUgZXNjYXBlOiAnICsgbSlcbn1cblxuZnVuY3Rpb24gdW50aWxkZSAoc3RyKSB7XG4gIGlmICghaGFzRXhjYXBlLnRlc3Qoc3RyKSkgcmV0dXJuIHN0clxuICByZXR1cm4gc3RyLnJlcGxhY2UoZXNjYXBlTWF0Y2hlciwgZXNjYXBlUmVwbGFjZXIpXG59XG5cbmZ1bmN0aW9uIHNldHRlciAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICB2YXIgcGFydFxuICB2YXIgaGFzTmV4dFBhcnRcblxuICBmb3IgKHZhciBwID0gMSwgbGVuID0gcG9pbnRlci5sZW5ndGg7IHAgPCBsZW47KSB7XG4gICAgaWYgKHBvaW50ZXJbcF0gPT09ICdjb25zdHJ1Y3RvcicgfHwgcG9pbnRlcltwXSA9PT0gJ3Byb3RvdHlwZScgfHwgcG9pbnRlcltwXSA9PT0gJ19fcHJvdG9fXycpIHJldHVybiBvYmpcblxuICAgIHBhcnQgPSB1bnRpbGRlKHBvaW50ZXJbcCsrXSlcbiAgICBoYXNOZXh0UGFydCA9IGxlbiA+IHBcblxuICAgIGlmICh0eXBlb2Ygb2JqW3BhcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gc3VwcG9ydCBzZXR0aW5nIG9mIC8tXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIHBhcnQgPT09ICctJykge1xuICAgICAgICBwYXJ0ID0gb2JqLmxlbmd0aFxuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0IG5lc3RlZCBvYmplY3RzL2FycmF5IHdoZW4gc2V0dGluZyB2YWx1ZXNcbiAgICAgIGlmIChoYXNOZXh0UGFydCkge1xuICAgICAgICBpZiAoKHBvaW50ZXJbcF0gIT09ICcnICYmIHBvaW50ZXJbcF0gPCBJbmZpbml0eSkgfHwgcG9pbnRlcltwXSA9PT0gJy0nKSBvYmpbcGFydF0gPSBbXVxuICAgICAgICBlbHNlIG9ialtwYXJ0XSA9IHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNOZXh0UGFydCkgYnJlYWtcbiAgICBvYmogPSBvYmpbcGFydF1cbiAgfVxuXG4gIHZhciBvbGRWYWx1ZSA9IG9ialtwYXJ0XVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG9ialtwYXJ0XVxuICBlbHNlIG9ialtwYXJ0XSA9IHZhbHVlXG4gIHJldHVybiBvbGRWYWx1ZVxufVxuXG5mdW5jdGlvbiBjb21waWxlUG9pbnRlciAocG9pbnRlcikge1xuICBpZiAodHlwZW9mIHBvaW50ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcG9pbnRlciA9IHBvaW50ZXIuc3BsaXQoJy8nKVxuICAgIGlmIChwb2ludGVyWzBdID09PSAnJykgcmV0dXJuIHBvaW50ZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLicpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb2ludGVyKSkge1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwb2ludGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwYXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLiBNdXN0IGJlIG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlci4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRlclxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4nKVxufVxuXG5mdW5jdGlvbiBnZXQgKG9iaiwgcG9pbnRlcikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIHZhciBsZW4gPSBwb2ludGVyLmxlbmd0aFxuICBpZiAobGVuID09PSAxKSByZXR1cm4gb2JqXG5cbiAgZm9yICh2YXIgcCA9IDE7IHAgPCBsZW47KSB7XG4gICAgb2JqID0gb2JqW3VudGlsZGUocG9pbnRlcltwKytdKV1cbiAgICBpZiAobGVuID09PSBwKSByZXR1cm4gb2JqXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlciBmb3Igc2V0LicpXG4gIHJldHVybiBzZXR0ZXIob2JqLCBwb2ludGVyLCB2YWx1ZSlcbn1cblxuZnVuY3Rpb24gY29tcGlsZSAocG9pbnRlcikge1xuICB2YXIgY29tcGlsZWQgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGdldChvYmplY3QsIGNvbXBpbGVkKVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAob2JqZWN0LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldChvYmplY3QsIGNvbXBpbGVkLCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5nZXQgPSBnZXRcbmV4cG9ydHMuc2V0ID0gc2V0XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTAwJVwiPlxuICAgIDxOb2RlUmVkTm9kZUZvcm0gOm5vZGU9XCJsb2NhbE5vZGVcIiA6ZXJyb3JzPVwiZXJyb3JzXCIgc3R5bGU9XCJ3aWR0aDogMTAwJVwiIC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IHZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi92YWxpZGF0b3JcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbnBvaW50ZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIk5vZGVSZWRWdWVBcHBcIixcbiAgcHJvcHM6IHtcbiAgICBub2RlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGRpc2FibGVTYXZlQnV0dG9uT25FcnJvcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2FsTm9kZTogdGhpcy5ub2RlLFxuICAgICAgZXJyb3JzOiB7fSxcbiAgICB9O1xuICB9LFxuICBiZWZvcmVNb3VudCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvcih0aGlzLmxvY2FsTm9kZSk7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmxvY2FsTm9kZS5fZGVmLmRlZmF1bHRzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICB0aGlzLiR3YXRjaChcbiAgICAgICAgKCkgPT4gdGhpcy5sb2NhbE5vZGVbcHJvcF0sXG4gICAgICAgIChuZXdWYWwpID0+IHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5sb2NhbE5vZGUuX2RlZi5jcmVkZW50aWFscykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmxvY2FsTm9kZS5fZGVmLmNyZWRlbnRpYWxzW3Byb3BdLnR5cGUgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1tgaGFzXyR7cHJvcH1gXVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdID0gXCJfX1BXRF9fXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHdhdGNoKFxuICAgICAgICAoKSA9PiB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1twcm9wXSxcbiAgICAgICAgKG5ld1ZhbCwgb2xkVmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5sb2NhbE5vZGUuX2RlZi5jcmVkZW50aWFsc1twcm9wXS50eXBlID09PSBcInBhc3N3b3JkXCIgJiZcbiAgICAgICAgICAgIG5ld1ZhbCAhPT0gb2xkVmFsXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1tgaGFzXyR7cHJvcH1gXSA9ICEhbmV3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBkZWVwOiB0cnVlIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZVVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yKSB7XG4gICAgICAkKFwiI25vZGUtZGlhbG9nLW9rXCIpPy5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpLnJlbW92ZUNsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAkKFwiI25vZGUtY29uZmlnLWRpYWxvZy1va1wiKVxuICAgICAgICA/LnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSlcbiAgICAgICAgLnJlbW92ZUNsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAkKFwiI3JlZC11aS13b3Jrc3BhY2VcIikuZ2V0KDApLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJcIik7XG4gICAgICAvLyAkKFwiI3JlZC11aS13b3Jrc3BhY2UtY2hhcnQgc3ZnXCIpXG4gICAgICAvLyAgIC5nZXQoMClcbiAgICAgIC8vICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgfVxuXG4gICAgLy8gTk9URTogbXVzdCBzZXQgY3JlZGVudGlhbHMgcHJvcCB0byB1bmRlZmluZWQgdG8gYXZvaWQgdXBkYXRpbmcgaXQgdG8gX19QV0RfXyBpbiB0aGUgc2VydmVyXG4gICAgT2JqZWN0LmtleXModGhpcy5sb2NhbE5vZGUuX2RlZi5jcmVkZW50aWFscykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmxvY2FsTm9kZS5fZGVmLmNyZWRlbnRpYWxzW3Byb3BdLnR5cGUgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1tgaGFzXyR7cHJvcH1gXSAmJlxuICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1twcm9wXSA9PT0gXCJfX1BXRF9fXCJcbiAgICAgICkge1xuICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1twcm9wXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHZhbGlkYXRlKCkge1xuICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRvcih0aGlzLmxvY2FsTm9kZSk7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IHRoaXMudmFsaWRhdG9yLmVycm9ycztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnMucmVkdWNlKChhY2MsIGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXJyb3JWYWx1ZSA9IGpzb25wb2ludGVyLmdldChcbiAgICAgICAgICAgIHRoaXMubG9jYWxOb2RlLFxuICAgICAgICAgICAgZXJyb3IuaW5zdGFuY2VQYXRoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBlcnJvci5wYXJlbnRTY2hlbWEuZm9ybWF0ID09PSBcInBhc3N3b3JkXCIgJiZcbiAgICAgICAgICAgIGVycm9yVmFsdWUgPT09IFwiX19QV0RfX1wiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgXCJwYXNzd29yZCBmaWVsZHMgd2l0aCB2YWx1ZSBlcXVhbCB0byBfX1BXRF9fIHNob3VsZCBub3QgYmUgYW4gZXJyb3JcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGBub2RlJHtlcnJvci5pbnN0YW5jZVBhdGgucmVwbGFjZUFsbChcIi9cIiwgXCIuXCIpfWA7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmVycm9ycykubGVuZ3RoKSB7XG4gICAgICAgICAgJChcIiNub2RlLWRpYWxvZy1va1wiKT8ucHJvcChcImRpc2FibGVkXCIsIHRydWUpLmFkZENsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgJChcIiNub2RlLWNvbmZpZy1kaWFsb2ctb2tcIilcbiAgICAgICAgICAgID8ucHJvcChcImRpc2FibGVkXCIsIHRydWUpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAkKFwiI3JlZC11aS13b3Jrc3BhY2VcIilcbiAgICAgICAgICAgIC5nZXQoMClcbiAgICAgICAgICAgIC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiLCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgICAvLyAkKFwiI3JlZC11aS13b3Jrc3BhY2UtY2hhcnQgc3ZnXCIpXG4gICAgICAgICAgLy8gICAuZ2V0KDApXG4gICAgICAgICAgLy8gICAuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJChcIiNub2RlLWRpYWxvZy1va1wiKS5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpLnJlbW92ZUNsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICAgJChcIiNub2RlLWNvbmZpZy1kaWFsb2ctb2tcIilcbiAgICAgICAgICAgIC5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAkKFwiI3JlZC11aS13b3Jrc3BhY2VcIikuZ2V0KDApLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJcIik7XG4gICAgICAgICAgLy8gJChcIiNyZWQtdWktd29ya3NwYWNlLWNoYXJ0IHN2Z1wiKVxuICAgICAgICAgIC8vICAgLmdldCgwKVxuICAgICAgICAgIC8vICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4ubm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2Uge1xuICBjb2xvcjogdmFyKC0tcmVkLXVpLWZvcm0taW5wdXQtYm9yZGVyLWVycm9yLWNvbG9yKTtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dFxuICAgICAgcmVmPVwiaW5wdXRGaWVsZFwiXG4gICAgICA6dHlwZT1cInR5cGVcIlxuICAgICAgOnZhbHVlPVwiaW50ZXJuYWxWYWx1ZVwiXG4gICAgICA6cGxhY2Vob2xkZXI9XCJwbGFjZWhvbGRlclwiXG4gICAgICBAaW5wdXQ9XCJvbklucHV0XCJcbiAgICAgIEBmb2N1cz1cIm9uRm9jdXNcIlxuICAgICAgQGJsdXI9XCJvbkJsdXJcIlxuICAgICAgc3R5bGU9XCJmbGV4OiAxOyB3aWR0aDogMTAwJVwiXG4gICAgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCIsIFwiaW5wdXRcIl0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVybmFsVmFsdWU6IFwiXCIsXG4gICAgICBzZWNyZXRQYXR0ZXJuOiBcIioqKioqKioqKioqKipcIixcbiAgICB9O1xuICB9LFxuICBiZWZvcmVNb3VudCgpIHtcbiAgICB0aGlzLmludGVybmFsVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMub25CbHVyKCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0KGV2ZW50KSB7XG4gICAgICB0aGlzLmludGVybmFsVmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIHRoaXMuaW50ZXJuYWxWYWx1ZSk7XG4gICAgICB0aGlzLiRlbWl0KFwiaW5wdXRcIiwgdGhpcy5pbnRlcm5hbFZhbHVlKTtcbiAgICB9LFxuICAgIG9uRm9jdXMoKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMudHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9PT0gdGhpcy5zZWNyZXRQYXR0ZXJuXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gXCJcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQmx1cigpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwicGFzc3dvcmRcIiAmJiB0aGlzLnZhbHVlID09PSBcIl9fUFdEX19cIikge1xuICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB0aGlzLnNlY3JldFBhdHRlcm47XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImNvbnN0IFRZUEVEX0lOUFVUX1RZUEVTID0gW1xuICBcIm1zZ1wiLFxuICBcImZsb3dcIixcbiAgXCJnbG9iYWxcIixcbiAgXCJzdHJcIixcbiAgXCJudW1cIixcbiAgXCJib29sXCIsXG4gIFwianNvblwiLFxuICBcImJpblwiLFxuICBcInJlXCIsXG4gIFwianNvbmF0YVwiLFxuICBcImRhdGVcIixcbiAgXCJlbnZcIixcbiAgXCJub2RlXCIsXG4gIFwiY3JlZFwiLFxuXTtcblxuZXhwb3J0IHsgVFlQRURfSU5QVVRfVFlQRVMgfTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlXCI+XG4gICAgPGlucHV0XG4gICAgICB0eXBlPVwidGV4dFwiXG4gICAgICByZWY9XCJ0eXBlZElucHV0XCJcbiAgICAgIGNsYXNzPVwibm9kZS1yZWQtdHlwZWQtaW5wdXRcIlxuICAgICAgc3R5bGU9XCJmbGV4OiAxOyB3aWR0aDogMTAwJVwiXG4gICAgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IFRZUEVEX0lOUFVUX1RZUEVTIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW1dBUk5dIEludmFsaWQgdmFsdWUgZm9yICd2YWx1ZScgcHJvcGVydHkuIEl0IG11c3QgYmUgYW4gb2JqZWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9XG4gICAgICAgICAgdHlwZW9mIG9iaj8udmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iaj8udHlwZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJbV0FSTl0gSW52YWxpZCB2YWx1ZSBmb3IgJ3ZhbHVlJyBwcm9wZXJ0eS4gSXQgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCAndmFsdWUnIGFuZCAndHlwZScgcHJvcGVydGllcyBiZWluZyBzdHJpbmdzLlwiLFxuICAgICAgICAgICAgb2JqXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICAgIH0sXG4gICAgfSxcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiAoKSA9PiBUWVBFRF9JTlBVVF9UWVBFUyxcbiAgICB9LFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlwiLFxuICAgIH0sXG4gIH0sXG4gIGVtaXRzOiBbXCJ1cGRhdGU6dmFsdWVcIl0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNQcm92aWRlZFZhbHVlVHlwZVZhbGlkKCkge1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudmFsdWUudHlwZTtcbiAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy50eXBlcztcblxuICAgICAgcmV0dXJuIHR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuICAgIH0sXG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNQcm92aWRlZFZhbHVlVHlwZVZhbGlkOiB7XG4gICAgICBoYW5kbGVyKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVmFsaWRhdGlvbiBmYWlsZWQ6IHRoaXMudmFsdWUudHlwZSAoJHt0aGlzLnZhbHVlLnR5cGV9KSBtdXN0IGJlIG9uZSBvZiB0aGUgcHJvdmlkZWQgdHlwZXMgKCR7dGhpcy50eXBlc30pLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgaW5wdXRFbGVtZW50ID0gdGhpcy4kcmVmcy50eXBlZElucHV0O1xuICAgIHRoaXMuJGlucHV0ID0gJChpbnB1dEVsZW1lbnQpLnR5cGVkSW5wdXQoe1xuICAgICAgZGVmYXVsdDogdGhpcy52YWx1ZS50eXBlIHx8IHRoaXMudHlwZXNbMF0sXG4gICAgICB0eXBlczogdGhpcy50eXBlcyxcbiAgICB9KTtcblxuICAgIHRoaXMuJGlucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiLCB0aGlzLnZhbHVlLnZhbHVlIHx8IFwiXCIpO1xuICAgIHRoaXMuJGlucHV0LnR5cGVkSW5wdXQoXCJ0eXBlXCIsIHRoaXMudmFsdWUudHlwZSB8fCB0aGlzLnR5cGVzWzBdKTtcblxuICAgIC8vIE5PVEU6IHdoZW4gdHlwZWQgaW5wdXQgaXMganVzdCBhIHRleHQgaW5wdXQsIGl0IGlzbid0IGVtaXRpbmcgY2hhbmdlIHdoaWxlIHR5cGluZyBiZWNhdXNlIGl0IGlzIHVwZGF0aW5nIHRoZSB2YWx1ZSBpbiBhIGhpZGRlbiBpbnB1dFxuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGlucHV0RWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcInZhbHVlXCJdLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfSk7XG5cbiAgICAvLyBOT1RFOiB0aGlzIGVtaXRzIGNoYW5nZXMgdG8gYWxsIHR5cGVzIHRoYXQgbG9zZSBmb2N1cyB3aGVuIGNob29zaW5nIGEgdmFsdWUsIGJ1dCB0ZXh0IGlucHV0c1xuICAgIHRoaXMuJGlucHV0Lm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9KTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBlcnJvcihuZXdWYWwpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGl2ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBcIi5yZWQtdWktdHlwZWRJbnB1dC1jb250YWluZXJcIlxuICAgICAgICApO1xuICAgICAgICBpZiAobmV3VmFsKSB7XG4gICAgICAgICAgdGFyZ2V0RGl2LmNsYXNzTGlzdC5hZGQoXCJpbnB1dC1lcnJvclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXREaXYuY2xhc3NMaXN0LnJlbW92ZShcImlucHV0LWVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DaGFuZ2UoKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuJGlucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiKTtcbiAgICAgIGNvbnN0IG5ld1R5cGUgPSB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidHlwZVwiKTtcbiAgICAgIGlmICh0aGlzLnZhbHVlLnZhbHVlICE9PSBuZXdWYWx1ZSB8fCB0aGlzLnZhbHVlLnR5cGUgIT09IG5ld1R5cGUpIHtcbiAgICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCB7XG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIHR5cGU6IG5ld1R5cGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIDppZD1cImlucHV0SWRcIiBzdHlsZT1cIndpZHRoOiAxMDAlXCIgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCJdLFxuICBjb21wdXRlZDoge1xuICAgIGlucHV0UHJlZml4KCkge1xuICAgICAgcmV0dXJuIFwibm9kZS1pbnB1dC1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KTtcbiAgICB9LFxuICAgIGlucHV0SWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnB1dFByZWZpeCArIFwiLVwiICsgdGhpcy52YWx1ZTtcbiAgICB9LFxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIFJFRC5lZGl0b3IucHJlcGFyZUNvbmZpZ05vZGVTZWxlY3QoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy52YWx1ZSxcbiAgICAgIHRoaXMudHlwZSxcbiAgICAgIHRoaXMuaW5wdXRQcmVmaXhcbiAgICApO1xuXG4gICAgY29uc3QgaW5wdXQgPSAkKFwiI1wiICsgdGhpcy5pbnB1dElkKTtcbiAgICBpbnB1dC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIGlucHV0LnZhbCgpKTtcbiAgICB9KTtcblxuICAgIGlucHV0LnZhbCh0aGlzLnZhbHVlIHx8IFwiX0FERF9cIik7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgcmVmPVwic2VsZWN0SW5wdXRcIlxuICAgICAgY2xhc3M9XCJub2RlLWlucHV0LXNlbGVjdFwiXG4gICAgICBzdHlsZT1cIndpZHRoOiAxMDAlXCJcbiAgICAvPlxuICAgIDxkaXYgdi1pZj1cImVycm9yXCIgY2xhc3M9XCJub2RlLXJlZC12dWUtaW5wdXQtZXJyb3ItbWVzc2FnZVwiPlxuICAgICAge3sgZXJyb3IgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcgfCBBcnJheSxcbiAgICBvcHRpb25zOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW1dBUk5dIEludmFsaWQgdmFsdWUgZm9yICdvcHRpb25zJyBwcm9wZXJ0eS4gSXQgbXVzdCBiZSBhbiBhcnJheS5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWx1ZS5ldmVyeSgoaXRlbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgaXRlbSAhPT0gbnVsbDtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGl0ZW0uaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSAmJlxuICAgICAgICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eShcImxhYmVsXCIpICYmXG4gICAgICAgICAgICB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGl0ZW0ubGFiZWwgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIltXQVJOXSBJbnZhbGlkIHZhbHVlIGZvciAnb3B0aW9ucycgcHJvcGVydHkuIEVhY2ggaXRlbSBtdXN0IGJlIGFuIG9iamVjdCB3aXRoICd2YWx1ZScgYW5kICdsYWJlbCcgcHJvcGVydGllcyBiZWluZyBzdHJpbmdzLlwiLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcbiAgICB9LFxuICAgIG11bHRpcGxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCJdLFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IHRoaXMuJHJlZnMuc2VsZWN0SW5wdXQ7XG4gICAgY29uc3QgJHNlbGVjdElucHV0ID0gJChpbnB1dEVsZW1lbnQpO1xuICAgICRzZWxlY3RJbnB1dC50eXBlZElucHV0KHtcbiAgICAgIHR5cGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtdWx0aXBsZTogdGhpcy5tdWx0aXBsZSxcbiAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgJHNlbGVjdElucHV0LnR5cGVkSW5wdXQoXG4gICAgICBcInZhbHVlXCIsXG4gICAgICBBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpID8gdGhpcy52YWx1ZS5qb2luKFwiLFwiKSA6IHRoaXMudmFsdWVcbiAgICApO1xuICAgICRzZWxlY3RJbnB1dC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMubXVsdGlwbGVcbiAgICAgICAgPyAkc2VsZWN0SW5wdXQudHlwZWRJbnB1dChcInZhbHVlXCIpPy5zcGxpdChcIixcIilcbiAgICAgICAgOiAkc2VsZWN0SW5wdXQudHlwZWRJbnB1dChcInZhbHVlXCIpO1xuICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCBuZXdWYWx1ZSk7XG4gICAgfSk7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgcmVmPVwiY29udGFpbmVyRGl2XCIgY2xhc3M9XCJub2RlLXRleHQtZWRpdG9yLWNvbnRhaW5lclwiPlxuICAgIDxkaXYgcmVmPVwiZWRpdG9yRGl2XCIgOmlkPVwiZWRpdG9ySWRcIiBjbGFzcz1cIm5vZGUtdGV4dC1lZGl0b3JcIj48L2Rpdj5cbiAgICA8ZGl2IHYtc2hvdz1cImVycm9yXCIgY2xhc3M9XCJub2RlLXJlZC12dWUtaW5wdXQtZXJyb3ItbWVzc2FnZVwiPlxuICAgICAge3sgZXJyb3IgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgbGFuZ3VhZ2U6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiYWJhcFwiLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZExhbmd1YWdlcyA9IFtcbiAgICAgICAgICBcImFiYXBcIixcbiAgICAgICAgICBcImFwZXhcIixcbiAgICAgICAgICBcImF6Y2xpXCIsXG4gICAgICAgICAgXCJiYXRcIixcbiAgICAgICAgICBcImJpY2VwXCIsXG4gICAgICAgICAgXCJjYW1lbGlnb1wiLFxuICAgICAgICAgIFwiY2xvanVyZVwiLFxuICAgICAgICAgIFwiY29mZmVlXCIsXG4gICAgICAgICAgXCJjcHBcIixcbiAgICAgICAgICBcImNzaGFycFwiLFxuICAgICAgICAgIFwiY3NwXCIsXG4gICAgICAgICAgXCJjc3NcIixcbiAgICAgICAgICBcImN5cGhlclwiLFxuICAgICAgICAgIFwiZGFydFwiLFxuICAgICAgICAgIFwiZG9ja2VyZmlsZVwiLFxuICAgICAgICAgIFwiZWNsXCIsXG4gICAgICAgICAgXCJlbGl4aXJcIixcbiAgICAgICAgICBcImZsb3c5XCIsXG4gICAgICAgICAgXCJmcmVlbWFya2VyMlwiLFxuICAgICAgICAgIFwiZnNoYXJwXCIsXG4gICAgICAgICAgXCJnb1wiLFxuICAgICAgICAgIFwiZ3JhcGhxbFwiLFxuICAgICAgICAgIFwiaGFuZGxlYmFyc1wiLFxuICAgICAgICAgIFwiaGNsXCIsXG4gICAgICAgICAgXCJodG1sXCIsXG4gICAgICAgICAgXCJpbmlcIixcbiAgICAgICAgICBcImphdmFcIixcbiAgICAgICAgICBcImphdmFzY3JpcHRcIixcbiAgICAgICAgICBcImp1bGlhXCIsXG4gICAgICAgICAgXCJrb3RsaW5cIixcbiAgICAgICAgICBcImxlc3NcIixcbiAgICAgICAgICBcImxleG9uXCIsXG4gICAgICAgICAgXCJsaXF1aWRcIixcbiAgICAgICAgICBcImx1YVwiLFxuICAgICAgICAgIFwibTNcIixcbiAgICAgICAgICBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJtZHhcIixcbiAgICAgICAgICBcIm1pcHNcIixcbiAgICAgICAgICBcIm1zZGF4XCIsXG4gICAgICAgICAgXCJteXNxbFwiLFxuICAgICAgICAgIFwib2JqZWN0aXZlLWNcIixcbiAgICAgICAgICBcInBhc2NhbFwiLFxuICAgICAgICAgIFwicGFzY2FsaWdvXCIsXG4gICAgICAgICAgXCJwZXJsXCIsXG4gICAgICAgICAgXCJwZ3NxbFwiLFxuICAgICAgICAgIFwicGhwXCIsXG4gICAgICAgICAgXCJwbGFcIixcbiAgICAgICAgICBcInBvc3RpYXRzXCIsXG4gICAgICAgICAgXCJwb3dlcnF1ZXJ5XCIsXG4gICAgICAgICAgXCJwb3dlcnNoZWxsXCIsXG4gICAgICAgICAgXCJwcm90b2J1ZlwiLFxuICAgICAgICAgIFwicHViXCIsXG4gICAgICAgICAgXCJweXRob25cIixcbiAgICAgICAgICBcInFzaGFycFwiLFxuICAgICAgICAgIFwiclwiLFxuICAgICAgICAgIFwicmF6b3JcIixcbiAgICAgICAgICBcInJlZGlzXCIsXG4gICAgICAgICAgXCJyZWRzaGlmdFwiLFxuICAgICAgICAgIFwicmVzdHJ1Y3R1cmVkdGV4dFwiLFxuICAgICAgICAgIFwicnVieVwiLFxuICAgICAgICAgIFwicnVzdFwiLFxuICAgICAgICAgIFwic2JcIixcbiAgICAgICAgICBcInNjYWxhXCIsXG4gICAgICAgICAgXCJzY2hlbWVcIixcbiAgICAgICAgICBcInNjc3NcIixcbiAgICAgICAgICBcInNoZWxsXCIsXG4gICAgICAgICAgXCJzb2xpZGl0eVwiLFxuICAgICAgICAgIFwic29waGlhXCIsXG4gICAgICAgICAgXCJzcGFycWxcIixcbiAgICAgICAgICBcInNxbFwiLFxuICAgICAgICAgIFwic3RcIixcbiAgICAgICAgICBcInN3aWZ0XCIsXG4gICAgICAgICAgXCJzeXN0ZW12ZXJpbG9nXCIsXG4gICAgICAgICAgXCJ0Y2xcIixcbiAgICAgICAgICBcInR3aWdcIixcbiAgICAgICAgICBcInR5cGVzY3JpcHRcIixcbiAgICAgICAgICBcInR5cGVzcGVjXCIsXG4gICAgICAgICAgXCJ2YlwiLFxuICAgICAgICAgIFwid2dzbFwiLFxuICAgICAgICAgIFwieG1sXCIsXG4gICAgICAgICAgXCJ5YW1sXCIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhbGxvd2VkTGFuZ3VhZ2VzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFtXQVJOXTogSW52YWxpZCB2YWx1ZSBmb3IgJ3R5cGUnIHByb3BlcnR5OiBcIiR7dmFsdWV9XCIuIGAgK1xuICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mOiAke2FsbG93ZWRMYW5ndWFnZXMuam9pbihcIiwgXCIpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGVycm9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcIlwiLFxuICAgIH0sXG4gIH0sXG4gIGVtaXRzOiBbXCJ1cGRhdGU6dmFsdWVcIl0sXG4gIGVkaXRvcjogbnVsbCxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9ySWQ6IFwibm9kZS1yZWQtZWRpdG9yLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpLFxuICAgIH07XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5tb3VudEVkaXRvcigpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbW91bnRFZGl0b3IoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckVsID0gdGhpcy4kcmVmcy5jb250YWluZXJEaXY7XG4gICAgICAgIGNvbnN0IGVkaXRvckVsID0gdGhpcy4kcmVmcy5lZGl0b3JEaXY7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lckVsICYmIGVkaXRvckVsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZUhlaWdodCA9IGNvbnRhaW5lckVsLnN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZVdpZHRoID0gY29udGFpbmVyRWwuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBpZiAoaW5saW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLmhlaWdodCA9IGlubGluZUhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLmhlaWdodCA9IFwiMjAwcHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLndpZHRoID0gaW5saW5lV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3JFbC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUVkaXRvckluc3RhbmNlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJbTm9kZVJlZEVkaXRvcklucHV0XSBFcnJvciBzZXR0aW5nIGluaXRpYWwgZWRpdG9yIHN0eWxlOlwiLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVFZGl0b3JJbnN0YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJbTm9kZVJlZEVkaXRvcklucHV0XSBDb250YWluZXIgb3IgRWRpdG9yIGRpdiByZWZzIG5vdCBmb3VuZCBvbiBtb3VudC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlRWRpdG9ySW5zdGFuY2UoKSB7XG4gICAgICB0aGlzLmVkaXRvckluc3RhbmNlID0gUkVELmVkaXRvci5jcmVhdGVFZGl0b3Ioe1xuICAgICAgICBpZDogdGhpcy5lZGl0b3JJZCxcbiAgICAgICAgbW9kZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UuZ2V0U2Vzc2lvbigpLm9uKFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5lZGl0b3JJbnN0YW5jZS5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBiZWZvcmVVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmVkaXRvckluc3RhbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmVkaXRvckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXN0cm95aW5nIGVkaXRvciBmb3IgSUQgJHt0aGlzLmVkaXRvcklkfTpgLCBlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0ICQgZnJvbSBcImpxdWVyeVwiO1xuaW1wb3J0IHsgY3JlYXRlQXBwLCBDb21wb25lbnQsIEFwcCwgZGVmaW5lQ29tcG9uZW50IH0gZnJvbSBcInZ1ZVwiO1xuaW1wb3J0IHsgY2xvbmVEZWVwLCBpc0VxdWFsLCBtZXJnZSB9IGZyb20gXCJlcy10b29sa2l0XCI7XG5pbXBvcnQgeyBBbnlTY2hlbWEsIFZhbGlkYXRlRnVuY3Rpb24gfSBmcm9tIFwiYWp2XCI7XG5pbXBvcnQge1xuICBnZXREZWZhdWx0c0Zyb21TY2hlbWEsXG4gIGdldENyZWRlbnRpYWxzRnJvbVNjaGVtYSxcbiAgcGF0Y2hQYXNzd29yZFBhdHRlcm5zLFxufSBmcm9tIFwiLi4vdXRpbHNcIjtcblxuaW1wb3J0IE5vZGVSZWRWdWVBcHAgZnJvbSBcIi4vQXBwLnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRJbnB1dCBmcm9tIFwiLi9jb21wb25lbnRzL05vZGVSZWRJbnB1dC52dWVcIjtcbmltcG9ydCBOb2RlUmVkVHlwZWRJbnB1dCBmcm9tIFwiLi9jb21wb25lbnRzL05vZGVSZWRUeXBlZElucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRDb25maWdJbnB1dCBmcm9tIFwiLi9jb21wb25lbnRzL05vZGVSZWRDb25maWdJbnB1dC52dWVcIjtcbmltcG9ydCBOb2RlUmVkU2VsZWN0SW5wdXQgZnJvbSBcIi4vY29tcG9uZW50cy9Ob2RlUmVkU2VsZWN0SW5wdXQudnVlXCI7XG5pbXBvcnQgTm9kZVJlZEVkaXRvcklucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZEVkaXRvcklucHV0LnZ1ZVwiO1xuXG5pbXBvcnQgeyB2YWxpZGF0b3JTZXJ2aWNlIH0gZnJvbSBcIi4vdmFsaWRhdG9yXCI7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVSZWRWdWVBcHAoXG4gIG5vZGU6IGFueSxcbiAgZm9ybTogSU5vZGVGb3JtLFxuICB2YWxpZGF0b3I6IFZhbGlkYXRlRnVuY3Rpb24gfCAoKCkgPT4gYm9vbGVhbilcbik6IEFwcDxFbGVtZW50PiB7XG4gIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcChOb2RlUmVkVnVlQXBwLCB7XG4gICAgbm9kZSxcbiAgICB2YWxpZGF0b3IsXG4gICAgZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yOiBmb3JtLmRpc2FibGVTYXZlQnV0dG9uT25FcnJvcixcbiAgfSk7XG5cbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRJbnB1dFwiLCBOb2RlUmVkSW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZFR5cGVkSW5wdXRcIiwgTm9kZVJlZFR5cGVkSW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZENvbmZpZ0lucHV0XCIsIE5vZGVSZWRDb25maWdJbnB1dCk7XG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkU2VsZWN0SW5wdXRcIiwgTm9kZVJlZFNlbGVjdElucHV0KTtcbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRFZGl0b3JJbnB1dFwiLCBOb2RlUmVkRWRpdG9ySW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZE5vZGVGb3JtXCIsIGZvcm0uY29tcG9uZW50KTtcbiAgcmV0dXJuIGFwcDtcbn1cblxuZnVuY3Rpb24gbW91bnRBcHAoXG4gIG5vZGU6IGFueSxcbiAgZm9ybTogSU5vZGVGb3JtLFxuICB2YWxpZGF0b3I6IFZhbGlkYXRlRnVuY3Rpb24gfCAoKCkgPT4gYm9vbGVhbilcbikge1xuICAkKFwiI2FwcFwiKS5lbXB0eSgpO1xuICBub2RlLl9uZXdTdGF0ZSA9IGNsb25lRGVlcChub2RlKTtcbiAgbm9kZS5fYXBwID0gY3JlYXRlTm9kZVJlZFZ1ZUFwcChub2RlLl9uZXdTdGF0ZSwgZm9ybSwgdmFsaWRhdG9yKTtcbiAgbm9kZS5fYXBwLm1vdW50KFwiI2FwcFwiKTtcbn1cblxuZnVuY3Rpb24gdW5tb3VudEFwcChub2RlOiBhbnkpIHtcbiAgaWYgKG5vZGUuX2FwcCkge1xuICAgIG5vZGUuX2FwcC51bm1vdW50KCk7XG4gICAgbm9kZS5fYXBwID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROb2RlU3RhdGUobm9kZTogYW55KSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGNyZWRlbnRpYWxzOiB7fSxcbiAgfTtcbiAgT2JqZWN0LmtleXMobm9kZS5fZGVmLmRlZmF1bHRzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgc3RhdGVbcHJvcF0gPSBub2RlW3Byb3BdO1xuICB9KTtcbiAgT2JqZWN0LmtleXMobm9kZS5fZGVmLmNyZWRlbnRpYWxzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgc3RhdGUuY3JlZGVudGlhbHNbcHJvcF0gPSBub2RlLmNyZWRlbnRpYWxzW3Byb3BdO1xuXG4gICAgaWYgKG5vZGUuX2RlZi5jcmVkZW50aWFsc1twcm9wXS50eXBlID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgIHN0YXRlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdID1cbiAgICAgICAgbm9kZS5jcmVkZW50aWFsc1tgaGFzXyR7cHJvcH1gXSB8fCBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlcyhvOiBSZWNvcmQ8YW55LCBhbnk+LCBuOiBSZWNvcmQ8YW55LCBhbnk+KSB7XG4gIGNvbnN0IGNoYW5nZXMgPSB7fTtcblxuICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgY29uc3QgX28gPSBvW3Byb3BdO1xuICAgIGNvbnN0IF9uID0gbltwcm9wXTtcblxuICAgIGlmICh0eXBlb2YgX28gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IF9jaGFuZ2VzID0gZ2V0Q2hhbmdlcyhfbywgX24pO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKF9jaGFuZ2VzKS5sZW5ndGgpIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IF9jaGFuZ2VzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzRXF1YWwoX28sIF9uKSkge1xuICAgICAgY2hhbmdlc1twcm9wXSA9IF9vO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNoYW5nZXM7XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIGJ1dHRvbiBjb25maWd1cmF0aW9uIGZvciBhIG5vZGUuXG4gKlxuICogQGludGVyZmFjZSBJTm9kZUJ1dHRvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRvZ2dsZSAtIFRleHQgdG8gZGlzcGxheSB3aGVuIHRvZ2dsaW5nIHRoZSBidXR0b24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IHZvaWR9IG9uY2xpY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBib29sZWFufSBbZW5hYmxlZF0gLSBGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgYnV0dG9uIHNob3VsZCBiZVxuICogICBlbmFibGVkLiBSZXR1cm5zIHRydWUgaWYgdGhlIGJ1dHRvbiBzaG91bGQgYmUgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBib29sZWFufSBbdmlzaWJsZV0gLSBGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgYnV0dG9uIHNob3VsZCBiZVxuICogICB2aXNpYmxlLiBSZXR1cm5zIHRydWUgaWYgdGhlIGJ1dHRvbiBzaG91bGQgYmUgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5pbnRlcmZhY2UgSU5vZGVCdXR0b24ge1xuICB0b2dnbGU6IHN0cmluZztcbiAgb25jbGljazogKCkgPT4gdm9pZDtcbiAgZW5hYmxlZD86ICgpID0+IGJvb2xlYW47XG4gIHZpc2libGU/OiAoKSA9PiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSU5vZGVGb3JtIHtcbiAgY29tcG9uZW50OiBDb21wb25lbnQ7XG4gIGRpc2FibGVTYXZlQnV0dG9uT25FcnJvcj86IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIE5vZGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBub2RlIHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSBUaGUgY2F0ZWdvcnkgdGhpcyBub2RlIGJlbG9uZ3MgdG8gaW4gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXSAtIFRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpbiBoZXggZm9ybWF0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXSAtIFRoZSBpY29uIHRvIGRpc3BsYXkgZm9yIHRoaXMgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbGFiZWxdIC0gVGhlIGxhYmVsIHRvIGRpc3BsYXkgb24gdGhlIG5vZGUuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2lucHV0c10gLSBOdW1iZXIgb2YgaW5wdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW291dHB1dHNdIC0gTnVtYmVyIG9mIG91dHB1dCBwb3J0cyB0aGUgbm9kZSBzaG91bGQgaGF2ZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbcGFsZXR0ZUxhYmVsXSAtIFRoZSBsYWJlbCB0byBzaG93IGluIHRoZSBwYWxldHRlLiBDYW4gYmUgYSBzdGF0aWMgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtsYWJlbFN0eWxlXSAtIENTUyBzdHlsZSB0byBhcHBseSB0byB0aGUgbm9kZSBsYWJlbC4gQ2FuIGJlIGEgc3RhdGljIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbaW5wdXRMYWJlbHNdIC0gTGFiZWxzIGZvciB0aGUgaW5wdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW291dHB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBvdXRwdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge1wibGVmdFwifFwicmlnaHRcIn0gW2FsaWduXSAtIEFsaWdubWVudCBvZiB0aGUgbm9kZSBjb250ZW50LlxuICogQHByb3BlcnR5IHtJTm9kZUJ1dHRvbn0gW2J1dHRvbl0gLSBDb25maWd1cmF0aW9uIGZvciBhIGJ1dHRvbiBvbiB0aGUgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZUFkZF0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcGFsZXR0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZVJlbW92ZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge0NvbXBvbmVudH0gZm9ybSAtIFRoZSBmb3JtIGNvbXBvbmVudCB0byB1c2UgZm9yIGNvbmZpZ3VyaW5nIHRoZSBub2RlLlxuICogQHByb3BlcnR5IHtBbnlTY2hlbWF9IFtzY2hlbWFdIC0gU2NoZW1hIGRlZmluaXRpb24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmludGVyZmFjZSBJTm9kZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgY29sb3I/OiBzdHJpbmc7XG4gIGljb24/OiBzdHJpbmc7XG4gIGxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGlucHV0cz86IG51bWJlcjtcbiAgb3V0cHV0cz86IG51bWJlcjtcbiAgcGFsZXR0ZUxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGxhYmVsU3R5bGU/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgaW5wdXRMYWJlbHM/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgb3V0cHV0TGFiZWxzPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGFsaWduPzogXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG4gIGJ1dHRvbj86IElOb2RlQnV0dG9uO1xuICBvblBhbGV0dGVBZGQ/OiAoKSA9PiB2b2lkO1xuICBvblBhbGV0dGVSZW1vdmU/OiAoKSA9PiB2b2lkO1xuICBmb3JtOiBJTm9kZUZvcm07XG59XG5cbi8qKlxuICogUHJlcGFyZXMgYSBub2RlIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoaXMgaXMgYSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHRvIHJlZ2lzdGVyIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyB0eXBlIGF0IHJ1bnRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVDb25maWcgLSBUaGUgc3RhdGljIGNvbmZpZ3VyYXRpb24gc2hhcmVkIGJ5IGFsbCBub2RlcyBvZiB0aGlzIGtpbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbm9kZUNvbmZpZy5jYXRlZ29yeT1cInVuZGVmaW5lZFwiXSAtIFRoZSBjYXRlZ29yeSB0aGlzIG5vZGUgYmVsb25ncyB0byBpbiB0aGUgcGFsZXR0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtub2RlQ29uZmlnLmNvbG9yPVwiI0ZGRkZGRlwiXSAtIFRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpbiBoZXggZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gW25vZGVDb25maWcuaWNvbl0gLSBUaGUgaWNvbiB0byBkaXNwbGF5IGZvciB0aGlzIG5vZGVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5sYWJlbF0gLSBUaGUgbGFiZWwgdG8gZGlzcGxheSBvbiB0aGUgbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtub2RlQ29uZmlnLmlucHV0cz0wXSAtIE51bWJlciBvZiBpbnB1dCBwb3J0cyB0aGUgbm9kZSBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtub2RlQ29uZmlnLm91dHB1dHM9MF0gLSBOdW1iZXIgb2Ygb3V0cHV0IHBvcnRzIHRoZSBub2RlIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0geyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW25vZGVDb25maWcucGFsZXR0ZUxhYmVsXSAtIFRoZSBsYWJlbCB0byBzaG93IGluIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0geyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW25vZGVDb25maWcubGFiZWxTdHlsZV0gLSBDU1Mgc3R5bGUgdG8gYXBwbHkgdG8gdGhlIG5vZGUgbGFiZWxcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5pbnB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBpbnB1dCBwb3J0c1xuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLm91dHB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBvdXRwdXQgcG9ydHNcbiAqIEBwYXJhbSB7XCJsZWZ0XCJ8XCJyaWdodFwifSBbbm9kZUNvbmZpZy5hbGlnbj1cImxlZnRcIl0gLSBBbGlnbm1lbnQgb2YgdGhlIG5vZGUgY29udGVudFxuICogQHBhcmFtIHtJTm9kZUJ1dHRvbn0gW25vZGVDb25maWcuYnV0dG9uXSAtIENvbmZpZ3VyYXRpb24gZm9yIGEgYnV0dG9uIG9uIHRoZSBub2RlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtub2RlQ29uZmlnLm9uUGFsZXR0ZUFkZF0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcGFsZXR0ZVxuICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbbm9kZUNvbmZpZy5vblBhbGV0dGVSZW1vdmVdIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gbm9kZUNvbmZpZy5mb3JtIC0gVGhlIGZvcm0gY29tcG9uZW50IHRvIHVzZSBmb3IgY29uZmlndXJpbmcgdGhlIG5vZGVcbiAqIEBwYXJhbSB7QW55U2NoZW1hfSBbbm9kZUNvbmZpZy5zY2hlbWFdIC0gU2NoZW1hIGRlZmluaXRpb24gZm9yIHZhbGlkYXRpb25cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24odHlwZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPn0gLSBBIGZ1bmN0aW9uIHRoYXQgcmVnaXN0ZXJzIHRoZSBub2RlIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShvcHRpb25zOiBPbWl0PElOb2RlLCBcInR5cGVcIj4pIHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIG5vZGUgdHlwZSB3aXRoIHRoZSBOb2RlLVJFRCBydW50aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIGlkZW50aWZpZXIgZm9yIHRoZSBub2RlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gcmVnaXN0cmF0aW9uIGlzIGNvbXBsZXRlXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZXJlIGlzIGEgbmV0d29yayBlcnJvciBvciB0aGUgc2VydmVyIHJldHVybnMgYW4gZXJyb3Igc3RhdHVzXG4gICAqL1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKHR5cGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvbnJnL25vZGVzLyR7dHlwZX1gKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHNjaGVtYSB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBjb25zdCBkZWZhdWx0cyA9IGdldERlZmF1bHRzRnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgaWYgKGRlZmF1bHRzLmNyZWRlbnRpYWxzKSBkZWxldGUgZGVmYXVsdHMuY3JlZGVudGlhbHM7XG4gICAgICBjb25zdCBjcmVkZW50aWFscyA9IGdldENyZWRlbnRpYWxzRnJvbVNjaGVtYShcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXMuY3JlZGVudGlhbHNcbiAgICAgICk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiZGVmYXVsdHNcIiwgZGVmYXVsdHMpO1xuICAgICAgY29uc29sZS5sb2coXCJjcmVkZW50aWFsc1wiLCBjcmVkZW50aWFscyk7XG5cbiAgICAgIFJFRC5ub2Rlcy5yZWdpc3RlclR5cGUodHlwZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGxhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25lZGl0cHJlcGFyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IHZhbGlkYXRvclNlcnZpY2UuY3JlYXRlVmFsaWRhdG9yKHNjaGVtYSk7XG4gICAgICAgICAgbW91bnRBcHAodGhpcywgb3B0aW9ucy5mb3JtLCB2YWxpZGF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBvbmVkaXRzYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXM7XG4gICAgICAgICAgdW5tb3VudEFwcChub2RlKTtcblxuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gZ2V0Tm9kZVN0YXRlKG5vZGUuX25ld1N0YXRlKTtcbiAgICAgICAgICBjb25zdCBvbGRTdGF0ZSA9IGdldE5vZGVTdGF0ZShub2RlKTtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0Q2hhbmdlcyhvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhIU9iamVjdC5rZXlzKGNoYW5nZXMpPy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFjaGFuZ2VkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhub2RlLl9kZWYuZGVmYXVsdHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLl9kZWYuZGVmYXVsdHM/Lltwcm9wXT8udHlwZSkge1xuICAgICAgICAgICAgICBjb25zdCBvbGRDb25maWdOb2RlSWQgPSBub2RlW3Byb3BdO1xuICAgICAgICAgICAgICBjb25zdCBuZXdDb25maWdOb2RlSWQgPSBub2RlLl9uZXdTdGF0ZVtwcm9wXTtcbiAgICAgICAgICAgICAgaWYgKG9sZENvbmZpZ05vZGVJZCAhPT0gbmV3Q29uZmlnTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQ29uZmlnTm9kZSA9IFJFRC5ub2Rlcy5ub2RlKG9sZENvbmZpZ05vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9sZENvbmZpZ05vZGUgJiYgb2xkQ29uZmlnTm9kZS5fZGVmLmNhdGVnb3J5ID09PSBcImNvbmZpZ1wiKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlSW5kZXggPSBvbGRDb25maWdOb2RlLnVzZXJzLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgKF9ub2RlKSA9PiBfbm9kZS5pZCA9PT0gbm9kZS5pZFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZENvbmZpZ05vZGUudXNlcnMuc3BsaWNlKHBhcmVudE5vZGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhub2RlLl9kZWYuZGVmYXVsdHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLl9kZWYuZGVmYXVsdHM/Lltwcm9wXT8udHlwZSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdTdGF0ZUNvbmZpZ05vZGVJZCA9IG5vZGUuX25ld1N0YXRlW3Byb3BdO1xuICAgICAgICAgICAgICBjb25zdCBuZXdTdGF0ZUNvbmZpZ05vZGUgPSBSRUQubm9kZXMubm9kZShuZXdTdGF0ZUNvbmZpZ05vZGVJZCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZUNvbmZpZ05vZGUgJiZcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZUNvbmZpZ05vZGUuX2RlZi5jYXRlZ29yeSA9PT0gXCJjb25maWdcIlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlSW5kZXggPSBuZXdTdGF0ZUNvbmZpZ05vZGUudXNlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICAgKF9ub2RlKSA9PiBfbm9kZS5pZCA9PT0gbm9kZS5pZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlQ29uZmlnTm9kZS51c2Vycy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWVyZ2Uobm9kZSwgbmV3U3RhdGUpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZWQsXG4gICAgICAgICAgICBoaXN0b3J5OiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0OiBcImVkaXRcIixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgbGlua3M6IFtdLFxuICAgICAgICAgICAgICAgIGRpcnR5OiBSRUQubm9kZXMuZGlydHkoKSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VkLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvbmVkaXRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1bm1vdW50QXBwKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBvbmVkaXRkZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1bm1vdW50QXBwKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBvbnBhbGV0dGVhZGQ6IG9wdGlvbnMub25QYWxldHRlQWRkLFxuICAgICAgICBvbnBhbHR0ZXJlbW92ZTogb3B0aW9ucy5vblBhbGV0dGVSZW1vdmUsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbm9kZSB0eXBlICR7dHlwZX06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyByZWdpc3RlclR5cGUsIElOb2RlLCBJTm9kZUJ1dHRvbiB9O1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBOYW1lPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUubmFtZVwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5uYW1lJ11cIlxuICAgICAgICBwbGFjZWhvbGRlcj1cIm5hbWVcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gSG9zdG5hbWU8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5ob3N0XCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmhvc3QnXVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiaG9zdG5hbWVcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIk5vZGVSZWROb2RlRm9ybVwiLFxuICBwcm9wczoge1xuICAgIG5vZGU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG4gICAgZXJyb3JzOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiAoKSA9PiAoe30pLFxuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCIvLyBOT1RFOiB0aGlzIGZpbGUgaXMgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbi8vIE5PVEU7IHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgbnJnXG5pbXBvcnQgeyByZWdpc3RlclR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9jbGllbnRcIjtcbmltcG9ydCBjb21wb25lbnQgZnJvbSBcIi4vRm9ybS52dWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgcmVnaXN0ZXJUeXBlKHtcbiAgY2F0ZWdvcnk6IFwiY29uZmlnXCIsXG4gIGNvbG9yOiBcIiNhNmJiY2ZcIixcbiAgZm9ybToge1xuICAgIGNvbXBvbmVudCxcbiAgICBkaXNhYmxlU2F2ZUJ1dHRvbk9uRXJyb3I6IHRydWUsXG4gIH0sXG59KTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gVXNlcm5hbWU8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jcmVkZW50aWFscy51c2VybmFtZVwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jcmVkZW50aWFscy51c2VybmFtZSddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gUGFzc3dvcmQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jcmVkZW50aWFscy5wYXNzd29yZFwiXG4gICAgICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jcmVkZW50aWFscy5wYXNzd29yZCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD48aSBjbGFzcz1cImZhIGZhLXRhZ1wiPjwvaT4gUGFzc3dvcmQgMjwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmNyZWRlbnRpYWxzLnBhc3N3b3JkMlwiXG4gICAgICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5jcmVkZW50aWFscy5wYXNzd29yZDInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+VHlwZWQgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRUeXBlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLm15UHJvcGVydHlcIlxuICAgICAgICA6dHlwZXM9XCJ0eXBlc1wiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5teVByb3BlcnR5J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlR5cGVkIElucHV0IDI8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRUeXBlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLm15UHJvcGVydHkyXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm15UHJvcGVydHkyJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPkNvbmZpZyBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZENvbmZpZ0lucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLnJlbW90ZVNlcnZlclwiXG4gICAgICAgIHR5cGU9XCJyZW1vdGUtc2VydmVyXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLnJlbW90ZVNlcnZlciddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5Db25maWcgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRDb25maWdJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5hbm90aGVyUmVtb3RlU2VydmVyXCJcbiAgICAgICAgdHlwZT1cInJlbW90ZS1zZXJ2ZXJcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuYW5vdGhlclJlbW90ZVNlcnZlciddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5TZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jb3VudHJ5XCJcbiAgICAgICAgOm9wdGlvbnM9XCJjb3VudHJpZXNcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY291bnRyeSddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5NdWx0aVNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmZydWl0XCJcbiAgICAgICAgOm9wdGlvbnM9XCJmcnVpdHNcIlxuICAgICAgICBtdWx0aXBsZVxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuZnJ1aXQnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+U2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUubnVtYmVyXCJcbiAgICAgICAgOm9wdGlvbnM9XCJudW1iZXJzXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm51bWJlciddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5TZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5vYmplY3RcIlxuICAgICAgICA6b3B0aW9ucz1cIm9iamVjdHNcIlxuICAgICAgICBtdWx0aXBsZVxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUub2JqZWN0J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmFycmF5XCJcbiAgICAgICAgOm9wdGlvbnM9XCJhcnJheXNcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuYXJyYXknXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+RWRpdG9yIHdpdGggZGVmYXVsdCBoZWlnaHQgMjAwcHggYW5kIEpTT048L2xhYmVsPlxuICAgICAgPE5vZGVSZWRFZGl0b3JJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5qc29udGVzdFwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5qc29udGVzdCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5FZGl0b3Igd2l0aCBjdXN0b20gaGVpZ2h0IGFuZCBDU1M8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRFZGl0b3JJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jc3N0ZXN0XCJcbiAgICAgICAgbGFuZ3VhZ2U9XCJjc3NcIlxuICAgICAgICBzdHlsZT1cImhlaWdodDogMTAwcHhcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3NzdGVzdCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJOb2RlUmVkTm9kZUZvcm1cIixcbiAgcHJvcHM6IHtcbiAgICBub2RlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIGVycm9yczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgICB9LFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlczogW1wic3RyXCIsIFwibXNnXCIsIFwibm9kZVwiXSxcbiAgICAgIGNvdW50cmllczogW1xuICAgICAgICB7IHZhbHVlOiBcInVzYVwiLCBsYWJlbDogXCJ1c2FcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcImFyZ2VudGluYVwiLCBsYWJlbDogXCJhcmdlbnRpbmFcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcImJyYXNpbFwiLCBsYWJlbDogXCJicmFzaWxcIiB9LFxuICAgICAgXSxcbiAgICAgIGZydWl0czogW1xuICAgICAgICB7IHZhbHVlOiBcImFwcGxlXCIsIGxhYmVsOiBcImFwcGxlXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJtZWxvblwiLCBsYWJlbDogXCJtZWxvblwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwicmFzcGJlcnJ5XCIsIGxhYmVsOiBcInJhc3BiZXJyeVwiIH0sXG4gICAgICBdLFxuICAgICAgbnVtYmVyczogW1xuICAgICAgICB7IHZhbHVlOiBcIjFcIiwgbGFiZWw6IFwiMVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwiMlwiLCBsYWJlbDogXCIyXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCIzXCIsIGxhYmVsOiBcIjNcIiB9LFxuICAgICAgXSxcbiAgICAgIG9iamVjdHM6IFtcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoeyB0ZXN0OiBcImFcIiB9KSwgbGFiZWw6IFwiYVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KHsgdGVzdDogXCJiXCIgfSksIGxhYmVsOiBcImJcIiB9LFxuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeSh7IHRlc3Q6IFwiY1wiIH0pLCBsYWJlbDogXCJjXCIgfSxcbiAgICAgIF0sXG4gICAgICBhcnJheXM6IFtcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoW1wiYVwiXSksIGxhYmVsOiBcImFcIiB9LFxuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeShbXCJiXCJdKSwgbGFiZWw6IFwiYlwiIH0sXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KFtcImNcIl0pLCBsYWJlbDogXCJjXCIgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsIi8vIE5PVEU6IHRoaXMgZmlsZSBpcyBwcm92aWRlZCBieSB0aGUgdXNlclxuLy8gTk9URTsgdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBucmdcbmltcG9ydCB7IHJlZ2lzdGVyVHlwZSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL2NsaWVudFwiO1xuaW1wb3J0IGNvbXBvbmVudCBmcm9tIFwiLi9Gb3JtLnZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCByZWdpc3RlclR5cGUoe1xuICBjYXRlZ29yeTogXCJmdW5jdGlvblwiLFxuICBjb2xvcjogXCIjRkZGRkZGXCIsXG4gIGlucHV0czogMSxcbiAgb3V0cHV0czogMSxcbiAgaWNvbjogXCJ2dWUucG5nXCIsXG4gIGZvcm06IHtcbiAgICBjb21wb25lbnQsXG4gICAgZGlzYWJsZVNhdmVCdXR0b25PbkVycm9yOiB0cnVlLFxuICB9LFxuICBvblBhbGV0dGVBZGQ6ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIk5PREUgVFlQRSBSRUdJU1RFUkVEIE9OIFRIRSBQQUxFVFRFXCIpO1xuICB9LFxufSk7XG4iLCIvLyBOT1RFOiB0aGlzIHdpbGwgYmUgZ2VuZXJhdGVkIGJ5IG5yZyB1c2luZyBhIHRlbXBsYXRlXG5pbXBvcnQgcmVtb3RlU2VydmVyIGZyb20gXCIuL25vZGVzL3JlbW90ZS1zZXJ2ZXIvY2xpZW50XCI7XG5pbXBvcnQgeW91ck5vZGUgZnJvbSBcIi4vbm9kZXMveW91ci1ub2RlL2NsaWVudFwiO1xuXG4vLyBUT0RPOiBpcyB0aGVyZSBhIHVzZSBjYXNlIGZvciBjb250cm9sbGluZyB0aGUgb3JkZXIgbm9kZXMgaW4gdGhlIGVkaXRvciBhcmUgcmVnaXN0ZXJlZD9cbmFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyTm9kZXMoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3JlbW90ZVNlcnZlcihcInJlbW90ZS1zZXJ2ZXJcIiksIHlvdXJOb2RlKFwieW91ci1ub2RlXCIpXSk7XG4gICAgY29uc29sZS5sb2coXCJBbGwgbm9kZSB0eXBlcyByZWdpc3RlcmVkIGluIHBhcmFsbGVsXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWdpc3RlcmluZyBub2RlIHR5cGVzOlwiLCBlcnJvcik7XG4gIH1cbn1cblxucmVnaXN0ZXJOb2RlcygpO1xuIl0sIm5hbWVzIjpbIm1hcCIsImhhc093blByb3BlcnR5IiwiaXNQbGFpbk9iamVjdCIsImlzUmVmIiwid2FybiIsImNvbXB1dGVkIiwidHlwZSIsInNlbGYiLCJyZWFkb25seSIsIndhdGNoIiwiZWZmZWN0Iiwic2NvcGUiLCJwIiwiaWQiLCJjb21wb25lbnQiLCJ2ZXJzaW9uIiwicmVmIiwicmVzb2x2ZSIsImgiLCJjcmVhdGVBcHAiLCJyZXF1aXJlZCIsInR5cGVzIiwicmVtb3ZlMiIsInJlbW92ZSIsImlzTW9kZWxMaXN0ZW5lciIsImVtaXQiLCJuYW1lcyIsImlzQm9vbGVhbiIsImNhbWVsaXplJDEiLCJzdGFjayIsInByb3BlcnRpZXMiLCJjb2RlIiwicmVxdWlyZSQkMCIsIlVzZWRWYWx1ZVN0YXRlIiwicHJlZml4ZXMiLCJkZWYiLCJyZXF1aXJlJCQxIiwibm90IiwiaXRlbXMiLCJydWxlcyIsImtleXdvcmQiLCJUeXBlIiwibmFtZXNfMSIsInJlcXVpcmUkJDIiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkNCIsIkRhdGFUeXBlIiwiZGF0YVR5cGUiLCJwYXR0ZXJuIiwidmFsaWRhdGUiLCJlcnJvcnMiLCJfYSIsInN1YnNjaGVtYSIsImVxdWFsIiwidHJhdmVyc2UiLCJqc29uU2NoZW1hVHJhdmVyc2VNb2R1bGUiLCJsaW1pdCIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkMTAiLCJidWZmZXIiLCJ1cmkiLCJmYXN0VXJpIiwiZmFzdFVyaU1vZHVsZSIsInVyaV8xIiwiQWp2IiwiJHNjaGVtYSIsImRlZmluaXRpb25zIiwiZm9ybWF0IiwiY29yZV8xIiwiY29yZSIsInVjczJsZW5ndGhfMSIsInVjczJsZW5ndGgiLCJlcXVhbF8xIiwidmFsaWRhdGlvbl8xIiwidmFsaWRhdGlvbiIsInByZWZpeEl0ZW1zIiwicmVxdWlyZSQkMTEiLCJyZXF1aXJlJCQxMiIsInJlcXVpcmUkJDEzIiwicmVxdWlyZSQkMTQiLCJyZXF1aXJlJCQxNSIsImFwcGxpY2F0b3IiLCJmb3JtYXRfMiIsIkRpc2NyRXJyb3IiLCJvbmVPZiIsImFqdiIsImFkZEZvcm1hdHMiLCJmb3JtYXRzIiwiY29tcGlsZSIsImpzb25wb2ludGVyIiwiX3NmY19tYWluIiwiX2hvaXN0ZWRfMSIsIl9vcGVuQmxvY2siLCJfY3JlYXRlRWxlbWVudEJsb2NrIiwiX2NyZWF0ZVZOb2RlIiwiX2hvaXN0ZWRfMiIsIl9jcmVhdGVFbGVtZW50Vk5vZGUiLCJfaG9pc3RlZF8zIiwiX3RvRGlzcGxheVN0cmluZyIsIl9jcmVhdGVDb21tZW50Vk5vZGUiLCJpc09iamVjdCIsIl93aXRoRGlyZWN0aXZlcyIsIiQiLCJkZWZhdWx0cyIsIl9jcmVhdGVUZXh0Vk5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0E7QUFBQTtBQUVBLFdBQVMsUUFBUSxLQUFLO0FBQ2QsVUFBQUEsT0FBNkIsdUJBQUEsT0FBTyxJQUFJO0FBQzlDLGVBQVcsT0FBTyxJQUFJLE1BQU0sR0FBRyxFQUFHLENBQUFBLEtBQUksR0FBRyxJQUFJO0FBQ3RDLFdBQUEsQ0FBQyxRQUFRLE9BQU9BO0FBQUEsRUFDekI7QUFFQSxRQUFNLFlBQXdELE9BQU8sT0FBTyxDQUFBLENBQUU7QUFDOUUsUUFBTSxZQUF3RCxPQUFPLE9BQU8sQ0FBQSxDQUFFO0FBQzlFLFFBQU0sT0FBTyxNQUFNO0FBQUEsRUFDbkI7QUFDQSxRQUFNLEtBQUssTUFBTTtBQUNqQixRQUFNLE9BQU8sQ0FBQyxRQUFRLElBQUksV0FBVyxDQUFDLE1BQU0sT0FBTyxJQUFJLFdBQVcsQ0FBQyxNQUFNO0FBQUEsR0FDeEUsSUFBSSxXQUFXLENBQUMsSUFBSSxPQUFPLElBQUksV0FBVyxDQUFDLElBQUk7QUFDaEQsUUFBTSxrQkFBa0IsQ0FBQyxRQUFRLElBQUksV0FBVyxXQUFXO0FBQzNELFFBQU0sU0FBUyxPQUFPO0FBQ3RCLFFBQU0sU0FBUyxDQUFDLEtBQUssT0FBTztBQUNwQixVQUFBLElBQUksSUFBSSxRQUFRLEVBQUU7QUFDeEIsUUFBSSxJQUFJLElBQUk7QUFDTixVQUFBLE9BQU8sR0FBRyxDQUFDO0FBQUEsSUFBQTtBQUFBLEVBRW5CO0FBQ0EsUUFBTUMsbUJBQWlCLE9BQU8sVUFBVTtBQUN4QyxRQUFNLFNBQVMsQ0FBQyxLQUFLLFFBQVFBLGlC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VUFDM0IsT0FBTyxPQUFNLE9BQUEsZUFBQTtBQUFBOztNQUlsQkUsZ0JBUU0sT0FSTixhQVFNO0FBQUEsUUFQSixPQUFBLEVBQUEsTUFBQSxPQUFBLEVBQUEsSUFBQUEsZ0JBQWdELGVBQXpDLHFDQUFpQyxFQUFBO0FBQUEsUUFDeENGLFlBS0UsK0JBQUE7QUFBQSxVQUpRLE9BQU8sT0FBSSxLQUFDO0FBQUEsVUF6SDVCLGtCQXlIdUIsT0FBQSxFQUFBLE1BQUEsT0FBQSxFQUFBLElBQUEsWUFBQSxPQUFBLEtBQUssVUFBTztBQUFBLFVBQzNCLFVBQVM7QUFBQSxVQUNULE9BQUEsRUFBcUIsVUFBQSxRQUFBO0FBQUEsVUFDcEIsT0FBTyxPQUFNLE9BQUEsY0FBQTtBQUFBOzs7OztBQ3ZIdEIsUUFBQSxXQUFlLGFBQWE7QUFBQSxJQUMxQixVQUFVO0FBQUEsSUFDVixPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0EsMEJBQTBCO0FBQUEsSUFDNUI7QUFBQSxJQUNBLGNBQWMsTUFBTTtBQUNsQixjQUFRLElBQUkscUNBQXFDO0FBQUEsSUFBQTtBQUFBLEVBRXJELENBQUM7QUNiRCxpQkFBZSxnQkFBZ0I7QUFDekIsUUFBQTtBQUNJLFlBQUEsUUFBUSxJQUFJLENBQUMsYUFBYSxlQUFlLEdBQUcsU0FBUyxXQUFXLENBQUMsQ0FBQztBQUN4RSxjQUFRLElBQUksdUNBQXVDO0FBQUEsYUFDNUMsT0FBTztBQUNOLGNBQUEsTUFBTSxpQ0FBaUMsS0FBSztBQUFBLElBQUE7QUFBQSxFQUV4RDtBQUVBLGdCQUFjOzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5Ml19

//# sourceURL=src/client.js
</script>
