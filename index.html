<script type="text/html" data-template-name="remote-server">
  <div id="app"></div>
</script>

<script type="text/html" data-template-name="your-node">
  <div id="app"></div>
</script>

<style>
  /* TODO: add this as a global vue app style instead */
  .node-red-vue-input-error-message {
    color: var(--red-ui-form-input-border-error-color);
  }
</style>

<!-- TODO: create a /core/client lib and change to ts -->
<script type="text/javascript">
  RED.events.on("deploy", () => {
    RED.nodes.eachNode(function (node) {
      console.log("RESET INITIAL STATE");
      node._initial_state = null;
    });
  });

  function getChanges(o, n) {
    const changes = {};

    console.log(o);
    console.log(n);

    Object.keys(o).forEach((prop) => {
      const _o = o[prop];
      const _n = n[prop];

      if (typeof _o === "object") {
        const _changes = getChanges(_o, _n);
        if (Object.keys(_changes).length) {
          changes[prop] = _changes;
        }
      } else if (!_.isEqual(_o, _n)) {
        changes[prop] = _o;
      }
    });

    return changes;
  }

  function createValidator(schema) {
    const ajv = new ajv7({
      allErrors: true,
      useDefaults: "empty",
    });

    return ajv.compile(schema);
  }

  function createApp(node, form, validator) {
    const NodeRedInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input
          ref="inputField"
          :type="type"
          :value="internalValue"
          :placeholder="placeholder"
          @input="onInput"
          @focus="onFocus"
          @blur="onBlur"
          style="flex: 1; width: 100%;"
        />
        <div v-if="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String,
        type: {
          type: String,
          default: "text",
          validator: function (value) {
            return ["text", "password"].includes(value);
          },
        },
        placeholder: String,
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value", "input"],
      data() {
        return {
          internalValue: "",
          secretPattern: "*************",
        };
      },
      beforeMount() {
        this.internalValue = this.value;
        this.onBlur();
      },
      methods: {
        onInput(event) {
          this.internalValue = event.target.value;
          this.$emit("update:value", this.internalValue);
          this.$emit("input", this.internalValue);
        },
        onFocus() {
          if (
            this.type === "password" &&
            this.internalValue === this.secretPattern
          ) {
            this.internalValue = "";
          }
        },
        onBlur() {
          if (this.type === "password" && this.value === "__PWD__") {
            this.internalValue = this.secretPattern;
          }
        },
      },
    };

    const NodeRedTypedInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input type="text" ref="typedInput" class="node-red-typed-input" style="flex: 1; width: 100%;"/>
        <div v-if="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: {
          type: Object,
          required: true,
          validator: function (obj) {
            if (!typeof obj === "object") {
              console.warn("Prop 'value' must be an object.");
              return false;
            }
            const isValid =
              obj.hasOwnProperty("value") &&
              obj.hasOwnProperty("type") &&
              typeof obj.value === "string" &&
              typeof obj.type === "string";
            if (!isValid) {
              console.warn(
                "Validation failed for prop 'value': It must be an object with 'value' and 'type' properties being strings.",
                obj
              );
            }
            return isValid;
          },
        },
        types: {
          type: Array,
          default: () => [
            "msg",
            "flow",
            "global",
            "str",
            "num",
            "bool",
            "json",
            "bin",
            "re",
            "jsonata",
            "date",
            "env",
            "node",
            "cred",
          ],
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      computed: {
        isProvidedValueTypeValid() {
          const type = this.value.type;
          const types = this.types;

          return types.includes(type);
        },
      },
      watch: {
        isProvidedValueTypeValid: {
          handler(newValue) {
            if (!newValue) {
              console.warn(
                `Validation failed: this.value.type (${this.value.type}) must be one of the provided types (${this.types}).`
              );
            }
          },
          immediate: true,
        },
      },
      mounted() {
        const inputElement = this.$refs.typedInput;
        this.$input = $(inputElement).typedInput({
          default: this.value.type || this.types[0],
          types: this.types,
        });

        this.$input.typedInput("value", this.value.value || "");
        this.$input.typedInput("type", this.value.type || this.types[0]);

        // NOTE: when typed input is just a text input, it isn't emiting change while typing because it is updating the value in a hidden input
        this.$nextTick(() => {
          const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.attributeName === "value") {
                this.onChange();
              }
            }
          });

          observer.observe(inputElement, {
            attributes: true,
            attributeFilter: ["value"],
          });

          this._observer = observer;
        });

        // NOTE: this emits changes to all types that lose focus when choosing a value, but text inputs
        this.$input.on("change", () => {
          this.onChange();
        });
      },
      watch: {
        error(newVal) {
          this.$nextTick(() => {
            const targetDiv = this.$el.querySelector(
              ".red-ui-typedInput-container"
            );
            if (newVal) {
              targetDiv.classList.add("input-error");
            } else {
              targetDiv.classList.remove("input-error");
            }
          });
        },
      },
      methods: {
        onChange() {
          const newValue = this.$input.typedInput("value");
          const newType = this.$input.typedInput("type");
          if (this.value.value !== newValue || this.value.type !== newType) {
            this.$emit("update:value", {
              value: newValue,
              type: newType,
            });
          }
        },
      },
    };

    const NodeRedConfigInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input type="text" :id="inputId" style="width: 100%"/>
        <div v-if="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String,
        type: String,
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      computed: {
        inputPrefix() {
          return "node-input-" + Math.random().toString(36).substring(2, 9);
        },
        inputId() {
          return this.inputPrefix + "-" + this.value;
        },
      },
      mounted() {
        console.log(this);
        RED.editor.prepareConfigNodeSelect(
          this,
          this.value,
          this.type,
          this.inputPrefix
        );

        const input = $("#" + this.inputId);
        input.on("change", () => {
          this.$emit("update:value", input.val());
        });

        input.val(this.value || "_ADD_");
      },
    };

    const NodeRedSelectInput = {
      template: `
      <div style="display: flex; flex-direction: column; width: 100%;">
        <input type="text" ref="selectInput" class="node-input-select" style="width: 100%"/>
        <div v-if="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String | Array,
        options: {
          type: Array,
          required: true,
          validator: function (value) {
            if (!Array.isArray(value)) {
              console.warn("Prop 'options' must be an array.");
              return false;
            }
            const isValid = value.every((item) => {
              const isObject = typeof item === "object" && item !== null;
              if (!isObject) return false;
              return (
                item.hasOwnProperty("value") &&
                item.hasOwnProperty("label") &&
                typeof item.value === "string" &&
                typeof item.label === "string"
              );
            });

            if (!isValid) {
              console.warn(
                "Validation failed for prop 'options': Each item must be an object with 'value' and 'label' properties being strings.",
                value
              );
            }
            return isValid;
          },
        },
        multiple: {
          type: Boolean,
          default: false,
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      mounted() {
        const inputElement = this.$refs.selectInput;
        const $selectInput = $(inputElement);
        $selectInput.typedInput({
          types: [
            {
              multiple: this.multiple,
              options: this.options,
            },
          ],
        });

        $selectInput.typedInput(
          "value",
          Array.isArray(this.value) ? this.value.join(",") : this.value
        );
        $selectInput.on("change", () => {
          const newValue = this.multiple
            ? $selectInput.typedInput("value")?.split(",")
            : $selectInput.typedInput("value");
          this.$emit("update:value", newValue);
        });
      },
    };

    const NodeRedEditorInput = {
      template: `
      <div ref="containerDiv" class="node-text-editor-container">
        <div ref="editorDiv" :id="editorId" class="node-text-editor"></div>
        <div v-show="error" class="node-red-vue-input-error-message">
          {{ error }}
        </div>
      </div>`,
      props: {
        value: String,
        language: {
          type: String,
          default: "json",
          validator: function (value) {
            const allowedLanguages = [
              "text",
              "json",
              "javascript",
              "html",
              "css",
              "markdown",
              "sql",
              "yaml",
            ];
            const isValid = allowedLanguages.includes(value);
            if (!isValid) {
              console.warn(
                `[NodeRedEditorComponent] Invalid ACE editor mode prop: "${value}". ` +
                  `Expected one of: ${allowedLanguages.join(", ")}`
              );
            }
            return isValid;
          },
        },
        error: {
          type: String,
          default: "",
        },
      },
      emits: ["update:value"],
      editor: null,
      data() {
        return {
          editorId:
            "node-red-editor-" + Math.random().toString(36).substring(2, 9),
        };
      },
      mounted() {
        this.mountEditor();
      },
      methods: {
        mountEditor() {
          this.$nextTick(() => {
            const containerEl = this.$refs.containerDiv;
            const editorEl = this.$refs.editorDiv;

            if (containerEl && editorEl) {
              try {
                const inlineHeight = containerEl.style.height;
                const inlineWidth = containerEl.style.width;
                if (inlineHeight) {
                  editorEl.style.height = inlineHeight;
                } else {
                  editorEl.style.height = "200px";
                }

                if (inlineWidth) {
                  editorEl.style.width = inlineWidth;
                } else {
                  editorEl.style.width = "100%";
                }

                this.createEditorInstance();
              } catch (e) {
                console.error(
                  "[NodeRedEditorInput] Error setting initial editor style:",
                  e
                );
                this.createEditorInstance();
              }
            } else {
              console.error(
                "[NodeRedEditorInput] Container or Editor div refs not found on mount."
              );
            }
          });
        },
        createEditorInstance() {
          this.editorInstance = RED.editor.createEditor({
            id: this.editorId,
            mode: this.language,
            value: this.value,
          });
          this.editorInstance.getSession().on("change", () => {
            const currentValue = this.editorInstance.getValue();
            if (currentValue !== this.value) {
              this.$emit("update:value", currentValue);
            }
          });
        },
      },
      beforeUnmount() {
        if (this.editorInstance) {
          try {
            this.editorInstance.destroy();
          } catch (err) {
            console.error(
              `Error destroying editor for ID ${this.editorId}:`,
              err
            );
          }
          this.editorInstance = null;
        }
      },
    };

    const app = Vue.createApp({
      data() {
        return {
          node: node._newState,
          errors: {},
        };
      },
      validator,
      beforeMount() {
        this.validate();

        Object.keys(this.node._def.defaults).forEach((prop) => {
          this.$watch(
            () => this.node[prop],
            (newVal) => {
              this.validate();
            },
            { deep: true }
          );
        });

        Object.keys(this.node._def.credentials).forEach((prop) => {
          if (
            this.node._def.credentials[prop].type === "password" &&
            this.node.credentials[`has_${prop}`]
          ) {
            this.node.credentials[prop] = "__PWD__";
          }

          this.$watch(
            () => this.node.credentials[prop],
            (newVal, oldVal) => {
              this.validate();

              if (
                this.node._def.credentials[prop].type === "password" &&
                newVal !== oldVal
              ) {
                this.node.credentials[`has_${prop}`] = !!newVal;
              }
            },
            { deep: true }
          );
        });
      },
      beforeUnmount() {
        $("#node-dialog-ok").prop("disabled", false).removeClass("disabled");
        $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
        // $("#red-ui-workspace-chart svg")
        //   .get(0)
        //   .style.setProperty("pointer-events", "all");

        // NOTE: must set credentials prop to undefined to avoid updating it to __PWD__ in the server
        Object.keys(this.node._def.credentials).forEach((prop) => {
          if (
            this.node._def.credentials[prop].type === "password" &&
            this.node.credentials[`has_${prop}`] &&
            this.node.credentials[prop] === "__PWD__"
          ) {
            this.node.credentials[prop] = undefined;
          }
        });
      },
      methods: {
        validate() {
          const valid = validator(this.node);
          if (!valid) {
            const errors = validator.errors;
            this.errors = errors.reduce((acc, error) => {
              const key = `node${error.instancePath.replaceAll("/", ".")}`;
              acc[key] = error.message;
              return acc;
            }, {});
          } else {
            this.errors = {};
          }
          if (Object.keys(this.errors).length) {
            $("#node-dialog-ok").prop("disabled", true).addClass("disabled");
            $("#red-ui-workspace")
              .get(0)
              .style.setProperty("pointer-events", "none", "important");
            // $("#red-ui-workspace-chart svg")
            //   .get(0)
            //   .style.setProperty("pointer-events", "none", "important");
          } else {
            $("#node-dialog-ok")
              .prop("disabled", false)
              .removeClass("disabled");
            $("#red-ui-workspace")
              .get(0)
              .style.setProperty("pointer-events", "");
            // $("#red-ui-workspace-chart svg")
            //   .get(0)
            //   .style.setProperty("pointer-events", "all");
          }
        },
      },
      template: `
    	<div style="width: 100%;">
    		<NodeRedNodeForm
          :node="node"
          :errors="errors"
          style="width: 100%;"
        />
    	</div>`,
    });
    app.config.performance = true;
    app.component("NodeRedInput", NodeRedInput);
    app.component("NodeRedTypedInput", NodeRedTypedInput);
    app.component("NodeRedConfigInput", NodeRedConfigInput);
    app.component("NodeRedSelectInput", NodeRedSelectInput);
    app.component("NodeRedEditorInput", NodeRedEditorInput);
    app.component("NodeRedNodeForm", form);

    return app;
  }

  function mountApp(node, formComponent, schema) {
    $("#app").empty();
    const validator = createValidator(schema);
    node._newState = _.cloneDeep(node);
    node._app = createApp(node, formComponent, validator);
    node._app.mount("#app");
  }

  function unmountApp(node) {
    if (node._app) {
      node._app.unmount();
      node._app = null;
    }
  }

  function getNodeState(node) {
    const state = {
      credentials: {},
    };
    Object.keys(node._def.defaults).forEach((prop) => {
      state[prop] = node[prop];
    });
    Object.keys(node._def.credentials).forEach((prop) => {
      state.credentials[prop] = node.credentials[prop];

      if (node._def.credentials[prop].type === "password") {
        state.credentials[`has_${prop}`] =
          node.credentials[`has_${prop}`] || false;
      }
    });

    return state;
  }

  // TODO: remove this as it will be handled by the bundler
  function loadExternalScripts(urls, callback) {
    const scriptsLoaded = new Array(urls.length).fill(false); // To track the loading state of each script

    const checkIfAllLoaded = () => {
      if (scriptsLoaded.every((status) => status)) {
        callback();
      }
    };

    const onScriptLoad = (index) => {
      scriptsLoaded[index] = true;
      checkIfAllLoaded();
    };

    // Create and append each script
    urls.forEach((url, index) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = () => onScriptLoad(index);
      document.head.appendChild(script);
    });
  }

  // NOTE: provided by the User
  const yourNodeFormComponent = {
    template: `
    	<div>
    		<div class="form-row">
    			<label style="width: 100%"><i class="fa fa-tag"></i> Username</label>
    			<NodeRedInput
            v-model:value="node.credentials.username"
            :error="errors['node.credentials.username']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%"><i class="fa fa-tag"></i> Password</label>
    			<NodeRedInput
            v-model:value="node.credentials.password"
            type="password"
            :error="errors['node.credentials.password']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Typed Input</label>
    			<NodeRedTypedInput
            v-model:value="node.myProperty"
            :types="types"
            :error="errors['node.myProperty']"
          />
    		</div>
        <div class="form-row">
    			<label style="width: 100%">Typed Input 2</label>
    			<NodeRedTypedInput
            v-model:value="node.myProperty2"
            :error="errors['node.myProperty2']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Config Input</label>
    			<NodeRedConfigInput
            v-model:value="node.remoteServer"
            type="remote-server"
            :error="errors['node.remoteServer']"
          />
    		</div>
        <div class="form-row">
    			<label style="width: 100%">Config Input</label>
    			<NodeRedConfigInput
            v-model:value="node.anotherRemoteServer"
            type="remote-server"
            :error="errors['node.anotherRemoteServer']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.country"
            :options="countries"
            :error="errors['node.country']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">MultiSelect Input</label>
    			<NodeRedSelectInput
            v-model:value="node.fruit"
            :options="fruits"
            multiple
            :error="errors['node.fruit']"
          />
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.number"
            :options="numbers"
            :error="errors['node.number']"
          />
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.object"
            :options="objects"
            multiple
            :error="errors['node.object']"
          />
    		</div>
          <div class="form-row">
    			<label style="width: 100%">Select Input</label>
    			<NodeRedSelectInput
            v-model:value="node.array"
            :options="arrays"
            :error="errors['node.array']"
          />
    		</div>
    		<div class="form-row">
    			<label style="width: 100%">Editor with default height 200px and JSON</label>
    			<NodeRedEditorInput
            v-model:value="node.jsontest"
            :error="errors['node.jsontest']"
          />
    		</div>
    		<div class="form-row">
    		  <label style="width: 100%">Editor with custom height and CSS</label>
    		  <NodeRedEditorInput
            v-model:value="node.csstest"
            language="css"
            style="height: 100px;"
            :error="errors['node.csstest']"
          />
    		</div>
    	</div>`,
    props: {
      node: {
        type: Object,
        required: true,
      },
      errors: {
        type: Object,
        default: () => ({}),
      },
    },
    data() {
      return {
        types: ["str", "msg", "node"],
        countries: [
          { value: "usa", label: "usa" },
          { value: "argentina", label: "argentina" },
          { value: "brasil", label: "brasil" },
        ],
        fruits: [
          { value: "apple", label: "apple" },
          { value: "melon", label: "melon" },
          { value: "raspberry", label: "raspberry" },
        ],
        numbers: [
          { value: "1", label: "1" },
          { value: "2", label: "2" },
          { value: "3", label: "3" },
        ],
        objects: [
          { value: JSON.stringify({ test: "a" }), label: "a" },
          { value: JSON.stringify({ test: "b" }), label: "b" },
          { value: JSON.stringify({ test: "c" }), label: "c" },
        ],
        arrays: [
          { value: JSON.stringify(["a"]), label: "a" },
          { value: JSON.stringify(["b"]), label: "b" },
          { value: JSON.stringify(["c"]), label: "c" },
        ],
      };
    },
  };

  // NOTE: provided by the User
  const yourNodeFormSchema = {
    type: "object",
    properties: {
      credentials: {
        type: "object",
        properties: {
          username: {
            type: "string",
            minLength: 5,
            maxLength: 10,
            default: "",
          },
          // password: {
          //   type: "string",
          //   minLength: 8,
          //   maxLength: 20,
          //   pattern: "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]+$",
          //   default: "",
          // },
        },
        default: {},
        // required: ["password", "username"],
      },
      myProperty: {
        type: "object",
        properties: {
          value: {
            type: "string",
            default: "",
          },
          type: {
            type: "string",
            enum: [
              "msg",
              "flow",
              "global",
              "str",
              "num",
              "bool",
              "json",
              "bin",
              "re",
              "jsonata",
              "date",
              "env",
              "node",
              "cred",
            ],
            default: "str",
          },
        },
        required: ["value", "type"],
        default: {},
        oneOf: [
          {
            properties: {
              type: { const: "str" },
              value: { type: "string", minLength: 10 },
            },
          },
        ],
      },
      myProperty2: {
        type: "object",
        properties: {
          value: {
            type: "string",
            default: "",
          },
          type: {
            type: "string",
            enum: [
              "msg",
              "flow",
              "global",
              "str",
              "num",
              "bool",
              "json",
              "bin",
              "re",
              "jsonata",
              "date",
              "env",
              "node",
              "cred",
            ],
            default: "str",
          },
        },
        required: ["value", "type"],
        default: {},
      },
      country: {
        type: "string",
        default: "brasil",
      },
    },
  };

  // NOTE: provided by the User
  const serverNodeForm = {
    template: `
    <div>
      <div class="form-row">
        <label style="width: 100%"><i class="fa fa-tag"></i> Name</label>
        <NodeRedInput
          v-model:value="node.name"
          :error="errors['node.name']"
          placeholder="name"
        />
      </div>
      <div class="form-row">
        <label style="width: 100%"><i class="fa fa-tag"></i> Hostname</label>
        <NodeRedInput
          v-model:value="node.host"
          :error="errors['node.host']"
          placeholder="hostname"
        />
      </div>
    </div>`,
    props: {
      node: {
        type: Object,
        required: true,
      },
      errors: {
        type: Object,
        default: () => ({}),
      },
    },
  };

  // NOTE: provided by the User
  const serverNodeSchema = {
    type: "object",
    properties: {
      name: {
        type: "string",
        default: "server-node",
      },
      host: {
        type: "string",
        default: "",
      },
    },
  };

  // TODO: define interface
  function registerType({
    type,
    category,
    color,
    icon,
    label,
    inputs,
    outputs,
    paletteLabel,
    labelStyle,
    inputLabels,
    outputLabels,
    align,
    button,
    onPaletteAdd,
    onPaletteRemove,
    form,
    schema,
  }) {
    $.getJSON(`/nrg/nodes/${type}`, function ({ defaults, credentials }) {
      console.log(defaults);
      console.log(credentials);
      const node = {
        defaults,
        credentials,
        type,
        category,
        color,
        icon,
        inputs,
        outputs,
        paletteLabel,
        labelStyle,
        inputLabels,
        outputLabels,
        align,
        button,
        label: function () {
          // TODO: add better defaults with i18n
          return this.name;
        },
        oneditprepare: function () {
          const node = this;
          console.log(node);

          if (typeof Vue !== "undefined" && typeof ajv7 !== "undefined") {
            console.log("dependencies loaded already");
            mountApp(node, form, schema);
            return;
          }

          // TODO: this will be bundled and shared as a plugin
          // TODO: include ajv better errors
          // TODO: include TypeBox for writing json schemas
          const urls = [
            "https://unpkg.com/vue@3/dist/vue.global.js",
            "https://cdnjs.cloudflare.com/ajax/libs/ajv/8.17.1/ajv7.min.js",
            "https://cdn.jsdelivr.net/npm/es-toolkit@%5E1",
          ];

          loadExternalScripts(urls, () => {
            mountApp(node, form, schema);
          });
        },
        oneditsave: function () {
          const node = this;
          unmountApp(node);

          const newState = getNodeState(node._newState);
          const oldState = getNodeState(node);
          const changes = getChanges(oldState, newState);
          const changed = !!Object.keys(changes)?.length;
          if (!changed) {
            return false;
          }

          // NOTE: if 2 different node props have the same config node value, there will be only one entry in the config node users for our node. DEFAULT NODE-RED BEHAVIOUR!
          Object.keys(node._def.defaults).forEach((prop) => {
            if (node._def.defaults?.[prop]?.type) {
              const oldConfigNodeId = node[prop];
              const newConfigNodeId = node._newState[prop];
              if (oldConfigNodeId !== newConfigNodeId) {
                const oldConfigNode = RED.nodes.node(oldConfigNodeId);
                if (oldConfigNode && oldConfigNode._def.category === "config") {
                  const parentNodeIndex = oldConfigNode.users.findIndex(
                    (_node) => _node.id === node.id
                  );
                  if (parentNodeIndex !== -1) {
                    oldConfigNode.users.splice(parentNodeIndex, 1);
                  }
                }
              }
            }
          });

          Object.keys(node._def.defaults).forEach((prop) => {
            if (node._def.defaults?.[prop]?.type) {
              const newStateConfigNodeId = node._newState[prop];
              const newStateConfigNode = RED.nodes.node(newStateConfigNodeId);
              if (
                newStateConfigNode &&
                newStateConfigNode._def.category === "config"
              ) {
                const parentNodeIndex = newStateConfigNode.users.findIndex(
                  (_node) => _node.id === node.id
                );
                if (parentNodeIndex === -1) {
                  newStateConfigNode.users.push(node);
                }
              }
            }
          });

          _.mergeWith(
            node,
            node._newState,
            (objValue, srcValue, key, object, source, stack) => {
              if (key.startsWith("_")) {
                return objValue;
              }
              if (key === "constructor") {
                return objValue;
              }
              return undefined;
            }
          );

          return {
            changed,
            history: [
              {
                t: "edit",
                node,
                changes,
                links: [],
                dirty: RED.nodes.dirty(),
                changed,
              },
            ],
          };
        },
        oneditcancel: function () {
          unmountApp(this);
        },
        oneditdelete: function () {
          unmountApp(this);
        },
        onpaletteadd: onPaletteAdd,
        onpaltteremove: onPaletteRemove,
      };

      RED.nodes.registerType(type, node);
    });
  }

  // TODO: move this to its own module (/src/nodes/{node-type}/client/index.js)
  registerType({
    type: "remote-server",
    category: "config",
    color: "#a6bbcf",
    form: serverNodeForm,
    schema: serverNodeSchema,
  });

  // TODO: move this to its own module (/src/nodes/{node-type}/client/index.js)
  registerType({
    type: "your-node",
    category: "function",
    color: "#FFFFFF",
    inputs: 1,
    outputs: 1,
    icon: "vue.png",
    form: yourNodeFormComponent,
    schema: yourNodeFormSchema,
  });

  //# sourceURL=dynamicScript.js
</script>
